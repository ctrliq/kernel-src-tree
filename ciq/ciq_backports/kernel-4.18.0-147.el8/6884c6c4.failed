RDMA/verbs: Store the write/write_ex uapi entry points in the uverbs_api

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-147.el8
commit-author Jason Gunthorpe <jgg@ziepe.ca>
commit 6884c6c4bd09fb35b79a3967d15821cdfcbe77a3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-147.el8/6884c6c4.failed

Bringing all uapi entry points into one place lets us deal with them
consistently. For instance the write, write_ex and ioctl paths can be
disabled when an API is not supported by the driver.

This will replace the uverbs_cmd_table static arrays.

	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
	Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
(cherry picked from commit 6884c6c4bd09fb35b79a3967d15821cdfcbe77a3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/core/rdma_core.h
#	drivers/infiniband/core/uverbs_uapi.c
#	include/rdma/uverbs_ioctl.h
diff --cc drivers/infiniband/core/rdma_core.h
index a243cc2a59f7,d36a0573c5e4..000000000000
--- a/drivers/infiniband/core/rdma_core.h
+++ b/drivers/infiniband/core/rdma_core.h
@@@ -113,4 -106,81 +113,84 @@@ int uverbs_finalize_object(struct ib_uo
  			   enum uverbs_obj_access access,
  			   bool commit);
  
++<<<<<<< HEAD
++=======
+ void setup_ufile_idr_uobject(struct ib_uverbs_file *ufile);
+ void release_ufile_idr_uobject(struct ib_uverbs_file *ufile);
+ 
+ /*
+  * This is the runtime description of the uverbs API, used by the syscall
+  * machinery to validate and dispatch calls.
+  */
+ 
+ /*
+  * Depending on ID the slot pointer in the radix tree points at one of these
+  * structs.
+  */
+ struct uverbs_api_object {
+ 	const struct uverbs_obj_type *type_attrs;
+ 	const struct uverbs_obj_type_class *type_class;
+ 	u8 disabled:1;
+ };
+ 
+ struct uverbs_api_ioctl_method {
+ 	int (__rcu *handler)(struct ib_uverbs_file *ufile,
+ 			     struct uverbs_attr_bundle *ctx);
+ 	DECLARE_BITMAP(attr_mandatory, UVERBS_API_ATTR_BKEY_LEN);
+ 	u16 bundle_size;
+ 	u8 use_stack:1;
+ 	u8 driver_method:1;
+ 	u8 disabled:1;
+ 	u8 key_bitmap_len;
+ 	u8 destroy_bkey;
+ };
+ 
+ struct uverbs_api_write_method {
+ 	ssize_t (*handler)(struct ib_uverbs_file *file, const char __user *buf,
+ 			   int in_len, int out_len);
+ 	int (*handler_ex)(struct ib_uverbs_file *file, struct ib_udata *ucore,
+ 			  struct ib_udata *uhw);
+ 	u8 disabled:1;
+ 	u8 is_ex:1;
+ };
+ 
+ struct uverbs_api_attr {
+ 	struct uverbs_attr_spec spec;
+ };
+ 
+ struct uverbs_api {
+ 	/* radix tree contains struct uverbs_api_* pointers */
+ 	struct radix_tree_root radix;
+ 	enum rdma_driver_id driver_id;
+ 
+ 	unsigned int num_write;
+ 	unsigned int num_write_ex;
+ 	struct uverbs_api_write_method notsupp_method;
+ 	const struct uverbs_api_write_method **write_methods;
+ 	const struct uverbs_api_write_method **write_ex_methods;
+ };
+ 
+ static inline const struct uverbs_api_object *
+ uapi_get_object(struct uverbs_api *uapi, u16 object_id)
+ {
+ 	return radix_tree_lookup(&uapi->radix, uapi_key_obj(object_id));
+ }
+ 
+ char *uapi_key_format(char *S, unsigned int key);
+ struct uverbs_api *uverbs_alloc_api(struct ib_device *ibdev);
+ void uverbs_disassociate_api_pre(struct ib_uverbs_device *uverbs_dev);
+ void uverbs_disassociate_api(struct uverbs_api *uapi);
+ void uverbs_destroy_api(struct uverbs_api *uapi);
+ void uapi_compute_bundle_size(struct uverbs_api_ioctl_method *method_elm,
+ 			      unsigned int num_attrs);
+ void uverbs_user_mmap_disassociate(struct ib_uverbs_file *ufile);
+ 
+ extern const struct uapi_definition uverbs_def_obj_counters[];
+ extern const struct uapi_definition uverbs_def_obj_cq[];
+ extern const struct uapi_definition uverbs_def_obj_dm[];
+ extern const struct uapi_definition uverbs_def_obj_flow_action[];
+ extern const struct uapi_definition uverbs_def_obj_intf[];
+ extern const struct uapi_definition uverbs_def_obj_mr[];
+ 
++>>>>>>> 6884c6c4bd09 (RDMA/verbs: Store the write/write_ex uapi entry points in the uverbs_api)
  #endif /* RDMA_CORE_H */
diff --cc include/rdma/uverbs_ioctl.h
index 90a4947ff548,5df8ed79ba6c..000000000000
--- a/include/rdma/uverbs_ioctl.h
+++ b/include/rdma/uverbs_ioctl.h
@@@ -110,58 -110,205 +110,199 @@@ struct uverbs_attr_spec 
  			 * contained in the ids array. Currently only PTR_IN
  			 * attributes are supported in the ids array.
  			 */
 -			const struct uverbs_attr_spec *ids;
 +			const struct uverbs_attr_spec	*ids;
  		} enum_def;
 -
 -		struct {
 -			/*
 -			 * higher bits mean the namespace and lower bits mean
 -			 * the type id within the namespace.
 -			 */
 -			u16				obj_type;
 -			u16				min_len;
 -			u16				max_len;
 -			u8				access;
 -		} objs_arr;
 -	} u2;
 +	};
  };
  
++<<<<<<< HEAD
 +struct uverbs_attr_spec_hash {
 +	size_t				num_attrs;
 +	unsigned long			*mandatory_attrs_bitmask;
 +	struct uverbs_attr_spec		attrs[0];
++=======
+ /*
+  * Information about the API is loaded into a radix tree. For IOCTL we start
+  * with a tuple of:
+  *  object_id, attr_id, method_id
+  *
+  * Which is a 48 bit value, with most of the bits guaranteed to be zero. Based
+  * on the current kernel support this is compressed into 16 bit key for the
+  * radix tree. Since this compression is entirely internal to the kernel the
+  * below limits can be revised if the kernel gains additional data.
+  *
+  * With 64 leafs per node this is a 3 level radix tree.
+  *
+  * The tree encodes multiple types, and uses a scheme where OBJ_ID,0,0 returns
+  * the object slot, and OBJ_ID,METH_ID,0 and returns the method slot.
+  *
+  * This also encodes the tables for the write() and write() extended commands
+  * using the coding
+  *   OBJ_ID,UVERBS_API_METHOD_IS_WRITE,command #
+  *   OBJ_ID,UVERBS_API_METHOD_IS_WRITE_EX,command_ex #
+  * ie the WRITE path is treated as a special method type in the ioctl
+  * framework.
+  */
+ enum uapi_radix_data {
+ 	UVERBS_API_NS_FLAG = 1U << UVERBS_ID_NS_SHIFT,
+ 
+ 	UVERBS_API_ATTR_KEY_BITS = 6,
+ 	UVERBS_API_ATTR_KEY_MASK = GENMASK(UVERBS_API_ATTR_KEY_BITS - 1, 0),
+ 	UVERBS_API_ATTR_BKEY_LEN = (1 << UVERBS_API_ATTR_KEY_BITS) - 1,
+ 	UVERBS_API_WRITE_KEY_NUM = 1 << UVERBS_API_ATTR_KEY_BITS,
+ 
+ 	UVERBS_API_METHOD_KEY_BITS = 5,
+ 	UVERBS_API_METHOD_KEY_SHIFT = UVERBS_API_ATTR_KEY_BITS,
+ 	UVERBS_API_METHOD_KEY_NUM_CORE = 22,
+ 	UVERBS_API_METHOD_IS_WRITE = 30 << UVERBS_API_METHOD_KEY_SHIFT,
+ 	UVERBS_API_METHOD_IS_WRITE_EX = 31 << UVERBS_API_METHOD_KEY_SHIFT,
+ 	UVERBS_API_METHOD_KEY_NUM_DRIVER =
+ 		(UVERBS_API_METHOD_IS_WRITE >> UVERBS_API_METHOD_KEY_SHIFT) -
+ 		UVERBS_API_METHOD_KEY_NUM_CORE,
+ 	UVERBS_API_METHOD_KEY_MASK = GENMASK(
+ 		UVERBS_API_METHOD_KEY_BITS + UVERBS_API_METHOD_KEY_SHIFT - 1,
+ 		UVERBS_API_METHOD_KEY_SHIFT),
+ 
+ 	UVERBS_API_OBJ_KEY_BITS = 5,
+ 	UVERBS_API_OBJ_KEY_SHIFT =
+ 		UVERBS_API_METHOD_KEY_BITS + UVERBS_API_METHOD_KEY_SHIFT,
+ 	UVERBS_API_OBJ_KEY_NUM_CORE = 24,
+ 	UVERBS_API_OBJ_KEY_NUM_DRIVER =
+ 		(1 << UVERBS_API_OBJ_KEY_BITS) - UVERBS_API_OBJ_KEY_NUM_CORE,
+ 	UVERBS_API_OBJ_KEY_MASK = GENMASK(31, UVERBS_API_OBJ_KEY_SHIFT),
+ 
+ 	/* This id guaranteed to not exist in the radix tree */
+ 	UVERBS_API_KEY_ERR = 0xFFFFFFFF,
++>>>>>>> 6884c6c4bd09 (RDMA/verbs: Store the write/write_ex uapi entry points in the uverbs_api)
  };
  
 -static inline __attribute_const__ u32 uapi_key_obj(u32 id)
 -{
 -	if (id & UVERBS_API_NS_FLAG) {
 -		id &= ~UVERBS_API_NS_FLAG;
 -		if (id >= UVERBS_API_OBJ_KEY_NUM_DRIVER)
 -			return UVERBS_API_KEY_ERR;
 -		id = id + UVERBS_API_OBJ_KEY_NUM_CORE;
 -	} else {
 -		if (id >= UVERBS_API_OBJ_KEY_NUM_CORE)
 -			return UVERBS_API_KEY_ERR;
 -	}
 +struct uverbs_attr_bundle;
 +struct ib_uverbs_file;
  
++<<<<<<< HEAD
 +enum {
++=======
+ 	return id << UVERBS_API_OBJ_KEY_SHIFT;
+ }
+ 
+ static inline __attribute_const__ bool uapi_key_is_object(u32 key)
+ {
+ 	return (key & ~UVERBS_API_OBJ_KEY_MASK) == 0;
+ }
+ 
+ static inline __attribute_const__ u32 uapi_key_ioctl_method(u32 id)
+ {
+ 	if (id & UVERBS_API_NS_FLAG) {
+ 		id &= ~UVERBS_API_NS_FLAG;
+ 		if (id >= UVERBS_API_METHOD_KEY_NUM_DRIVER)
+ 			return UVERBS_API_KEY_ERR;
+ 		id = id + UVERBS_API_METHOD_KEY_NUM_CORE;
+ 	} else {
+ 		id++;
+ 		if (id >= UVERBS_API_METHOD_KEY_NUM_CORE)
+ 			return UVERBS_API_KEY_ERR;
+ 	}
+ 
+ 	return id << UVERBS_API_METHOD_KEY_SHIFT;
+ }
+ 
+ static inline __attribute_const__ u32 uapi_key_write_method(u32 id)
+ {
+ 	if (id >= UVERBS_API_WRITE_KEY_NUM)
+ 		return UVERBS_API_KEY_ERR;
+ 	return UVERBS_API_METHOD_IS_WRITE | id;
+ }
+ 
+ static inline __attribute_const__ u32 uapi_key_write_ex_method(u32 id)
+ {
+ 	if (id >= UVERBS_API_WRITE_KEY_NUM)
+ 		return UVERBS_API_KEY_ERR;
+ 	return UVERBS_API_METHOD_IS_WRITE_EX | id;
+ }
+ 
+ static inline __attribute_const__ u32
+ uapi_key_attr_to_ioctl_method(u32 attr_key)
+ {
+ 	return attr_key &
+ 	       (UVERBS_API_OBJ_KEY_MASK | UVERBS_API_METHOD_KEY_MASK);
+ }
+ 
+ static inline __attribute_const__ bool uapi_key_is_ioctl_method(u32 key)
+ {
+ 	unsigned int method = key & UVERBS_API_METHOD_KEY_MASK;
+ 
+ 	return method != 0 && method < UVERBS_API_METHOD_IS_WRITE &&
+ 	       (key & UVERBS_API_ATTR_KEY_MASK) == 0;
+ }
+ 
+ static inline __attribute_const__ bool uapi_key_is_write_method(u32 key)
+ {
+ 	return (key & UVERBS_API_METHOD_KEY_MASK) == UVERBS_API_METHOD_IS_WRITE;
+ }
+ 
+ static inline __attribute_const__ bool uapi_key_is_write_ex_method(u32 key)
+ {
+ 	return (key & UVERBS_API_METHOD_KEY_MASK) ==
+ 	       UVERBS_API_METHOD_IS_WRITE_EX;
+ }
+ 
+ static inline __attribute_const__ u32 uapi_key_attrs_start(u32 ioctl_method_key)
+ {
+ 	/* 0 is the method slot itself */
+ 	return ioctl_method_key + 1;
+ }
+ 
+ static inline __attribute_const__ u32 uapi_key_attr(u32 id)
+ {
++>>>>>>> 6884c6c4bd09 (RDMA/verbs: Store the write/write_ex uapi entry points in the uverbs_api)
  	/*
 -	 * The attr is designed to fit in the typical single radix tree node
 -	 * of 64 entries. Since allmost all methods have driver attributes we
 -	 * organize things so that the driver and core attributes interleave to
 -	 * reduce the length of the attributes array in typical cases.
 +	 * Action marked with this flag creates a context (or root for all
 +	 * objects).
  	 */
 -	if (id & UVERBS_API_NS_FLAG) {
 -		id &= ~UVERBS_API_NS_FLAG;
 -		id++;
 -		if (id >= 1 << (UVERBS_API_ATTR_KEY_BITS - 1))
 -			return UVERBS_API_KEY_ERR;
 -		id = (id << 1) | 0;
 -	} else {
 -		if (id >= 1 << (UVERBS_API_ATTR_KEY_BITS - 1))
 -			return UVERBS_API_KEY_ERR;
 -		id = (id << 1) | 1;
 -	}
 +	UVERBS_ACTION_FLAG_CREATE_ROOT = 1U << 0,
 +};
  
 -	return id;
 -}
 +struct uverbs_method_spec {
 +	/* Combination of bits from enum UVERBS_ACTION_FLAG_XXXX */
 +	u32						flags;
 +	size_t						num_buckets;
 +	size_t						num_child_attrs;
 +	int (*handler)(struct ib_device *ib_dev, struct ib_uverbs_file *ufile,
 +		       struct uverbs_attr_bundle *ctx);
 +	struct uverbs_attr_spec_hash		*attr_buckets[0];
 +};
  
++<<<<<<< HEAD
 +struct uverbs_method_spec_hash {
 +	size_t					num_methods;
 +	struct uverbs_method_spec		*methods[0];
 +};
++=======
+ /* Only true for ioctl methods */
+ static inline __attribute_const__ bool uapi_key_is_attr(u32 key)
+ {
+ 	unsigned int method = key & UVERBS_API_METHOD_KEY_MASK;
+ 
+ 	return method != 0 && method < UVERBS_API_METHOD_IS_WRITE &&
+ 	       (key & UVERBS_API_ATTR_KEY_MASK) != 0;
+ }
++>>>>>>> 6884c6c4bd09 (RDMA/verbs: Store the write/write_ex uapi entry points in the uverbs_api)
  
 -/*
 - * This returns a value in the range [0 to UVERBS_API_ATTR_BKEY_LEN),
 - * basically it undoes the reservation of 0 in the ID numbering. attr_key
 - * must already be masked with UVERBS_API_ATTR_KEY_MASK, or be the output of
 - * uapi_key_attr().
 - */
 -static inline __attribute_const__ u32 uapi_bkey_attr(u32 attr_key)
 -{
 -	return attr_key - 1;
 -}
 +struct uverbs_object_spec {
 +	const struct uverbs_obj_type		*type_attrs;
 +	size_t					num_buckets;
 +	struct uverbs_method_spec_hash		*method_buckets[0];
 +};
  
 -static inline __attribute_const__ u32 uapi_bkey_to_key_attr(u32 attr_bkey)
 -{
 -	return attr_bkey + 1;
 -}
 +struct uverbs_object_spec_hash {
 +	size_t					num_objects;
 +	struct uverbs_object_spec		*objects[0];
 +};
 +
 +struct uverbs_root_spec {
 +	size_t					num_buckets;
 +	struct uverbs_object_spec_hash		*object_buckets[0];
 +};
  
  /*
   * =======================================
@@@ -191,137 -338,250 +332,261 @@@ struct uverbs_object_def 
  	const struct uverbs_method_def * const (*methods)[];
  };
  
++<<<<<<< HEAD
 +struct uverbs_object_tree_def {
 +	size_t					 num_objects;
 +	const struct uverbs_object_def * const (*objects)[];
++=======
+ enum uapi_definition_kind {
+ 	UAPI_DEF_END = 0,
+ 	UAPI_DEF_OBJECT_START,
+ 	UAPI_DEF_WRITE,
+ 	UAPI_DEF_CHAIN_OBJ_TREE,
+ 	UAPI_DEF_CHAIN,
+ 	UAPI_DEF_IS_SUPPORTED_FUNC,
+ 	UAPI_DEF_IS_SUPPORTED_DEV_FN,
++>>>>>>> 6884c6c4bd09 (RDMA/verbs: Store the write/write_ex uapi entry points in the uverbs_api)
  };
  
 -enum uapi_definition_scope {
 -	UAPI_SCOPE_OBJECT = 1,
 -};
 -
 +#define UA_FLAGS(_flags)  .flags = _flags
 +#define __UVERBS_ATTR0(_id, _type, _fld, _attr, ...)              \
 +	((const struct uverbs_attr_def)				  \
 +	 {.id = _id, .attr = {{._fld = {.type = _type, _attr, .flags = 0, } }, } })
 +#define __UVERBS_ATTR1(_id, _type, _fld, _attr, _extra1, ...)      \
 +	((const struct uverbs_attr_def)				  \
 +	 {.id = _id, .attr = {{._fld = {.type = _type, _attr, _extra1 } },} })
 +#define __UVERBS_ATTR2(_id, _type, _fld, _attr, _extra1, _extra2)    \
 +	((const struct uverbs_attr_def)				  \
 +	 {.id = _id, .attr = {{._fld = {.type = _type, _attr, _extra1, _extra2 } },} })
 +#define __UVERBS_ATTR(_id, _type, _fld, _attr, _extra1, _extra2, _n, ...)	\
 +	__UVERBS_ATTR##_n(_id, _type, _fld, _attr, _extra1, _extra2)
 +
++<<<<<<< HEAD
++=======
+ struct uapi_definition {
+ 	u8 kind;
+ 	u8 scope;
+ 	union {
+ 		struct {
+ 			u16 object_id;
+ 		} object_start;
+ 		struct {
+ 			u8 is_ex;
+ 			u16 command_num;
+ 		} write;
+ 	};
+ 
+ 	union {
+ 		bool (*func_is_supported)(struct ib_device *device);
+ 		ssize_t (*func_write)(struct ib_uverbs_file *file,
+ 				      const char __user *buf, int in_len,
+ 				      int out_len);
+ 		int (*func_write_ex)(struct ib_uverbs_file *file,
+ 				     struct ib_udata *ucore,
+ 				     struct ib_udata *uhw);
+ 		const struct uapi_definition *chain;
+ 		const struct uverbs_object_def *chain_obj_tree;
+ 		size_t needs_fn_offset;
+ 	};
+ };
+ 
+ /* Define things connected to object_id */
+ #define DECLARE_UVERBS_OBJECT(_object_id, ...)                                 \
+ 	{                                                                      \
+ 		.kind = UAPI_DEF_OBJECT_START,                                 \
+ 		.object_start = { .object_id = _object_id },                   \
+ 	},                                                                     \
+ 		##__VA_ARGS__
+ 
+ /* Use in a var_args of DECLARE_UVERBS_OBJECT */
+ #define DECLARE_UVERBS_WRITE(_command_num, _func, ...)                         \
+ 	{                                                                      \
+ 		.kind = UAPI_DEF_WRITE,                                        \
+ 		.scope = UAPI_SCOPE_OBJECT,                                    \
+ 		.write = { .is_ex = 0, .command_num = _command_num },          \
+ 		.func_write = _func,                                           \
+ 	},                                                                     \
+ 		##__VA_ARGS__
+ 
+ /* Use in a var_args of DECLARE_UVERBS_OBJECT */
+ #define DECLARE_UVERBS_WRITE_EX(_command_num, _func, ...)                      \
+ 	{                                                                      \
+ 		.kind = UAPI_DEF_WRITE,                                        \
+ 		.scope = UAPI_SCOPE_OBJECT,                                    \
+ 		.write = { .is_ex = 1, .command_num = _command_num },          \
+ 		.func_write_ex = _func,                                        \
+ 	},                                                                     \
+ 		##__VA_ARGS__
+ 
+ /*
+  * Object is only supported if the function pointer named ibdev_fn in struct
+  * ib_device is not NULL.
+  */
+ #define UAPI_DEF_OBJ_NEEDS_FN(ibdev_fn)                                        \
+ 	{                                                                      \
+ 		.kind = UAPI_DEF_IS_SUPPORTED_DEV_FN,                          \
+ 		.scope = UAPI_SCOPE_OBJECT,                                    \
+ 		.needs_fn_offset =                                             \
+ 			offsetof(struct ib_device, ibdev_fn) +                 \
+ 			BUILD_BUG_ON_ZERO(                                     \
+ 				sizeof(((struct ib_device *)0)->ibdev_fn) !=   \
+ 				sizeof(void *)),                               \
+ 	}
+ 
+ /* Call a function to determine if the entire object is supported or not */
+ #define UAPI_DEF_IS_OBJ_SUPPORTED(_func)                                       \
+ 	{                                                                      \
+ 		.kind = UAPI_DEF_IS_SUPPORTED_FUNC,                            \
+ 		.scope = UAPI_SCOPE_OBJECT, .func_is_supported = _func,        \
+ 	}
+ 
+ /* Include another struct uapi_definition in this one */
+ #define UAPI_DEF_CHAIN(_def_var)                                               \
+ 	{                                                                      \
+ 		.kind = UAPI_DEF_CHAIN, .chain = _def_var,                     \
+ 	}
+ 
+ /* Temporary until the tree base description is replaced */
+ #define UAPI_DEF_CHAIN_OBJ_TREE(_object_enum, _object_ptr)                     \
+ 	{                                                                      \
+ 		.kind = UAPI_DEF_CHAIN_OBJ_TREE,                               \
+ 		.object_start = { .object_id = _object_enum },                 \
+ 		.chain_obj_tree = _object_ptr,                                 \
+ 	}
+ #define UAPI_DEF_CHAIN_OBJ_TREE_NAMED(_object_enum, ...)                       \
+ 	UAPI_DEF_CHAIN_OBJ_TREE(_object_enum, &UVERBS_OBJECT(_object_enum)),   \
+ 		##__VA_ARGS__
+ 
+ /*
+  * =======================================
+  *	Attribute Specifications
+  * =======================================
+  */
+ 
+ #define UVERBS_ATTR_SIZE(_min_len, _len)			\
+ 	.u.ptr.min_len = _min_len, .u.ptr.len = _len
+ 
+ #define UVERBS_ATTR_NO_DATA() UVERBS_ATTR_SIZE(0, 0)
+ 
+ /*
+  * Specifies a uapi structure that cannot be extended. The user must always
+  * supply the whole structure and nothing more. The structure must be declared
+  * in a header under include/uapi/rdma.
+  */
++>>>>>>> 6884c6c4bd09 (RDMA/verbs: Store the write/write_ex uapi entry points in the uverbs_api)
  #define UVERBS_ATTR_TYPE(_type)					\
 -	.u.ptr.min_len = sizeof(_type), .u.ptr.len = sizeof(_type)
 -/*
 - * Specifies a uapi structure where the user must provide at least up to
 - * member 'last'.  Anything after last and up until the end of the structure
 - * can be non-zero, anything longer than the end of the structure must be
 - * zero. The structure must be declared in a header under include/uapi/rdma.
 - */
 -#define UVERBS_ATTR_STRUCT(_type, _last)                                       \
 -	.zero_trailing = 1,                                                    \
 -	UVERBS_ATTR_SIZE(((uintptr_t)(&((_type *)0)->_last + 1)),              \
 -			 sizeof(_type))
 -/*
 - * Specifies at least min_len bytes must be passed in, but the amount can be
 - * larger, up to the protocol maximum size. No check for zeroing is done.
 - */
 -#define UVERBS_ATTR_MIN_SIZE(_min_len) UVERBS_ATTR_SIZE(_min_len, USHRT_MAX)
 -
 -/* Must be used in the '...' of any UVERBS_ATTR */
 -#define UA_ALLOC_AND_COPY .alloc_and_copy = 1
 -#define UA_MANDATORY .mandatory = 1
 -#define UA_OPTIONAL .mandatory = 0
 -
 -/*
 - * min_len must be bigger than 0 and _max_len must be smaller than 4095.  Only
 - * READ\WRITE accesses are supported.
 - */
 -#define UVERBS_ATTR_IDRS_ARR(_attr_id, _idr_type, _access, _min_len, _max_len, \
 -			     ...)                                              \
 -	(&(const struct uverbs_attr_def){                                      \
 -		.id = (_attr_id) +                                             \
 -		      BUILD_BUG_ON_ZERO((_min_len) == 0 ||                     \
 -					(_max_len) >                           \
 -						PAGE_SIZE / sizeof(void *) ||  \
 -					(_min_len) > (_max_len) ||             \
 -					(_access) == UVERBS_ACCESS_NEW ||      \
 -					(_access) == UVERBS_ACCESS_DESTROY),   \
 -		.attr = { .type = UVERBS_ATTR_TYPE_IDRS_ARRAY,                 \
 -			  .u2.objs_arr.obj_type = _idr_type,                   \
 -			  .u2.objs_arr.access = _access,                       \
 -			  .u2.objs_arr.min_len = _min_len,                     \
 -			  .u2.objs_arr.max_len = _max_len,                     \
 -			  __VA_ARGS__ } })
 -
 -#define UVERBS_ATTR_IDR(_attr_id, _idr_type, _access, ...)                     \
 -	(&(const struct uverbs_attr_def){                                      \
 -		.id = _attr_id,                                                \
 -		.attr = { .type = UVERBS_ATTR_TYPE_IDR,                        \
 -			  .u.obj.obj_type = _idr_type,                         \
 -			  .u.obj.access = _access,                             \
 -			  __VA_ARGS__ } })
 -
 -#define UVERBS_ATTR_FD(_attr_id, _fd_type, _access, ...)                       \
 -	(&(const struct uverbs_attr_def){                                      \
 -		.id = (_attr_id) +                                             \
 -		      BUILD_BUG_ON_ZERO((_access) != UVERBS_ACCESS_NEW &&      \
 -					(_access) != UVERBS_ACCESS_READ),      \
 -		.attr = { .type = UVERBS_ATTR_TYPE_FD,                         \
 -			  .u.obj.obj_type = _fd_type,                          \
 -			  .u.obj.access = _access,                             \
 -			  __VA_ARGS__ } })
 -
 -#define UVERBS_ATTR_PTR_IN(_attr_id, _type, ...)                               \
 -	(&(const struct uverbs_attr_def){                                      \
 -		.id = _attr_id,                                                \
 -		.attr = { .type = UVERBS_ATTR_TYPE_PTR_IN,                     \
 -			  _type,                                               \
 -			  __VA_ARGS__ } })
 -
 -#define UVERBS_ATTR_PTR_OUT(_attr_id, _type, ...)                              \
 -	(&(const struct uverbs_attr_def){                                      \
 -		.id = _attr_id,                                                \
 -		.attr = { .type = UVERBS_ATTR_TYPE_PTR_OUT,                    \
 -			  _type,                                               \
 -			  __VA_ARGS__ } })
 -
 -/* _enum_arry should be a 'static const union uverbs_attr_spec[]' */
 -#define UVERBS_ATTR_ENUM_IN(_attr_id, _enum_arr, ...)                          \
 -	(&(const struct uverbs_attr_def){                                      \
 -		.id = _attr_id,                                                \
 -		.attr = { .type = UVERBS_ATTR_TYPE_ENUM_IN,                    \
 -			  .u2.enum_def.ids = _enum_arr,                        \
 -			  .u.enum_def.num_elems = ARRAY_SIZE(_enum_arr),       \
 -			  __VA_ARGS__ },                                       \
 -	})
 -
 -/* An input value that is a member in the enum _enum_type. */
 -#define UVERBS_ATTR_CONST_IN(_attr_id, _enum_type, ...)                        \
 -	UVERBS_ATTR_PTR_IN(                                                    \
 -		_attr_id,                                                      \
 -		UVERBS_ATTR_SIZE(                                              \
 -			sizeof(u64) + BUILD_BUG_ON_ZERO(!sizeof(_enum_type)),  \
 -			sizeof(u64)),                                          \
 -		__VA_ARGS__)
 +	.min_len = sizeof(_type), .len = sizeof(_type)
 +#define UVERBS_ATTR_STRUCT(_type, _last)			\
 +	.min_len = ((uintptr_t)(&((_type *)0)->_last + 1)), .len = sizeof(_type)
 +#define UVERBS_ATTR_SIZE(_min_len, _len)			\
 +	.min_len = _min_len, .len = _len
 +#define UVERBS_ATTR_MIN_SIZE(_min_len)				\
 +	UVERBS_ATTR_SIZE(_min_len, USHRT_MAX)
  
  /*
 - * An input value that is a bitwise combination of values of _enum_type.
 - * This permits the flag value to be passed as either a u32 or u64, it must
 - * be retrieved via uverbs_get_flag().
 + * In new compiler, UVERBS_ATTR could be simplified by declaring it as
 + * [_id] = {.type = _type, .len = _len, ##__VA_ARGS__}
 + * But since we support older compilers too, we need the more complex code.
   */
 -#define UVERBS_ATTR_FLAGS_IN(_attr_id, _enum_type, ...)                        \
 -	UVERBS_ATTR_PTR_IN(                                                    \
 -		_attr_id,                                                      \
 -		UVERBS_ATTR_SIZE(sizeof(u32) + BUILD_BUG_ON_ZERO(              \
 -						       !sizeof(_enum_type *)), \
 -				 sizeof(u64)),                                 \
 -		__VA_ARGS__)
 +#define UVERBS_ATTR(_id, _type, _fld, _attr, ...)			\
 +	__UVERBS_ATTR(_id, _type, _fld, _attr, ##__VA_ARGS__, 2, 1, 0)
 +#define UVERBS_ATTR_PTR_IN_SZ(_id, _len, ...)				\
 +	UVERBS_ATTR(_id, UVERBS_ATTR_TYPE_PTR_IN, ptr, _len, ##__VA_ARGS__)
 +/* If sizeof(_type) <= sizeof(u64), this will be inlined rather than a pointer */
 +#define UVERBS_ATTR_PTR_IN(_id, _type, ...)				\
 +	UVERBS_ATTR_PTR_IN_SZ(_id, _type, ##__VA_ARGS__)
 +#define UVERBS_ATTR_PTR_OUT_SZ(_id, _len, ...)				\
 +	UVERBS_ATTR(_id, UVERBS_ATTR_TYPE_PTR_OUT, ptr, _len, ##__VA_ARGS__)
 +#define UVERBS_ATTR_PTR_OUT(_id, _type, ...)				\
 +	UVERBS_ATTR_PTR_OUT_SZ(_id, _type, ##__VA_ARGS__)
 +#define UVERBS_ATTR_ENUM_IN(_id, _enum_arr, ...)			\
 +	UVERBS_ATTR(_id, UVERBS_ATTR_TYPE_ENUM_IN, enum_def,		\
 +		    .ids = (_enum_arr),					\
 +		    .num_elems = ARRAY_SIZE(_enum_arr), ##__VA_ARGS__)
  
  /*
 - * This spec is used in order to pass information to the hardware driver in a
 - * legacy way. Every verb that could get driver specific data should get this
 - * spec.
 + * In new compiler, UVERBS_ATTR_IDR (and FD) could be simplified by declaring
 + * it as
 + * {.id = _id,								\
 + *  .attr {.type = __obj_class,						\
 + *         .obj = {.obj_type = _idr_type,				\
 + *                       .access = _access                              \
 + *                }, ##__VA_ARGS__ } }
 + * But since we support older compilers too, we need the more complex code.
   */
 -#define UVERBS_ATTR_UHW()                                                      \
 -	UVERBS_ATTR_PTR_IN(UVERBS_ATTR_UHW_IN,                                 \
 -			   UVERBS_ATTR_MIN_SIZE(0),			       \
 -			   UA_OPTIONAL),				       \
 -	UVERBS_ATTR_PTR_OUT(UVERBS_ATTR_UHW_OUT,                               \
 -			    UVERBS_ATTR_MIN_SIZE(0),			       \
 -			    UA_OPTIONAL)
 +#define ___UVERBS_ATTR_OBJ0(_id, _obj_class, _obj_type, _access, ...)\
 +	((const struct uverbs_attr_def)					\
 +	{.id = _id,							\
 +	 .attr = { {.obj = {.type = _obj_class, .obj_type = _obj_type,	\
 +			    .access = _access, .flags = 0 } }, } })
 +#define ___UVERBS_ATTR_OBJ1(_id, _obj_class, _obj_type, _access, _flags)\
 +	((const struct uverbs_attr_def)					\
 +	{.id = _id,							\
 +	.attr = { {.obj = {.type = _obj_class, .obj_type = _obj_type,	\
 +			   .access = _access, _flags} }, } })
 +#define ___UVERBS_ATTR_OBJ(_id, _obj_class, _obj_type, _access, _flags, \
 +			   _n, ...)					\
 +	___UVERBS_ATTR_OBJ##_n(_id, _obj_class, _obj_type, _access, _flags)
 +#define __UVERBS_ATTR_OBJ(_id, _obj_class, _obj_type, _access, ...)	\
 +	___UVERBS_ATTR_OBJ(_id, _obj_class, _obj_type, _access,		\
 +			   ##__VA_ARGS__, 1, 0)
 +#define UVERBS_ATTR_IDR(_id, _idr_type, _access, ...)			 \
 +	__UVERBS_ATTR_OBJ(_id, UVERBS_ATTR_TYPE_IDR, _idr_type, _access,\
 +			  ##__VA_ARGS__)
 +#define UVERBS_ATTR_FD(_id, _fd_type, _access, ...)			\
 +	__UVERBS_ATTR_OBJ(_id, UVERBS_ATTR_TYPE_FD, _fd_type,		\
 +			  (_access) + BUILD_BUG_ON_ZERO(		\
 +				(_access) != UVERBS_ACCESS_NEW &&	\
 +				(_access) != UVERBS_ACCESS_READ),	\
 +			  ##__VA_ARGS__)
 +#define DECLARE_UVERBS_ATTR_SPEC(_name, ...)				\
 +	const struct uverbs_attr_def _name = __VA_ARGS__
 +
 +#define DECLARE_UVERBS_ENUM(_name, ...)					\
 +	const struct uverbs_enum_spec _name = {				\
 +		.len = ARRAY_SIZE(((struct uverbs_attr_spec[]){__VA_ARGS__})),\
 +		.ids = {__VA_ARGS__},					\
 +	}
 +#define _UVERBS_METHOD_ATTRS_SZ(...)					\
 +	(sizeof((const struct uverbs_attr_def * const []){__VA_ARGS__}) /\
 +	 sizeof(const struct uverbs_attr_def *))
 +#define _UVERBS_METHOD(_id, _handler, _flags, ...)			\
 +	((const struct uverbs_method_def) {				\
 +	 .id = _id,							\
 +	 .flags = _flags,						\
 +	 .handler = _handler,						\
 +	 .num_attrs = _UVERBS_METHOD_ATTRS_SZ(__VA_ARGS__),		\
 +	 .attrs = &(const struct uverbs_attr_def * const []){__VA_ARGS__} })
 +#define DECLARE_UVERBS_METHOD(_name, _id, _handler, ...)		\
 +	const struct uverbs_method_def _name =				\
 +		_UVERBS_METHOD(_id, _handler, 0, ##__VA_ARGS__)
 +#define DECLARE_UVERBS_CTX_METHOD(_name, _id, _handler, _flags, ...)	\
 +	const struct uverbs_method_def _name =				\
 +		_UVERBS_METHOD(_id, _handler,				\
 +			       UVERBS_ACTION_FLAG_CREATE_ROOT,		\
 +			       ##__VA_ARGS__)
 +#define _UVERBS_OBJECT_METHODS_SZ(...)					\
 +	(sizeof((const struct uverbs_method_def * const []){__VA_ARGS__}) / \
 +	 sizeof(const struct uverbs_method_def *))
 +#define _UVERBS_OBJECT(_id, _type_attrs, ...)				\
 +	((const struct uverbs_object_def) {				\
 +	 .id = _id,							\
 +	 .type_attrs = _type_attrs,					\
 +	 .num_methods = _UVERBS_OBJECT_METHODS_SZ(__VA_ARGS__),		\
 +	 .methods = &(const struct uverbs_method_def * const []){__VA_ARGS__} })
 +#define DECLARE_UVERBS_OBJECT(_name, _id, _type_attrs, ...)		\
 +	const struct uverbs_object_def _name =				\
 +		_UVERBS_OBJECT(_id, _type_attrs, ##__VA_ARGS__)
 +#define _UVERBS_TREE_OBJECTS_SZ(...)					\
 +	(sizeof((const struct uverbs_object_def * const []){__VA_ARGS__}) / \
 +	 sizeof(const struct uverbs_object_def *))
 +#define _UVERBS_OBJECT_TREE(...)					\
 +	((const struct uverbs_object_tree_def) {			\
 +	 .num_objects = _UVERBS_TREE_OBJECTS_SZ(__VA_ARGS__),		\
 +	 .objects = &(const struct uverbs_object_def * const []){__VA_ARGS__} })
 +#define DECLARE_UVERBS_OBJECT_TREE(_name, ...)				\
 +	const struct uverbs_object_tree_def _name =			\
 +		_UVERBS_OBJECT_TREE(__VA_ARGS__)
  
  /* =================================================
   *              Parsing infrastructure
* Unmerged path drivers/infiniband/core/uverbs_uapi.c
* Unmerged path drivers/infiniband/core/rdma_core.h
* Unmerged path drivers/infiniband/core/uverbs_uapi.c
* Unmerged path include/rdma/uverbs_ioctl.h
