net: tls, update curr on splice as well

jira LE-1907
cve CVE-2024-0646
Rebuild_History Non-Buildable kernel-4.18.0-538.el8
commit-author John Fastabend <john.fastabend@gmail.com>
commit c5a595000e2677e865a39f249c056bc05d6e55fd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-538.el8/c5a59500.failed

The curr pointer must also be updated on the splice similar to how
we do this for other copy types.

Fixes: d829e9c4112b ("tls: convert to generic sk_msg interface")
	Signed-off-by: John Fastabend <john.fastabend@gmail.com>
	Reported-by: Jann Horn <jannh@google.com>
Link: https://lore.kernel.org/r/20231206232706.374377-2-john.fastabend@gmail.com
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit c5a595000e2677e865a39f249c056bc05d6e55fd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/tls/tls_sw.c
diff --cc net/tls/tls_sw.c
index 74fd8da33d1e,e37b4d2e2acd..000000000000
--- a/net/tls/tls_sw.c
+++ b/net/tls/tls_sw.c
@@@ -922,7 -931,39 +922,43 @@@ static int tls_sw_push_pending_record(s
  				   &copied, flags);
  }
  
++<<<<<<< HEAD
 +int tls_sw_sendmsg(struct sock *sk, struct msghdr *msg, size_t size)
++=======
+ static int tls_sw_sendmsg_splice(struct sock *sk, struct msghdr *msg,
+ 				 struct sk_msg *msg_pl, size_t try_to_copy,
+ 				 ssize_t *copied)
+ {
+ 	struct page *page = NULL, **pages = &page;
+ 
+ 	do {
+ 		ssize_t part;
+ 		size_t off;
+ 
+ 		part = iov_iter_extract_pages(&msg->msg_iter, &pages,
+ 					      try_to_copy, 1, 0, &off);
+ 		if (part <= 0)
+ 			return part ?: -EIO;
+ 
+ 		if (WARN_ON_ONCE(!sendpage_ok(page))) {
+ 			iov_iter_revert(&msg->msg_iter, part);
+ 			return -EIO;
+ 		}
+ 
+ 		sk_msg_page_add(msg_pl, page, part, off);
+ 		msg_pl->sg.copybreak = 0;
+ 		msg_pl->sg.curr = msg_pl->sg.end;
+ 		sk_mem_charge(sk, part);
+ 		*copied += part;
+ 		try_to_copy -= part;
+ 	} while (try_to_copy && !sk_msg_full(msg_pl));
+ 
+ 	return 0;
+ }
+ 
+ static int tls_sw_sendmsg_locked(struct sock *sk, struct msghdr *msg,
+ 				 size_t size)
++>>>>>>> c5a595000e26 (net: tls, update curr on splice as well)
  {
  	long timeo = sock_sndtimeo(sk, msg->msg_flags & MSG_DONTWAIT);
  	struct tls_context *tls_ctx = tls_get_ctx(sk);
* Unmerged path net/tls/tls_sw.c
