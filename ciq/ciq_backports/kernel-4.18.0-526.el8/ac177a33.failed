net: sched: cls_flower: Undo tcf_bind_filter in case of an error

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-526.el8
commit-author Victor Nogueira <victor@mojatatu.com>
commit ac177a330077f264664f56259038e121bb214bec
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-526.el8/ac177a33.failed

If TCA_FLOWER_CLASSID is specified in the netlink message, the code will
call tcf_bind_filter. However, if any error occurs after that, the code
should undo this by calling tcf_unbind_filter.

Fixes: 77b9900ef53a ("tc: introduce Flower classifier")
	Signed-off-by: Victor Nogueira <victor@mojatatu.com>
	Acked-by: Jamal Hadi Salim <jhs@mojatatu.com>
	Reviewed-by: Pedro Tammela <pctammela@mojatatu.com>
	Reviewed-by: Simon Horman <simon.horman@corigine.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit ac177a330077f264664f56259038e121bb214bec)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sched/cls_flower.c
diff --cc net/sched/cls_flower.c
index d6486cb6efd1,8da9d039d964..000000000000
--- a/net/sched/cls_flower.c
+++ b/net/sched/cls_flower.c
@@@ -2023,43 -2168,9 +2023,49 @@@ errout_cleanup
  	return ret;
  }
  
++<<<<<<< HEAD
 +static int fl_set_parms(struct net *net, struct tcf_proto *tp,
 +			struct cls_fl_filter *f, struct fl_flow_mask *mask,
 +			unsigned long base, struct nlattr **tb,
 +			struct nlattr *est,
 +			struct fl_flow_tmplt *tmplt,
 +			u32 flags, u32 fl_flags,
 +			struct netlink_ext_ack *extack)
 +{
 +	int err;
 +
 +	err = tcf_exts_validate_ex(net, tp, tb, est, &f->exts, flags,
 +				   fl_flags, extack);
 +	if (err < 0)
 +		return err;
 +
 +	if (tb[TCA_FLOWER_CLASSID]) {
 +		f->res.classid = nla_get_u32(tb[TCA_FLOWER_CLASSID]);
 +		if (flags & TCA_ACT_FLAGS_NO_RTNL)
 +			rtnl_lock();
 +		tcf_bind_filter(tp, &f->res, base);
 +		if (flags & TCA_ACT_FLAGS_NO_RTNL)
 +			rtnl_unlock();
 +	}
 +
 +	err = fl_set_key(net, tb, &f->key, &mask->key, extack);
 +	if (err)
 +		return err;
 +
 +	fl_mask_update_range(mask);
 +	fl_set_masked_key(&f->mkey, &f->key, mask);
 +
 +	if (!fl_mask_fits_tmplt(tmplt, mask)) {
 +		NL_SET_ERR_MSG_MOD(extack, "Mask does not fit the template");
 +		return -EINVAL;
 +	}
 +
 +	return 0;
++=======
+ static bool fl_needs_tc_skb_ext(const struct fl_flow_key *mask)
+ {
+ 	return mask->meta.l2_miss;
++>>>>>>> ac177a330077 (net: sched: cls_flower: Undo tcf_bind_filter in case of an error)
  }
  
  static int fl_ht_insert_unique(struct cls_fl_filter *fnew,
* Unmerged path net/sched/cls_flower.c
