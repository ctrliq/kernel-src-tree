USB: core: Add API to change the wireless_status

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-526.el8
commit-author Bastien Nocera <hadess@hadess.net>
commit 0a4db185f0788dfc828512d0004c468921bf6c0a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-526.el8/0a4db185.failed

This adds the API that allows device specific drivers to tell user-space
about whether the wireless device is connected to its receiver dongle.

See "USB: core: Add wireless_status sysfs attribute" for a detailed
explanation of what this attribute should be used for.

	Signed-off-by: Bastien Nocera <hadess@hadess.net>
	Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
	Acked-by: Alan Stern <stern@rowland.harvard.edu>
Link: https://lore.kernel.org/r/20230302105555.51417-5-hadess@hadess.net
	Signed-off-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
(cherry picked from commit 0a4db185f0788dfc828512d0004c468921bf6c0a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/usb.h
diff --cc include/linux/usb.h
index d7580b040d7e,6dfd59d3d695..000000000000
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@@ -253,6 -261,8 +253,11 @@@ struct usb_interface 
  	unsigned needs_binding:1;	/* needs delayed unbind/rebind */
  	unsigned resetting_device:1;	/* true: bandwidth alloc after reset */
  	unsigned authorized:1;		/* used for interface authorization */
++<<<<<<< HEAD
++=======
+ 	enum usb_wireless_status wireless_status;
+ 	struct work_struct wireless_status_work;
++>>>>>>> 0a4db185f078 (USB: core: Add API to change the wireless_status)
  
  	struct device dev;		/* interface specific device info */
  	struct device *usb_dev;
diff --git a/drivers/usb/core/message.c b/drivers/usb/core/message.c
index ca5526b767be..3fa2bbfa2626 100644
--- a/drivers/usb/core/message.c
+++ b/drivers/usb/core/message.c
@@ -1903,6 +1903,45 @@ static void __usb_queue_reset_device(struct work_struct *ws)
 	usb_put_intf(iface);	/* Undo _get_ in usb_queue_reset_device() */
 }
 
+/*
+ * Internal function to set the wireless_status sysfs attribute
+ * See usb_set_wireless_status() for more details
+ */
+static void __usb_wireless_status_intf(struct work_struct *ws)
+{
+	struct usb_interface *iface =
+		container_of(ws, struct usb_interface, wireless_status_work);
+
+	device_lock(iface->dev.parent);
+	if (iface->sysfs_files_created)
+		usb_update_wireless_status_attr(iface);
+	device_unlock(iface->dev.parent);
+	usb_put_intf(iface);	/* Undo _get_ in usb_set_wireless_status() */
+}
+
+/**
+ * usb_set_wireless_status - sets the wireless_status struct member
+ * @dev: the device to modify
+ * @status: the new wireless status
+ *
+ * Set the wireless_status struct member to the new value, and emit
+ * sysfs changes as necessary.
+ *
+ * Returns: 0 on success, -EALREADY if already set.
+ */
+int usb_set_wireless_status(struct usb_interface *iface,
+		enum usb_wireless_status status)
+{
+	if (iface->wireless_status == status)
+		return -EALREADY;
+
+	usb_get_intf(iface);
+	iface->wireless_status = status;
+	schedule_work(&iface->wireless_status_work);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(usb_set_wireless_status);
 
 /*
  * usb_set_configuration - Makes a particular device setting be current
@@ -2095,6 +2134,7 @@ int usb_set_configuration(struct usb_device *dev, int configuration)
 		intf->dev.type = &usb_if_device_type;
 		intf->dev.groups = usb_interface_groups;
 		INIT_WORK(&intf->reset_ws, __usb_queue_reset_device);
+		INIT_WORK(&intf->wireless_status_work, __usb_wireless_status_intf);
 		intf->minor = -1;
 		device_initialize(&intf->dev);
 		pm_runtime_no_callbacks(&intf->dev);
* Unmerged path include/linux/usb.h
