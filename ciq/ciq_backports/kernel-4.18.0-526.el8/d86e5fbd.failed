net: skb_queue_purge_reason() optimizations

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-526.el8
commit-author Eric Dumazet <edumazet@google.com>
commit d86e5fbd4c965fdda72f99ccd54a1031ea4df51d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-526.el8/d86e5fbd.failed

1) Exit early if the list is empty.

2) splice the list into a local list,
   so that we block hard irqs only once.

	Signed-off-by: Eric Dumazet <edumazet@google.com>
	Reviewed-by: Simon Horman <horms@kernel.org>
Link: https://lore.kernel.org/r/20231003181920.3280453-1-edumazet@google.com
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit d86e5fbd4c965fdda72f99ccd54a1031ea4df51d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/core/skbuff.c
diff --cc net/core/skbuff.c
index 5b0b94138c72,da3f96bdd6f6..000000000000
--- a/net/core/skbuff.c
+++ b/net/core/skbuff.c
@@@ -3241,13 -3719,24 +3241,29 @@@ EXPORT_SYMBOL(skb_dequeue_tail)
   *	the list and one reference dropped. This function takes the list
   *	lock and is atomic with respect to other list locking functions.
   */
 -void skb_queue_purge_reason(struct sk_buff_head *list,
 -			    enum skb_drop_reason reason)
 +void skb_queue_purge(struct sk_buff_head *list)
  {
++<<<<<<< HEAD
 +	struct sk_buff *skb;
 +	while ((skb = skb_dequeue(list)) != NULL)
 +		kfree_skb(skb);
++=======
+ 	struct sk_buff_head tmp;
+ 	unsigned long flags;
+ 
+ 	if (skb_queue_empty_lockless(list))
+ 		return;
+ 
+ 	__skb_queue_head_init(&tmp);
+ 
+ 	spin_lock_irqsave(&list->lock, flags);
+ 	skb_queue_splice_init(list, &tmp);
+ 	spin_unlock_irqrestore(&list->lock, flags);
+ 
+ 	__skb_queue_purge_reason(&tmp, reason);
++>>>>>>> d86e5fbd4c96 (net: skb_queue_purge_reason() optimizations)
  }
 -EXPORT_SYMBOL(skb_queue_purge_reason);
 +EXPORT_SYMBOL(skb_queue_purge);
  
  /**
   *	skb_rbtree_purge - empty a skb rbtree
* Unmerged path net/core/skbuff.c
