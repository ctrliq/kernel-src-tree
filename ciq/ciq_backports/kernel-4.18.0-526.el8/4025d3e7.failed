net: add skb_queue_purge_reason and __skb_queue_purge_reason

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-526.el8
commit-author Eric Dumazet <edumazet@google.com>
commit 4025d3e73abde4f65f4b04d4b1d8449b00e31473
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-526.el8/4025d3e7.failed

skb_queue_purge() and __skb_queue_purge() become wrappers
around the new generic functions.

New SKB_DROP_REASON_QUEUE_PURGE drop reason is added,
but users can start adding more specific reasons.

	Signed-off-by: Eric Dumazet <edumazet@google.com>
	Reviewed-by: Simon Horman <horms@kernel.org>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 4025d3e73abde4f65f4b04d4b1d8449b00e31473)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/skbuff.h
#	include/net/dropreason-core.h
diff --cc include/linux/skbuff.h
index f8604f48e933,9aec136bc690..000000000000
--- a/include/linux/skbuff.h
+++ b/include/linux/skbuff.h
@@@ -2859,12 -3157,26 +2860,31 @@@ static inline int skb_orphan_frags_rx(s
   *	the list and one reference dropped. This function does not take the
   *	list lock and the caller must hold the relevant locks to use it.
   */
++<<<<<<< HEAD
 +void skb_queue_purge(struct sk_buff_head *list);
 +static inline void __skb_queue_purge(struct sk_buff_head *list)
++=======
+ static inline void __skb_queue_purge_reason(struct sk_buff_head *list,
+ 					    enum skb_drop_reason reason)
++>>>>>>> 4025d3e73abd (net: add skb_queue_purge_reason and __skb_queue_purge_reason)
  {
  	struct sk_buff *skb;
+ 
  	while ((skb = __skb_dequeue(list)) != NULL)
- 		kfree_skb(skb);
+ 		kfree_skb_reason(skb, reason);
+ }
+ 
+ static inline void __skb_queue_purge(struct sk_buff_head *list)
+ {
+ 	__skb_queue_purge_reason(list, SKB_DROP_REASON_QUEUE_PURGE);
+ }
+ 
+ void skb_queue_purge_reason(struct sk_buff_head *list,
+ 			    enum skb_drop_reason reason);
+ 
+ static inline void skb_queue_purge(struct sk_buff_head *list)
+ {
+ 	skb_queue_purge_reason(list, SKB_DROP_REASON_QUEUE_PURGE);
  }
  
  unsigned int skb_rbtree_purge(struct rb_root *root);
* Unmerged path include/net/dropreason-core.h
* Unmerged path include/linux/skbuff.h
* Unmerged path include/net/dropreason-core.h
diff --git a/net/core/skbuff.c b/net/core/skbuff.c
index 5b0b94138c72..85181fb18a59 100644
--- a/net/core/skbuff.c
+++ b/net/core/skbuff.c
@@ -3234,20 +3234,23 @@ struct sk_buff *skb_dequeue_tail(struct sk_buff_head *list)
 EXPORT_SYMBOL(skb_dequeue_tail);
 
 /**
- *	skb_queue_purge - empty a list
+ *	skb_queue_purge_reason - empty a list
  *	@list: list to empty
+ *	@reason: drop reason
  *
  *	Delete all buffers on an &sk_buff list. Each buffer is removed from
  *	the list and one reference dropped. This function takes the list
  *	lock and is atomic with respect to other list locking functions.
  */
-void skb_queue_purge(struct sk_buff_head *list)
+void skb_queue_purge_reason(struct sk_buff_head *list,
+			    enum skb_drop_reason reason)
 {
 	struct sk_buff *skb;
+
 	while ((skb = skb_dequeue(list)) != NULL)
-		kfree_skb(skb);
+		kfree_skb_reason(skb, reason);
 }
-EXPORT_SYMBOL(skb_queue_purge);
+EXPORT_SYMBOL(skb_queue_purge_reason);
 
 /**
  *	skb_rbtree_purge - empty a skb rbtree
