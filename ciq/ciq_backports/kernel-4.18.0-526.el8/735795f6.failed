netfilter: flowtable: GC pushes back packets to classic path

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-526.el8
commit-author Pablo Neira Ayuso <pablo@netfilter.org>
commit 735795f68b37e9bb49f642407a0d49b1631ea1c7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-526.el8/735795f6.failed

Since 41f2c7c342d3 ("net/sched: act_ct: Fix promotion of offloaded
unreplied tuple"), flowtable GC pushes back flows with IPS_SEEN_REPLY
back to classic path in every run, ie. every second. This is because of
a new check for NF_FLOW_HW_ESTABLISHED which is specific of sched/act_ct.

In Netfilter's flowtable case, NF_FLOW_HW_ESTABLISHED never gets set on
and IPS_SEEN_REPLY is unreliable since users decide when to offload the
flow before, such bit might be set on at a later stage.

Fix it by adding a custom .gc handler that sched/act_ct can use to
deal with its NF_FLOW_HW_ESTABLISHED bit.

Fixes: 41f2c7c342d3 ("net/sched: act_ct: Fix promotion of offloaded unreplied tuple")
	Reported-by: Vladimir Smelhaus <vl.sm@email.cz>
	Reviewed-by: Paul Blakey <paulb@nvidia.com>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 735795f68b37e9bb49f642407a0d49b1631ea1c7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/nf_flow_table_core.c
diff --cc net/netfilter/nf_flow_table_core.c
index 30240bbee53e,920a5a29ae1d..000000000000
--- a/net/netfilter/nf_flow_table_core.c
+++ b/net/netfilter/nf_flow_table_core.c
@@@ -379,8 -410,9 +385,14 @@@ static bool nf_flow_custom_gc(struct nf
  static void nf_flow_offload_gc_step(struct nf_flowtable *flow_table,
  				    struct flow_offload *flow, void *data)
  {
++<<<<<<< HEAD
 +
 +	if (nf_flow_has_expired(flow) || nf_ct_is_dying(flow->ct))
++=======
+ 	if (nf_flow_has_expired(flow) ||
+ 	    nf_ct_is_dying(flow->ct) ||
+ 	    nf_flow_custom_gc(flow_table, flow))
++>>>>>>> 735795f68b37 (netfilter: flowtable: GC pushes back packets to classic path)
  		flow_offload_teardown(flow);
  
  	if (test_bit(NF_FLOW_TEARDOWN, &flow->flags)) {
diff --git a/include/net/netfilter/nf_flow_table.h b/include/net/netfilter/nf_flow_table.h
index 5cb275c17a88..f4d1af6b788c 100644
--- a/include/net/netfilter/nf_flow_table.h
+++ b/include/net/netfilter/nf_flow_table.h
@@ -48,6 +48,7 @@ struct nf_flowtable_type {
 	struct list_head		list;
 	int				family;
 	int				(*init)(struct nf_flowtable *ft);
+	bool				(*gc)(const struct flow_offload *flow);
 	int				(*setup)(struct nf_flowtable *ft,
 						 struct net_device *dev,
 						 enum flow_block_command cmd);
* Unmerged path net/netfilter/nf_flow_table_core.c
diff --git a/net/sched/act_ct.c b/net/sched/act_ct.c
index adb56fcdd4bd..5a5c136ab7c9 100644
--- a/net/sched/act_ct.c
+++ b/net/sched/act_ct.c
@@ -277,7 +277,14 @@ static int tcf_ct_flow_table_fill_actions(struct net *net,
 	return err;
 }
 
+static bool tcf_ct_flow_is_outdated(const struct flow_offload *flow)
+{
+	return test_bit(IPS_SEEN_REPLY_BIT, &flow->ct->status) &&
+	       !test_bit(NF_FLOW_HW_ESTABLISHED, &flow->flags);
+}
+
 static struct nf_flowtable_type flowtable_ct = {
+	.gc		= tcf_ct_flow_is_outdated,
 	.action		= tcf_ct_flow_table_fill_actions,
 	.owner		= THIS_MODULE,
 };
