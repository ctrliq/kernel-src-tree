KVM: arm64: Hide ID_AA64MMFR2_EL1.NV from guest and userspace

jira KERNEL-541
Rebuild_History Non-Buildable kernel-5.14.0-611.26.1.el9_7
commit-author Marc Zyngier <maz@kernel.org>
commit 9d6745572899599966fb76a868acca1cae9518af
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-5.14.0-611.26.1.el9_7/9d674557.failed

Since our take on FEAT_NV is to only support FEAT_NV2, we should
never expose ID_AA64MMFR2_EL1.NV to a guest nor userspace.

Make sure we mask this field for good.

	Signed-off-by: Marc Zyngier <maz@kernel.org>
	Reviewed-by: Joey Gouly <joey.gouly@arm.com>
Link: https://lore.kernel.org/r/20250220134907.554085-3-maz@kernel.org
[oliver: squash diff for NV field]
	Signed-off-by: Oliver Upton <oliver.upton@linux.dev>
(cherry picked from commit 9d6745572899599966fb76a868acca1cae9518af)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/arm64/kvm/sys_regs.c
diff --cc arch/arm64/kvm/sys_regs.c
index 5d5e0b00d377,4f675f4ae536..000000000000
--- a/arch/arm64/kvm/sys_regs.c
+++ b/arch/arm64/kvm/sys_regs.c
@@@ -1579,12 -1618,21 +1579,13 @@@ static u64 __kvm_read_sanitised_id_reg(
  		if (!vcpu_has_ptrauth(vcpu))
  			val &= ~(ARM64_FEATURE_MASK(ID_AA64ISAR2_EL1_APA3) |
  				 ARM64_FEATURE_MASK(ID_AA64ISAR2_EL1_GPA3));
 -		if (!cpus_have_final_cap(ARM64_HAS_WFXT) ||
 -		    has_broken_cntvoff())
 +		if (!cpus_have_final_cap(ARM64_HAS_WFXT))
  			val &= ~ARM64_FEATURE_MASK(ID_AA64ISAR2_EL1_WFxT);
  		break;
 -	case SYS_ID_AA64ISAR3_EL1:
 -		val &= ID_AA64ISAR3_EL1_FPRCVT | ID_AA64ISAR3_EL1_FAMINMAX;
 -		break;
  	case SYS_ID_AA64MMFR2_EL1:
  		val &= ~ID_AA64MMFR2_EL1_CCIDX_MASK;
+ 		val &= ~ID_AA64MMFR2_EL1_NV;
  		break;
 -	case SYS_ID_AA64MMFR3_EL1:
 -		val &= ID_AA64MMFR3_EL1_TCRX | ID_AA64MMFR3_EL1_S1POE |
 -			ID_AA64MMFR3_EL1_S1PIE;
 -		break;
  	case SYS_ID_MMFR4_EL1:
  		val &= ~ARM64_FEATURE_MASK(ID_MMFR4_EL1_CCIDX);
  		break;
@@@ -1888,27 -1943,51 +1889,54 @@@ static int set_id_aa64pfr1_el1(struct k
  	if ((hw_val & mpam_mask) == (user_val & mpam_mask))
  		user_val &= ~ID_AA64PFR1_EL1_MPAM_frac_MASK;
  
++<<<<<<< HEAD
++=======
+ 	return set_id_reg(vcpu, rd, user_val);
+ }
+ 
+ static int set_id_aa64mmfr2_el1(struct kvm_vcpu *vcpu,
+ 				const struct sys_reg_desc *rd, u64 user_val)
+ {
+ 	u64 hw_val = read_sanitised_ftr_reg(SYS_ID_AA64MMFR2_EL1);
+ 	u64 nv_mask = ID_AA64MMFR2_EL1_NV_MASK;
+ 
+ 	/*
+ 	 * We made the mistake to expose the now deprecated NV field,
+ 	 * so allow userspace to write it, but silently ignore it.
+ 	 */
+ 	if ((hw_val & nv_mask) == (user_val & nv_mask))
+ 		user_val &= ~nv_mask;
+ 
+ 	return set_id_reg(vcpu, rd, user_val);
+ }
+ 
+ static int set_ctr_el0(struct kvm_vcpu *vcpu,
+ 		       const struct sys_reg_desc *rd, u64 user_val)
+ {
+ 	u8 user_L1Ip = SYS_FIELD_GET(CTR_EL0, L1Ip, user_val);
+ 
++>>>>>>> 9d6745572899 (KVM: arm64: Hide ID_AA64MMFR2_EL1.NV from guest and userspace)
  	/*
 -	 * Both AIVIVT (0b01) and VPIPT (0b00) are documented as reserved.
 -	 * Hence only allow to set VIPT(0b10) or PIPT(0b11) for L1Ip based
 -	 * on what hardware reports.
 +	 * Previously MTE_frac was hidden from guest. However, if the
 +	 * hardware supports MTE2 but not MTE_ASYM_FAULT then a value
 +	 * of 0 for this field indicates that the hardware supports
 +	 * MTE_ASYNC. Whereas, 0xf indicates MTE_ASYNC is not supported.
  	 *
 -	 * Using a VIPT software model on PIPT will lead to over invalidation,
 -	 * but still correct. Hence, we can allow downgrading PIPT to VIPT,
 -	 * but not the other way around. This is handled via arm64_ftr_safe_value()
 -	 * as CTR_EL0 ftr_bits has L1Ip field with type FTR_EXACT and safe value
 -	 * set as VIPT.
 +	 * As KVM must accept values from KVM provided by user-space,
 +	 * when ID_AA64PFR1_EL1.MTE is 2 allow user-space to set
 +	 * ID_AA64PFR1_EL1.MTE_frac to 0. However, ignore it to avoid
 +	 * incorrectly claiming hardware support for MTE_ASYNC in the
 +	 * guest.
  	 */
 -	switch (user_L1Ip) {
 -	case CTR_EL0_L1Ip_RESERVED_VPIPT:
 -	case CTR_EL0_L1Ip_RESERVED_AIVIVT:
 -		return -EINVAL;
 -	case CTR_EL0_L1Ip_VIPT:
 -	case CTR_EL0_L1Ip_PIPT:
 -		return set_id_reg(vcpu, rd, user_val);
 -	default:
 -		return -ENOENT;
 +
 +	if (mte == ID_AA64PFR1_EL1_MTE_MTE2 &&
 +	    hw_mte_frac == ID_AA64PFR1_EL1_MTE_frac_NI &&
 +	    user_mte_frac == ID_AA64PFR1_EL1_MTE_frac_ASYNC) {
 +		user_val &= ~ID_AA64PFR1_EL1_MTE_frac_MASK;
 +		user_val |= hw_val & ID_AA64PFR1_EL1_MTE_frac_MASK;
  	}
 +
 +	return set_id_reg(vcpu, rd, user_val);
  }
  
  /*
* Unmerged path arch/arm64/kvm/sys_regs.c
