uprobes: Fix race in uprobe_free_utask

jira KERNEL-541
Rebuild_History Non-Buildable kernel-5.14.0-611.26.1.el9_7
commit-author Jiri Olsa <jolsa@kernel.org>
commit b583ef82b671c9a752fbe3e95bd4c1c51eab764d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-5.14.0-611.26.1.el9_7/b583ef82.failed

Max Makarov reported kernel panic [1] in perf user callchain code.

The reason for that is the race between uprobe_free_utask and bpf
profiler code doing the perf user stack unwind and is triggered
within uprobe_free_utask function:
  - after current->utask is freed and
  - before current->utask is set to NULL

 general protection fault, probably for non-canonical address 0x9e759c37ee555c76: 0000 [#1] SMP PTI
 RIP: 0010:is_uprobe_at_func_entry+0x28/0x80
 ...
  ? die_addr+0x36/0x90
  ? exc_general_protection+0x217/0x420
  ? asm_exc_general_protection+0x26/0x30
  ? is_uprobe_at_func_entry+0x28/0x80
  perf_callchain_user+0x20a/0x360
  get_perf_callchain+0x147/0x1d0
  bpf_get_stackid+0x60/0x90
  bpf_prog_9aac297fb833e2f5_do_perf_event+0x434/0x53b
  ? __smp_call_single_queue+0xad/0x120
  bpf_overflow_handler+0x75/0x110
  ...
  asm_sysvec_apic_timer_interrupt+0x1a/0x20
 RIP: 0010:__kmem_cache_free+0x1cb/0x350
 ...
  ? uprobe_free_utask+0x62/0x80
  ? acct_collect+0x4c/0x220
  uprobe_free_utask+0x62/0x80
  mm_release+0x12/0xb0
  do_exit+0x26b/0xaa0
  __x64_sys_exit+0x1b/0x20
  do_syscall_64+0x5a/0x80

It can be easily reproduced by running following commands in
separate terminals:

  # while :; do bpftrace -e 'uprobe:/bin/ls:_start  { printf("hit\n"); }' -c ls; done
  # bpftrace -e 'profile:hz:100000 { @[ustack()] = count(); }'

Fixing this by making sure current->utask pointer is set to NULL
before we start to release the utask object.

[1] https://github.com/grafana/pyroscope/issues/3673

Fixes: cfa7f3d2c526 ("perf,x86: avoid missing caller address in stack traces captured in uprobe")
	Reported-by: Max Makarov <maxpain@linux.com>
	Signed-off-by: Jiri Olsa <jolsa@kernel.org>
	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
	Acked-by: Oleg Nesterov <oleg@redhat.com>
	Acked-by: Andrii Nakryiko <andrii@kernel.org>
Link: https://lore.kernel.org/r/20250109141440.2692173-1-jolsa@kernel.org
(cherry picked from commit b583ef82b671c9a752fbe3e95bd4c1c51eab764d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/events/uprobes.c
diff --cc kernel/events/uprobes.c
index 9e3b1cde21bc,5d71ef85420c..000000000000
--- a/kernel/events/uprobes.c
+++ b/kernel/events/uprobes.c
@@@ -1720,18 -1915,50 +1720,24 @@@ void uprobe_free_utask(struct task_stru
  	if (!utask)
  		return;
  
++<<<<<<< HEAD
 +	if (utask->active_uprobe)
 +		put_uprobe(utask->active_uprobe);
++=======
+ 	t->utask = NULL;
+ 	WARN_ON_ONCE(utask->active_uprobe || utask->xol_vaddr);
+ 
+ 	timer_delete_sync(&utask->ri_timer);
++>>>>>>> b583ef82b671 (uprobes: Fix race in uprobe_free_utask)
  
  	ri = utask->return_instances;
  	while (ri)
 -		ri = free_ret_instance(ri, true /* cleanup_hprobe */);
 +		ri = free_ret_instance(ri);
  
 +	xol_free_insn_slot(t);
  	kfree(utask);
- 	t->utask = NULL;
  }
  
 -#define RI_TIMER_PERIOD (HZ / 10) /* 100 ms */
 -
 -#define for_each_ret_instance_rcu(pos, head) \
 -	for (pos = rcu_dereference_raw(head); pos; pos = rcu_dereference_raw(pos->next))
 -
 -static void ri_timer(struct timer_list *timer)
 -{
 -	struct uprobe_task *utask = container_of(timer, struct uprobe_task, ri_timer);
 -	struct return_instance *ri;
 -
 -	/* SRCU protects uprobe from reuse for the cmpxchg() inside hprobe_expire(). */
 -	guard(srcu)(&uretprobes_srcu);
 -	/* RCU protects return_instance from freeing. */
 -	guard(rcu)();
 -
 -	for_each_ret_instance_rcu(ri, utask->return_instances)
 -		hprobe_expire(&ri->hprobe, false);
 -}
 -
 -static struct uprobe_task *alloc_utask(void)
 -{
 -	struct uprobe_task *utask;
 -
 -	utask = kzalloc(sizeof(*utask), GFP_KERNEL);
 -	if (!utask)
 -		return NULL;
 -
 -	timer_setup(&utask->ri_timer, ri_timer, 0);
 -
 -	return utask;
 -}
 -
  /*
   * Allocate a uprobe_task object for the task if necessary.
   * Called when the thread hits a breakpoint.
* Unmerged path kernel/events/uprobes.c
