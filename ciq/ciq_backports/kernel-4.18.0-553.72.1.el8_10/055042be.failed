efi/libstub: Check return value of efi_parse_options

jira LE-4066
Rebuild_History Non-Buildable kernel-4.18.0-553.72.1.el8_10
commit-author Arvind Sankar <nivedita@alum.mit.edu>
commit 055042bedd4e0af8186266b189b81e73e708b82b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.72.1.el8_10/055042be.failed

efi_parse_options can fail if it is unable to allocate space for a copy
of the command line. Check the return value to make sure it succeeded.

	Signed-off-by: Arvind Sankar <nivedita@alum.mit.edu>
Link: https://lore.kernel.org/r/20200430182843.2510180-12-nivedita@alum.mit.edu
	Signed-off-by: Ard Biesheuvel <ardb@kernel.org>
(cherry picked from commit 055042bedd4e0af8186266b189b81e73e708b82b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/firmware/efi/libstub/arm-stub.c
#	drivers/firmware/efi/libstub/x86-stub.c
diff --cc drivers/firmware/efi/libstub/arm-stub.c
index 3658b6e086e5,c2484bf75c5d..000000000000
--- a/drivers/firmware/efi/libstub/arm-stub.c
+++ b/drivers/firmware/efi/libstub/arm-stub.c
@@@ -173,29 -207,41 +173,44 @@@ unsigned long efi_entry(void *handle, e
  
  	if (IS_ENABLED(CONFIG_CMDLINE_EXTEND) ||
  	    IS_ENABLED(CONFIG_CMDLINE_FORCE) ||
- 	    cmdline_size == 0)
- 		efi_parse_options(CONFIG_CMDLINE);
+ 	    cmdline_size == 0) {
+ 		status = efi_parse_options(CONFIG_CMDLINE);
+ 		if (status != EFI_SUCCESS) {
+ 			efi_err("Failed to parse options\n");
+ 			goto fail_free_cmdline;
+ 		}
+ 	}
  
- 	if (!IS_ENABLED(CONFIG_CMDLINE_FORCE) && cmdline_size > 0)
- 		efi_parse_options(cmdline_ptr);
+ 	if (!IS_ENABLED(CONFIG_CMDLINE_FORCE) && cmdline_size > 0) {
+ 		status = efi_parse_options(cmdline_ptr);
+ 		if (status != EFI_SUCCESS) {
+ 			efi_err("Failed to parse options\n");
+ 			goto fail_free_cmdline;
+ 		}
+ 	}
  
 -	efi_info("Booting Linux Kernel...\n");
 +	pr_efi(sys_table, "Booting Linux Kernel...\n");
  
 -	si = setup_graphics();
 +	si = setup_graphics(sys_table);
  
 -	status = handle_kernel_image(&image_addr, &image_size,
 +	status = handle_kernel_image(sys_table, image_addr, &image_size,
  				     &reserve_addr,
  				     &reserve_size,
  				     dram_base, image);
  	if (status != EFI_SUCCESS) {
++<<<<<<< HEAD:drivers/firmware/efi/libstub/arm-stub.c
 +		pr_efi_err(sys_table, "Failed to relocate kernel\n");
 +		goto fail_free_cmdline;
++=======
+ 		efi_err("Failed to relocate kernel\n");
+ 		goto fail_free_screeninfo;
++>>>>>>> 055042bedd4e (efi/libstub: Check return value of efi_parse_options):drivers/firmware/efi/libstub/efi-stub.c
  	}
  
 -	efi_retrieve_tpm2_eventlog();
 -
  	/* Ask the firmware to clear memory on unclean shutdown */
 -	efi_enable_reset_attack_mitigation();
 +	efi_enable_reset_attack_mitigation(sys_table);
  
 -	secure_boot = efi_get_secureboot();
 +	secure_boot = efi_get_secureboot(sys_table);
  
  	/*
  	 * Unauthenticated device tree data is a security hazard, so ignore
@@@ -259,73 -315,33 +274,82 @@@
  		}
  	}
  
 -	install_memreserve_table();
 +	install_memreserve_table(sys_table);
  
 -	status = allocate_new_fdt_and_exit_boot(handle, &fdt_addr,
 -						efi_get_max_fdt_addr(dram_base),
 -						initrd_addr, initrd_size,
 -						cmdline_ptr, fdt_addr, fdt_size);
 -	if (status != EFI_SUCCESS)
 -		goto fail_free_initrd;
 +	new_fdt_addr = fdt_addr;
 +	status = allocate_new_fdt_and_exit_boot(sys_table, handle,
 +				&new_fdt_addr, efi_get_max_fdt_addr(dram_base),
 +				initrd_addr, initrd_size, cmdline_ptr,
 +				fdt_addr, fdt_size);
  
 -	efi_enter_kernel(image_addr, fdt_addr, fdt_totalsize((void *)fdt_addr));
 -	/* not reached */
 +	/*
 +	 * If all went well, we need to return the FDT address to the
 +	 * calling function so it can be passed to kernel as part of
 +	 * the kernel boot protocol.
 +	 */
 +	if (status == EFI_SUCCESS)
 +		return new_fdt_addr;
  
 -fail_free_initrd:
 -	efi_err("Failed to update FDT and exit boot services\n");
 +	pr_efi_err(sys_table, "Failed to update FDT and exit boot services\n");
  
 -	efi_free(initrd_size, initrd_addr);
 -	efi_free(fdt_size, fdt_addr);
 +	efi_free(sys_table, initrd_size, initrd_addr);
 +	efi_free(sys_table, fdt_size, fdt_addr);
  
  fail_free_image:
++<<<<<<< HEAD:drivers/firmware/efi/libstub/arm-stub.c
 +	efi_free(sys_table, image_size, *image_addr);
 +	efi_free(sys_table, reserve_size, reserve_addr);
 +fail_free_cmdline:
 +	free_screen_info(sys_table, si);
 +	efi_free(sys_table, cmdline_size, (unsigned long)cmdline_ptr);
++=======
+ 	efi_free(image_size, image_addr);
+ 	efi_free(reserve_size, reserve_addr);
+ fail_free_screeninfo:
+ 	free_screen_info(si);
+ fail_free_cmdline:
+ 	efi_free(cmdline_size, (unsigned long)cmdline_ptr);
++>>>>>>> 055042bedd4e (efi/libstub: Check return value of efi_parse_options):drivers/firmware/efi/libstub/efi-stub.c
  fail:
 -	return status;
 +	return EFI_ERROR;
 +}
 +
 +static int cmp_mem_desc(const void *l, const void *r)
 +{
 +	const efi_memory_desc_t *left = l, *right = r;
 +
 +	return (left->phys_addr > right->phys_addr) ? 1 : -1;
 +}
 +
 +/*
 + * Returns whether region @left ends exactly where region @right starts,
 + * or false if either argument is NULL.
 + */
 +static bool regions_are_adjacent(efi_memory_desc_t *left,
 +				 efi_memory_desc_t *right)
 +{
 +	u64 left_end;
 +
 +	if (left == NULL || right == NULL)
 +		return false;
 +
 +	left_end = left->phys_addr + left->num_pages * EFI_PAGE_SIZE;
 +
 +	return left_end == right->phys_addr;
 +}
 +
 +/*
 + * Returns whether region @left and region @right have compatible memory type
 + * mapping attributes, and are both EFI_MEMORY_RUNTIME regions.
 + */
 +static bool regions_have_compatible_memory_type_attrs(efi_memory_desc_t *left,
 +						      efi_memory_desc_t *right)
 +{
 +	static const u64 mem_type_mask = EFI_MEMORY_WB | EFI_MEMORY_WT |
 +					 EFI_MEMORY_WC | EFI_MEMORY_UC |
 +					 EFI_MEMORY_RUNTIME;
 +
 +	return ((left->attribute ^ right->attribute) & mem_type_mask) == 0;
  }
  
  /*
* Unmerged path drivers/firmware/efi/libstub/x86-stub.c
* Unmerged path drivers/firmware/efi/libstub/arm-stub.c
* Unmerged path drivers/firmware/efi/libstub/x86-stub.c
