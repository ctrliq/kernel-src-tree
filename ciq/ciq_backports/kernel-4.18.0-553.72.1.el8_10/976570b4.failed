sbitmap: Advance the queue index before waking up a queue

jira LE-4066
Rebuild_History Non-Buildable kernel-4.18.0-553.72.1.el8_10
commit-author Gabriel Krisman Bertazi <krisman@suse.de>
commit 976570b4ecd30d3ec6e1b0910da8e5edc591f2b6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.72.1.el8_10/976570b4.failed

When a queue is awaken, the wake_index written by sbq_wake_ptr currently
keeps pointing to the same queue.  On the next wake up, it will thus
retry the same queue, which is unfair to other queues, and can lead to
starvation.  This patch, moves the index update to happen before the
queue is returned, such that it will now try a different queue first on
the next wake up, improving fairness.

Fixes: 4f8126bb2308 ("sbitmap: Use single per-bitmap counting to wake up queued tags")
	Reported-by: Jan Kara <jack@suse.cz>
	Reviewed-by: Jan Kara <jack@suse.cz>
	Signed-off-by: Gabriel Krisman Bertazi <krisman@suse.de>
Link: https://lore.kernel.org/r/20221115224553.23594-2-krisman@suse.de
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit 976570b4ecd30d3ec6e1b0910da8e5edc591f2b6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	lib/sbitmap.c
diff --cc lib/sbitmap.c
index 0956b5ca3935,bea7984f7987..000000000000
--- a/lib/sbitmap.c
+++ b/lib/sbitmap.c
@@@ -539,7 -571,15 +539,19 @@@ static struct sbq_wait_state *sbq_wake_
  	for (i = 0; i < SBQ_WAIT_QUEUES; i++) {
  		struct sbq_wait_state *ws = &sbq->ws[wake_index];
  
++<<<<<<< HEAD
 +		if (waitqueue_active(&ws->wait) && atomic_read(&ws->wait_cnt)) {
++=======
+ 		/*
+ 		 * Advance the index before checking the current queue.
+ 		 * It improves fairness, by ensuring the queue doesn't
+ 		 * need to be fully emptied before trying to wake up
+ 		 * from the next one.
+ 		 */
+ 		wake_index = sbq_index_inc(wake_index);
+ 
+ 		if (waitqueue_active(&ws->wait)) {
++>>>>>>> 976570b4ecd3 (sbitmap: Advance the queue index before waking up a queue)
  			if (wake_index != atomic_read(&sbq->wake_index))
  				atomic_set(&sbq->wake_index, wake_index);
  			return ws;
* Unmerged path lib/sbitmap.c
