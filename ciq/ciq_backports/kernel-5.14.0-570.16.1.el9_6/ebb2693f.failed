ice: Read SDP section from NVM for pin definitions

jira NONE_AUTOMATION
Rebuild_History Non-Buildable kernel-5.14.0-570.16.1.el9_6
commit-author Yochai Hagvi <yochai.hagvi@intel.com>
commit ebb2693f8fbdb444e01ac6b6b50282aaabc96e77
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-5.14.0-570.16.1.el9_6/ebb2693f.failed

PTP pins assignment and their related SDPs (Software Definable Pins) are
currently hardcoded.
Fix that by reading NVM section instead on products supporting this,
which are E810 products.
If SDP section is not defined in NVM, the driver continues to use the
hardcoded table.

	Reviewed-by: Arkadiusz Kubalewski <arkadiusz.kubalewski@intel.com>
	Signed-off-by: Yochai Hagvi <yochai.hagvi@intel.com>
Co-developed-by: Karol Kolacinski <karol.kolacinski@intel.com>
	Signed-off-by: Karol Kolacinski <karol.kolacinski@intel.com>
	Reviewed-by: Simon Horman <horms@kernel.org>
	Tested-by: Pucha Himasekhar Reddy <himasekharx.reddy.pucha@intel.com> (A Contingent worker at Intel)
	Signed-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>
(cherry picked from commit ebb2693f8fbdb444e01ac6b6b50282aaabc96e77)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/ice/ice_ptp.c
#	drivers/net/ethernet/intel/ice/ice_ptp.h
#	drivers/net/ethernet/intel/ice/ice_ptp_hw.h
diff --cc drivers/net/ethernet/intel/ice/ice_ptp.c
index 0d0c1b2cbd01,753709ef1ab2..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_ptp.c
+++ b/drivers/net/ethernet/intel/ice/ice_ptp.c
@@@ -39,15 -39,21 +39,33 @@@ static const struct ice_ptp_pin_desc ic
  	{  ONE_PPS, { -1, 5 }},
  };
  
++<<<<<<< HEAD
 +#define E810_OUT_PROP_DELAY_NS 1
 +
 +static const struct ptp_pin_desc ice_pin_desc_e810t[] = {
 +	/* name    idx   func         chan */
 +	{ "GNSS",  GNSS, PTP_PF_EXTTS, 0, { 0, } },
 +	{ "SMA1",  SMA1, PTP_PF_NONE, 1, { 0, } },
 +	{ "U.FL1", UFL1, PTP_PF_NONE, 1, { 0, } },
 +	{ "SMA2",  SMA2, PTP_PF_NONE, 2, { 0, } },
 +	{ "U.FL2", UFL2, PTP_PF_NONE, 2, { 0, } },
++=======
+ static const char ice_pin_names_nvm[][64] = {
+ 	"GNSS",
+ 	"SMA1",
+ 	"U.FL1",
+ 	"SMA2",
+ 	"U.FL2",
+ };
+ 
+ static const struct ice_ptp_pin_desc ice_pin_desc_e810_sma[] = {
+ 	/* name,   gpio */
+ 	{  GNSS, {  1, -1 }},
+ 	{  SMA1, {  1,  0 }},
+ 	{  UFL1, { -1,  0 }},
+ 	{  SMA2, {  3,  2 }},
+ 	{  UFL2, {  3, -1 }},
++>>>>>>> ebb2693f8fbd (ice: Read SDP section from NVM for pin definitions)
  };
  
  /**
@@@ -2612,8 -2383,12 +2630,17 @@@ static void ice_ptp_setup_pin_cfg(struc
  		struct ptp_pin_desc *pin = &pf->ptp.pin_desc[i];
  		const char *name = NULL;
  
++<<<<<<< HEAD
 +		name = ice_pin_names[desc->name_idx];
 +		strscpy(pin->name, name, sizeof(pin->name));
++=======
+ 		if (!ice_is_feature_supported(pf, ICE_F_SMA_CTRL))
+ 			name = ice_pin_names[desc->name_idx];
+ 		else if (desc->name_idx != GPIO_NA)
+ 			name = ice_pin_names_nvm[desc->name_idx];
+ 		if (name)
+ 			strscpy(pin->name, name, sizeof(pin->name));
++>>>>>>> ebb2693f8fbd (ice: Read SDP section from NVM for pin definitions)
  
  		pin->index = i;
  	}
@@@ -2622,20 -2397,17 +2649,32 @@@
  }
  
  /**
++<<<<<<< HEAD
 + * ice_ptp_disable_sma_pins_e810t - Disable E810-T SMA pins
++=======
+  * ice_ptp_disable_pins - Disable PTP pins
++>>>>>>> ebb2693f8fbd (ice: Read SDP section from NVM for pin definitions)
   * @pf: pointer to the PF structure
 + * @info: PTP clock info structure
   *
   * Disable the OS access to the SMA pins. Called to clear out the OS
 - * indications of pin support when we fail to setup the SMA control register.
 + * indications of pin support when we fail to setup the E810-T SMA control
 + * register.
   */
++<<<<<<< HEAD
 +static void
 +ice_ptp_disable_sma_pins_e810t(struct ice_pf *pf, struct ptp_clock_info *info)
++=======
+ static void ice_ptp_disable_pins(struct ice_pf *pf)
++>>>>>>> ebb2693f8fbd (ice: Read SDP section from NVM for pin definitions)
  {
 -	struct ptp_clock_info *info = &pf->ptp.info;
 +	struct device *dev = ice_pf_to_dev(pf);
  
++<<<<<<< HEAD
 +	dev_warn(dev, "Failed to configure E810-T SMA pin control\n");
++=======
+ 	dev_warn(ice_pf_to_dev(pf), "Failed to configure PTP pin control\n");
++>>>>>>> ebb2693f8fbd (ice: Read SDP section from NVM for pin definitions)
  
  	info->enable = NULL;
  	info->verify = NULL;
@@@ -2645,46 -2417,75 +2684,118 @@@
  }
  
  /**
++<<<<<<< HEAD
 + * ice_ptp_setup_sma_pins_e810t - Setup the SMA pins
 + * @pf: pointer to the PF structure
 + * @info: PTP clock info structure
 + *
 + * Finish setting up the SMA pins by allocating pin_config, and setting it up
 + * according to the current status of the SMA. On failure, disable all of the
 + * extended SMA pin support.
 + */
 +static void
 +ice_ptp_setup_sma_pins_e810t(struct ice_pf *pf, struct ptp_clock_info *info)
 +{
 +	struct device *dev = ice_pf_to_dev(pf);
 +	int err;
 +
 +	/* Allocate memory for kernel pins interface */
 +	info->pin_config = devm_kcalloc(dev, info->n_pins,
 +					sizeof(*info->pin_config), GFP_KERNEL);
 +	if (!info->pin_config) {
 +		ice_ptp_disable_sma_pins_e810t(pf, info);
 +		return;
 +	}
 +
 +	/* Read current SMA status */
 +	err = ice_get_sma_config_e810t(&pf->hw, info->pin_config);
 +	if (err)
 +		ice_ptp_disable_sma_pins_e810t(pf, info);
 +}
 +
 +/**
 + * ice_ptp_setup_pins_e810t - Setup PTP pins in sysfs
 + * @pf: pointer to the PF instance
++=======
+  * ice_ptp_parse_sdp_entries - update ice_ptp_pin_desc structure from NVM
+  * @pf: pointer to the PF structure
+  * @entries: SDP connection section from NVM
+  * @num_entries: number of valid entries in sdp_entries
+  * @pins: PTP pins array to update
+  *
+  * Return: 0 on success, negative error code otherwise.
++>>>>>>> ebb2693f8fbd (ice: Read SDP section from NVM for pin definitions)
   */
- static void ice_ptp_setup_pins_e810t(struct ice_pf *pf)
+ static int ice_ptp_parse_sdp_entries(struct ice_pf *pf, __le16 *entries,
+ 				     unsigned int num_entries,
+ 				     struct ice_ptp_pin_desc *pins)
  {
++<<<<<<< HEAD
 +	pf->ptp.info.enable = ice_ptp_gpio_enable_e810t;
 +	pf->ptp.info.n_pins = NUM_PTP_PINS_E810T;
 +	pf->ptp.info.verify = ice_verify_pin_e810t;
 +
 +	/* Complete setup of the SMA pins */
 +	ice_ptp_setup_sma_pins_e810t(pf, &pf->ptp.info);
++=======
+ 	unsigned int n_pins = 0;
+ 	unsigned int i;
+ 
+ 	/* Setup ice_pin_desc array */
+ 	for (i = 0; i < ICE_N_PINS_MAX; i++) {
+ 		pins[i].name_idx = -1;
+ 		pins[i].gpio[0] = -1;
+ 		pins[i].gpio[1] = -1;
+ 	}
+ 
+ 	for (i = 0; i < num_entries; i++) {
+ 		u16 entry = le16_to_cpu(entries[i]);
+ 		DECLARE_BITMAP(bitmap, GPIO_NA);
+ 		unsigned int bitmap_idx;
+ 		bool dir;
+ 		u16 gpio;
+ 
+ 		*bitmap = FIELD_GET(ICE_AQC_NVM_SDP_AC_PIN_M, entry);
+ 		dir = !!FIELD_GET(ICE_AQC_NVM_SDP_AC_DIR_M, entry);
+ 		gpio = FIELD_GET(ICE_AQC_NVM_SDP_AC_SDP_NUM_M, entry);
+ 		for_each_set_bit(bitmap_idx, bitmap, GPIO_NA + 1) {
+ 			unsigned int idx;
+ 
+ 			/* Check if entry's pin bit is valid */
+ 			if (bitmap_idx >= NUM_PTP_PINS_NVM &&
+ 			    bitmap_idx != GPIO_NA)
+ 				continue;
+ 
+ 			/* Check if pin already exists */
+ 			for (idx = 0; idx < ICE_N_PINS_MAX; idx++)
+ 				if (pins[idx].name_idx == bitmap_idx)
+ 					break;
+ 
+ 			if (idx == ICE_N_PINS_MAX) {
+ 				/* Pin not found, setup its entry and name */
+ 				idx = n_pins++;
+ 				pins[idx].name_idx = bitmap_idx;
+ 				if (bitmap_idx == GPIO_NA)
+ 					strscpy(pf->ptp.pin_desc[idx].name,
+ 						ice_pin_names[gpio],
+ 						sizeof(pf->ptp.pin_desc[idx]
+ 							       .name));
+ 			}
+ 
+ 			/* Setup in/out GPIO number */
+ 			pins[idx].gpio[dir] = gpio;
+ 		}
+ 	}
+ 
+ 	for (i = 0; i < n_pins; i++) {
+ 		dev_dbg(ice_pf_to_dev(pf),
+ 			"NVM pin entry[%d] : name_idx %d gpio_out %d gpio_in %d\n",
+ 			i, pins[i].name_idx, pins[i].gpio[1], pins[i].gpio[0]);
+ 	}
+ 
+ 	pf->ptp.info.n_pins = n_pins;
+ 	return 0;
++>>>>>>> ebb2693f8fbd (ice: Read SDP section from NVM for pin definitions)
  }
  
  /**
@@@ -2724,21 -2521,54 +2835,55 @@@ static void ice_ptp_set_funcs_e82x(stru
   *
   * Assign functions to the PTP capabiltiies structure for E810 devices.
   * Functions which operate across all device families should be set directly
 - * in ice_ptp_set_caps. Only add functions here which are distinct for E810
 + * in ice_ptp_set_caps. Only add functions here which are distinct for e810
   * devices.
   */
 -static void ice_ptp_set_funcs_e810(struct ice_pf *pf)
 +static void
 +ice_ptp_set_funcs_e810(struct ice_pf *pf, struct ptp_clock_info *info)
  {
- 	if (ice_is_e810t(&pf->hw) &&
- 	    ice_is_feature_supported(pf, ICE_F_SMA_CTRL)) {
- 		ice_ptp_setup_pins_e810t(pf);
- 		return;
+ 	__le16 entries[ICE_AQC_NVM_SDP_AC_MAX_SIZE];
+ 	struct ice_ptp_pin_desc *desc = NULL;
+ 	struct ice_ptp *ptp = &pf->ptp;
+ 	unsigned int num_entries;
+ 	int err;
+ 
+ 	err = ice_ptp_read_sdp_ac(&pf->hw, entries, &num_entries);
+ 	if (err) {
+ 		/* SDP section does not exist in NVM or is corrupted */
+ 		if (ice_is_feature_supported(pf, ICE_F_SMA_CTRL)) {
+ 			ptp->ice_pin_desc = ice_pin_desc_e810_sma;
+ 			ptp->info.n_pins =
+ 				ICE_PIN_DESC_ARR_LEN(ice_pin_desc_e810_sma);
+ 		} else {
+ 			pf->ptp.ice_pin_desc = ice_pin_desc_e810;
+ 			pf->ptp.info.n_pins =
+ 				ICE_PIN_DESC_ARR_LEN(ice_pin_desc_e810);
+ 			err = 0;
+ 		}
+ 	} else {
+ 		desc = devm_kcalloc(ice_pf_to_dev(pf), ICE_N_PINS_MAX,
+ 				    sizeof(struct ice_ptp_pin_desc),
+ 				    GFP_KERNEL);
+ 		if (!desc)
+ 			goto err;
+ 
+ 		err = ice_ptp_parse_sdp_entries(pf, entries, num_entries, desc);
+ 		if (err)
+ 			goto err;
+ 
+ 		ptp->ice_pin_desc = (const struct ice_ptp_pin_desc *)desc;
  	}
  
- 	pf->ptp.ice_pin_desc = ice_pin_desc_e810;
- 	pf->ptp.info.n_pins = ICE_PIN_DESC_ARR_LEN(ice_pin_desc_e810);
+ 	ptp->info.pin_config = ptp->pin_desc;
  	ice_ptp_setup_pin_cfg(pf);
+ 
+ 	if (ice_is_feature_supported(pf, ICE_F_SMA_CTRL))
+ 		err = ice_ptp_set_sma_cfg(pf);
+ err:
+ 	if (err) {
+ 		devm_kfree(ice_pf_to_dev(pf), desc);
+ 		ice_ptp_disable_pins(pf);
+ 	}
  }
  
  /**
diff --cc drivers/net/ethernet/intel/ice/ice_ptp.h
index eccd52108010,b8ab162a5538..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_ptp.h
+++ b/drivers/net/ethernet/intel/ice/ice_ptp.h
@@@ -230,6 -199,16 +230,19 @@@ enum ice_ptp_pin 
  	ONE_PPS
  };
  
++<<<<<<< HEAD
++=======
+ enum ice_ptp_pin_nvm {
+ 	GNSS = 0,
+ 	SMA1,
+ 	UFL1,
+ 	SMA2,
+ 	UFL2,
+ 	NUM_PTP_PINS_NVM,
+ 	GPIO_NA = 9
+ };
+ 
++>>>>>>> ebb2693f8fbd (ice: Read SDP section from NVM for pin definitions)
  /* Per-channel register definitions */
  #define GLTSYN_AUX_OUT(_chan, _idx)	(GLTSYN_AUX_OUT_0(_idx) + ((_chan) * 8))
  #define GLTSYN_AUX_IN(_chan, _idx)	(GLTSYN_AUX_IN_0(_idx) + ((_chan) * 8))
diff --cc drivers/net/ethernet/intel/ice/ice_ptp_hw.h
index 6a2a64d886c1,ff98f76969e3..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_ptp_hw.h
+++ b/drivers/net/ethernet/intel/ice/ice_ptp_hw.h
@@@ -400,10 -401,11 +400,18 @@@ int ice_phy_cfg_rx_offset_e82x(struct i
  int ice_phy_cfg_intr_e82x(struct ice_hw *hw, u8 quad, bool ena, u8 threshold);
  
  /* E810 family functions */
++<<<<<<< HEAD
 +int ice_read_sma_ctrl_e810t(struct ice_hw *hw, u8 *data);
 +int ice_write_sma_ctrl_e810t(struct ice_hw *hw, u8 data);
 +int ice_read_pca9575_reg_e810t(struct ice_hw *hw, u8 offset, u8 *data);
 +int ice_cgu_get_num_pins(struct ice_hw *hw, bool input);
++=======
+ int ice_read_sma_ctrl(struct ice_hw *hw, u8 *data);
+ int ice_write_sma_ctrl(struct ice_hw *hw, u8 data);
+ int ice_read_pca9575_reg(struct ice_hw *hw, u8 offset, u8 *data);
+ bool ice_is_pca9575_present(struct ice_hw *hw);
+ int ice_ptp_read_sdp_ac(struct ice_hw *hw, __le16 *entries, uint *num_entries);
++>>>>>>> ebb2693f8fbd (ice: Read SDP section from NVM for pin definitions)
  enum dpll_pin_type ice_cgu_get_pin_type(struct ice_hw *hw, u8 pin, bool input);
  struct dpll_pin_frequency *
  ice_cgu_get_pin_freq_supp(struct ice_hw *hw, u8 pin, bool input, u8 *num);
diff --git a/drivers/net/ethernet/intel/ice/ice_adminq_cmd.h b/drivers/net/ethernet/intel/ice/ice_adminq_cmd.h
index 0be1a98d7cc1..1f01f3501d6b 100644
--- a/drivers/net/ethernet/intel/ice/ice_adminq_cmd.h
+++ b/drivers/net/ethernet/intel/ice/ice_adminq_cmd.h
@@ -1742,6 +1742,15 @@ struct ice_aqc_nvm {
 };
 
 #define ICE_AQC_NVM_START_POINT			0
+#define ICE_AQC_NVM_SECTOR_UNIT			4096
+#define ICE_AQC_NVM_SDP_AC_PTR_OFFSET		0xD8
+#define ICE_AQC_NVM_SDP_AC_PTR_M		GENMASK(14, 0)
+#define ICE_AQC_NVM_SDP_AC_PTR_INVAL		0x7FFF
+#define ICE_AQC_NVM_SDP_AC_PTR_TYPE_M		BIT(15)
+#define ICE_AQC_NVM_SDP_AC_SDP_NUM_M		GENMASK(2, 0)
+#define ICE_AQC_NVM_SDP_AC_DIR_M		BIT(3)
+#define ICE_AQC_NVM_SDP_AC_PIN_M		GENMASK(15, 6)
+#define ICE_AQC_NVM_SDP_AC_MAX_SIZE		7
 
 #define ICE_AQC_NVM_TX_TOPO_MOD_ID		0x14B
 
* Unmerged path drivers/net/ethernet/intel/ice/ice_ptp.c
* Unmerged path drivers/net/ethernet/intel/ice/ice_ptp.h
diff --git a/drivers/net/ethernet/intel/ice/ice_ptp_hw.c b/drivers/net/ethernet/intel/ice/ice_ptp_hw.c
index 5696f70f0e13..22e13c94f0c3 100644
--- a/drivers/net/ethernet/intel/ice/ice_ptp_hw.c
+++ b/drivers/net/ethernet/intel/ice/ice_ptp_hw.c
@@ -5429,6 +5429,66 @@ int ice_read_pca9575_reg_e810t(struct ice_hw *hw, u8 offset, u8 *data)
 	return ice_aq_read_i2c(hw, link_topo, 0, addr, 1, data, NULL);
 }
 
+/**
+ * ice_ptp_read_sdp_ac - read SDP available connections section from NVM
+ * @hw: pointer to the HW struct
+ * @entries: returns the SDP available connections section from NVM
+ * @num_entries: returns the number of valid entries
+ *
+ * Return: 0 on success, negative error code if NVM read failed or section does
+ * not exist or is corrupted
+ */
+int ice_ptp_read_sdp_ac(struct ice_hw *hw, __le16 *entries, uint *num_entries)
+{
+	__le16 data;
+	u32 offset;
+	int err;
+
+	err = ice_acquire_nvm(hw, ICE_RES_READ);
+	if (err)
+		goto exit;
+
+	/* Read the offset of SDP_AC */
+	offset = ICE_AQC_NVM_SDP_AC_PTR_OFFSET;
+	err = ice_aq_read_nvm(hw, 0, offset, sizeof(data), &data, false, true,
+			      NULL);
+	if (err)
+		goto exit;
+
+	/* Check if section exist */
+	offset = FIELD_GET(ICE_AQC_NVM_SDP_AC_PTR_M, le16_to_cpu(data));
+	if (offset == ICE_AQC_NVM_SDP_AC_PTR_INVAL) {
+		err = -EINVAL;
+		goto exit;
+	}
+
+	if (offset & ICE_AQC_NVM_SDP_AC_PTR_TYPE_M) {
+		offset &= ICE_AQC_NVM_SDP_AC_PTR_M;
+		offset *= ICE_AQC_NVM_SECTOR_UNIT;
+	} else {
+		offset *= sizeof(data);
+	}
+
+	/* Skip reading section length and read the number of valid entries */
+	offset += sizeof(data);
+	err = ice_aq_read_nvm(hw, 0, offset, sizeof(data), &data, false, true,
+			      NULL);
+	if (err)
+		goto exit;
+	*num_entries = le16_to_cpu(data);
+
+	/* Read SDP configuration section */
+	offset += sizeof(data);
+	err = ice_aq_read_nvm(hw, 0, offset, *num_entries * sizeof(data),
+			      entries, false, true, NULL);
+
+exit:
+	if (err)
+		dev_dbg(ice_hw_to_dev(hw), "Failed to configure SDP connection section\n");
+	ice_release_nvm(hw);
+	return err;
+}
+
 /**
  * ice_ptp_init_phy_e810 - initialize PHY parameters
  * @ptp: pointer to the PTP HW struct
* Unmerged path drivers/net/ethernet/intel/ice/ice_ptp_hw.h
