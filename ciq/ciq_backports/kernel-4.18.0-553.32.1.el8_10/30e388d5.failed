gfs2: Switch to a per-filesystem glock workqueue

jira LE-2169
Rebuild_History Non-Buildable kernel-4.18.0-553.32.1.el8_10
commit-author Andreas Gruenbacher <agruenba@redhat.com>
commit 30e388d573673474cbd089dec83688331c117add
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.32.1.el8_10/30e388d5.failed

Switch to a per-filesystem glock workqueue.  Additional workqueues are
cheap nowadays, and keeping separate workqueues allows to flush the work
of each filesystem without affecting the others.

	Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
(cherry picked from commit 30e388d573673474cbd089dec83688331c117add)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/gfs2/glock.c
diff --cc fs/gfs2/glock.c
index 7d0a91100c66,32991cb22023..000000000000
--- a/fs/gfs2/glock.c
+++ b/fs/gfs2/glock.c
@@@ -62,10 -61,10 +62,9 @@@ struct gfs2_glock_iter 
  typedef void (*glock_examiner) (struct gfs2_glock * gl);
  
  static void do_xmote(struct gfs2_glock *gl, struct gfs2_holder *gh, unsigned int target);
 -static void request_demote(struct gfs2_glock *gl, unsigned int state,
 -			   unsigned long delay, bool remote);
 +static void __gfs2_glock_dq(struct gfs2_holder *gh);
  
  static struct dentry *gfs2_root;
- static struct workqueue_struct *glock_workqueue;
  static LIST_HEAD(lru_list);
  static atomic_t lru_count = ATOMIC_INIT(0);
  static DEFINE_SPINLOCK(lru_lock);
@@@ -273,8 -272,10 +272,15 @@@ static void gfs2_glock_remove_from_lru(
   * Enqueue the glock on the work queue.  Passes one glock reference on to the
   * work queue.
   */
++<<<<<<< HEAD
 +static void __gfs2_glock_queue_work(struct gfs2_glock *gl, unsigned long delay) {
 +	if (!queue_delayed_work(glock_workqueue, &gl->gl_work, delay)) {
++=======
+ static void gfs2_glock_queue_work(struct gfs2_glock *gl, unsigned long delay) {
+ 	struct gfs2_sbd *sdp = gl->gl_name.ln_sbd;
+ 
+ 	if (!queue_delayed_work(sdp->sd_glock_wq, &gl->gl_work, delay)) {
++>>>>>>> 30e388d57367 (gfs2: Switch to a per-filesystem glock workqueue)
  		/*
  		 * We are holding the lockref spinlock, and the work was still
  		 * queued above.  The queued work (glock_work_func) takes that
@@@ -2432,19 -2537,16 +2440,24 @@@ int __init gfs2_glock_init(void
  	if (ret < 0)
  		return ret;
  
 -	glock_shrinker = shrinker_alloc(0, "gfs2-glock");
 -	if (!glock_shrinker) {
++<<<<<<< HEAD
 +	glock_workqueue = alloc_workqueue("glock_workqueue", WQ_MEM_RECLAIM |
 +					  WQ_HIGHPRI | WQ_FREEZABLE, 0);
 +	if (!glock_workqueue) {
  		rhashtable_destroy(&gl_hash_table);
  		return -ENOMEM;
  	}
  
 -	glock_shrinker->count_objects = gfs2_glock_shrink_count;
 -	glock_shrinker->scan_objects = gfs2_glock_shrink_scan;
 -
 -	shrinker_register(glock_shrinker);
 +	ret = register_shrinker(&glock_shrinker);
 +	if (ret) {
 +		destroy_workqueue(glock_workqueue);
++=======
++	glock_shrinker = shrinker_alloc(0, "gfs2-glock");
++	if (!glock_shrinker) {
++>>>>>>> 30e388d57367 (gfs2: Switch to a per-filesystem glock workqueue)
 +		rhashtable_destroy(&gl_hash_table);
 +		return ret;
 +	}
  
  	for (i = 0; i < GLOCK_WAIT_TABLE_SIZE; i++)
  		init_waitqueue_head(glock_wait_table + i);
@@@ -2454,9 -2556,8 +2467,8 @@@
  
  void gfs2_glock_exit(void)
  {
 -	shrinker_free(glock_shrinker);
 +	unregister_shrinker(&glock_shrinker);
  	rhashtable_destroy(&gl_hash_table);
- 	destroy_workqueue(glock_workqueue);
  }
  
  static void gfs2_glock_iter_next(struct gfs2_glock_iter *gi, loff_t n)
* Unmerged path fs/gfs2/glock.c
diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index bce238196547..806f1c758cdd 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -776,6 +776,7 @@ struct gfs2_sbd {
 
 	/* Workqueue stuff */
 
+	struct workqueue_struct *sd_glock_wq;
 	struct workqueue_struct *sd_delete_wq;
 
 	/* Daemon stuff */
diff --git a/fs/gfs2/ops_fstype.c b/fs/gfs2/ops_fstype.c
index 65032e10b64a..a17fa5bc0f85 100644
--- a/fs/gfs2/ops_fstype.c
+++ b/fs/gfs2/ops_fstype.c
@@ -1171,11 +1171,17 @@ static int gfs2_fill_super(struct super_block *sb, struct fs_context *fc)
 
 	snprintf(sdp->sd_fsname, sizeof(sdp->sd_fsname), "%s", sdp->sd_table_name);
 
+	error = -ENOMEM;
+	sdp->sd_glock_wq = alloc_workqueue("gfs2-glock/%s",
+			WQ_MEM_RECLAIM | WQ_HIGHPRI | WQ_FREEZABLE, 0,
+			sdp->sd_fsname);
+	if (!sdp->sd_glock_wq)
+		goto fail_free;
+
 	sdp->sd_delete_wq = alloc_workqueue("gfs2-delete/%s",
 			WQ_MEM_RECLAIM | WQ_FREEZABLE, 0, sdp->sd_fsname);
-	error = -ENOMEM;
 	if (!sdp->sd_delete_wq)
-		goto fail_free;
+		goto fail_glock_wq;
 
 	error = gfs2_sys_fs_add(sdp);
 	if (error)
@@ -1287,6 +1293,8 @@ static int gfs2_fill_super(struct super_block *sb, struct fs_context *fc)
 	gfs2_sys_fs_del(sdp);
 fail_delete_wq:
 	destroy_workqueue(sdp->sd_delete_wq);
+fail_glock_wq:
+	destroy_workqueue(sdp->sd_glock_wq);
 fail_free:
 	free_sbd(sdp);
 	sb->s_fs_info = NULL;
