thermal: Remove netlink support

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Amit Kucheria <amit.kucheria@linaro.org>
commit f96c8e50152814d05a4002b8c03a80366a27afa3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/f96c8e50.failed

There are no users of netlink messages for thermal inside the kernel.
Remove the code and adjust the documentation.

	Signed-off-by: Amit Kucheria <amit.kucheria@linaro.org>
	Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
	Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
Link: https://lore.kernel.org/r/8ff02cf62186c7a54fff325fad40a2e9ca3affa6.1571656014.git.amit.kucheria@linaro.org
(cherry picked from commit f96c8e50152814d05a4002b8c03a80366a27afa3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/thermal/sysfs-api.txt
diff --cc Documentation/thermal/sysfs-api.txt
index 911399730c1c,b40b1f839148..000000000000
--- a/Documentation/thermal/sysfs-api.txt
+++ b/Documentation/thermal/sysfs-api.txt
@@@ -574,34 -725,28 +574,54 @@@ method, the sys I/F structure will be b
      |---temp1_input:		37000
      |---temp1_crit:		100000
  
++<<<<<<< HEAD:Documentation/thermal/sysfs-api.txt
 +4. Event Notification
 +
 +The framework includes a simple notification mechanism, in the form of a
 +netlink event. Netlink socket initialization is done during the _init_
 +of the framework. Drivers which intend to use the notification mechanism
 +just need to call thermal_generate_netlink_event() with two arguments viz
 +(originator, event). The originator is a pointer to struct thermal_zone_device
 +from where the event has been originated. An integer which represents the
 +thermal zone device will be used in the message to identify the zone. The
 +event will be one of:{THERMAL_AUX0, THERMAL_AUX1, THERMAL_CRITICAL,
 +THERMAL_DEV_FAULT}. Notification can be sent when the current temperature
 +crosses any of the configured thresholds.
 +
 +5. Export Symbol APIs:
++=======
+ 4. Export Symbol APIs
+ =====================
+ 
+ 4.1. get_tz_trend
+ -----------------
++>>>>>>> f96c8e501528 (thermal: Remove netlink support):Documentation/driver-api/thermal/sysfs-api.rst
  
 +5.1: get_tz_trend:
  This function returns the trend of a thermal zone, i.e the rate of change
  of temperature of the thermal zone. Ideally, the thermal sensor drivers
  are supposed to implement the callback. If they don't, the thermal
  framework calculated the trend by comparing the previous and the current
  temperature values.
  
++<<<<<<< HEAD:Documentation/thermal/sysfs-api.txt
 +5.2:get_thermal_instance:
++=======
+ 4.2. get_thermal_instance
+ -------------------------
+ 
++>>>>>>> f96c8e501528 (thermal: Remove netlink support):Documentation/driver-api/thermal/sysfs-api.rst
  This function returns the thermal_instance corresponding to a given
  {thermal_zone, cooling_device, trip_point} combination. Returns NULL
  if such an instance does not exist.
  
++<<<<<<< HEAD:Documentation/thermal/sysfs-api.txt
 +5.3:thermal_notify_framework:
++=======
+ 4.3. thermal_notify_framework
+ -----------------------------
+ 
++>>>>>>> f96c8e501528 (thermal: Remove netlink support):Documentation/driver-api/thermal/sysfs-api.rst
  This function handles the trip events from sensor drivers. It starts
  throttling the cooling devices according to the policy configured.
  For CRITICAL and HOT trip points, this notifies the respective drivers,
@@@ -609,12 -754,15 +629,23 @@@ and does actual throttling for other tr
  The throttling policy is based on the configured platform data; if no
  platform data is provided, this uses the step_wise throttling policy.
  
++<<<<<<< HEAD:Documentation/thermal/sysfs-api.txt
 +5.4:thermal_cdev_update:
++=======
+ 4.4. thermal_cdev_update
+ ------------------------
+ 
++>>>>>>> f96c8e501528 (thermal: Remove netlink support):Documentation/driver-api/thermal/sysfs-api.rst
  This function serves as an arbitrator to set the state of a cooling
  device. It sets the cooling device to the deepest cooling state if
  possible.
  
++<<<<<<< HEAD:Documentation/thermal/sysfs-api.txt
 +6. thermal_emergency_poweroff:
++=======
+ 5. thermal_emergency_poweroff
+ =============================
++>>>>>>> f96c8e501528 (thermal: Remove netlink support):Documentation/driver-api/thermal/sysfs-api.rst
  
  On an event of critical trip temperature crossing. Thermal framework
  allows the system to shutdown gracefully by calling orderly_poweroff().
* Unmerged path Documentation/thermal/sysfs-api.txt
diff --git a/drivers/thermal/thermal_core.c b/drivers/thermal/thermal_core.c
index cf139cb114db..0b814e735fbe 100644
--- a/drivers/thermal/thermal_core.c
+++ b/drivers/thermal/thermal_core.c
@@ -19,8 +19,6 @@
 #include <linux/reboot.h>
 #include <linux/string.h>
 #include <linux/of.h>
-#include <net/netlink.h>
-#include <net/genetlink.h>
 #include <linux/suspend.h>
 
 #define CREATE_TRACE_POINTS
@@ -1524,97 +1522,6 @@ struct thermal_zone_device *thermal_zone_get_zone_by_name(const char *name)
 }
 EXPORT_SYMBOL_GPL(thermal_zone_get_zone_by_name);
 
-#ifdef CONFIG_NET
-static const struct genl_multicast_group thermal_event_mcgrps[] = {
-	{ .name = THERMAL_GENL_MCAST_GROUP_NAME, },
-};
-
-static struct genl_family thermal_event_genl_family __ro_after_init = {
-	.module = THIS_MODULE,
-	.name = THERMAL_GENL_FAMILY_NAME,
-	.version = THERMAL_GENL_VERSION,
-	.maxattr = THERMAL_GENL_ATTR_MAX,
-	.mcgrps = thermal_event_mcgrps,
-	.n_mcgrps = ARRAY_SIZE(thermal_event_mcgrps),
-};
-
-int thermal_generate_netlink_event(struct thermal_zone_device *tz,
-				   enum events event)
-{
-	struct sk_buff *skb;
-	struct nlattr *attr;
-	struct thermal_genl_event *thermal_event;
-	void *msg_header;
-	int size;
-	int result;
-	static unsigned int thermal_event_seqnum;
-
-	if (!tz)
-		return -EINVAL;
-
-	/* allocate memory */
-	size = nla_total_size(sizeof(struct thermal_genl_event)) +
-	       nla_total_size(0);
-
-	skb = genlmsg_new(size, GFP_ATOMIC);
-	if (!skb)
-		return -ENOMEM;
-
-	/* add the genetlink message header */
-	msg_header = genlmsg_put(skb, 0, thermal_event_seqnum++,
-				 &thermal_event_genl_family, 0,
-				 THERMAL_GENL_CMD_EVENT);
-	if (!msg_header) {
-		nlmsg_free(skb);
-		return -ENOMEM;
-	}
-
-	/* fill the data */
-	attr = nla_reserve(skb, THERMAL_GENL_ATTR_EVENT,
-			   sizeof(struct thermal_genl_event));
-
-	if (!attr) {
-		nlmsg_free(skb);
-		return -EINVAL;
-	}
-
-	thermal_event = nla_data(attr);
-	if (!thermal_event) {
-		nlmsg_free(skb);
-		return -EINVAL;
-	}
-
-	memset(thermal_event, 0, sizeof(struct thermal_genl_event));
-
-	thermal_event->orig = tz->id;
-	thermal_event->event = event;
-
-	/* send multicast genetlink message */
-	genlmsg_end(skb, msg_header);
-
-	result = genlmsg_multicast(&thermal_event_genl_family, skb, 0,
-				   0, GFP_ATOMIC);
-	if (result)
-		dev_err(&tz->device, "Failed to send netlink event:%d", result);
-
-	return result;
-}
-EXPORT_SYMBOL_GPL(thermal_generate_netlink_event);
-
-static int __init genetlink_init(void)
-{
-	return genl_register_family(&thermal_event_genl_family);
-}
-
-static void genetlink_exit(void)
-{
-	genl_unregister_family(&thermal_event_genl_family);
-}
-#else /* !CONFIG_NET */
-static inline int genetlink_init(void) { return 0; }
-static inline void genetlink_exit(void) {}
-#endif /* !CONFIG_NET */
-
 static int thermal_pm_notify(struct notifier_block *nb,
 			     unsigned long mode, void *_unused)
 {
@@ -1662,13 +1569,9 @@ static int __init thermal_init(void)
 	if (result)
 		goto unregister_governors;
 
-	result = genetlink_init();
-	if (result)
-		goto unregister_class;
-
 	result = of_parse_thermal_zones();
 	if (result)
-		goto exit_netlink;
+		goto unregister_class;
 
 	result = register_pm_notifier(&thermal_pm_nb);
 	if (result)
@@ -1677,8 +1580,6 @@ static int __init thermal_init(void)
 
 	return 0;
 
-exit_netlink:
-	genetlink_exit();
 unregister_class:
 	class_unregister(&thermal_class);
 unregister_governors:
diff --git a/include/linux/thermal.h b/include/linux/thermal.h
index f8c048155ef7..1c8c799eb00c 100644
--- a/include/linux/thermal.h
+++ b/include/linux/thermal.h
@@ -561,15 +561,4 @@ thermal_zone_device_is_enabled(struct thermal_zone_device *tz)
 { return -ENODEV; }
 #endif /* CONFIG_THERMAL */
 
-#if defined(CONFIG_NET) && IS_ENABLED(CONFIG_THERMAL)
-extern int thermal_generate_netlink_event(struct thermal_zone_device *tz,
-						enum events event);
-#else
-static inline int thermal_generate_netlink_event(struct thermal_zone_device *tz,
-						enum events event)
-{
-	return 0;
-}
-#endif
-
 #endif /* __THERMAL_H__ */
