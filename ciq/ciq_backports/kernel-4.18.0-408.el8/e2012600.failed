arm64: perf: Add userspace counter access disable switch

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Rob Herring <robh@kernel.org>
commit e2012600810c9ded81f6f63a8d04781be3c300ad
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/e2012600.failed

Like x86, some users may want to disable userspace PMU counter
altogether. Add a sysctl 'perf_user_access' file to control userspace
counter access. The default is '0' which is disabled. Writing '1'
enables access.

Note that x86 supports globally enabling user access by writing '2' to
/sys/bus/event_source/devices/cpu/rdpmc. As there's not existing
userspace support to worry about, this shouldn't be necessary for Arm.
It could be added later if the need arises.

	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Ingo Molnar <mingo@redhat.com>
	Cc: Arnaldo Carvalho de Melo <acme@kernel.org>
	Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
	Cc: Jiri Olsa <jolsa@redhat.com>
	Cc: Namhyung Kim <namhyung@kernel.org>
	Cc: Catalin Marinas <catalin.marinas@arm.com>
	Cc: linux-perf-users@vger.kernel.org
	Acked-by: Will Deacon <will@kernel.org>
	Reviewed-by: Mark Rutland <mark.rutland@arm.com>
	Signed-off-by: Rob Herring <robh@kernel.org>
Link: https://lore.kernel.org/r/20211208201124.310740-4-robh@kernel.org
	Signed-off-by: Will Deacon <will@kernel.org>
(cherry picked from commit e2012600810c9ded81f6f63a8d04781be3c300ad)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/admin-guide/sysctl/kernel.rst
#	arch/arm64/kernel/perf_event.c
diff --cc arch/arm64/kernel/perf_event.c
index aae1d60d4d61,6ae20c4217af..000000000000
--- a/arch/arm64/kernel/perf_event.c
+++ b/arch/arm64/kernel/perf_event.c
@@@ -961,7 -1106,24 +963,28 @@@ static int armv8pmu_probe_pmu(struct ar
  	return probe.present ? 0 : -ENODEV;
  }
  
++<<<<<<< HEAD
 +static int armv8_pmu_init(struct arm_pmu *cpu_pmu)
++=======
+ static struct ctl_table armv8_pmu_sysctl_table[] = {
+ 	{
+ 		.procname       = "perf_user_access",
+ 		.data		= &sysctl_perf_user_access,
+ 		.maxlen		= sizeof(unsigned int),
+ 		.mode           = 0644,
+ 		.proc_handler	= proc_dointvec_minmax,
+ 		.extra1		= SYSCTL_ZERO,
+ 		.extra2		= SYSCTL_ONE,
+ 	},
+ 	{ }
+ };
+ 
+ static int armv8_pmu_init(struct arm_pmu *cpu_pmu, char *name,
+ 			  int (*map_event)(struct perf_event *event),
+ 			  const struct attribute_group *events,
+ 			  const struct attribute_group *format,
+ 			  const struct attribute_group *caps)
++>>>>>>> e2012600810c (arm64: perf: Add userspace counter access disable switch)
  {
  	int ret = armv8pmu_probe_pmu(cpu_pmu);
  	if (ret)
@@@ -980,6 -1142,17 +1003,20 @@@
  	cpu_pmu->set_event_filter	= armv8pmu_set_event_filter;
  	cpu_pmu->filter_match		= armv8pmu_filter_match;
  
++<<<<<<< HEAD
++=======
+ 	cpu_pmu->name			= name;
+ 	cpu_pmu->map_event		= map_event;
+ 	cpu_pmu->attr_groups[ARMPMU_ATTR_GROUP_EVENTS] = events ?
+ 			events : &armv8_pmuv3_events_attr_group;
+ 	cpu_pmu->attr_groups[ARMPMU_ATTR_GROUP_FORMATS] = format ?
+ 			format : &armv8_pmuv3_format_attr_group;
+ 	cpu_pmu->attr_groups[ARMPMU_ATTR_GROUP_CAPS] = caps ?
+ 			caps : &armv8_pmuv3_caps_attr_group;
+ 
+ 	register_sysctl("kernel", armv8_pmu_sysctl_table);
+ 
++>>>>>>> e2012600810c (arm64: perf: Add userspace counter access disable switch)
  	return 0;
  }
  
* Unmerged path Documentation/admin-guide/sysctl/kernel.rst
* Unmerged path Documentation/admin-guide/sysctl/kernel.rst
* Unmerged path arch/arm64/kernel/perf_event.c
