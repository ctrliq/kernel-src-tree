kvm: x86: abstract locking around pvclock_update_vm_gtod_copy

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Paolo Bonzini <pbonzini@redhat.com>
commit 6b6fcd2804a2dcc86068859188708ee57c7ca19f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/6b6fcd28.failed

Updates to the kvmclock parameters needs to do a complicated dance of
KVM_REQ_MCLOCK_INPROGRESS and KVM_REQ_CLOCK_UPDATE in addition to taking
pvclock_gtod_sync_lock.  Place that in two functions that can be called
on all of master clock update, KVM_SET_CLOCK, and Hyper-V reenlightenment.

	Reviewed-by: Marcelo Tosatti <mtosatti@redhat.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 6b6fcd2804a2dcc86068859188708ee57c7ca19f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/x86.c
diff --cc arch/x86/kvm/x86.c
index 87d165bd834e,759ba849e10b..000000000000
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@@ -2827,10 -2755,16 +2821,22 @@@ static void kvm_start_pvclock_update(st
  	kvm_make_mclock_inprogress_request(kvm);
  
  	/* no guest entries from this point */
++<<<<<<< HEAD
 +	raw_spin_lock_irqsave(&ka->pvclock_gtod_sync_lock, flags);
 +	pvclock_update_vm_gtod_copy(kvm);
 +	raw_spin_unlock_irqrestore(&ka->pvclock_gtod_sync_lock, flags);
++=======
+ 	spin_lock_irq(&ka->pvclock_gtod_sync_lock);
+ }
++>>>>>>> 6b6fcd2804a2 (kvm: x86: abstract locking around pvclock_update_vm_gtod_copy)
  
+ static void kvm_end_pvclock_update(struct kvm *kvm)
+ {
+ 	struct kvm_arch *ka = &kvm->arch;
+ 	struct kvm_vcpu *vcpu;
+ 	int i;
+ 
+ 	spin_unlock_irq(&ka->pvclock_gtod_sync_lock);
  	kvm_for_each_vcpu(i, vcpu, kvm)
  		kvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);
  
@@@ -6284,15 -6086,12 +6295,22 @@@ set_pit2_out
  		 * is slightly ahead) here we risk going negative on unsigned
  		 * 'system_time' when 'user_ns.clock' is very small.
  		 */
++<<<<<<< HEAD
 +		raw_spin_lock_irq(&ka->pvclock_gtod_sync_lock);
++=======
++>>>>>>> 6b6fcd2804a2 (kvm: x86: abstract locking around pvclock_update_vm_gtod_copy)
  		if (kvm->arch.use_master_clock)
  			now_ns = ka->master_kernel_ns;
  		else
  			now_ns = get_kvmclock_base_ns();
  		ka->kvmclock_offset = user_ns.clock - now_ns;
++<<<<<<< HEAD
 +		raw_spin_unlock_irq(&ka->pvclock_gtod_sync_lock);
 +
 +		kvm_make_all_cpus_request(kvm, KVM_REQ_CLOCK_UPDATE);
++=======
+ 		kvm_end_pvclock_update(kvm);
++>>>>>>> 6b6fcd2804a2 (kvm: x86: abstract locking around pvclock_update_vm_gtod_copy)
  		break;
  	}
  	case KVM_GET_CLOCK: {
@@@ -8345,16 -8121,11 +8362,23 @@@ static void kvm_hyperv_tsc_notifier(voi
  	list_for_each_entry(kvm, &vm_list, vm_list) {
  		struct kvm_arch *ka = &kvm->arch;
  
++<<<<<<< HEAD
 +		raw_spin_lock_irqsave(&ka->pvclock_gtod_sync_lock, flags);
 +		pvclock_update_vm_gtod_copy(kvm);
 +		raw_spin_unlock_irqrestore(&ka->pvclock_gtod_sync_lock, flags);
 +
 +		kvm_for_each_vcpu(cpu, vcpu, kvm)
 +			kvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);
 +
 +		kvm_for_each_vcpu(cpu, vcpu, kvm)
 +			kvm_clear_request(KVM_REQ_MCLOCK_INPROGRESS, vcpu);
++=======
+ 		spin_lock_irq(&ka->pvclock_gtod_sync_lock);
+ 		pvclock_update_vm_gtod_copy(kvm);
+ 		kvm_end_pvclock_update(kvm);
++>>>>>>> 6b6fcd2804a2 (kvm: x86: abstract locking around pvclock_update_vm_gtod_copy)
  	}
+ 
  	mutex_unlock(&kvm_lock);
  }
  #endif
diff --git a/arch/x86/include/asm/kvm_host.h b/arch/x86/include/asm/kvm_host.h
index f522af3a451f..b8b1e3cd0d28 100644
--- a/arch/x86/include/asm/kvm_host.h
+++ b/arch/x86/include/asm/kvm_host.h
@@ -1849,7 +1849,6 @@ u64 kvm_calc_nested_tsc_multiplier(u64 l1_multiplier, u64 l2_multiplier);
 unsigned long kvm_get_linear_rip(struct kvm_vcpu *vcpu);
 bool kvm_is_linear_rip(struct kvm_vcpu *vcpu, unsigned long linear_rip);
 
-void kvm_make_mclock_inprogress_request(struct kvm *kvm);
 void kvm_make_scan_ioapic_request(struct kvm *kvm);
 void kvm_make_scan_ioapic_request_mask(struct kvm *kvm,
 				       unsigned long *vcpu_bitmap);
* Unmerged path arch/x86/kvm/x86.c
