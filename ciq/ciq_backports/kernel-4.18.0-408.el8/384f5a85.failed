software nodes: Split software_node_notify()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Rafael J. Wysocki <rafael.j.wysocki@intel.com>
commit 384f5a857baeba88cf013b36999a97b471e4bd9c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/384f5a85.failed

Split software_node_notify_remove) out of software_node_notify()
and make device_platform_notify() call the latter on device addition
and the former on device removal.

While at it, put the headers of the above functions into base.h,
because they don't need to be present in a global header file.

No intentional functional impact.

	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
	Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
	Reviewed-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
	Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
(cherry picked from commit 384f5a857baeba88cf013b36999a97b471e4bd9c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/base/base.h
#	drivers/base/swnode.c
diff --cc drivers/base/base.h
index 0208ffa9bdde,2882af26392a..000000000000
--- a/drivers/base/base.h
+++ b/drivers/base/base.h
@@@ -181,3 -194,14 +181,17 @@@ extern void fw_devlink_drivers_done(voi
  
  /* device pm support */
  void device_pm_move_to_tail(struct device *dev);
++<<<<<<< HEAD
++=======
+ 
+ #ifdef CONFIG_DEVTMPFS
+ int devtmpfs_create_node(struct device *dev);
+ int devtmpfs_delete_node(struct device *dev);
+ #else
+ static inline int devtmpfs_create_node(struct device *dev) { return 0; }
+ static inline int devtmpfs_delete_node(struct device *dev) { return 0; }
+ #endif
+ 
+ void software_node_notify(struct device *dev);
+ void software_node_notify_remove(struct device *dev);
++>>>>>>> 384f5a857bae (software nodes: Split software_node_notify())
diff --cc drivers/base/swnode.c
index f20196e5fd54,7bd0f3cfb7eb..000000000000
--- a/drivers/base/swnode.c
+++ b/drivers/base/swnode.c
@@@ -1117,7 -1083,44 +1120,48 @@@ void device_remove_software_node(struc
  }
  EXPORT_SYMBOL_GPL(device_remove_software_node);
  
++<<<<<<< HEAD
 +int software_node_notify(struct device *dev, unsigned long action)
++=======
+ /**
+  * device_create_managed_software_node - Create a software node for a device
+  * @dev: The device the software node is assigned to.
+  * @properties: Device properties for the software node.
+  * @parent: Parent of the software node.
+  *
+  * Creates a software node as a managed resource for @dev, which means the
+  * lifetime of the newly created software node is tied to the lifetime of @dev.
+  * Software nodes created with this function should not be reused or shared
+  * because of that. The function takes a deep copy of @properties for the
+  * software node.
+  *
+  * Since the new software node is assigned directly to @dev, and since it should
+  * not be shared, it is not returned to the caller. The function returns 0 on
+  * success, and errno in case of an error.
+  */
+ int device_create_managed_software_node(struct device *dev,
+ 					const struct property_entry *properties,
+ 					const struct software_node *parent)
+ {
+ 	struct fwnode_handle *p = software_node_fwnode(parent);
+ 	struct fwnode_handle *fwnode;
+ 
+ 	if (parent && !p)
+ 		return -EINVAL;
+ 
+ 	fwnode = fwnode_create_software_node(properties, p);
+ 	if (IS_ERR(fwnode))
+ 		return PTR_ERR(fwnode);
+ 
+ 	to_swnode(fwnode)->managed = true;
+ 	set_secondary_fwnode(dev, fwnode);
+ 
+ 	return 0;
+ }
+ EXPORT_SYMBOL_GPL(device_create_managed_software_node);
+ 
+ void software_node_notify(struct device *dev)
++>>>>>>> 384f5a857bae (software nodes: Split software_node_notify())
  {
  	struct swnode *swnode;
  	int ret;
* Unmerged path drivers/base/base.h
diff --git a/drivers/base/core.c b/drivers/base/core.c
index bb4d7a7dbbec..e6b59bef784b 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -1989,16 +1989,15 @@ static inline int device_is_not_partition(struct device *dev)
 static int
 device_platform_notify(struct device *dev, enum kobject_action action)
 {
-	int ret;
-
 	if (action == KOBJ_ADD)
 		acpi_device_notify(dev);
 	else if (action == KOBJ_REMOVE)
 		acpi_device_notify_remove(dev);
 
-	ret = software_node_notify(dev, action);
-	if (ret)
-		return ret;
+	if (action == KOBJ_ADD)
+		software_node_notify(dev);
+	else if (action == KOBJ_REMOVE)
+		software_node_notify_remove(dev);
 
 	if (platform_notify && action == KOBJ_ADD)
 		platform_notify(dev);
* Unmerged path drivers/base/swnode.c
diff --git a/include/linux/property.h b/include/linux/property.h
index 82370bc4b508..c121adc69d7d 100644
--- a/include/linux/property.h
+++ b/include/linux/property.h
@@ -451,8 +451,6 @@ void software_node_unregister_node_group(const struct software_node **node_group
 int software_node_register(const struct software_node *node);
 void software_node_unregister(const struct software_node *node);
 
-int software_node_notify(struct device *dev, unsigned long action);
-
 struct fwnode_handle *
 fwnode_create_software_node(const struct property_entry *properties,
 			    const struct fwnode_handle *parent);
