mm, memory_hotplug: drop arch_free_nodedata

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Michal Hocko <mhocko@suse.com>
commit 390511e1476eb1cc41d420a7661b33f4d8584c3f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/390511e1.failed

Prior to "mm: handle uninitialized numa nodes gracefully" memory hotplug
used to allocate pgdat when memory has been added to a node
(hotadd_init_pgdat) arch_free_nodedata has been only used in the failure
path because once the pgdat is exported (to be visible by NODA_DATA(nid))
it cannot really be freed because there is no synchronization available
for that.

pgdat is allocated for each possible nodes now so the memory hotplug
doesn't need to do the ever use arch_free_nodedata so drop it.

This patch doesn't introduce any functional change.

Link: https://lkml.kernel.org/r/20220127085305.20890-4-mhocko@kernel.org
	Signed-off-by: Michal Hocko <mhocko@suse.com>
	Acked-by: Rafael Aquini <raquini@redhat.com>
	Acked-by: David Hildenbrand <david@redhat.com>
	Acked-by: Mike Rapoport <rppt@linux.ibm.com>
	Reviewed-by: Oscar Salvador <osalvador@suse.de>
	Cc: Alexey Makhalov <amakhalov@vmware.com>
	Cc: Christoph Lameter <cl@linux.com>
	Cc: Dennis Zhou <dennis@kernel.org>
	Cc: Eric Dumazet <eric.dumazet@gmail.com>
	Cc: Nico Pache <npache@redhat.com>
	Cc: Tejun Heo <tj@kernel.org>
	Cc: Wei Yang <richard.weiyang@gmail.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 390511e1476eb1cc41d420a7661b33f4d8584c3f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/memory_hotplug.c
diff --cc mm/memory_hotplug.c
index 27b7636cc032,55c3e5309088..000000000000
--- a/mm/memory_hotplug.c
+++ b/mm/memory_hotplug.c
@@@ -1007,18 -1217,8 +1007,23 @@@ static pg_data_t __ref *hotadd_new_pgda
  	return pgdat;
  }
  
++<<<<<<< HEAD
 +static void rollback_node_hotadd(int nid)
 +{
 +	pg_data_t *pgdat = NODE_DATA(nid);
 +
 +	arch_refresh_nodedata(nid, NULL);
 +	free_percpu(pgdat->per_cpu_nodestats);
 +	arch_free_nodedata(pgdat);
 +}
 +
 +
 +/**
 + * try_online_node - online a node if offlined
++=======
+ /*
+  * __try_online_node - online a node if offlined
++>>>>>>> 390511e1476e (mm, memory_hotplug: drop arch_free_nodedata)
   * @nid: the node ID
   * @set_node_online: Whether we want to online the node
   * called by cpu_up() to online a node without onlined memory.
diff --git a/arch/ia64/mm/discontig.c b/arch/ia64/mm/discontig.c
index a69c83049d5d..9f4662e07091 100644
--- a/arch/ia64/mm/discontig.c
+++ b/arch/ia64/mm/discontig.c
@@ -743,11 +743,6 @@ pg_data_t *arch_alloc_nodedata(int nid)
 	return kzalloc(size, GFP_KERNEL);
 }
 
-void arch_free_nodedata(pg_data_t *pgdat)
-{
-	kfree(pgdat);
-}
-
 void arch_refresh_nodedata(int update_node, pg_data_t *update_pgdat)
 {
 	pgdat_list[update_node] = update_pgdat;
diff --git a/include/linux/memory_hotplug.h b/include/linux/memory_hotplug.h
index d16c9fe0f6df..dcda0326123c 100644
--- a/include/linux/memory_hotplug.h
+++ b/include/linux/memory_hotplug.h
@@ -151,17 +151,14 @@ static inline int memory_add_physaddr_to_nid(u64 start)
  * node_data[nid] = kzalloc() works well. But it depends on the architecture.
  *
  * In general, generic_alloc_nodedata() is used.
- * Now, arch_free_nodedata() is just defined for error path of node_hot_add.
  *
  */
 extern pg_data_t *arch_alloc_nodedata(int nid);
-extern void arch_free_nodedata(pg_data_t *pgdat);
 extern void arch_refresh_nodedata(int nid, pg_data_t *pgdat);
 
 #else /* CONFIG_HAVE_ARCH_NODEDATA_EXTENSION */
 
 #define arch_alloc_nodedata(nid)	generic_alloc_nodedata(nid)
-#define arch_free_nodedata(pgdat)	generic_free_nodedata(pgdat)
 
 #ifdef CONFIG_NUMA
 /*
* Unmerged path mm/memory_hotplug.c
