KVM: VMX: Move RESET emulation to vmx_vcpu_reset()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Sean Christopherson <seanjc@google.com>
commit 06692e4b8055cc0c6b136fa7df77221ae9639e97
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/06692e4b.failed

Move vCPU RESET emulation, including initializating of select VMCS state,
to vmx_vcpu_reset().  Drop the open coded "vCPU load" sequence, as
->vcpu_reset() is invoked while the vCPU is properly loaded (which is
kind of the point of ->vcpu_reset()...).  Hopefully KVM will someday
expose a dedicated RESET ioctl(), and in the meantime separating "create"
from "RESET" is a nice cleanup.

Deferring VMCS initialization is effectively a nop as it's impossible to
safely access the VMCS between the current call site and its new home, as
both the vCPU and the pCPU are put immediately after init_vmcs(), i.e.
the VMCS isn't guaranteed to be loaded.

Note, task preemption is not a problem as vmx_sched_in() _can't_ touch
the VMCS as ->sched_in() is invoked before the vCPU, and thus VMCS, is
reloaded.  I.e. the preemption path also can't consume VMCS state.

	Cc: Reiji Watanabe <reijiw@google.com>
	Signed-off-by: Sean Christopherson <seanjc@google.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
Message-Id: <20210921000303.400537-9-seanjc@google.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 06692e4b8055cc0c6b136fa7df77221ae9639e97)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/vmx/vmx.c
diff --cc arch/x86/kvm/vmx/vmx.c
index f3f37efd9ecb,b8bfb46d58f4..000000000000
--- a/arch/x86/kvm/vmx/vmx.c
+++ b/arch/x86/kvm/vmx/vmx.c
@@@ -6955,26 -6914,6 +6976,29 @@@ static int vmx_create_vcpu(struct kvm_v
  			goto free_vmcs;
  	}
  
++<<<<<<< HEAD
 +	if (nested)
 +		memcpy(&vmx->nested.msrs, &vmcs_config.nested, sizeof(vmx->nested.msrs));
 +
 +	vcpu_setup_sgx_lepubkeyhash(vcpu);
 +
 +	vmx->nested.posted_intr_nv = -1;
 +	vmx->nested.vmxon_ptr = INVALID_GPA;
 +	vmx->nested.current_vmptr = INVALID_GPA;
 +	vmx->nested.hv_evmcs_vmptr = EVMPTR_INVALID;
 +
 +	vmx->vcpu.arch.microcode_version = 0x100000000ULL;
 +	vmx->msr_ia32_feature_control_valid_bits = FEAT_CTL_LOCKED;
 +
 +	/*
 +	 * Enforce invariant: pi_desc.nv is always either POSTED_INTR_VECTOR
 +	 * or POSTED_INTR_WAKEUP_VECTOR.
 +	 */
 +	vmx->pi_desc.nv = POSTED_INTR_VECTOR;
 +	vmx->pi_desc.sn = 1;
 +
++=======
++>>>>>>> 06692e4b8055 (KVM: VMX: Move RESET emulation to vmx_vcpu_reset())
  	return 0;
  
  free_vmcs:
* Unmerged path arch/x86/kvm/vmx/vmx.c
