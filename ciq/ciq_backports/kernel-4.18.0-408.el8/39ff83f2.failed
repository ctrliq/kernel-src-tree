time: Handle negative seconds correctly in timespec64_to_ns()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Lukas Hannen <lukas.hannen@opensource.tttech-industrial.com>
commit 39ff83f2f6cc5cc1458dfcea9697f96338210beb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/39ff83f2.failed

timespec64_ns() prevents multiplication overflows by comparing the seconds
value of the timespec to KTIME_SEC_MAX. If the value is greater or equal it
returns KTIME_MAX.

But that check casts the signed seconds value to unsigned which makes the
comparision true for all negative values and therefore return wrongly
KTIME_MAX.

Negative second values are perfectly valid and required in some places,
e.g. ptp_clock_adjtime().

Remove the cast and add a check for the negative boundary which is required
to prevent undefined behaviour due to multiplication underflow.

Fixes: cb47755725da ("time: Prevent undefined behaviour in timespec64_to_ns()")'
	Signed-off-by: Lukas Hannen <lukas.hannen@opensource.tttech-industrial.com>
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Cc: stable@vger.kernel.org
Link: https://lore.kernel.org/r/AM6PR01MB541637BD6F336B8FFB72AF80EEC69@AM6PR01MB5416.eurprd01.prod.exchangelabs.com
(cherry picked from commit 39ff83f2f6cc5cc1458dfcea9697f96338210beb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/time64.h
diff --cc include/linux/time64.h
index a911c22d9538,81b9686a2079..000000000000
--- a/include/linux/time64.h
+++ b/include/linux/time64.h
@@@ -30,8 -25,21 +30,10 @@@ struct itimerspec64 
  #define TIME64_MIN			(-TIME64_MAX - 1)
  
  #define KTIME_MAX			((s64)~((u64)1 << 63))
+ #define KTIME_MIN			(-KTIME_MAX - 1)
  #define KTIME_SEC_MAX			(KTIME_MAX / NSEC_PER_SEC)
+ #define KTIME_SEC_MIN			(KTIME_MIN / NSEC_PER_SEC)
  
 -/*
 - * Limits for settimeofday():
 - *
 - * To prevent setting the time close to the wraparound point time setting
 - * is limited so a reasonable uptime can be accomodated. Uptime of 30 years
 - * should be really sufficient, which means the cutoff is 2232. At that
 - * point the cutoff is just a small part of the larger problem.
 - */
 -#define TIME_UPTIME_SEC_MAX		(30LL * 365 * 24 *3600)
 -#define TIME_SETTOD_SEC_MAX		(KTIME_SEC_MAX - TIME_UPTIME_SEC_MAX)
 -
  static inline int timespec64_equal(const struct timespec64 *a,
  				   const struct timespec64 *b)
  {
@@@ -108,6 -126,13 +110,16 @@@ static inline bool timespec64_valid_str
   */
  static inline s64 timespec64_to_ns(const struct timespec64 *ts)
  {
++<<<<<<< HEAD
++=======
+ 	/* Prevent multiplication overflow / underflow */
+ 	if (ts->tv_sec >= KTIME_SEC_MAX)
+ 		return KTIME_MAX;
+ 
+ 	if (ts->tv_sec <= KTIME_SEC_MIN)
+ 		return KTIME_MIN;
+ 
++>>>>>>> 39ff83f2f6cc (time: Handle negative seconds correctly in timespec64_to_ns())
  	return ((s64) ts->tv_sec * NSEC_PER_SEC) + ts->tv_nsec;
  }
  
* Unmerged path include/linux/time64.h
