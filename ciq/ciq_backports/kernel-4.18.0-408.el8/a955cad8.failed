KVM: x86/mmu: Retry page fault if root is invalidated by memslot update

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Sean Christopherson <seanjc@google.com>
commit a955cad84cdaffa282b3cf8f5ce69e9e5655e585
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/a955cad8.failed

Bail from the page fault handler if the root shadow page was obsoleted by
a memslot update.  Do the check _after_ acuiring mmu_lock, as the TDP MMU
doesn't rely on the memslot/MMU generation, and instead relies on the
root being explicit marked invalid by kvm_mmu_zap_all_fast(), which takes
mmu_lock for write.

For the TDP MMU, inserting a SPTE into an obsolete root can leak a SP if
kvm_tdp_mmu_zap_invalidated_roots() has already zapped the SP, i.e. has
moved past the gfn associated with the SP.

For other MMUs, the resulting behavior is far more convoluted, though
unlikely to be truly problematic.  Installing SPs/SPTEs into the obsolete
root isn't directly problematic, as the obsolete root will be unloaded
and dropped before the vCPU re-enters the guest.  But because the legacy
MMU tracks shadow pages by their role, any SP created by the fault can
can be reused in the new post-reload root.  Again, that _shouldn't_ be
problematic as any leaf child SPTEs will be created for the current/valid
memslot generation, and kvm_mmu_get_page() will not reuse child SPs from
the old generation as they will be flagged as obsolete.  But, given that
continuing with the fault is pointess (the root will be unloaded), apply
the check to all MMUs.

Fixes: b7cccd397f31 ("KVM: x86/mmu: Fast invalidation for TDP MMU")
	Cc: stable@vger.kernel.org
	Cc: Ben Gardon <bgardon@google.com>
	Signed-off-by: Sean Christopherson <seanjc@google.com>
Message-Id: <20211120045046.3940942-5-seanjc@google.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit a955cad84cdaffa282b3cf8f5ce69e9e5655e585)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/mmu/mmu.c
#	arch/x86/kvm/mmu/paging_tmpl.h
diff --cc arch/x86/kvm/mmu/mmu.c
index 970fc4a0eb93,e2e1d012df22..000000000000
--- a/arch/x86/kvm/mmu/mmu.c
+++ b/arch/x86/kvm/mmu/mmu.c
@@@ -3985,8 -4031,9 +4003,13 @@@ static int direct_page_fault(struct kvm
  	else
  		write_lock(&vcpu->kvm->mmu_lock);
  
++<<<<<<< HEAD
 +	if (!is_noslot_pfn(pfn) && mmu_notifier_retry_hva(vcpu->kvm, mmu_seq, hva))
++=======
+ 	if (is_page_fault_stale(vcpu, fault, mmu_seq))
++>>>>>>> a955cad84cda (KVM: x86/mmu: Retry page fault if root is invalidated by memslot update)
  		goto out_unlock;
+ 
  	r = make_mmu_pages_available(vcpu);
  	if (r)
  		goto out_unlock;
diff --cc arch/x86/kvm/mmu/paging_tmpl.h
index de3ee26beb48,708a5d297fe1..000000000000
--- a/arch/x86/kvm/mmu/paging_tmpl.h
+++ b/arch/x86/kvm/mmu/paging_tmpl.h
@@@ -920,7 -911,8 +920,12 @@@ static int FNAME(page_fault)(struct kvm
  
  	r = RET_PF_RETRY;
  	write_lock(&vcpu->kvm->mmu_lock);
++<<<<<<< HEAD
 +	if (!is_noslot_pfn(pfn) && mmu_notifier_retry_hva(vcpu->kvm, mmu_seq, hva))
++=======
+ 
+ 	if (is_page_fault_stale(vcpu, fault, mmu_seq))
++>>>>>>> a955cad84cda (KVM: x86/mmu: Retry page fault if root is invalidated by memslot update)
  		goto out_unlock;
  
  	kvm_mmu_audit(vcpu, AUDIT_PRE_PAGE_FAULT);
* Unmerged path arch/x86/kvm/mmu/mmu.c
* Unmerged path arch/x86/kvm/mmu/paging_tmpl.h
