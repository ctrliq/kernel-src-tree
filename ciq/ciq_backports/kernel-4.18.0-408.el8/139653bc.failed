net/smc: Remove corked dealyed work

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Tony Lu <tonylu@linux.alibaba.com>
commit 139653bc6635bcf0923a1d4fa06d3ac594528dd9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/139653bc.failed

Based on the manual of TCP_CORK [1] and MSG_MORE [2], these two options
have the same effect. Applications can set these options and informs the
kernel to pend the data, and send them out only when the socket or
syscall does not specify this flag. In other words, there's no need to
send data out by a delayed work, which will queue a lot of work.

This removes corked delayed work with SMC_TX_CORK_DELAY (250ms), and the
applications control how/when to send them out. It improves the
performance for sendfile and throughput, and remove unnecessary race of
lock_sock(). This also unlocks the limitation of sndbuf, and try to fill
it up before sending.

[1] https://linux.die.net/man/7/tcp
[2] https://man7.org/linux/man-pages/man2/send.2.html

	Signed-off-by: Tony Lu <tonylu@linux.alibaba.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 139653bc6635bcf0923a1d4fa06d3ac594528dd9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/smc/smc_tx.c
diff --cc net/smc/smc_tx.c
index 31ee76131a79,9cec62cae7cb..000000000000
--- a/net/smc/smc_tx.c
+++ b/net/smc/smc_tx.c
@@@ -28,9 -28,9 +28,8 @@@
  #include "smc_ism.h"
  #include "smc_tx.h"
  #include "smc_stats.h"
 -#include "smc_tracepoint.h"
  
  #define SMC_TX_WORK_DELAY	0
- #define SMC_TX_CORK_DELAY	(HZ >> 2)	/* 250 ms */
  
  /***************************** sndbuf producer *******************************/
  
@@@ -236,15 -236,15 +235,22 @@@ int smc_tx_sendmsg(struct smc_sock *smc
  		if ((msg->msg_flags & MSG_OOB) && !send_remaining)
  			conn->urg_tx_pend = true;
  		if ((msg->msg_flags & MSG_MORE || smc_tx_is_corked(smc)) &&
- 		    (atomic_read(&conn->sndbuf_space) >
- 						(conn->sndbuf_desc->len >> 1)))
- 			/* for a corked socket defer the RDMA writes if there
- 			 * is still sufficient sndbuf_space available
+ 		    (atomic_read(&conn->sndbuf_space)))
+ 			/* for a corked socket defer the RDMA writes if
+ 			 * sndbuf_space is still available. The applications
+ 			 * should known how/when to uncork it.
  			 */
++<<<<<<< HEAD
 +			queue_delayed_work(conn->lgr->tx_wq, &conn->tx_work,
 +					   SMC_TX_CORK_DELAY);
 +		else
 +			smc_tx_sndbuf_nonempty(conn);
++=======
+ 			continue;
+ 		smc_tx_sndbuf_nonempty(conn);
+ 
+ 		trace_smc_tx_sendmsg(smc, copylen);
++>>>>>>> 139653bc6635 (net/smc: Remove corked dealyed work)
  	} /* while (msg_data_left(msg)) */
  
  	return send_done;
* Unmerged path net/smc/smc_tx.c
