s390/qdio: split do_QDIO()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Julian Wiedmann <jwi@linux.ibm.com>
commit a60bffe536f90834ddedc0ed4ddf81af943eb061
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/a60bffe5.failed

The callers know what type of queue they want to work with. Introduce
type-specific variants to add buffers on an {Input,Output} queue, so
that we can avoid some function parameters and the de-muxing into
type-specific hot paths.

	Signed-off-by: Julian Wiedmann <jwi@linux.ibm.com>
	Reviewed-by: Benjamin Block <bblock@linux.ibm.com>
	Signed-off-by: Heiko Carstens <hca@linux.ibm.com>
(cherry picked from commit a60bffe536f90834ddedc0ed4ddf81af943eb061)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/s390/include/asm/qdio.h
#	drivers/s390/cio/qdio_main.c
#	drivers/s390/net/qeth_core_main.c
diff --cc arch/s390/include/asm/qdio.h
index 97bfcbd53275,c65652fa2dbd..000000000000
--- a/arch/s390/include/asm/qdio.h
+++ b/arch/s390/include/asm/qdio.h
@@@ -337,10 -336,6 +337,13 @@@ struct qdio_initialize 
  	struct qdio_buffer ***output_sbal_addr_array;
  };
  
++<<<<<<< HEAD
 +#define QDIO_FLAG_SYNC_INPUT		0x01
 +#define QDIO_FLAG_SYNC_OUTPUT		0x02
 +#define QDIO_FLAG_PCI_OUT		0x10
 +
++=======
++>>>>>>> a60bffe536f9 (s390/qdio: split do_QDIO())
  int qdio_alloc_buffers(struct qdio_buffer **buf, unsigned int count);
  void qdio_free_buffers(struct qdio_buffer **buf, unsigned int count);
  void qdio_reset_buffers(struct qdio_buffer **buf, unsigned int count);
@@@ -350,16 -345,18 +353,31 @@@ extern int qdio_allocate(struct ccw_dev
  extern int qdio_establish(struct ccw_device *cdev,
  			  struct qdio_initialize *init_data);
  extern int qdio_activate(struct ccw_device *);
++<<<<<<< HEAD
 +extern struct qaob *qdio_allocate_aob(void);
 +extern void qdio_release_aob(struct qaob *);
 +extern int do_QDIO(struct ccw_device *cdev, unsigned int callflags, int q_nr,
 +		   unsigned int bufnr, unsigned int count, struct qaob *aob);
 +extern int qdio_start_irq(struct ccw_device *cdev);
 +extern int qdio_stop_irq(struct ccw_device *cdev);
 +extern int qdio_get_next_buffers(struct ccw_device *, int, int *, int *);
 +extern int qdio_inspect_queue(struct ccw_device *cdev, unsigned int nr,
 +			      bool is_input, unsigned int *bufnr,
 +			      unsigned int *error);
++=======
+ extern int qdio_start_irq(struct ccw_device *cdev);
+ extern int qdio_stop_irq(struct ccw_device *cdev);
+ extern int qdio_inspect_input_queue(struct ccw_device *cdev, unsigned int nr,
+ 				    unsigned int *bufnr, unsigned int *error);
+ extern int qdio_inspect_output_queue(struct ccw_device *cdev, unsigned int nr,
+ 				     unsigned int *bufnr, unsigned int *error);
+ extern int qdio_add_bufs_to_input_queue(struct ccw_device *cdev,
+ 					unsigned int q_nr, unsigned int bufnr,
+ 					unsigned int count);
+ extern int qdio_add_bufs_to_output_queue(struct ccw_device *cdev,
+ 					 unsigned int q_nr, unsigned int bufnr,
+ 					 unsigned int count, struct qaob *aob);
++>>>>>>> a60bffe536f9 (s390/qdio: split do_QDIO())
  extern int qdio_shutdown(struct ccw_device *, int);
  extern int qdio_free(struct ccw_device *);
  extern int qdio_get_ssqd_desc(struct ccw_device *, struct qdio_ssqd_desc *);
diff --cc drivers/s390/cio/qdio_main.c
index 70e5627982b2,82c2383b0740..000000000000
--- a/drivers/s390/cio/qdio_main.c
+++ b/drivers/s390/cio/qdio_main.c
@@@ -1367,15 -1309,10 +1395,20 @@@ int qdio_add_bufs_to_output_queue(struc
  		return -EIO;
  	if (!count)
  		return 0;
++<<<<<<< HEAD
 +	if (callflags & QDIO_FLAG_SYNC_INPUT)
 +		return handle_inbound(irq_ptr->input_qs[q_nr],
 +				      callflags, bufnr, count);
 +	else if (callflags & QDIO_FLAG_SYNC_OUTPUT)
 +		return handle_outbound(irq_ptr->output_qs[q_nr],
 +				       callflags, bufnr, count, aob);
 +	return -EINVAL;
++=======
+ 
+ 	return handle_outbound(irq_ptr->output_qs[q_nr], bufnr, count, aob);
++>>>>>>> a60bffe536f9 (s390/qdio: split do_QDIO())
  }
- EXPORT_SYMBOL_GPL(do_QDIO);
+ EXPORT_SYMBOL_GPL(qdio_add_bufs_to_output_queue);
  
  /**
   * qdio_start_irq - enable interrupt processing for the device
diff --cc drivers/s390/net/qeth_core_main.c
index b84043897803,fe2c4c699d37..000000000000
--- a/drivers/s390/net/qeth_core_main.c
+++ b/drivers/s390/net/qeth_core_main.c
@@@ -359,8 -355,8 +359,13 @@@ static int qeth_cq_init(struct qeth_car
  		qdio_reset_buffers(card->qdio.c_q->qdio_bufs,
  				   QDIO_MAX_BUFFERS_PER_Q);
  		card->qdio.c_q->next_buf_to_init = 127;
++<<<<<<< HEAD
 +		rc = do_QDIO(CARD_DDEV(card), QDIO_FLAG_SYNC_INPUT,
 +			     card->qdio.no_in_queues - 1, 0, 127, NULL);
++=======
+ 
+ 		rc = qdio_add_bufs_to_input_queue(CARD_DDEV(card), 1, 0, 127);
++>>>>>>> a60bffe536f9 (s390/qdio: split do_QDIO())
  		if (rc) {
  			QETH_CARD_TEXT_(card, 2, "1err%d", rc);
  			goto out;
* Unmerged path arch/s390/include/asm/qdio.h
* Unmerged path drivers/s390/cio/qdio_main.c
* Unmerged path drivers/s390/net/qeth_core_main.c
diff --git a/drivers/s390/scsi/zfcp_qdio.c b/drivers/s390/scsi/zfcp_qdio.c
index e450a22d3f21..97bb87c755f5 100644
--- a/drivers/s390/scsi/zfcp_qdio.c
+++ b/drivers/s390/scsi/zfcp_qdio.c
@@ -154,7 +154,7 @@ static void zfcp_qdio_int_resp(struct ccw_device *cdev, unsigned int qdio_err,
 	/*
 	 * put SBALs back to response queue
 	 */
-	if (do_QDIO(cdev, QDIO_FLAG_SYNC_INPUT, 0, idx, count, NULL))
+	if (qdio_add_bufs_to_input_queue(cdev, 0, idx, count))
 		zfcp_erp_adapter_reopen(qdio->adapter, 0, "qdires2");
 }
 
@@ -325,8 +325,9 @@ int zfcp_qdio_send(struct zfcp_qdio *qdio, struct zfcp_qdio_req *q_req)
 
 	atomic_sub(sbal_number, &qdio->req_q_free);
 
-	retval = do_QDIO(qdio->adapter->ccw_device, QDIO_FLAG_SYNC_OUTPUT, 0,
-			 q_req->sbal_first, sbal_number, NULL);
+	retval = qdio_add_bufs_to_output_queue(qdio->adapter->ccw_device, 0,
+					       q_req->sbal_first, sbal_number,
+					       NULL);
 
 	if (unlikely(retval)) {
 		/* Failed to submit the IO, roll back our modifications. */
@@ -394,7 +395,10 @@ void zfcp_qdio_close(struct zfcp_qdio *qdio)
 	if (!(atomic_read(&adapter->status) & ZFCP_STATUS_ADAPTER_QDIOUP))
 		return;
 
-	/* clear QDIOUP flag, thus do_QDIO is not called during qdio_shutdown */
+	/*
+	 * Clear QDIOUP flag, thus qdio_add_bufs_to_output_queue() is not called
+	 * during qdio_shutdown().
+	 */
 	spin_lock_irq(&qdio->req_q_lock);
 	atomic_andnot(ZFCP_STATUS_ADAPTER_QDIOUP, &adapter->status);
 	spin_unlock_irq(&qdio->req_q_lock);
@@ -497,8 +501,7 @@ int zfcp_qdio_open(struct zfcp_qdio *qdio)
 		sbale->addr = 0;
 	}
 
-	if (do_QDIO(cdev, QDIO_FLAG_SYNC_INPUT, 0, 0, QDIO_MAX_BUFFERS_PER_Q,
-		    NULL))
+	if (qdio_add_bufs_to_input_queue(cdev, 0, 0, QDIO_MAX_BUFFERS_PER_Q))
 		goto failed_qdio;
 
 	/* set index of first available SBALS / number of available SBALS */
