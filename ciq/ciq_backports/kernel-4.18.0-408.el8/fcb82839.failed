KVM: arm64: Fix boolreturn.cocci warnings

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author kernel test robot <lkp@intel.com>
commit fcb8283920b135bca2916133e2383a501ad57eaa
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/fcb82839.failed

arch/arm64/kvm/mmu.c:1114:9-10: WARNING: return of 0/1 in function 'kvm_age_gfn' with return type bool
arch/arm64/kvm/mmu.c:1084:9-10: WARNING: return of 0/1 in function 'kvm_set_spte_gfn' with return type bool
arch/arm64/kvm/mmu.c:1127:9-10: WARNING: return of 0/1 in function 'kvm_test_age_gfn' with return type bool
arch/arm64/kvm/mmu.c:1070:9-10: WARNING: return of 0/1 in function 'kvm_unmap_gfn_range' with return type bool

 Return statements in functions returning bool should use
 true/false instead of 1/0.
Generated by: scripts/coccinelle/misc/boolreturn.cocci

Fixes: cd4c71835228 ("KVM: arm64: Convert to the gfn-based MMU notifier callbacks")
	Reported-by: kernel test robot <lkp@intel.com>
	Signed-off-by: kernel test robot <lkp@intel.com>
	Reviewed-by: Sean Christopherson <seanjc@google.com>
	Signed-off-by: Marc Zyngier <maz@kernel.org>
Link: https://lore.kernel.org/r/20210426223357.GA45871@cd4295a34ed8
(cherry picked from commit fcb8283920b135bca2916133e2383a501ad57eaa)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/arm64/kvm/mmu.c
diff --cc arch/arm64/kvm/mmu.c
index 60713ffdcad4,c10207fed2f3..000000000000
--- a/arch/arm64/kvm/mmu.c
+++ b/arch/arm64/kvm/mmu.c
@@@ -2019,150 -1153,70 +2019,188 @@@ out_unlock
  	return ret;
  }
  
 -bool kvm_unmap_gfn_range(struct kvm *kvm, struct kvm_gfn_range *range)
 +static int handle_hva_to_gpa(struct kvm *kvm,
 +			     unsigned long start,
 +			     unsigned long end,
 +			     int (*handler)(struct kvm *kvm,
 +					    gpa_t gpa, u64 size,
 +					    void *data),
 +			     void *data)
  {
++<<<<<<< HEAD
 +	struct kvm_memslots *slots;
 +	struct kvm_memory_slot *memslot;
 +	int ret = 0;
++=======
+ 	if (!kvm->arch.mmu.pgt)
+ 		return false;
++>>>>>>> fcb8283920b1 (KVM: arm64: Fix boolreturn.cocci warnings)
 +
 +	slots = kvm_memslots(kvm);
 +
++<<<<<<< HEAD
 +	/* we only care about the pages that the guest sees */
 +	kvm_for_each_memslot(memslot, slots) {
 +		unsigned long hva_start, hva_end;
 +		gfn_t gpa;
 +
 +		hva_start = max(start, memslot->userspace_addr);
 +		hva_end = min(end, memslot->userspace_addr +
 +					(memslot->npages << PAGE_SHIFT));
 +		if (hva_start >= hva_end)
 +			continue;
  
 -	__unmap_stage2_range(&kvm->arch.mmu, range->start << PAGE_SHIFT,
 -			     (range->end - range->start) << PAGE_SHIFT,
 -			     range->may_block);
 +		gpa = hva_to_gfn_memslot(hva_start, memslot) << PAGE_SHIFT;
 +		ret |= handler(kvm, gpa, (u64)(hva_end - hva_start), data);
 +	}
 +
 +	return ret;
 +}
  
 +static int kvm_unmap_hva_handler(struct kvm *kvm, gpa_t gpa, u64 size, void *data)
 +{
 +	unsigned flags = *(unsigned *)data;
 +	bool may_block = flags & MMU_NOTIFIER_RANGE_BLOCKABLE;
 +
 +	__unmap_stage2_range(kvm, gpa, size, may_block);
 +	return 0;
++=======
+ 	return false;
++>>>>>>> fcb8283920b1 (KVM: arm64: Fix boolreturn.cocci warnings)
  }
  
 -bool kvm_set_spte_gfn(struct kvm *kvm, struct kvm_gfn_range *range)
 +int kvm_unmap_hva_range(struct kvm *kvm,
 +			unsigned long start, unsigned long end, unsigned flags)
  {
++<<<<<<< HEAD
 +	if (!kvm->arch.pgd)
 +		return 0;
++=======
+ 	kvm_pfn_t pfn = pte_pfn(range->pte);
+ 
+ 	if (!kvm->arch.mmu.pgt)
+ 		return false;
++>>>>>>> fcb8283920b1 (KVM: arm64: Fix boolreturn.cocci warnings)
  
 -	WARN_ON(range->end - range->start != 1);
 +	handle_hva_to_gpa(kvm, start, end, &kvm_unmap_hva_handler, &flags);
 +	return 0;
 +}
 +
 +static int kvm_set_spte_handler(struct kvm *kvm, gpa_t gpa, u64 size, void *data)
 +{
 +	pte_t *pte = (pte_t *)data;
  
 +	WARN_ON(size != PAGE_SIZE);
  	/*
 -	 * We've moved a page around, probably through CoW, so let's treat it
 -	 * just like a translation fault and clean the cache to the PoC.
 +	 * We can always call stage2_set_pte with KVM_S2PTE_FLAG_LOGGING_ACTIVE
 +	 * flag clear because MMU notifiers will have unmapped a huge PMD before
 +	 * calling ->change_pte() (which in turn calls kvm_set_spte_hva()) and
 +	 * therefore stage2_set_pte() never needs to clear out a huge PMD
 +	 * through this calling path.
  	 */
 -	clean_dcache_guest_page(pfn, PAGE_SIZE);
 +	stage2_set_pte(kvm, NULL, gpa, pte, 0);
 +	return 0;
 +}
 +
 +
 +int kvm_set_spte_hva(struct kvm *kvm, unsigned long hva, pte_t pte)
 +{
 +	unsigned long end = hva + PAGE_SIZE;
 +	kvm_pfn_t pfn = pte_pfn(pte);
 +	pte_t stage2_pte;
 +
 +	if (!kvm->arch.pgd)
 +		return 0;
  
  	/*
 -	 * The MMU notifiers will have unmapped a huge PMD before calling
 -	 * ->change_pte() (which in turn calls kvm_set_spte_gfn()) and
 -	 * therefore we never need to clear out a huge PMD through this
 -	 * calling path and a memcache is not required.
 +	 * We've moved a page around, probably through CoW, so let's treat it
 +	 * just like a translation fault and clean the cache to the PoC.
  	 */
 -	kvm_pgtable_stage2_map(kvm->arch.mmu.pgt, range->start << PAGE_SHIFT,
 -			       PAGE_SIZE, __pfn_to_phys(pfn),
 -			       KVM_PGTABLE_PROT_R, NULL);
 +	clean_dcache_guest_page(pfn, PAGE_SIZE);
 +	stage2_pte = kvm_pfn_pte(pfn, PAGE_S2);
 +	handle_hva_to_gpa(kvm, hva, end, &kvm_set_spte_handler, &stage2_pte);
  
- 	return 0;
+ 	return false;
  }
  
 -bool kvm_age_gfn(struct kvm *kvm, struct kvm_gfn_range *range)
 +static int kvm_age_hva_handler(struct kvm *kvm, gpa_t gpa, u64 size, void *data)
  {
++<<<<<<< HEAD
 +	pud_t *pud;
 +	pmd_t *pmd;
 +	pte_t *pte;
 +
 +	WARN_ON(size != PAGE_SIZE && size != PMD_SIZE && size != PUD_SIZE);
 +	if (!stage2_get_leaf_entry(kvm, gpa, &pud, &pmd, &pte))
 +		return 0;
++=======
+ 	u64 size = (range->end - range->start) << PAGE_SHIFT;
+ 	kvm_pte_t kpte;
+ 	pte_t pte;
+ 
+ 	if (!kvm->arch.mmu.pgt)
+ 		return false;
+ 
+ 	WARN_ON(size != PAGE_SIZE && size != PMD_SIZE && size != PUD_SIZE);
+ 
+ 	kpte = kvm_pgtable_stage2_mkold(kvm->arch.mmu.pgt,
+ 					range->start << PAGE_SHIFT);
+ 	pte = __pte(kpte);
+ 	return pte_valid(pte) && pte_young(pte);
+ }
+ 
+ bool kvm_test_age_gfn(struct kvm *kvm, struct kvm_gfn_range *range)
+ {
+ 	if (!kvm->arch.mmu.pgt)
+ 		return false;
++>>>>>>> fcb8283920b1 (KVM: arm64: Fix boolreturn.cocci warnings)
 +
 +	if (pud)
 +		return stage2_pudp_test_and_clear_young(pud);
 +	else if (pmd)
 +		return stage2_pmdp_test_and_clear_young(pmd);
 +	else
 +		return stage2_ptep_test_and_clear_young(pte);
 +}
 +
 +static int kvm_test_age_hva_handler(struct kvm *kvm, gpa_t gpa, u64 size, void *data)
 +{
 +	pud_t *pud;
 +	pmd_t *pmd;
 +	pte_t *pte;
 +
 +	WARN_ON(size != PAGE_SIZE && size != PMD_SIZE && size != PUD_SIZE);
 +	if (!stage2_get_leaf_entry(kvm, gpa, &pud, &pmd, &pte))
 +		return 0;
 +
 +	if (pud)
 +		return kvm_s2pud_young(*pud);
 +	else if (pmd)
 +		return pmd_young(*pmd);
 +	else
 +		return pte_young(*pte);
 +}
 +
 +int kvm_age_hva(struct kvm *kvm, unsigned long start, unsigned long end)
 +{
 +	if (!kvm->arch.pgd)
 +		return 0;
 +
 +	return handle_hva_to_gpa(kvm, start, end, kvm_age_hva_handler, NULL);
 +}
 +
 +int kvm_test_age_hva(struct kvm *kvm, unsigned long hva)
 +{
 +	if (!kvm->arch.pgd)
 +		return 0;
 +
 +	return handle_hva_to_gpa(kvm, hva, hva + PAGE_SIZE,
 +				 kvm_test_age_hva_handler, NULL);
 +}
  
 -	return kvm_pgtable_stage2_is_young(kvm->arch.mmu.pgt,
 -					   range->start << PAGE_SHIFT);
 +void kvm_mmu_free_memory_caches(struct kvm_vcpu *vcpu)
 +{
 +	kvm_mmu_free_memory_cache(&vcpu->arch.mmu_page_cache);
  }
  
  phys_addr_t kvm_mmu_get_httbr(void)
* Unmerged path arch/arm64/kvm/mmu.c
