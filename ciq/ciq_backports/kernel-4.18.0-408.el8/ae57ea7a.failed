s390/qeth: clean up device_type management

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Julian Wiedmann <jwi@linux.ibm.com>
commit ae57ea7a19b784e5982ae25bdba3cdf7c98f3067
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/ae57ea7a.failed

qeth uses three device_type structs - a generic one, and one for each
sub-driver (which is used for fixed-layer devices only). Instead of
exporting these device_types back&forth between the driver's modules,
make all the logic self-contained within the sub-drivers.

On disc->setup() they either install their own device_type, or add the
sysfs attributes that are missing in the generic device_type. Later on
disc->remove() these attributes are removed again from any device that
has the generic device_type.

	Signed-off-by: Julian Wiedmann <jwi@linux.ibm.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit ae57ea7a19b784e5982ae25bdba3cdf7c98f3067)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/s390/net/qeth_core.h
#	drivers/s390/net/qeth_core_main.c
diff --cc drivers/s390/net/qeth_core.h
index 5a71f2df4f14,c17031519900..000000000000
--- a/drivers/s390/net/qeth_core.h
+++ b/drivers/s390/net/qeth_core.h
@@@ -779,13 -766,7 +779,12 @@@ enum qeth_threads 
  	QETH_RECOVER_THREAD = 1,
  };
  
 +struct qeth_osn_info {
 +	int (*assist_cb)(struct net_device *dev, void *data);
 +	int (*data_cb)(struct sk_buff *skb);
 +};
 +
  struct qeth_discipline {
- 	const struct device_type *devtype;
  	int (*setup) (struct ccwgroup_device *);
  	void (*remove) (struct ccwgroup_device *);
  	int (*set_online)(struct qeth_card *card, bool carrier_ok);
@@@ -1057,10 -1038,7 +1056,13 @@@ int qeth_get_priority_queue(struct qeth
  extern const struct qeth_discipline qeth_l2_discipline;
  extern const struct qeth_discipline qeth_l3_discipline;
  extern const struct ethtool_ops qeth_ethtool_ops;
 +extern const struct ethtool_ops qeth_osn_ethtool_ops;
  extern const struct attribute_group *qeth_dev_groups[];
++<<<<<<< HEAD
 +extern const struct attribute_group *qeth_osn_dev_groups[];
 +extern const struct device_type qeth_generic_devtype;
++=======
++>>>>>>> ae57ea7a19b7 (s390/qeth: clean up device_type management)
  
  const char *qeth_get_cardname_short(struct qeth_card *);
  int qeth_resize_buffer_pool(struct qeth_card *card, unsigned int count);
diff --cc drivers/s390/net/qeth_core_main.c
index b84043897803,7f486212c6aa..000000000000
--- a/drivers/s390/net/qeth_core_main.c
+++ b/drivers/s390/net/qeth_core_main.c
@@@ -6325,15 -6286,10 +6325,14 @@@ void qeth_remove_discipline(struct qeth
  	card->discipline = NULL;
  }
  
- const struct device_type qeth_generic_devtype = {
+ static const struct device_type qeth_generic_devtype = {
  	.name = "qeth_generic",
  };
- EXPORT_SYMBOL_GPL(qeth_generic_devtype);
  
 +static const struct device_type qeth_osn_devtype = {
 +	.name = "qeth_osn",
 +};
 +
  #define DBF_NAME_LEN	20
  
  struct qeth_dbf_entry {
@@@ -6528,8 -6473,6 +6527,11 @@@ static int qeth_core_probe_device(struc
  		if (rc)
  			goto err_setup_disc;
  
++<<<<<<< HEAD
 +		gdev->dev.type = IS_OSN(card) ? &qeth_osn_devtype :
 +						card->discipline->devtype;
++=======
++>>>>>>> ae57ea7a19b7 (s390/qeth: clean up device_type management)
  		break;
  	}
  
* Unmerged path drivers/s390/net/qeth_core.h
* Unmerged path drivers/s390/net/qeth_core_main.c
diff --git a/drivers/s390/net/qeth_l2_main.c b/drivers/s390/net/qeth_l2_main.c
index 8c32c74d18bb..16e5d698aa92 100644
--- a/drivers/s390/net/qeth_l2_main.c
+++ b/drivers/s390/net/qeth_l2_main.c
@@ -2421,10 +2421,12 @@ static int qeth_l2_probe_device(struct ccwgroup_device *gdev)
 	qeth_l2_vnicc_set_defaults(card);
 	mutex_init(&card->sbp_lock);
 
-	if (gdev->dev.type == &qeth_generic_devtype) {
+	if (gdev->dev.type) {
 		rc = device_add_groups(&gdev->dev, qeth_l2_attr_groups);
 		if (rc)
 			return rc;
+	} else {
+		gdev->dev.type = &qeth_l2_devtype;
 	}
 
 	INIT_WORK(&card->rx_mode_work, qeth_l2_rx_mode_work);
@@ -2436,8 +2438,9 @@ static void qeth_l2_remove_device(struct ccwgroup_device *gdev)
 	struct qeth_card *card = dev_get_drvdata(&gdev->dev);
 	struct qeth_priv *priv;
 
-	if (gdev->dev.type == &qeth_generic_devtype)
+	if (gdev->dev.type != &qeth_l2_devtype)
 		device_remove_groups(&gdev->dev, qeth_l2_attr_groups);
+
 	qeth_set_allowed_threads(card, 0, 1);
 	wait_event(card->wait_q, qeth_threads_running(card, 0xffffffff) == 0);
 
@@ -2564,7 +2567,6 @@ static int qeth_l2_control_event(struct qeth_card *card,
 }
 
 const struct qeth_discipline qeth_l2_discipline = {
-	.devtype = &qeth_l2_devtype,
 	.setup = qeth_l2_probe_device,
 	.remove = qeth_l2_remove_device,
 	.set_online = qeth_l2_set_online,
diff --git a/drivers/s390/net/qeth_l3_main.c b/drivers/s390/net/qeth_l3_main.c
index 5e2f626ff607..ee2a4a8ffe06 100644
--- a/drivers/s390/net/qeth_l3_main.c
+++ b/drivers/s390/net/qeth_l3_main.c
@@ -1943,12 +1943,14 @@ static int qeth_l3_probe_device(struct ccwgroup_device *gdev)
 	if (!card->cmd_wq)
 		return -ENOMEM;
 
-	if (gdev->dev.type == &qeth_generic_devtype) {
+	if (gdev->dev.type) {
 		rc = device_add_groups(&gdev->dev, qeth_l3_attr_groups);
 		if (rc) {
 			destroy_workqueue(card->cmd_wq);
 			return rc;
 		}
+	} else {
+		gdev->dev.type = &qeth_l3_devtype;
 	}
 
 	INIT_WORK(&card->rx_mode_work, qeth_l3_rx_mode_work);
@@ -1959,7 +1961,7 @@ static void qeth_l3_remove_device(struct ccwgroup_device *cgdev)
 {
 	struct qeth_card *card = dev_get_drvdata(&cgdev->dev);
 
-	if (cgdev->dev.type == &qeth_generic_devtype)
+	if (cgdev->dev.type != &qeth_l3_devtype)
 		device_remove_groups(&cgdev->dev, qeth_l3_attr_groups);
 
 	qeth_set_allowed_threads(card, 0, 1);
@@ -2067,7 +2069,6 @@ static int qeth_l3_control_event(struct qeth_card *card,
 }
 
 const struct qeth_discipline qeth_l3_discipline = {
-	.devtype = &qeth_l3_devtype,
 	.setup = qeth_l3_probe_device,
 	.remove = qeth_l3_remove_device,
 	.set_online = qeth_l3_set_online,
