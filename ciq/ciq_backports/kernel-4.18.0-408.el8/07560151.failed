block: make bio_crypt_clone() able to fail

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Eric Biggers <ebiggers@google.com>
commit 07560151db960d26b425410d6fd778e6757a5da2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/07560151.failed

bio_crypt_clone() assumes its gfp_mask argument always includes
__GFP_DIRECT_RECLAIM, so that the mempool_alloc() will always succeed.

However, bio_crypt_clone() might be called with GFP_ATOMIC via
setup_clone() in drivers/md/dm-rq.c, or with GFP_NOWAIT via
kcryptd_io_read() in drivers/md/dm-crypt.c.

Neither case is currently reachable with a bio that actually has an
encryption context.  However, it's fragile to rely on this.  Just make
bio_crypt_clone() able to fail, analogous to bio_integrity_clone().

	Reported-by: Miaohe Lin <linmiaohe@huawei.com>
	Signed-off-by: Eric Biggers <ebiggers@google.com>
	Reviewed-by: Mike Snitzer <snitzer@redhat.com>
	Reviewed-by: Satya Tangirala <satyat@google.com>
	Cc: Satya Tangirala <satyat@google.com>
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit 07560151db960d26b425410d6fd778e6757a5da2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	block/bio.c
#	block/blk-crypto.c
#	block/bounce.c
#	drivers/md/dm.c
#	include/linux/blk-crypto.h
diff --cc block/bio.c
index df04c1ad5361,b42e046b12eb..000000000000
--- a/block/bio.c
+++ b/block/bio.c
@@@ -695,18 -713,18 +695,31 @@@ struct bio *bio_clone_fast(struct bio *
  
  	__bio_clone_fast(b, bio);
  
++<<<<<<< HEAD
 +	if (bio_integrity(bio)) {
 +		int ret;
 +
 +		ret = bio_integrity_clone(b, bio, gfp_mask);
 +
 +		if (ret < 0) {
 +			bio_put(b);
 +			return NULL;
 +		}
 +	}
++=======
+ 	if (bio_crypt_clone(b, bio, gfp_mask) < 0)
+ 		goto err_put;
+ 
+ 	if (bio_integrity(bio) &&
+ 	    bio_integrity_clone(b, bio, gfp_mask) < 0)
+ 		goto err_put;
++>>>>>>> 07560151db96 (block: make bio_crypt_clone() able to fail)
  
  	return b;
+ 
+ err_put:
+ 	bio_put(b);
+ 	return NULL;
  }
  EXPORT_SYMBOL(bio_clone_fast);
  
diff --cc block/bounce.c
index 580bf2905f1e,162a6eee8999..000000000000
--- a/block/bounce.c
+++ b/block/bounce.c
@@@ -248,15 -267,12 +248,24 @@@ static struct bio *bounce_clone_bio(str
  		break;
  	}
  
++<<<<<<< HEAD
 +	if (bio_integrity(bio_src)) {
 +		int ret;
 +
 +		ret = bio_integrity_clone(bio, bio_src, gfp_mask);
 +		if (ret < 0) {
 +			bio_put(bio);
 +			return NULL;
 +		}
 +	}
++=======
+ 	if (bio_crypt_clone(bio, bio_src, gfp_mask) < 0)
+ 		goto err_put;
+ 
+ 	if (bio_integrity(bio_src) &&
+ 	    bio_integrity_clone(bio, bio_src, gfp_mask) < 0)
+ 		goto err_put;
++>>>>>>> 07560151db96 (block: make bio_crypt_clone() able to fail)
  
  	bio_clone_blkg_association(bio, bio_src);
  	blkcg_bio_issue_init(bio);
diff --cc drivers/md/dm.c
index d626b645f571,e959cd74cd4b..000000000000
--- a/drivers/md/dm.c
+++ b/drivers/md/dm.c
@@@ -1345,9 -1330,11 +1346,14 @@@ static int clone_bio(struct dm_target_i
  
  	__bio_clone_fast(clone, bio);
  
- 	if (bio_integrity(bio)) {
- 		int r;
++<<<<<<< HEAD
++=======
+ 	r = bio_crypt_clone(clone, bio, GFP_NOIO);
+ 	if (r < 0)
+ 		return r;
  
++>>>>>>> 07560151db96 (block: make bio_crypt_clone() able to fail)
+ 	if (bio_integrity(bio)) {
  		if (unlikely(!dm_target_has_integrity(tio->ti->type) &&
  			     !dm_target_passes_integrity(tio->ti->type))) {
  			DMWARN("%s: the target %s doesn't support integrity data.",
* Unmerged path block/blk-crypto.c
* Unmerged path include/linux/blk-crypto.h
* Unmerged path block/bio.c
* Unmerged path block/blk-crypto.c
* Unmerged path block/bounce.c
* Unmerged path drivers/md/dm.c
* Unmerged path include/linux/blk-crypto.h
