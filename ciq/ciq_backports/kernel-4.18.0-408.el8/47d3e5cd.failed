KVM: x86: hyper-v: HVCALL_SEND_IPI_EX is an XMM fast hypercall

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Vitaly Kuznetsov <vkuznets@redhat.com>
commit 47d3e5cdfe607ec6883eb0faa7acf05b8cb3f92a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/47d3e5cd.failed

It has been proven on practice that at least Windows Server 2019 tries
using HVCALL_SEND_IPI_EX in 'XMM fast' mode when it has more than 64 vCPUs
and it needs to send an IPI to a vCPU > 63. Similarly to other XMM Fast
hypercalls (HVCALL_FLUSH_VIRTUAL_ADDRESS_{LIST,SPACE}{,_EX}), this
information is missing in TLFS as of 6.0b. Currently, KVM returns an error
(HV_STATUS_INVALID_HYPERCALL_INPUT) and Windows crashes.

Note, HVCALL_SEND_IPI is a 'standard' fast hypercall (not 'XMM fast') as
all its parameters fit into RDX:R8 and this is handled by KVM correctly.

	Cc: stable@vger.kernel.org # 5.14.x: 3244867af8c0: KVM: x86: Ignore sparse banks size for an "all CPUs", non-sparse IPI req
	Cc: stable@vger.kernel.org # 5.14.x
Fixes: d8f5537a8816 ("KVM: hyper-v: Advertise support for fast XMM hypercalls")
	Signed-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>
Message-Id: <20220222154642.684285-5-vkuznets@redhat.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 47d3e5cdfe607ec6883eb0faa7acf05b8cb3f92a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/hyperv.c
diff --cc arch/x86/kvm/hyperv.c
index 2ec52ff76a36,edf024f1f141..000000000000
--- a/arch/x86/kvm/hyperv.c
+++ b/arch/x86/kvm/hyperv.c
@@@ -1910,9 -1885,11 +1910,10 @@@ static u64 kvm_hv_send_ipi(struct kvm_v
  	DECLARE_BITMAP(vcpu_bitmap, KVM_MAX_VCPUS);
  	unsigned long *vcpu_mask;
  	unsigned long valid_bank_mask;
 -	u64 sparse_banks[64];
 -	int sparse_banks_len;
 +	u64 sparse_banks[KVM_HV_MAX_SPARSE_VCPU_SET_BITS];
  	u32 vector;
  	bool all_cpus;
+ 	int i;
  
  	if (hc->code == HVCALL_SEND_IPI) {
  		if (!hc->fast) {
@@@ -1943,21 -1926,37 +1950,50 @@@
  
  		vector = send_ipi_ex.vector;
  		valid_bank_mask = send_ipi_ex.vp_set.valid_bank_mask;
++<<<<<<< HEAD
++=======
+ 		sparse_banks_len = bitmap_weight(&valid_bank_mask, 64);
+ 
++>>>>>>> 47d3e5cdfe60 (KVM: x86: hyper-v: HVCALL_SEND_IPI_EX is an XMM fast hypercall)
  		all_cpus = send_ipi_ex.vp_set.format == HV_GENERIC_SET_ALL;
  
 +		if (hc->var_cnt != bitmap_weight(&valid_bank_mask, 64))
 +			return HV_STATUS_INVALID_HYPERCALL_INPUT;
 +
  		if (all_cpus)
  			goto check_and_send_ipi;
  
 -		if (!sparse_banks_len)
 +		if (!hc->var_cnt)
  			goto ret_success;
  
++<<<<<<< HEAD
 +		if (kvm_get_sparse_vp_set(kvm, hc, sparse_banks,
 +					  offsetof(struct hv_send_ipi_ex,
 +						   vp_set.bank_contents)))
 +			return HV_STATUS_INVALID_HYPERCALL_INPUT;
++=======
+ 		if (!hc->fast) {
+ 			if (kvm_read_guest(kvm,
+ 					   hc->ingpa + offsetof(struct hv_send_ipi_ex,
+ 								vp_set.bank_contents),
+ 					   sparse_banks,
+ 					   sparse_banks_len * sizeof(sparse_banks[0])))
+ 				return HV_STATUS_INVALID_HYPERCALL_INPUT;
+ 		} else {
+ 			/*
+ 			 * The lower half of XMM0 is already consumed, each XMM holds
+ 			 * two sparse banks.
+ 			 */
+ 			if (sparse_banks_len > (2 * HV_HYPERCALL_MAX_XMM_REGISTERS - 1))
+ 				return HV_STATUS_INVALID_HYPERCALL_INPUT;
+ 			for (i = 0; i < sparse_banks_len; i++) {
+ 				if (i % 2)
+ 					sparse_banks[i] = sse128_lo(hc->xmm[(i + 1) / 2]);
+ 				else
+ 					sparse_banks[i] = sse128_hi(hc->xmm[i / 2]);
+ 			}
+ 		}
++>>>>>>> 47d3e5cdfe60 (KVM: x86: hyper-v: HVCALL_SEND_IPI_EX is an XMM fast hypercall)
  	}
  
  check_and_send_ipi:
@@@ -2296,17 -2283,11 +2333,20 @@@ int kvm_hv_hypercall(struct kvm_vcpu *v
  			ret = HV_STATUS_INVALID_HYPERCALL_INPUT;
  			break;
  		}
 -		ret = kvm_hv_flush_tlb(vcpu, &hc);
 +		ret = kvm_hv_flush_tlb(vcpu, &hc, true);
  		break;
  	case HVCALL_SEND_IPI:
++<<<<<<< HEAD
 +		if (unlikely(hc.rep || hc.var_cnt)) {
 +			ret = HV_STATUS_INVALID_HYPERCALL_INPUT;
 +			break;
 +		}
 +		ret = kvm_hv_send_ipi(vcpu, &hc);
 +		break;
++=======
++>>>>>>> 47d3e5cdfe60 (KVM: x86: hyper-v: HVCALL_SEND_IPI_EX is an XMM fast hypercall)
  	case HVCALL_SEND_IPI_EX:
- 		if (unlikely(hc.fast || hc.rep)) {
+ 		if (unlikely(hc.rep)) {
  			ret = HV_STATUS_INVALID_HYPERCALL_INPUT;
  			break;
  		}
* Unmerged path arch/x86/kvm/hyperv.c
