dmaengine: idxd: create dmaengine driver for wq 'device'

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Dave Jiang <dave.jiang@intel.com>
commit 0cda4f6986a3824cac500f66326ff267bf37110f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/0cda4f69.failed

The original architecture of /sys/bus/dsa invented a scheme whereby a
single entry in the list of bus drivers, /sys/bus/drivers/dsa, handled
all device types and internally routed them to different drivers.
Those internal drivers were invisible to userspace. Now, as
/sys/bus/dsa wants to grow support for alternate drivers for a given
device, for example vfio-mdev instead of kernel-internal-dmaengine, a
proper bus device-driver model is needed. The first step in that process
is separating the existing omnibus/implicit "dsa" driver into proper
individual drivers registered on /sys/bus/dsa. Establish the
idxd_dmaengine_drv driver that controls the enabling and disabling of the
wq and also register and unregister the dma channel.

idxd_wq_alloc_resources() and idxd_wq_free_resources() also get moved to
the dmaengine driver. The resources (dma descriptors allocation and setup)
are only used by the dmaengine driver and should only happen when it loads.

The char dev driver (cdev) related bits are left in the __drv_enable_wq()
and __drv_disable_wq() calls to be moved when we split out the char dev
driver just like how the dmaengine driver is split out.

WQ autoload support is not expected currently. With the amount of
configuration needed for the device, the wq is always expected to
be enabled by a tool (or via sysfs) rather than auto enabled at driver
load.

	Reviewed-by: Dan Williams <dan.j.williams@intel.com>
	Signed-off-by: Dave Jiang <dave.jiang@intel.com>
Link: https://lore.kernel.org/r/162637467033.744545.12330636655625405394.stgit@djiang5-desk3.ch.intel.com
	Signed-off-by: Vinod Koul <vkoul@kernel.org>
(cherry picked from commit 0cda4f6986a3824cac500f66326ff267bf37110f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/dma/idxd/device.c
#	drivers/dma/idxd/idxd.h
#	drivers/dma/idxd/init.c
diff --cc drivers/dma/idxd/device.c
index 4a2af9799239,4dcc9431ae3d..000000000000
--- a/drivers/dma/idxd/device.c
+++ b/drivers/dma/idxd/device.c
@@@ -1129,3 -1129,206 +1129,209 @@@ int idxd_device_load_config(struct idxd
  
  	return 0;
  }
++<<<<<<< HEAD
++=======
+ 
+ int __drv_enable_wq(struct idxd_wq *wq)
+ {
+ 	struct idxd_device *idxd = wq->idxd;
+ 	struct device *dev = &idxd->pdev->dev;
+ 	unsigned long flags;
+ 	int rc = -ENXIO;
+ 
+ 	lockdep_assert_held(&wq->wq_lock);
+ 
+ 	if (idxd->state != IDXD_DEV_ENABLED)
+ 		goto err;
+ 
+ 	if (wq->state != IDXD_WQ_DISABLED) {
+ 		dev_dbg(dev, "wq %d already enabled.\n", wq->id);
+ 		rc = -EBUSY;
+ 		goto err;
+ 	}
+ 
+ 	if (!wq->group) {
+ 		dev_dbg(dev, "wq %d not attached to group.\n", wq->id);
+ 		goto err;
+ 	}
+ 
+ 	if (strlen(wq->name) == 0) {
+ 		dev_dbg(dev, "wq %d name not set.\n", wq->id);
+ 		goto err;
+ 	}
+ 
+ 	/* Shared WQ checks */
+ 	if (wq_shared(wq)) {
+ 		if (!device_swq_supported(idxd)) {
+ 			dev_dbg(dev, "PASID not enabled and shared wq.\n");
+ 			goto err;
+ 		}
+ 		/*
+ 		 * Shared wq with the threshold set to 0 means the user
+ 		 * did not set the threshold or transitioned from a
+ 		 * dedicated wq but did not set threshold. A value
+ 		 * of 0 would effectively disable the shared wq. The
+ 		 * driver does not allow a value of 0 to be set for
+ 		 * threshold via sysfs.
+ 		 */
+ 		if (wq->threshold == 0) {
+ 			dev_dbg(dev, "Shared wq and threshold 0.\n");
+ 			goto err;
+ 		}
+ 	}
+ 
+ 	rc = 0;
+ 	spin_lock_irqsave(&idxd->dev_lock, flags);
+ 	if (test_bit(IDXD_FLAG_CONFIGURABLE, &idxd->flags))
+ 		rc = idxd_device_config(idxd);
+ 	spin_unlock_irqrestore(&idxd->dev_lock, flags);
+ 	if (rc < 0) {
+ 		dev_dbg(dev, "Writing wq %d config failed: %d\n", wq->id, rc);
+ 		goto err;
+ 	}
+ 
+ 	rc = idxd_wq_enable(wq);
+ 	if (rc < 0) {
+ 		dev_dbg(dev, "wq %d enabling failed: %d\n", wq->id, rc);
+ 		goto err;
+ 	}
+ 
+ 	rc = idxd_wq_map_portal(wq);
+ 	if (rc < 0) {
+ 		dev_dbg(dev, "wq %d portal mapping failed: %d\n", wq->id, rc);
+ 		goto err_map_portal;
+ 	}
+ 
+ 	wq->client_count = 0;
+ 
+ 	if (is_idxd_wq_cdev(wq)) {
+ 		rc = idxd_wq_add_cdev(wq);
+ 		if (rc < 0) {
+ 			dev_dbg(dev, "wq %d cdev creation failed\n", wq->id);
+ 			goto err_client;
+ 		}
+ 	}
+ 
+ 	return 0;
+ 
+ err_client:
+ 	idxd_wq_unmap_portal(wq);
+ err_map_portal:
+ 	rc = idxd_wq_disable(wq, false);
+ 	if (rc < 0)
+ 		dev_dbg(dev, "wq %s disable failed\n", dev_name(wq_confdev(wq)));
+ err:
+ 	return rc;
+ }
+ 
+ int drv_enable_wq(struct idxd_wq *wq)
+ {
+ 	int rc;
+ 
+ 	mutex_lock(&wq->wq_lock);
+ 	rc = __drv_enable_wq(wq);
+ 	mutex_unlock(&wq->wq_lock);
+ 	return rc;
+ }
+ 
+ void __drv_disable_wq(struct idxd_wq *wq)
+ {
+ 	struct idxd_device *idxd = wq->idxd;
+ 	struct device *dev = &idxd->pdev->dev;
+ 
+ 	lockdep_assert_held(&wq->wq_lock);
+ 
+ 	if (is_idxd_wq_cdev(wq))
+ 		idxd_wq_del_cdev(wq);
+ 
+ 	if (idxd_wq_refcount(wq))
+ 		dev_warn(dev, "Clients has claim on wq %d: %d\n",
+ 			 wq->id, idxd_wq_refcount(wq));
+ 
+ 	idxd_wq_unmap_portal(wq);
+ 
+ 	idxd_wq_drain(wq);
+ 	idxd_wq_reset(wq);
+ 
+ 	wq->client_count = 0;
+ }
+ 
+ void drv_disable_wq(struct idxd_wq *wq)
+ {
+ 	mutex_lock(&wq->wq_lock);
+ 	__drv_disable_wq(wq);
+ 	mutex_unlock(&wq->wq_lock);
+ }
+ 
+ int idxd_device_drv_probe(struct idxd_dev *idxd_dev)
+ {
+ 	struct idxd_device *idxd = idxd_dev_to_idxd(idxd_dev);
+ 	unsigned long flags;
+ 	int rc = 0;
+ 
+ 	/*
+ 	 * Device should be in disabled state for the idxd_drv to load. If it's in
+ 	 * enabled state, then the device was altered outside of driver's control.
+ 	 * If the state is in halted state, then we don't want to proceed.
+ 	 */
+ 	if (idxd->state != IDXD_DEV_DISABLED)
+ 		return -ENXIO;
+ 
+ 	/* Device configuration */
+ 	spin_lock_irqsave(&idxd->dev_lock, flags);
+ 	if (test_bit(IDXD_FLAG_CONFIGURABLE, &idxd->flags))
+ 		rc = idxd_device_config(idxd);
+ 	spin_unlock_irqrestore(&idxd->dev_lock, flags);
+ 	if (rc < 0)
+ 		return -ENXIO;
+ 
+ 	/* Start device */
+ 	rc = idxd_device_enable(idxd);
+ 	if (rc < 0)
+ 		return rc;
+ 
+ 	/* Setup DMA device without channels */
+ 	rc = idxd_register_dma_device(idxd);
+ 	if (rc < 0) {
+ 		idxd_device_disable(idxd);
+ 		return rc;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ void idxd_device_drv_remove(struct idxd_dev *idxd_dev)
+ {
+ 	struct device *dev = &idxd_dev->conf_dev;
+ 	struct idxd_device *idxd = idxd_dev_to_idxd(idxd_dev);
+ 	int i;
+ 
+ 	for (i = 0; i < idxd->max_wqs; i++) {
+ 		struct idxd_wq *wq = idxd->wqs[i];
+ 		struct device *wq_dev = wq_confdev(wq);
+ 
+ 		if (wq->state == IDXD_WQ_DISABLED)
+ 			continue;
+ 		dev_warn(dev, "Active wq %d on disable %s.\n", i, dev_name(wq_dev));
+ 		device_release_driver(wq_dev);
+ 	}
+ 
+ 	idxd_unregister_dma_device(idxd);
+ 	idxd_device_disable(idxd);
+ 	if (test_bit(IDXD_FLAG_CONFIGURABLE, &idxd->flags))
+ 		idxd_device_reset(idxd);
+ }
+ 
+ static enum idxd_dev_type dev_types[] = {
+ 	IDXD_DEV_DSA,
+ 	IDXD_DEV_IAX,
+ 	IDXD_DEV_NONE,
+ };
+ 
+ struct idxd_device_driver idxd_drv = {
+ 	.type = dev_types,
+ 	.probe = idxd_device_drv_probe,
+ 	.remove = idxd_device_drv_remove,
+ 	.name = "idxd",
+ };
++>>>>>>> 0cda4f6986a3 (dmaengine: idxd: create dmaengine driver for wq 'device')
diff --cc drivers/dma/idxd/idxd.h
index 813e19b4ecc8,a840c328bec9..000000000000
--- a/drivers/dma/idxd/idxd.h
+++ b/drivers/dma/idxd/idxd.h
@@@ -38,6 -54,13 +38,13 @@@ struct idxd_device_driver 
  	struct device_driver drv;
  };
  
++<<<<<<< HEAD
++=======
+ extern struct idxd_device_driver dsa_drv;
+ extern struct idxd_device_driver idxd_drv;
+ extern struct idxd_device_driver idxd_dmaengine_drv;
+ 
++>>>>>>> 0cda4f6986a3 (dmaengine: idxd: create dmaengine driver for wq 'device')
  struct idxd_irq_entry {
  	struct idxd_device *idxd;
  	int id;
@@@ -422,6 -503,14 +429,17 @@@ void idxd_mask_msix_vector(struct idxd_
  void idxd_unmask_msix_vector(struct idxd_device *idxd, int vec_id);
  
  /* device control */
++<<<<<<< HEAD
++=======
+ int idxd_register_idxd_drv(void);
+ void idxd_unregister_idxd_drv(void);
+ int idxd_device_drv_probe(struct idxd_dev *idxd_dev);
+ void idxd_device_drv_remove(struct idxd_dev *idxd_dev);
+ int drv_enable_wq(struct idxd_wq *wq);
+ int __drv_enable_wq(struct idxd_wq *wq);
+ void drv_disable_wq(struct idxd_wq *wq);
+ void __drv_disable_wq(struct idxd_wq *wq);
++>>>>>>> 0cda4f6986a3 (dmaengine: idxd: create dmaengine driver for wq 'device')
  int idxd_device_init_reset(struct idxd_device *idxd);
  int idxd_device_enable(struct idxd_device *idxd);
  int idxd_device_disable(struct idxd_device *idxd);
diff --cc drivers/dma/idxd/init.c
index 20eae71edab4,6f38128ce400..000000000000
--- a/drivers/dma/idxd/init.c
+++ b/drivers/dma/idxd/init.c
@@@ -824,6 -844,14 +824,17 @@@ static int __init idxd_init_module(void
  	if (err < 0)
  		goto err_idxd_driver_register;
  
++<<<<<<< HEAD
++=======
+ 	err = idxd_driver_register(&idxd_dmaengine_drv);
+ 	if (err < 0)
+ 		goto err_idxd_dmaengine_driver_register;
+ 
+ 	err = idxd_driver_register(&dsa_drv);
+ 	if (err < 0)
+ 		goto err_dsa_driver_register;
+ 
++>>>>>>> 0cda4f6986a3 (dmaengine: idxd: create dmaengine driver for wq 'device')
  	err = idxd_cdev_register();
  	if (err)
  		goto err_cdev_register;
@@@ -837,7 -865,11 +848,15 @@@
  err_pci_register:
  	idxd_cdev_remove();
  err_cdev_register:
++<<<<<<< HEAD
 +	idxd_unregister_driver();
++=======
+ 	idxd_driver_unregister(&dsa_drv);
+ err_dsa_driver_register:
+ 	idxd_driver_unregister(&idxd_dmaengine_drv);
+ err_idxd_dmaengine_driver_register:
+ 	idxd_driver_unregister(&idxd_drv);
++>>>>>>> 0cda4f6986a3 (dmaengine: idxd: create dmaengine driver for wq 'device')
  err_idxd_driver_register:
  	idxd_unregister_bus_type();
  	return err;
@@@ -846,7 -878,9 +865,13 @@@ module_init(idxd_init_module)
  
  static void __exit idxd_exit_module(void)
  {
++<<<<<<< HEAD
 +	idxd_unregister_driver();
++=======
+ 	idxd_driver_unregister(&idxd_dmaengine_drv);
+ 	idxd_driver_unregister(&idxd_drv);
+ 	idxd_driver_unregister(&dsa_drv);
++>>>>>>> 0cda4f6986a3 (dmaengine: idxd: create dmaengine driver for wq 'device')
  	pci_unregister_driver(&idxd_pci_driver);
  	idxd_cdev_remove();
  	idxd_unregister_bus_type();
* Unmerged path drivers/dma/idxd/device.c
diff --git a/drivers/dma/idxd/dma.c b/drivers/dma/idxd/dma.c
index 77439b645044..76310bc20c51 100644
--- a/drivers/dma/idxd/dma.c
+++ b/drivers/dma/idxd/dma.c
@@ -262,3 +262,80 @@ void idxd_unregister_dma_channel(struct idxd_wq *wq)
 	wq->idxd_chan = NULL;
 	put_device(&wq->conf_dev);
 }
+
+static int idxd_dmaengine_drv_probe(struct idxd_dev *idxd_dev)
+{
+	struct device *dev = &idxd_dev->conf_dev;
+	struct idxd_wq *wq = idxd_dev_to_wq(idxd_dev);
+	struct idxd_device *idxd = wq->idxd;
+	int rc;
+
+	if (idxd->state != IDXD_DEV_ENABLED)
+		return -ENXIO;
+
+	mutex_lock(&wq->wq_lock);
+	wq->type = IDXD_WQT_KERNEL;
+	rc = __drv_enable_wq(wq);
+	if (rc < 0) {
+		dev_dbg(dev, "Enable wq %d failed: %d\n", wq->id, rc);
+		rc = -ENXIO;
+		goto err;
+	}
+
+	rc = idxd_wq_alloc_resources(wq);
+	if (rc < 0) {
+		dev_dbg(dev, "WQ resource alloc failed\n");
+		goto err_res_alloc;
+	}
+
+	rc = idxd_wq_init_percpu_ref(wq);
+	if (rc < 0) {
+		dev_dbg(dev, "percpu_ref setup failed\n");
+		goto err_ref;
+	}
+
+	rc = idxd_register_dma_channel(wq);
+	if (rc < 0) {
+		dev_dbg(dev, "Failed to register dma channel\n");
+		goto err_dma;
+	}
+
+	mutex_unlock(&wq->wq_lock);
+	return 0;
+
+err_dma:
+	idxd_wq_quiesce(wq);
+err_ref:
+	idxd_wq_free_resources(wq);
+err_res_alloc:
+	__drv_disable_wq(wq);
+err:
+	wq->type = IDXD_WQT_NONE;
+	mutex_unlock(&wq->wq_lock);
+	return rc;
+}
+
+static void idxd_dmaengine_drv_remove(struct idxd_dev *idxd_dev)
+{
+	struct idxd_wq *wq = idxd_dev_to_wq(idxd_dev);
+
+	mutex_lock(&wq->wq_lock);
+	idxd_wq_quiesce(wq);
+	idxd_unregister_dma_channel(wq);
+	__drv_disable_wq(wq);
+	idxd_wq_free_resources(wq);
+	wq->type = IDXD_WQT_NONE;
+	mutex_unlock(&wq->wq_lock);
+}
+
+static enum idxd_dev_type dev_types[] = {
+	IDXD_DEV_WQ,
+	IDXD_DEV_NONE,
+};
+
+struct idxd_device_driver idxd_dmaengine_drv = {
+	.probe = idxd_dmaengine_drv_probe,
+	.remove = idxd_dmaengine_drv_remove,
+	.name = "dmaengine",
+	.type = dev_types,
+};
* Unmerged path drivers/dma/idxd/idxd.h
* Unmerged path drivers/dma/idxd/init.c
