scsi: core: sd: Add silence_suspend flag to suppress some PM messages

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Adrian Hunter <adrian.hunter@intel.com>
commit af4edb1d50c6d1044cb34bc43621411b7ba2cffe
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/af4edb1d.failed

Kernel messages produced during runtime PM can cause a never-ending cycle
because user space utilities (e.g. journald or rsyslog) write the messages
back to storage, causing runtime resume, more messages, and so on.

Messages that tell of things that are expected to happen are arguably
unnecessary, so add a flag to suppress them. This flag is used by the UFS
driver.

Link: https://lore.kernel.org/r/20220228113652.970857-2-adrian.hunter@intel.com
	Cc: stable@vger.kernel.org
	Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit af4edb1d50c6d1044cb34bc43621411b7ba2cffe)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/scsi/scsi_device.h
diff --cc include/scsi/scsi_device.h
index 72e28ed30288,57e3e239a1fc..000000000000
--- a/include/scsi/scsi_device.h
+++ b/include/scsi/scsi_device.h
@@@ -202,9 -203,13 +202,16 @@@ struct scsi_device 
  	unsigned broken_fua:1;		/* Don't set FUA bit */
  	unsigned lun_in_cdb:1;		/* Store LUN bits in CDB[1] */
  	unsigned unmap_limit_for_ws:1;	/* Use the UNMAP limit for WRITE SAME */
++<<<<<<< HEAD
++=======
+ 	unsigned rpm_autosuspend:1;	/* Enable runtime autosuspend at device
+ 					 * creation time */
+ 	unsigned ignore_media_change:1; /* Ignore MEDIA CHANGE on resume */
+ 	unsigned silence_suspend:1;	/* Do not print runtime PM related messages */
++>>>>>>> af4edb1d50c6 (scsi: core: sd: Add silence_suspend flag to suppress some PM messages)
  
 -	unsigned int queue_stopped;	/* request queue is quiesced */
 -	bool offline_already;		/* Device offline message logged */
 +	RH_KABI_FILL_HOLE(unsigned set_dbd_for_ms:1) /* Set "DBD" field in mode sense */
 +	RH_KABI_FILL_HOLE(unsigned offline_already:1) /* Device offline message logged */
  
  	atomic_t disk_events_disable_depth; /* disable depth for disk events */
  
diff --git a/drivers/scsi/scsi_error.c b/drivers/scsi/scsi_error.c
index 04670c98a190..3023ef5e2f55 100644
--- a/drivers/scsi/scsi_error.c
+++ b/drivers/scsi/scsi_error.c
@@ -485,8 +485,13 @@ static void scsi_report_sense(struct scsi_device *sdev,
 
 		if (sshdr->asc == 0x29) {
 			evt_type = SDEV_EVT_POWER_ON_RESET_OCCURRED;
-			sdev_printk(KERN_WARNING, sdev,
-				    "Power-on or device reset occurred\n");
+			/*
+			 * Do not print message if it is an expected side-effect
+			 * of runtime PM.
+			 */
+			if (!sdev->silence_suspend)
+				sdev_printk(KERN_WARNING, sdev,
+					    "Power-on or device reset occurred\n");
 		}
 
 		if (sshdr->asc == 0x2a && sshdr->ascq == 0x01) {
diff --git a/drivers/scsi/sd.c b/drivers/scsi/sd.c
index cdca33d6b92d..bceeeb58a1a1 100644
--- a/drivers/scsi/sd.c
+++ b/drivers/scsi/sd.c
@@ -3643,7 +3643,8 @@ static int sd_suspend_common(struct device *dev, bool ignore_stop_errors)
 		return 0;
 
 	if (sdkp->WCE && sdkp->media_present) {
-		sd_printk(KERN_NOTICE, sdkp, "Synchronizing SCSI cache\n");
+		if (!sdkp->device->silence_suspend)
+			sd_printk(KERN_NOTICE, sdkp, "Synchronizing SCSI cache\n");
 		ret = sd_sync_cache(sdkp, &sshdr);
 
 		if (ret) {
@@ -3665,7 +3666,8 @@ static int sd_suspend_common(struct device *dev, bool ignore_stop_errors)
 	}
 
 	if (sdkp->device->manage_start_stop) {
-		sd_printk(KERN_NOTICE, sdkp, "Stopping disk\n");
+		if (!sdkp->device->silence_suspend)
+			sd_printk(KERN_NOTICE, sdkp, "Stopping disk\n");
 		/* an error is not worth aborting a system sleep */
 		ret = sd_start_stop_device(sdkp, 0);
 		if (ignore_stop_errors)
* Unmerged path include/scsi/scsi_device.h
