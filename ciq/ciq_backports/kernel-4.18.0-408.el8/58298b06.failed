KVM: x86/mmu: Check for a REMOVED leaf SPTE before making the SPTE

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Sean Christopherson <seanjc@google.com>
commit 58298b068137f419de8bc839d54ceacaec788870
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/58298b06.failed

Explicitly check for a REMOVED leaf SPTE prior to attempting to map
the final SPTE when handling a TDP MMU fault.  Functionally, this is a
nop as tdp_mmu_set_spte_atomic() will eventually detect the frozen SPTE.
Pre-checking for a REMOVED SPTE is a minor optmization, but the real goal
is to allow tdp_mmu_set_spte_atomic() to have an invariant that the "old"
SPTE is never a REMOVED SPTE.

	Signed-off-by: Sean Christopherson <seanjc@google.com>
	Reviewed-by: Ben Gardon <bgardon@google.com>
Message-Id: <20220226001546.360188-24-seanjc@google.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 58298b068137f419de8bc839d54ceacaec788870)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/mmu/tdp_mmu.c
diff --cc arch/x86/kvm/mmu/tdp_mmu.c
index 97bb57fe39ca,cd6ceca5f2ba..000000000000
--- a/arch/x86/kvm/mmu/tdp_mmu.c
+++ b/arch/x86/kvm/mmu/tdp_mmu.c
@@@ -1020,7 -1193,11 +1020,15 @@@ int kvm_tdp_mmu_map(struct kvm_vcpu *vc
  		}
  	}
  
++<<<<<<< HEAD
 +	if (iter.level != level) {
++=======
+ 	/*
+ 	 * Force the guest to retry the access if the upper level SPTEs aren't
+ 	 * in place, or if the target leaf SPTE is frozen by another CPU.
+ 	 */
+ 	if (iter.level != fault->goal_level || is_removed_spte(iter.old_spte)) {
++>>>>>>> 58298b068137 (KVM: x86/mmu: Check for a REMOVED leaf SPTE before making the SPTE)
  		rcu_read_unlock();
  		return RET_PF_RETRY;
  	}
* Unmerged path arch/x86/kvm/mmu/tdp_mmu.c
