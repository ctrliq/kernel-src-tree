KVM: MMU: change FNAME(fetch)() arguments to kvm_page_fault

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Paolo Bonzini <pbonzini@redhat.com>
commit 9c03b1821a89c1f18983a385c6542c267dbd8459
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/9c03b182.failed

Pass struct kvm_page_fault to FNAME(fetch)() instead of
extracting the arguments from the struct.

	Suggested-by: Isaku Yamahata <isaku.yamahata@intel.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 9c03b1821a89c1f18983a385c6542c267dbd8459)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/mmu/paging_tmpl.h
diff --cc arch/x86/kvm/mmu/paging_tmpl.h
index de3ee26beb48,afd2ad8c5173..000000000000
--- a/arch/x86/kvm/mmu/paging_tmpl.h
+++ b/arch/x86/kvm/mmu/paging_tmpl.h
@@@ -835,16 -833,12 +833,14 @@@ FNAME(is_self_change_mapping)(struct kv
   */
  static int FNAME(page_fault)(struct kvm_vcpu *vcpu, struct kvm_page_fault *fault)
  {
- 	gpa_t addr = fault->addr;
- 	u32 error_code = fault->error_code;
  	struct guest_walker walker;
  	int r;
 +	kvm_pfn_t pfn;
 +	hva_t hva;
  	unsigned long mmu_seq;
 -	bool is_self_change_mapping;
 +	bool map_writable, is_self_change_mapping;
  
- 	pgprintk("%s: addr %lx err %x\n", __func__, addr, error_code);
+ 	pgprintk("%s: addr %lx err %x\n", __func__, fault->addr, fault->error_code);
  	WARN_ON_ONCE(fault->is_tdp);
  
  	/*
@@@ -927,8 -917,7 +920,12 @@@
  	r = make_mmu_pages_available(vcpu);
  	if (r)
  		goto out_unlock;
++<<<<<<< HEAD
 +	r = FNAME(fetch)(vcpu, addr, &walker, error_code, fault->max_level, pfn,
 +			 map_writable, fault->prefault);
++=======
+ 	r = FNAME(fetch)(vcpu, fault, &walker);
++>>>>>>> 9c03b1821a89 (KVM: MMU: change FNAME(fetch)() arguments to kvm_page_fault)
  	kvm_mmu_audit(vcpu, AUDIT_POST_PAGE_FAULT);
  
  out_unlock:
* Unmerged path arch/x86/kvm/mmu/paging_tmpl.h
