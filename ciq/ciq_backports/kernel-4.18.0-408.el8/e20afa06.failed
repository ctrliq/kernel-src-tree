PCI: Add array to track reset method ordering

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Amey Narkhede <ameynarkhede03@gmail.com>
commit e20afa06244eb5d7fa850f9fe2a78ae17ba96f81
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/e20afa06.failed

Add reset_methods[] in struct pci_dev to keep track of reset mechanisms
supported by the device and their ordering.

Refactor probing and reset functions to take advantage of calling
convention of reset functions.

Co-developed-by: Alex Williamson <alex.williamson@redhat.com>
Link: https://lore.kernel.org/r/20210817180500.1253-4-ameynarkhede03@gmail.com
	Signed-off-by: Alex Williamson <alex.williamson@redhat.com>
	Signed-off-by: Amey Narkhede <ameynarkhede03@gmail.com>
	Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
	Reviewed-by: Raphael Norwitz <raphael.norwitz@nutanix.com>
(cherry picked from commit e20afa06244eb5d7fa850f9fe2a78ae17ba96f81)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/pci/pci.c
#	include/linux/pci.h
diff --cc drivers/pci/pci.c
index c3df2812af1a,43a823f8dd69..000000000000
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@@ -5115,28 -5159,26 +5130,44 @@@ int __pci_reset_function_locked(struct 
  	might_sleep();
  
  	/*
- 	 * A reset method returns -ENOTTY if it doesn't support this device
- 	 * and we should try the next method.
+ 	 * A reset method returns -ENOTTY if it doesn't support this device and
+ 	 * we should try the next method.
  	 *
- 	 * If it returns 0 (success), we're finished.  If it returns any
- 	 * other error, we're also finished: this indicates that further
- 	 * reset mechanisms might be broken on the device.
+ 	 * If it returns 0 (success), we're finished.  If it returns any other
+ 	 * error, we're also finished: this indicates that further reset
+ 	 * mechanisms might be broken on the device.
  	 */
++<<<<<<< HEAD
 +	rc = pci_dev_specific_reset(dev, 0);
 +	if (rc != -ENOTTY)
 +		return rc;
 +	if (pcie_has_flr(dev)) {
 +		rc = pcie_flr(dev);
 +		if (rc != -ENOTTY)
 +			return rc;
 +	}
 +	rc = pci_af_flr(dev, 0);
 +	if (rc != -ENOTTY)
 +		return rc;
 +	rc = pci_pm_reset(dev, 0);
 +	if (rc != -ENOTTY)
 +		return rc;
 +	return pci_reset_bus_function(dev, 0);
++=======
+ 	for (i = 0; i < PCI_NUM_RESET_METHODS; i++) {
+ 		m = dev->reset_methods[i];
+ 		if (!m)
+ 			return -ENOTTY;
+ 
+ 		rc = pci_reset_fn_methods[m].reset_fn(dev, 0);
+ 		if (!rc)
+ 			return 0;
+ 		if (rc != -ENOTTY)
+ 			return rc;
+ 	}
+ 
+ 	return -ENOTTY;
++>>>>>>> e20afa06244e (PCI: Add array to track reset method ordering)
  }
  EXPORT_SYMBOL_GPL(__pci_reset_function_locked);
  
@@@ -5157,19 -5202,16 +5191,30 @@@ void pci_init_reset_methods(struct pci_
  
  	might_sleep();
  
++<<<<<<< HEAD
 +	rc = pci_dev_specific_reset(dev, 1);
 +	if (rc != -ENOTTY)
 +		return rc;
 +	if (pcie_has_flr(dev))
 +		return 0;
 +	rc = pci_af_flr(dev, 1);
 +	if (rc != -ENOTTY)
 +		return rc;
 +	rc = pci_pm_reset(dev, 1);
 +	if (rc != -ENOTTY)
 +		return rc;
++=======
+ 	i = 0;
+ 	for (m = 1; m < PCI_NUM_RESET_METHODS; m++) {
+ 		rc = pci_reset_fn_methods[m].reset_fn(dev, 1);
+ 		if (!rc)
+ 			dev->reset_methods[i++] = m;
+ 		else if (rc != -ENOTTY)
+ 			break;
+ 	}
++>>>>>>> e20afa06244e (PCI: Add array to track reset method ordering)
  
- 	return pci_reset_bus_function(dev, 1);
+ 	dev->reset_methods[i] = 0;
  }
  
  /**
diff --cc include/linux/pci.h
index 0b97f3c12e39,2faf517d20c1..000000000000
--- a/include/linux/pci.h
+++ b/include/linux/pci.h
@@@ -517,28 -510,8 +520,33 @@@ struct pci_dev 
  
  	unsigned long	priv_flags;	/* Private flags for the PCI driver */
  
++<<<<<<< HEAD
 +#ifdef CONFIG_PCI_PRI
 +	RH_KABI_USE(1, u16  pri_cap)	/* PRI Capability offset */
 +#endif
 +#ifdef CONFIG_PCI_PASID
 +	RH_KABI_USE(2, u16  pasid_cap)	/* PASID Capability offset */
 +#endif
 +#ifdef CONFIG_PCIE_DPC
 +	RH_KABI_USE(3, u16  dpc_cap)
 +	RH_KABI_USE(4, u8   dpc_rp_log_size)
 +#endif
 +	RH_KABI_USE(5, u16  acs_cap)
 +#ifdef CONFIG_PCIEASPM
 +	RH_KABI_USE(6, u16  l1ss)	/* L1SS Capability pointer */
 +#endif
 +#ifdef CONFIG_PCIEPORTBUS
 +	RH_KABI_USE(7, struct rcec_ea  *rcec_ea) /* RCEC cached endpoint association */
 +	RH_KABI_USE(8, struct pci_dev  *rcec)	 /* Associated RCEC device */
 +#endif
 +	RH_KABI_USE(9, 10, 11, 12, 13, struct pci_vpd  vpd)
 +	RH_KABI_RESERVE(14)
 +	RH_KABI_RESERVE(15)
 +	RH_KABI_AUX_EMBED(pci_dev_extended)
++=======
+ 	/* These methods index pci_reset_fn_methods[] */
+ 	u8 reset_methods[PCI_NUM_RESET_METHODS]; /* In priority order */
++>>>>>>> e20afa06244e (PCI: Add array to track reset method ordering)
  };
  
  static inline struct pci_dev *pci_physfn(struct pci_dev *dev)
* Unmerged path drivers/pci/pci.c
diff --git a/drivers/pci/pci.h b/drivers/pci/pci.h
index 0232c6490373..3010f3868998 100644
--- a/drivers/pci/pci.h
+++ b/drivers/pci/pci.h
@@ -33,7 +33,8 @@ enum pci_mmap_api {
 int pci_mmap_fits(struct pci_dev *pdev, int resno, struct vm_area_struct *vmai,
 		  enum pci_mmap_api mmap_api);
 
-int pci_probe_reset_function(struct pci_dev *dev);
+bool pci_reset_supported(struct pci_dev *dev);
+void pci_init_reset_methods(struct pci_dev *dev);
 int pci_bridge_secondary_bus_reset(struct pci_dev *dev);
 int pci_bus_error_reset(struct pci_dev *dev);
 
@@ -616,6 +617,11 @@ struct pci_dev_reset_methods {
 	int (*reset)(struct pci_dev *dev, int probe);
 };
 
+struct pci_reset_fn_method {
+	int (*reset_fn)(struct pci_dev *pdev, int probe);
+	char *name;
+};
+
 #ifdef CONFIG_PCI_QUIRKS
 int pci_dev_specific_reset(struct pci_dev *dev, int probe);
 #else
diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 959ced4f0209..6a2025cc853f 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -2403,9 +2403,8 @@ static void pci_init_capabilities(struct pci_dev *dev)
 	pci_rcec_init(dev);		/* Root Complex Event Collector */
 
 	pcie_report_downtraining(dev);
-
-	if (pci_probe_reset_function(dev) == 0)
-		dev->reset_fn = 1;
+	pci_init_reset_methods(dev);
+	dev->reset_fn = pci_reset_supported(dev);
 }
 
 /*
* Unmerged path include/linux/pci.h
