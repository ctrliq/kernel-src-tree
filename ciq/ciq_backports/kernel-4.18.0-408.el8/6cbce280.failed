dm: add local variables to clone_endio and __map_bio

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Mike Snitzer <snitzer@kernel.org>
commit 6cbce280fc741c2057d574366318eafbeabbcfda
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/6cbce280.failed

Avoid redundant dereferences in both functions.

	Signed-off-by: Mike Snitzer <snitzer@kernel.org>
(cherry picked from commit 6cbce280fc741c2057d574366318eafbeabbcfda)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/md/dm.c
diff --cc drivers/md/dm.c
index e7cb1b8972bd,152545ef00fa..000000000000
--- a/drivers/md/dm.c
+++ b/drivers/md/dm.c
@@@ -967,11 -976,12 +967,20 @@@ static bool swap_bios_limit(struct dm_t
  static void clone_endio(struct bio *bio)
  {
  	blk_status_t error = bio->bi_status;
++<<<<<<< HEAD
 +	struct dm_target_io *tio = container_of(bio, struct dm_target_io, clone);
 +	struct dm_io *io = tio->io;
 +	struct mapped_device *md = tio->io->md;
 +	dm_endio_fn endio = tio->ti->type->end_io;
 +	struct bio *orig_bio = io->orig_bio;
++=======
+ 	struct request_queue *q = bio->bi_bdev->bd_disk->queue;
+ 	struct dm_target_io *tio = clone_to_tio(bio);
+ 	struct dm_target *ti = tio->ti;
+ 	dm_endio_fn endio = ti->type->end_io;
+ 	struct dm_io *io = tio->io;
+ 	struct mapped_device *md = io->md;
++>>>>>>> 6cbce280fc74 (dm: add local variables to clone_endio and __map_bio)
  
  	if (unlikely(error == BLK_STS_TARGET)) {
  		if (bio_op(bio) == REQ_OP_DISCARD &&
@@@ -985,24 -992,23 +994,24 @@@
  			disable_write_zeroes(md);
  	}
  
 -	if (unlikely(blk_queue_is_zoned(q)))
 -		dm_zone_endio(io, bio);
 +	/*
 +	 * For zone-append bios get offset in zone of the written
 +	 * sector and add that to the original bio sector pos.
 +	 */
 +	if (bio_op(orig_bio) == REQ_OP_ZONE_APPEND) {
 +		sector_t written_sector = bio->bi_iter.bi_sector;
 +		struct request_queue *q = orig_bio->bi_disk->queue;
 +		u64 mask = (u64)blk_queue_zone_sectors(q) - 1;
 +
 +		orig_bio->bi_iter.bi_sector += written_sector & mask;
 +	}
  
  	if (endio) {
- 		int r = endio(tio->ti, bio, &error);
+ 		int r = endio(ti, bio, &error);
  		switch (r) {
  		case DM_ENDIO_REQUEUE:
 -			/*
 -			 * Requeuing writes to a sequential zone of a zoned
 -			 * target will break the sequential write pattern:
 -			 * fail such IO.
 -			 */
 -			if (WARN_ON_ONCE(dm_is_zone_write(md, bio)))
 -				error = BLK_STS_IOERR;
 -			else
 -				error = BLK_STS_DM_REQUEUE;
 -			fallthrough;
 +			error = BLK_STS_DM_REQUEUE;
 +			/*FALLTHRU*/
  		case DM_ENDIO_DONE:
  			break;
  		case DM_ENDIO_INCOMPLETE:
@@@ -1014,12 -1020,10 +1023,10 @@@
  		}
  	}
  
- 	if (unlikely(swap_bios_limit(tio->ti, bio))) {
- 		struct mapped_device *md = io->md;
+ 	if (unlikely(swap_bios_limit(ti, bio)))
  		up(&md->swap_bios_semaphore);
- 	}
  
 -	free_tio(bio);
 +	free_tio(tio);
  	dm_io_dec_pending(io, error);
  }
  
@@@ -1268,58 -1259,63 +1275,98 @@@ static noinline void __set_swap_bios_li
  	mutex_unlock(&md->swap_bios_lock);
  }
  
 -static void __map_bio(struct bio *clone)
 +static blk_qc_t __map_bio(struct dm_target_io *tio)
  {
++<<<<<<< HEAD
 +	int r;
 +	sector_t sector;
 +	struct bio *clone = &tio->clone;
 +	struct dm_io *io = tio->io;
 +	struct dm_target *ti = tio->ti;
 +	blk_qc_t ret = BLK_QC_T_NONE;
++=======
+ 	struct dm_target_io *tio = clone_to_tio(clone);
+ 	struct dm_target *ti = tio->ti;
+ 	struct dm_io *io = tio->io;
+ 	struct mapped_device *md = io->md;
+ 	int r;
++>>>>>>> 6cbce280fc74 (dm: add local variables to clone_endio and __map_bio)
  
  	clone->bi_end_io = clone_endio;
  
  	/*
 -	 * Map the clone.
 +	 * Map the clone.  If r == 0 we don't need to do
 +	 * anything, the target has assumed ownership of
 +	 * this io.
  	 */
  	dm_io_inc_pending(io);
 -	tio->old_sector = clone->bi_iter.bi_sector;
 +	sector = clone->bi_iter.bi_sector;
  
  	if (unlikely(swap_bios_limit(ti, clone))) {
- 		struct mapped_device *md = io->md;
  		int latch = get_swap_bios();
  		if (unlikely(latch != md->swap_bios))
  			__set_swap_bios_limit(md, latch);
  		down(&md->swap_bios_semaphore);
  	}
  
++<<<<<<< HEAD
 +	r = ti->type->map(ti, clone);
++=======
+ 	/*
+ 	 * Check if the IO needs a special mapping due to zone append emulation
+ 	 * on zoned target. In this case, dm_zone_map_bio() calls the target
+ 	 * map operation.
+ 	 */
+ 	if (unlikely(dm_emulate_zone_append(md)))
+ 		r = dm_zone_map_bio(tio);
+ 	else
+ 		r = ti->type->map(ti, clone);
+ 
++>>>>>>> 6cbce280fc74 (dm: add local variables to clone_endio and __map_bio)
  	switch (r) {
  	case DM_MAPIO_SUBMITTED:
 -		/* target has assumed ownership of this io */
 -		if (!ti->accounts_remapped_io)
 -			dm_io_set_flag(io, DM_IO_START_ACCT);
  		break;
  	case DM_MAPIO_REMAPPED:
++<<<<<<< HEAD
 +		/* the bio has been remapped so dispatch it */
 +		trace_block_bio_remap(clone->bi_disk->queue, clone,
 +				      bio_dev(io->orig_bio), sector);
 +		ret = generic_make_request(clone);
++=======
+ 		/*
+ 		 * the bio has been remapped so dispatch it, but defer
+ 		 * dm_start_io_acct() until after possible bio_split().
+ 		 */
+ 		__dm_submit_bio_remap(clone, disk_devt(md->disk),
+ 				      tio->old_sector);
+ 		dm_io_set_flag(io, DM_IO_START_ACCT);
++>>>>>>> 6cbce280fc74 (dm: add local variables to clone_endio and __map_bio)
  		break;
  	case DM_MAPIO_KILL:
 +		if (unlikely(swap_bios_limit(ti, clone))) {
 +			struct mapped_device *md = io->md;
 +			up(&md->swap_bios_semaphore);
 +		}
 +		free_tio(tio);
 +		dm_io_dec_pending(io, BLK_STS_IOERR);
 +		break;
  	case DM_MAPIO_REQUEUE:
++<<<<<<< HEAD
 +		if (unlikely(swap_bios_limit(ti, clone))) {
 +			struct mapped_device *md = io->md;
 +			up(&md->swap_bios_semaphore);
 +		}
 +		free_tio(tio);
 +		dm_io_dec_pending(io, BLK_STS_DM_REQUEUE);
++=======
+ 		if (unlikely(swap_bios_limit(ti, clone)))
+ 			up(&md->swap_bios_semaphore);
+ 		free_tio(clone);
+ 		if (r == DM_MAPIO_KILL)
+ 			dm_io_dec_pending(io, BLK_STS_IOERR);
+ 		else
+ 			dm_io_dec_pending(io, BLK_STS_DM_REQUEUE);
++>>>>>>> 6cbce280fc74 (dm: add local variables to clone_endio and __map_bio)
  		break;
  	default:
  		DMWARN("unimplemented target map return value: %d", r);
* Unmerged path drivers/md/dm.c
