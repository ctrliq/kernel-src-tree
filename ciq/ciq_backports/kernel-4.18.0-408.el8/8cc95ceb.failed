bnxt_en: improve fw diagnose devlink health messages

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Edwin Peer <edwin.peer@broadcom.com>
commit 8cc95ceb7087d6910050286301d05f4824a0bf59
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/8cc95ceb.failed

Add firmware event counters as well as health state severity. In
the unhealthy state, recommend a remedy and inform the user as to
its impact.

Readability of the devlink tool's output is negatively impacted by
adding these fields to the diagnosis. The single line of text, as
rendered by devlink health diagnose, benefits from more terse
descriptions, which can be substituted without loss of clarity, even
in pretty printed JSON mode.

	Signed-off-by: Edwin Peer <edwin.peer@broadcom.com>
	Signed-off-by: Michael Chan <michael.chan@broadcom.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 8cc95ceb7087d6910050286301d05f4824a0bf59)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/broadcom/bnxt/bnxt.c
#	drivers/net/ethernet/broadcom/bnxt/bnxt.h
#	drivers/net/ethernet/broadcom/bnxt/bnxt_devlink.c
diff --cc drivers/net/ethernet/broadcom/bnxt/bnxt.c
index 56316640722e,b4d9374548f8..000000000000
--- a/drivers/net/ethernet/broadcom/bnxt/bnxt.c
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt.c
@@@ -2135,13 -2134,21 +2135,27 @@@ static int bnxt_async_event_process(str
  		bp->fw_reset_max_dsecs = le16_to_cpu(cmpl->timestamp_hi);
  		if (!bp->fw_reset_max_dsecs)
  			bp->fw_reset_max_dsecs = BNXT_DFLT_FW_RST_MAX_DSECS;
++<<<<<<< HEAD
 +		if (EVENT_DATA1_RESET_NOTIFY_FATAL(data1)) {
 +			fatal_str = "fatal";
 +			set_bit(BNXT_STATE_FW_FATAL_COND, &bp->state);
++=======
+ 		if (EVENT_DATA1_RESET_NOTIFY_FW_ACTIVATION(data1)) {
+ 			set_bit(BNXT_STATE_FW_ACTIVATE_RESET, &bp->state);
+ 		} else if (EVENT_DATA1_RESET_NOTIFY_FATAL(data1)) {
+ 			type_str = "Fatal";
+ 			bp->fw_health->fatalities++;
+ 			set_bit(BNXT_STATE_FW_FATAL_COND, &bp->state);
+ 		} else if (data2 && BNXT_FW_STATUS_HEALTHY !=
+ 			   EVENT_DATA2_RESET_NOTIFY_FW_STATUS_CODE(data2)) {
+ 			type_str = "Non-fatal";
+ 			bp->fw_health->survivals++;
+ 			set_bit(BNXT_STATE_FW_NON_FATAL_COND, &bp->state);
++>>>>>>> 8cc95ceb7087 (bnxt_en: improve fw diagnose devlink health messages)
  		}
  		netif_warn(bp, hw, bp->dev,
 -			   "%s firmware reset event, data1: 0x%x, data2: 0x%x, min wait %u ms, max wait %u ms\n",
 -			   type_str, data1, data2,
 +			   "Firmware %s reset event, data1: 0x%x, data2: 0x%x, min wait %u ms, max wait %u ms\n",
 +			   fatal_str, data1, data2,
  			   bp->fw_reset_min_dsecs * 100,
  			   bp->fw_reset_max_dsecs * 100);
  		set_bit(BNXT_FW_RESET_NOTIFY_SP_EVENT, &bp->sp_event);
diff --cc drivers/net/ethernet/broadcom/bnxt/bnxt.h
index a76732cbea2c,bbbc63e882d1..000000000000
--- a/drivers/net/ethernet/broadcom/bnxt/bnxt.h
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt.h
@@@ -1529,8 -1556,8 +1544,9 @@@ struct bnxt_fw_health 
  	u32 last_fw_reset_cnt;
  	u8 enabled:1;
  	u8 primary:1;
 +	u8 fatal:1;
  	u8 status_reliable:1;
+ 	u8 resets_reliable:1;
  	u8 tmr_multiplier;
  	u8 tmr_counter;
  	u8 fw_reset_seq_cnt;
@@@ -1540,12 -1567,15 +1556,24 @@@
  	u32 echo_req_data1;
  	u32 echo_req_data2;
  	struct devlink_health_reporter	*fw_reporter;
++<<<<<<< HEAD
 +	struct devlink_health_reporter *fw_reset_reporter;
 +	struct devlink_health_reporter *fw_fatal_reporter;
 +};
 +
 +struct bnxt_fw_reporter_ctx {
 +	unsigned long sp_event;
++=======
+ 	/* Protects severity and remedy */
+ 	struct mutex lock;
+ 	enum bnxt_health_severity severity;
+ 	enum bnxt_health_remedy remedy;
+ 	u32 arrests;
+ 	u32 discoveries;
+ 	u32 survivals;
+ 	u32 fatalities;
+ 	u32 diagnoses;
++>>>>>>> 8cc95ceb7087 (bnxt_en: improve fw diagnose devlink health messages)
  };
  
  #define BNXT_FW_HEALTH_REG_TYPE_MASK	3
diff --cc drivers/net/ethernet/broadcom/bnxt/bnxt_devlink.c
index d875469f72ce,930cbf1ca4e0..000000000000
--- a/drivers/net/ethernet/broadcom/bnxt/bnxt_devlink.c
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt_devlink.c
@@@ -42,86 -51,143 +42,187 @@@ bnxt_dl_flash_update(struct devlink *dl
  	return rc;
  }
  
++<<<<<<< HEAD
 +static int bnxt_fw_reporter_diagnose(struct devlink_health_reporter *reporter,
 +				     struct devlink_fmsg *fmsg,
 +				     struct netlink_ext_ack *extack)
++=======
+ static int bnxt_hwrm_remote_dev_reset_set(struct bnxt *bp, bool remote_reset)
+ {
+ 	struct hwrm_func_cfg_input *req;
+ 	int rc;
+ 
+ 	if (~bp->fw_cap & BNXT_FW_CAP_HOT_RESET_IF)
+ 		return -EOPNOTSUPP;
+ 
+ 	rc = hwrm_req_init(bp, req, HWRM_FUNC_CFG);
+ 	if (rc)
+ 		return rc;
+ 
+ 	req->fid = cpu_to_le16(0xffff);
+ 	req->enables = cpu_to_le32(FUNC_CFG_REQ_ENABLES_HOT_RESET_IF_SUPPORT);
+ 	if (remote_reset)
+ 		req->flags = cpu_to_le32(FUNC_CFG_REQ_FLAGS_HOT_RESET_IF_EN_DIS);
+ 
+ 	return hwrm_req_send(bp, req);
+ }
+ 
+ static char *bnxt_health_severity_str(enum bnxt_health_severity severity)
+ {
+ 	switch (severity) {
+ 	case SEVERITY_NORMAL: return "normal";
+ 	case SEVERITY_WARNING: return "warning";
+ 	case SEVERITY_RECOVERABLE: return "recoverable";
+ 	case SEVERITY_FATAL: return "fatal";
+ 	default: return "unknown";
+ 	}
+ }
+ 
+ static char *bnxt_health_remedy_str(enum bnxt_health_remedy remedy)
+ {
+ 	switch (remedy) {
+ 	case REMEDY_DEVLINK_RECOVER: return "devlink recover";
+ 	case REMEDY_POWER_CYCLE_DEVICE: return "device power cycle";
+ 	case REMEDY_POWER_CYCLE_HOST: return "host power cycle";
+ 	case REMEDY_FW_UPDATE: return "update firmware";
+ 	case REMEDY_HW_REPLACE: return "replace hardware";
+ 	default: return "unknown";
+ 	}
+ }
+ 
+ static int bnxt_fw_diagnose(struct devlink_health_reporter *reporter,
+ 			    struct devlink_fmsg *fmsg,
+ 			    struct netlink_ext_ack *extack)
++>>>>>>> 8cc95ceb7087 (bnxt_en: improve fw diagnose devlink health messages)
  {
  	struct bnxt *bp = devlink_health_reporter_priv(reporter);
- 	u32 val;
+ 	struct bnxt_fw_health *h = bp->fw_health;
+ 	u32 fw_status, fw_resets;
  	int rc;
  
  	if (test_bit(BNXT_STATE_IN_FW_RESET, &bp->state))
- 		return 0;
+ 		return devlink_fmsg_string_pair_put(fmsg, "Status", "recovering");
  
- 	val = bnxt_fw_health_readl(bp, BNXT_FW_HEALTH_REG);
+ 	if (!h->status_reliable)
+ 		return devlink_fmsg_string_pair_put(fmsg, "Status", "unknown");
  
- 	if (BNXT_FW_IS_BOOTING(val)) {
- 		rc = devlink_fmsg_string_pair_put(fmsg, "Description",
- 						  "Not yet completed initialization");
+ 	mutex_lock(&h->lock);
+ 	fw_status = bnxt_fw_health_readl(bp, BNXT_FW_HEALTH_REG);
+ 	if (BNXT_FW_IS_BOOTING(fw_status)) {
+ 		rc = devlink_fmsg_string_pair_put(fmsg, "Status", "initializing");
+ 		if (rc)
+ 			goto unlock;
+ 	} else if (h->severity || fw_status != BNXT_FW_STATUS_HEALTHY) {
+ 		if (!h->severity) {
+ 			h->severity = SEVERITY_FATAL;
+ 			h->remedy = REMEDY_POWER_CYCLE_DEVICE;
+ 			h->diagnoses++;
+ 			devlink_health_report(h->fw_reporter,
+ 					      "FW error diagnosed", h);
+ 		}
+ 		rc = devlink_fmsg_string_pair_put(fmsg, "Status", "error");
  		if (rc)
- 			return rc;
- 	} else if (BNXT_FW_IS_ERR(val)) {
- 		rc = devlink_fmsg_string_pair_put(fmsg, "Description",
- 						  "Encountered fatal error and cannot recover");
+ 			goto unlock;
+ 		rc = devlink_fmsg_u32_pair_put(fmsg, "Syndrome", fw_status);
  		if (rc)
- 			return rc;
+ 			goto unlock;
+ 	} else {
+ 		rc = devlink_fmsg_string_pair_put(fmsg, "Status", "healthy");
+ 		if (rc)
+ 			goto unlock;
  	}
  
- 	if (val >> 16) {
- 		rc = devlink_fmsg_u32_pair_put(fmsg, "Error code", val >> 16);
+ 	rc = devlink_fmsg_string_pair_put(fmsg, "Severity",
+ 					  bnxt_health_severity_str(h->severity));
+ 	if (rc)
+ 		goto unlock;
+ 
+ 	if (h->severity) {
+ 		rc = devlink_fmsg_string_pair_put(fmsg, "Remedy",
+ 						  bnxt_health_remedy_str(h->remedy));
  		if (rc)
- 			return rc;
+ 			goto unlock;
+ 		if (h->remedy == REMEDY_DEVLINK_RECOVER) {
+ 			rc = devlink_fmsg_string_pair_put(fmsg, "Impact",
+ 							  "traffic+ntuple_cfg");
+ 			if (rc)
+ 				goto unlock;
+ 		}
  	}
  
- 	val = bnxt_fw_health_readl(bp, BNXT_FW_RESET_CNT_REG);
- 	rc = devlink_fmsg_u32_pair_put(fmsg, "Reset count", val);
- 	if (rc)
+ unlock:
+ 	mutex_unlock(&h->lock);
+ 	if (rc || !h->resets_reliable)
  		return rc;
  
- 	return 0;
+ 	fw_resets = bnxt_fw_health_readl(bp, BNXT_FW_RESET_CNT_REG);
+ 	rc = devlink_fmsg_u32_pair_put(fmsg, "Resets", fw_resets);
+ 	if (rc)
+ 		return rc;
+ 	rc = devlink_fmsg_u32_pair_put(fmsg, "Arrests", h->arrests);
+ 	if (rc)
+ 		return rc;
+ 	rc = devlink_fmsg_u32_pair_put(fmsg, "Survivals", h->survivals);
+ 	if (rc)
+ 		return rc;
+ 	rc = devlink_fmsg_u32_pair_put(fmsg, "Discoveries", h->discoveries);
+ 	if (rc)
+ 		return rc;
+ 	rc = devlink_fmsg_u32_pair_put(fmsg, "Fatalities", h->fatalities);
+ 	if (rc)
+ 		return rc;
+ 	return devlink_fmsg_u32_pair_put(fmsg, "Diagnoses", h->diagnoses);
  }
  
 -static int bnxt_fw_recover(struct devlink_health_reporter *reporter,
 -			   void *priv_ctx,
 -			   struct netlink_ext_ack *extack)
 +static const struct devlink_health_reporter_ops bnxt_dl_fw_reporter_ops = {
 +	.name = "fw",
 +	.diagnose = bnxt_fw_reporter_diagnose,
 +};
 +
 +static int bnxt_fw_reset_recover(struct devlink_health_reporter *reporter,
 +				 void *priv_ctx,
 +				 struct netlink_ext_ack *extack)
 +{
 +	struct bnxt *bp = devlink_health_reporter_priv(reporter);
 +
++<<<<<<< HEAD
 +	if (!priv_ctx)
 +		return -EOPNOTSUPP;
 +
 +	bnxt_fw_reset(bp);
 +	return -EINPROGRESS;
 +}
 +
 +static const
 +struct devlink_health_reporter_ops bnxt_dl_fw_reset_reporter_ops = {
 +	.name = "fw_reset",
 +	.recover = bnxt_fw_reset_recover,
 +};
 +
 +static int bnxt_fw_fatal_recover(struct devlink_health_reporter *reporter,
 +				 void *priv_ctx,
 +				 struct netlink_ext_ack *extack)
  {
  	struct bnxt *bp = devlink_health_reporter_priv(reporter);
 +	struct bnxt_fw_reporter_ctx *fw_reporter_ctx = priv_ctx;
 +	unsigned long event;
 +
 +	if (!priv_ctx)
 +		return -EOPNOTSUPP;
  
 +	bp->fw_health->fatal = true;
 +	event = fw_reporter_ctx->sp_event;
 +	if (event == BNXT_FW_RESET_NOTIFY_SP_EVENT)
 +		bnxt_fw_reset(bp);
 +	else if (event == BNXT_FW_EXCEPTION_SP_EVENT)
 +		bnxt_fw_exception(bp);
++=======
+ 	if (bp->fw_health->severity == SEVERITY_FATAL)
+ 		return -ENODEV;
+ 
+ 	set_bit(BNXT_STATE_RECOVER, &bp->state);
+ 	__bnxt_fw_recover(bp);
++>>>>>>> 8cc95ceb7087 (bnxt_en: improve fw diagnose devlink health messages)
  
  	return -EINPROGRESS;
  }
@@@ -206,77 -230,55 +307,103 @@@ void bnxt_dl_fw_reporters_destroy(struc
  		devlink_health_reporter_destroy(health->fw_reporter);
  		health->fw_reporter = NULL;
  	}
 +
 +	if (health->fw_fatal_reporter) {
 +		devlink_health_reporter_destroy(health->fw_fatal_reporter);
 +		health->fw_fatal_reporter = NULL;
 +	}
  }
  
 -void bnxt_devlink_health_fw_report(struct bnxt *bp)
 +void bnxt_devlink_health_report(struct bnxt *bp, unsigned long event)
  {
  	struct bnxt_fw_health *fw_health = bp->fw_health;
++<<<<<<< HEAD
 +	struct bnxt_fw_reporter_ctx fw_reporter_ctx;
++=======
+ 	int rc;
++>>>>>>> 8cc95ceb7087 (bnxt_en: improve fw diagnose devlink health messages)
 +
 +	fw_reporter_ctx.sp_event = event;
 +	switch (event) {
 +	case BNXT_FW_RESET_NOTIFY_SP_EVENT:
 +		if (test_bit(BNXT_STATE_FW_FATAL_COND, &bp->state)) {
 +			if (!fw_health->fw_fatal_reporter)
 +				return;
 +
 +			devlink_health_report(fw_health->fw_fatal_reporter,
 +					      "FW fatal async event received",
 +					      &fw_reporter_ctx);
 +			return;
 +		}
 +		if (!fw_health->fw_reset_reporter)
 +			return;
  
 -	if (!fw_health)
 +		devlink_health_report(fw_health->fw_reset_reporter,
 +				      "FW non-fatal reset event received",
 +				      &fw_reporter_ctx);
  		return;
  
 -	if (!fw_health->fw_reporter) {
 -		__bnxt_fw_recover(bp);
 +	case BNXT_FW_EXCEPTION_SP_EVENT:
 +		if (!fw_health->fw_fatal_reporter)
 +			return;
 +
 +		devlink_health_report(fw_health->fw_fatal_reporter,
 +				      "FW fatal error reported",
 +				      &fw_reporter_ctx);
  		return;
  	}
++<<<<<<< HEAD
++=======
+ 
+ 	mutex_lock(&fw_health->lock);
+ 	fw_health->severity = SEVERITY_RECOVERABLE;
+ 	fw_health->remedy = REMEDY_DEVLINK_RECOVER;
+ 	mutex_unlock(&fw_health->lock);
+ 	rc = devlink_health_report(fw_health->fw_reporter, "FW error reported",
+ 				   fw_health);
+ 	if (rc == -ECANCELED)
+ 		__bnxt_fw_recover(bp);
++>>>>>>> 8cc95ceb7087 (bnxt_en: improve fw diagnose devlink health messages)
  }
  
 -void bnxt_dl_health_fw_status_update(struct bnxt *bp, bool healthy)
 +void bnxt_dl_health_status_update(struct bnxt *bp, bool healthy)
  {
- 	struct bnxt_fw_health *health = bp->fw_health;
+ 	struct bnxt_fw_health *fw_health = bp->fw_health;
  	u8 state;
  
- 	if (healthy)
+ 	mutex_lock(&fw_health->lock);
+ 	if (healthy) {
+ 		fw_health->severity = SEVERITY_NORMAL;
  		state = DEVLINK_HEALTH_REPORTER_STATE_HEALTHY;
- 	else
+ 	} else {
+ 		fw_health->severity = SEVERITY_FATAL;
+ 		fw_health->remedy = REMEDY_POWER_CYCLE_DEVICE;
  		state = DEVLINK_HEALTH_REPORTER_STATE_ERROR;
++<<<<<<< HEAD
 +
 +	if (health->fatal)
 +		devlink_health_reporter_state_update(health->fw_fatal_reporter,
 +						     state);
 +	else
 +		devlink_health_reporter_state_update(health->fw_reset_reporter,
 +						     state);
 +
 +	health->fatal = false;
++=======
+ 	}
+ 	mutex_unlock(&fw_health->lock);
+ 	devlink_health_reporter_state_update(fw_health->fw_reporter, state);
++>>>>>>> 8cc95ceb7087 (bnxt_en: improve fw diagnose devlink health messages)
  }
  
 -void bnxt_dl_health_fw_recovery_done(struct bnxt *bp)
 +void bnxt_dl_health_recovery_done(struct bnxt *bp)
  {
 -	struct bnxt_dl *dl = devlink_priv(bp->dl);
 +	struct bnxt_fw_health *hlth = bp->fw_health;
  
 -	devlink_health_reporter_recovery_done(bp->fw_health->fw_reporter);
 -	bnxt_hwrm_remote_dev_reset_set(bp, dl->remote_reset);
 +	if (hlth->fatal)
 +		devlink_health_reporter_recovery_done(hlth->fw_fatal_reporter);
 +	else
 +		devlink_health_reporter_recovery_done(hlth->fw_reset_reporter);
  }
  
  static int bnxt_dl_info_get(struct devlink *dl, struct devlink_info_req *req,
* Unmerged path drivers/net/ethernet/broadcom/bnxt/bnxt.c
* Unmerged path drivers/net/ethernet/broadcom/bnxt/bnxt.h
* Unmerged path drivers/net/ethernet/broadcom/bnxt/bnxt_devlink.c
