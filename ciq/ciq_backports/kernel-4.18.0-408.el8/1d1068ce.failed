dm: retun the clone bio from alloc_tio

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Christoph Hellwig <hch@lst.de>
commit 1d1068cecff70cb8e48c7cb0ba27cc3fd906eb31
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/1d1068ce.failed

Return the clone bio embedded into the tio as that is what the callers
actually want.  Similar for the free side.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Mike Snitzer <snitzer@redhat.com>
Link: https://lore.kernel.org/r/20220202160109.108149-8-hch@lst.de
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit 1d1068cecff70cb8e48c7cb0ba27cc3fd906eb31)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/md/dm.c
diff --cc drivers/md/dm.c
index d626b645f571,c05b6ff1bb95..000000000000
--- a/drivers/md/dm.c
+++ b/drivers/md/dm.c
@@@ -630,8 -544,8 +630,13 @@@ static void free_io(struct mapped_devic
  	bio_put(&io->tio.clone);
  }
  
++<<<<<<< HEAD
 +static struct dm_target_io *alloc_tio(struct clone_info *ci, struct dm_target *ti,
 +				      unsigned target_bio_nr, gfp_t gfp_mask)
++=======
+ static struct bio *alloc_tio(struct clone_info *ci, struct dm_target *ti,
+ 		unsigned target_bio_nr, unsigned *len, gfp_t gfp_mask)
++>>>>>>> 1d1068cecff7 (dm: retun the clone bio from alloc_tio)
  {
  	struct dm_target_io *tio;
  
@@@ -651,15 -567,16 +656,15 @@@
  	tio->io = ci->io;
  	tio->ti = ti;
  	tio->target_bio_nr = target_bio_nr;
 -	tio->len_ptr = len;
  
- 	return tio;
+ 	return &tio->clone;
  }
  
- static void free_tio(struct dm_target_io *tio)
+ static void free_tio(struct bio *clone)
  {
- 	if (tio->inside_dm_io)
+ 	if (clone_to_tio(clone)->inside_dm_io)
  		return;
- 	bio_put(&tio->clone);
+ 	bio_put(clone);
  }
  
  /*
@@@ -1338,15 -1192,20 +1343,29 @@@ static void bio_setup_sector(struct bi
  /*
   * Creates a bio that consists of range of complete bvecs.
   */
 -static int __clone_and_map_data_bio(struct clone_info *ci, struct dm_target *ti,
 -				    sector_t sector, unsigned *len)
 +static int clone_bio(struct dm_target_io *tio, struct bio *bio,
 +		     sector_t sector, unsigned len)
  {
++<<<<<<< HEAD
 +	struct bio *clone = &tio->clone;
 +
 +	__bio_clone_fast(clone, bio);
 +
 +	if (bio_integrity(bio)) {
 +		int r;
++=======
+ 	struct bio *bio = ci->bio, *clone;
+ 	int r;
+ 
+ 	clone = alloc_tio(ci, ti, 0, len, GFP_NOIO);
+ 
+ 	r = bio_crypt_clone(clone, bio, GFP_NOIO);
+ 	if (r < 0)
+ 		goto free_tio;
+ 
+ 	if (bio_integrity(bio)) {
+ 		struct dm_target_io *tio = clone_to_tio(clone);
++>>>>>>> 1d1068cecff7 (dm: retun the clone bio from alloc_tio)
  
  		if (unlikely(!dm_target_has_integrity(tio->ti->type) &&
  			     !dm_target_passes_integrity(tio->ti->type))) {
@@@ -1367,21 -1227,26 +1386,32 @@@
  	if (bio_integrity(bio))
  		bio_integrity_trim(clone);
  
 -	__map_bio(clone);
  	return 0;
++<<<<<<< HEAD
++=======
+ free_tio:
+ 	free_tio(clone);
+ 	return r;
++>>>>>>> 1d1068cecff7 (dm: retun the clone bio from alloc_tio)
  }
  
  static void alloc_multiple_bios(struct bio_list *blist, struct clone_info *ci,
 -				struct dm_target *ti, unsigned num_bios,
 -				unsigned *len)
 +				struct dm_target *ti, unsigned num_bios)
  {
- 	struct dm_target_io *tio;
+ 	struct bio *bio;
  	int try;
  
  	if (!num_bios)
  		return;
  
  	if (num_bios == 1) {
++<<<<<<< HEAD
 +		tio = alloc_tio(ci, ti, 0, GFP_NOIO);
 +		bio_list_add(blist, &tio->clone);
++=======
+ 		bio = alloc_tio(ci, ti, 0, len, GFP_NOIO);
+ 		bio_list_add(blist, bio);
++>>>>>>> 1d1068cecff7 (dm: retun the clone bio from alloc_tio)
  		return;
  	}
  
@@@ -1392,21 -1256,20 +1421,32 @@@
  		if (try)
  			mutex_lock(&ci->io->md->table_devices_lock);
  		for (bio_nr = 0; bio_nr < num_bios; bio_nr++) {
++<<<<<<< HEAD
 +			tio = alloc_tio(ci, ti, bio_nr, try ? GFP_NOIO : GFP_NOWAIT);
 +			if (!tio)
++=======
+ 			bio = alloc_tio(ci, ti, bio_nr, len,
+ 					try ? GFP_NOIO : GFP_NOWAIT);
+ 			if (!bio)
++>>>>>>> 1d1068cecff7 (dm: retun the clone bio from alloc_tio)
  				break;
  
- 			bio_list_add(blist, &tio->clone);
+ 			bio_list_add(blist, bio);
  		}
  		if (try)
  			mutex_unlock(&ci->io->md->table_devices_lock);
  		if (bio_nr == num_bios)
  			return;
  
++<<<<<<< HEAD
 +		while ((bio = bio_list_pop(blist))) {
 +			tio = container_of(bio, struct dm_target_io, clone);
 +			free_tio(tio);
 +		}
++=======
+ 		while ((bio = bio_list_pop(blist)))
+ 			free_tio(bio);
++>>>>>>> 1d1068cecff7 (dm: retun the clone bio from alloc_tio)
  	}
  }
  
* Unmerged path drivers/md/dm.c
