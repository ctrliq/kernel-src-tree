net/smc: unlock on error paths in __smc_setsockopt()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Dan Carpenter <dan.carpenter@oracle.com>
commit 7a11455f376de8a4357af4a20ae68fefe29b8ceb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/7a11455f.failed

These two error paths need to release_sock(sk) before returning.

Fixes: a6a6fe27bab4 ("net/smc: Dynamic control handshake limitation by socket options")
	Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
	Reviewed-by: D. Wythe <alibuda@linux.alibaba.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 7a11455f376de8a4357af4a20ae68fefe29b8ceb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/smc/af_smc.c
diff --cc net/smc/af_smc.c
index 35d7b6b336de,30acc31b2c45..000000000000
--- a/net/smc/af_smc.c
+++ b/net/smc/af_smc.c
@@@ -2422,8 -2671,73 +2422,76 @@@ out
  	return rc ? rc : rc1;
  }
  
++<<<<<<< HEAD
++=======
+ static int __smc_getsockopt(struct socket *sock, int level, int optname,
+ 			    char __user *optval, int __user *optlen)
+ {
+ 	struct smc_sock *smc;
+ 	int val, len;
+ 
+ 	smc = smc_sk(sock->sk);
+ 
+ 	if (get_user(len, optlen))
+ 		return -EFAULT;
+ 
+ 	len = min_t(int, len, sizeof(int));
+ 
+ 	if (len < 0)
+ 		return -EINVAL;
+ 
+ 	switch (optname) {
+ 	case SMC_LIMIT_HS:
+ 		val = smc->limit_smc_hs;
+ 		break;
+ 	default:
+ 		return -EOPNOTSUPP;
+ 	}
+ 
+ 	if (put_user(len, optlen))
+ 		return -EFAULT;
+ 	if (copy_to_user(optval, &val, len))
+ 		return -EFAULT;
+ 
+ 	return 0;
+ }
+ 
+ static int __smc_setsockopt(struct socket *sock, int level, int optname,
+ 			    sockptr_t optval, unsigned int optlen)
+ {
+ 	struct sock *sk = sock->sk;
+ 	struct smc_sock *smc;
+ 	int val, rc;
+ 
+ 	smc = smc_sk(sk);
+ 
+ 	lock_sock(sk);
+ 	switch (optname) {
+ 	case SMC_LIMIT_HS:
+ 		if (optlen < sizeof(int)) {
+ 			rc = -EINVAL;
+ 			break;
+ 		}
+ 		if (copy_from_sockptr(&val, optval, sizeof(int))) {
+ 			rc = -EFAULT;
+ 			break;
+ 		}
+ 
+ 		smc->limit_smc_hs = !!val;
+ 		rc = 0;
+ 		break;
+ 	default:
+ 		rc = -EOPNOTSUPP;
+ 		break;
+ 	}
+ 	release_sock(sk);
+ 
+ 	return rc;
+ }
+ 
++>>>>>>> 7a11455f376d (net/smc: unlock on error paths in __smc_setsockopt())
  static int smc_setsockopt(struct socket *sock, int level, int optname,
 -			  sockptr_t optval, unsigned int optlen)
 +			  char __user *optval, unsigned int optlen)
  {
  	struct sock *sk = sock->sk;
  	struct smc_sock *smc;
* Unmerged path net/smc/af_smc.c
