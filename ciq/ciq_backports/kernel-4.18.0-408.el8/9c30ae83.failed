tcp: fix TCP socket rehash stats mis-accounting

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Yuchung Cheng <ycheng@google.com>
commit 9c30ae8398b0813e237bde387d67a7f74ab2db2d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/9c30ae83.failed

The previous commit 32efcc06d2a1 ("tcp: export count for rehash attempts")
would mis-account rehashing SNMP and socket stats:

  a. During handshake of an active open, only counts the first
     SYN timeout

  b. After handshake of passive and active open, stop updating
     after (roughly) TCP_RETRIES1 recurring RTOs

  c. After the socket aborts, over count timeout_rehash by 1

This patch fixes this by checking the rehash result from sk_rethink_txhash.

Fixes: 32efcc06d2a1 ("tcp: export count for rehash attempts")
	Signed-off-by: Yuchung Cheng <ycheng@google.com>
	Signed-off-by: Eric Dumazet <edumazet@google.com>
	Signed-off-by: Neal Cardwell <ncardwell@google.com>
Link: https://lore.kernel.org/r/20210119192619.1848270-1-ycheng@google.com
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit 9c30ae8398b0813e237bde387d67a7f74ab2db2d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/tcp_input.c
#	net/ipv4/tcp_timer.c
diff --cc net/ipv4/tcp_input.c
index 040dc4f9858b,a7dfca0a38cd..000000000000
--- a/net/ipv4/tcp_input.c
+++ b/net/ipv4/tcp_input.c
@@@ -4347,6 -4390,18 +4347,21 @@@ static void tcp_dsack_extend(struct soc
  		tcp_sack_extend(tp->duplicate_sack, seq, end_seq);
  }
  
++<<<<<<< HEAD
++=======
+ static void tcp_rcv_spurious_retrans(struct sock *sk, const struct sk_buff *skb)
+ {
+ 	/* When the ACK path fails or drops most ACKs, the sender would
+ 	 * timeout and spuriously retransmit the same segment repeatedly.
+ 	 * The receiver remembers and reflects via DSACKs. Leverage the
+ 	 * DSACK state and change the txhash to re-route speculatively.
+ 	 */
+ 	if (TCP_SKB_CB(skb)->seq == tcp_sk(sk)->duplicate_sack[0].start_seq &&
+ 	    sk_rethink_txhash(sk))
+ 		NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPDUPLICATEDATAREHASH);
+ }
+ 
++>>>>>>> 9c30ae8398b0 (tcp: fix TCP socket rehash stats mis-accounting)
  static void tcp_send_dupack(struct sock *sk, const struct sk_buff *skb)
  {
  	struct tcp_sock *tp = tcp_sk(sk);
diff --cc net/ipv4/tcp_timer.c
index df6b3cec1d87,faa92948441b..000000000000
--- a/net/ipv4/tcp_timer.c
+++ b/net/ipv4/tcp_timer.c
@@@ -228,11 -219,8 +228,16 @@@ static int tcp_write_timeout(struct soc
  	int retry_until;
  
  	if ((1 << sk->sk_state) & (TCPF_SYN_SENT | TCPF_SYN_RECV)) {
++<<<<<<< HEAD
 +		if (icsk->icsk_retransmits) {
 +			dst_negative_advice(sk);
 +		} else {
 +			sk_rethink_txhash(sk);
 +		}
++=======
+ 		if (icsk->icsk_retransmits)
+ 			__dst_negative_advice(sk);
++>>>>>>> 9c30ae8398b0 (tcp: fix TCP socket rehash stats mis-accounting)
  		retry_until = icsk->icsk_syn_retries ? : net->ipv4.sysctl_tcp_syn_retries;
  		expired = icsk->icsk_retransmits >= retry_until;
  	} else {
@@@ -240,9 -228,7 +245,13 @@@
  			/* Black hole detection */
  			tcp_mtu_probing(icsk, sk);
  
++<<<<<<< HEAD
 +			dst_negative_advice(sk);
 +		} else {
 +			sk_rethink_txhash(sk);
++=======
+ 			__dst_negative_advice(sk);
++>>>>>>> 9c30ae8398b0 (tcp: fix TCP socket rehash stats mis-accounting)
  		}
  
  		retry_until = net->ipv4.sysctl_tcp_retries2;
diff --git a/include/net/sock.h b/include/net/sock.h
index 4396c7f4d44f..a631e6bdaf5a 100644
--- a/include/net/sock.h
+++ b/include/net/sock.h
@@ -1982,10 +1982,13 @@ static inline void sk_set_txhash(struct sock *sk)
 	sk->sk_txhash = net_tx_rndhash();
 }
 
-static inline void sk_rethink_txhash(struct sock *sk)
+static inline bool sk_rethink_txhash(struct sock *sk)
 {
-	if (sk->sk_txhash)
+	if (sk->sk_txhash) {
 		sk_set_txhash(sk);
+		return true;
+	}
+	return false;
 }
 
 static inline struct dst_entry *
@@ -2008,12 +2011,10 @@ sk_dst_get(struct sock *sk)
 	return dst;
 }
 
-static inline void dst_negative_advice(struct sock *sk)
+static inline void __dst_negative_advice(struct sock *sk)
 {
 	struct dst_entry *ndst, *dst = __sk_dst_get(sk);
 
-	sk_rethink_txhash(sk);
-
 	if (dst && dst->ops->negative_advice) {
 		ndst = dst->ops->negative_advice(dst);
 
@@ -2025,6 +2026,12 @@ static inline void dst_negative_advice(struct sock *sk)
 	}
 }
 
+static inline void dst_negative_advice(struct sock *sk)
+{
+	sk_rethink_txhash(sk);
+	__dst_negative_advice(sk);
+}
+
 static inline void
 __sk_dst_set(struct sock *sk, struct dst_entry *dst)
 {
* Unmerged path net/ipv4/tcp_input.c
* Unmerged path net/ipv4/tcp_timer.c
