module: check for exit sections in layout_sections() instead of module_init_section()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Jessica Yu <jeyu@kernel.org>
commit 055f23b74b20f2824ce33047b4cf2e2aa856bf3b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/055f23b7.failed

Previously, when CONFIG_MODULE_UNLOAD=n, the module loader just does not
attempt to load exit sections since it never expects that any code in those
sections will ever execute. However, dynamic code patching (alternatives,
jump_label and static_call) can have sites in __exit code, even if __exit is
never executed. Therefore __exit must be present at runtime, at least for as
long as __init code is.

Commit 33121347fb1c ("module: treat exit sections the same as init
sections when !CONFIG_MODULE_UNLOAD") solves the requirements of
jump_labels and static_calls by putting the exit sections in the init
region of the module so that they are at least present at init, and
discarded afterwards. It does this by including a check for exit
sections in module_init_section(), so that it also returns true for exit
sections, and the module loader will automatically sort them in the init
region of the module.

However, the solution there was not completely arch-independent. ARM is
a special case where it supplies its own module_{init, exit}_section()
functions. Instead of pushing the exit section checks into
module_init_section(), just implement the exit section check in
layout_sections(), so that we don't have to touch arch-dependent code.

Fixes: 33121347fb1c ("module: treat exit sections the same as init sections when !CONFIG_MODULE_UNLOAD")
	Reviewed-by: Russell King (Oracle) <rmk+kernel@armlinux.org.uk>
	Signed-off-by: Jessica Yu <jeyu@kernel.org>
(cherry picked from commit 055f23b74b20f2824ce33047b4cf2e2aa856bf3b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/module.c
diff --cc kernel/module.c
index e07ea2b09d06,7e78dfabca97..000000000000
--- a/kernel/module.c
+++ b/kernel/module.c
@@@ -2378,10 -2401,21 +2378,28 @@@ static long get_offset(struct module *m
  	return ret;
  }
  
++<<<<<<< HEAD
 +/* Lay out the SHF_ALLOC sections in a way not dissimilar to how ld
 +   might -- code, read-only data, read-write data, small data.  Tally
 +   sizes, and place the offsets into sh_entsize fields: high bit means it
 +   belongs in init. */
++=======
+ static bool module_init_layout_section(const char *sname)
+ {
+ #ifndef CONFIG_MODULE_UNLOAD
+ 	if (module_exit_section(sname))
+ 		return true;
+ #endif
+ 	return module_init_section(sname);
+ }
+ 
+ /*
+  * Lay out the SHF_ALLOC sections in a way not dissimilar to how ld
+  * might -- code, read-only data, read-write data, small data.  Tally
+  * sizes, and place the offsets into sh_entsize fields: high bit means it
+  * belongs in init.
+  */
++>>>>>>> 055f23b74b20 (module: check for exit sections in layout_sections() instead of module_init_section())
  static void layout_sections(struct module *mod, struct load_info *info)
  {
  	static unsigned long const masks[][2] = {
@@@ -2408,7 -2444,7 +2426,11 @@@
  			if ((s->sh_flags & masks[m][0]) != masks[m][0]
  			    || (s->sh_flags & masks[m][1])
  			    || s->sh_entsize != ~0UL
++<<<<<<< HEAD
 +			    || strstarts(sname, ".init"))
++=======
+ 			    || module_init_layout_section(sname))
++>>>>>>> 055f23b74b20 (module: check for exit sections in layout_sections() instead of module_init_section())
  				continue;
  			s->sh_entsize = get_offset(mod, &mod->core_layout.size, s, i);
  			pr_debug("\t%s\n", sname);
@@@ -2441,7 -2477,7 +2463,11 @@@
  			if ((s->sh_flags & masks[m][0]) != masks[m][0]
  			    || (s->sh_flags & masks[m][1])
  			    || s->sh_entsize != ~0UL
++<<<<<<< HEAD
 +			    || !strstarts(sname, ".init"))
++=======
+ 			    || !module_init_layout_section(sname))
++>>>>>>> 055f23b74b20 (module: check for exit sections in layout_sections() instead of module_init_section())
  				continue;
  			s->sh_entsize = (get_offset(mod, &mod->init_layout.size, s, i)
  					 | INIT_OFFSET_MASK);
@@@ -2750,7 -2809,14 +2776,18 @@@ static void dynamic_debug_remove(struc
  
  void * __weak module_alloc(unsigned long size)
  {
++<<<<<<< HEAD
 +	return vmalloc_exec(size);
++=======
+ 	return __vmalloc_node_range(size, 1, VMALLOC_START, VMALLOC_END,
+ 			GFP_KERNEL, PAGE_KERNEL_EXEC, VM_FLUSH_RESET_PERMS,
+ 			NUMA_NO_NODE, __builtin_return_address(0));
+ }
+ 
+ bool __weak module_init_section(const char *name)
+ {
+ 	return strstarts(name, ".init");
++>>>>>>> 055f23b74b20 (module: check for exit sections in layout_sections() instead of module_init_section())
  }
  
  bool __weak module_exit_section(const char *name)
* Unmerged path kernel/module.c
