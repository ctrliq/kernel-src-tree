KVM: x86/mmu: Properly dereference rcu-protected TDP MMU sptep iterator

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Sean Christopherson <seanjc@google.com>
commit c435d4b7badfa791fea2a1a97a07e02e7134a150
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/c435d4b7.failed

Wrap the read of iter->sptep in tdp_mmu_map_handle_target_level() with
rcu_dereference().  Shadow pages in the TDP MMU, and thus their SPTEs,
are protected by rcu.

This fixes a Sparse warning at tdp_mmu.c:900:51:
  warning: incorrect type in argument 1 (different address spaces)
  expected unsigned long long [usertype] *sptep
  got unsigned long long [noderef] [usertype] __rcu *[usertype] sptep

Fixes: 7158bee4b475 ("KVM: MMU: pass kvm_mmu_page struct to make_spte")
	Cc: Ben Gardon <bgardon@google.com>
	Signed-off-by: Sean Christopherson <seanjc@google.com>
Message-Id: <20211103161833.3769487-1-seanjc@google.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit c435d4b7badfa791fea2a1a97a07e02e7134a150)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/mmu/tdp_mmu.c
diff --cc arch/x86/kvm/mmu/tdp_mmu.c
index 8e1489964d2a,a54c3491af42..000000000000
--- a/arch/x86/kvm/mmu/tdp_mmu.c
+++ b/arch/x86/kvm/mmu/tdp_mmu.c
@@@ -863,22 -893,22 +863,26 @@@ void kvm_tdp_mmu_invalidate_all_roots(s
   * Installs a last-level SPTE to handle a TDP page fault.
   * (NPT/EPT violation/misconfiguration)
   */
 -static int tdp_mmu_map_handle_target_level(struct kvm_vcpu *vcpu,
 -					  struct kvm_page_fault *fault,
 -					  struct tdp_iter *iter)
 +static int tdp_mmu_map_handle_target_level(struct kvm_vcpu *vcpu, int write,
 +					  int map_writable,
 +					  struct tdp_iter *iter,
 +					  kvm_pfn_t pfn, bool prefault)
  {
++<<<<<<< HEAD
++=======
+ 	struct kvm_mmu_page *sp = sptep_to_sp(rcu_dereference(iter->sptep));
++>>>>>>> c435d4b7badf (KVM: x86/mmu: Properly dereference rcu-protected TDP MMU sptep iterator)
  	u64 new_spte;
  	int ret = RET_PF_FIXED;
 -	bool wrprot = false;
 +	int make_spte_ret = 0;
  
 -	WARN_ON(sp->role.level != fault->goal_level);
 -	if (unlikely(!fault->slot))
 +	if (unlikely(is_noslot_pfn(pfn)))
  		new_spte = make_mmio_spte(vcpu, iter->gfn, ACC_ALL);
  	else
 -		wrprot = make_spte(vcpu, sp, fault->slot, ACC_ALL, iter->gfn,
 -					 fault->pfn, iter->old_spte, fault->prefetch, true,
 -					 fault->map_writable, &new_spte);
 +		make_spte_ret = make_spte(vcpu, ACC_ALL, iter->level, iter->gfn,
 +					 pfn, iter->old_spte, prefault, true,
 +					 map_writable, !shadow_accessed_mask,
 +					 &new_spte);
  
  	if (new_spte == iter->old_spte)
  		ret = RET_PF_SPURIOUS;
* Unmerged path arch/x86/kvm/mmu/tdp_mmu.c
