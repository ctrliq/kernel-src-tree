rtnetlink: enable alt_ifname for setlink/newlink

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Florent Fourcot <florent.fourcot@wifirst.fr>
commit 5ea08b5286f66ee5ac0150668c92d1718e83e1ad
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/5ea08b52.failed

buffer called "ifname" given in function rtnl_dev_get
is always valid when called by setlink/newlink,
but contains only empty string when IFLA_IFNAME is not given. So
IFLA_ALT_IFNAME is always ignored

This patch fixes rtnl_dev_get function with a remove of ifname argument,
and move ifname copy in do_setlink when required.

It extends feature of commit 76c9ac0ee878,
"net: rtnetlink: add possibility to use alternative names as message
handle""

CC: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: Florent Fourcot <florent.fourcot@wifirst.fr>
	Signed-off-by: Brian Baboch <brian.baboch@wifirst.fr>
	Reviewed-by: Jakub Kicinski <kuba@kernel.org>
	Signed-off-by: Paolo Abeni <pabeni@redhat.com>
(cherry picked from commit 5ea08b5286f66ee5ac0150668c92d1718e83e1ad)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/core/rtnetlink.c
diff --cc net/core/rtnetlink.c
index 44c8ff2718d2,5899b1d2de14..000000000000
--- a/net/core/rtnetlink.c
+++ b/net/core/rtnetlink.c
@@@ -2457,12 -2644,13 +2457,13 @@@ static int do_set_master(struct net_dev
  static int do_setlink(const struct sk_buff *skb,
  		      struct net_device *dev, struct ifinfomsg *ifm,
  		      struct netlink_ext_ack *extack,
- 		      struct nlattr **tb, char *ifname, int status)
+ 		      struct nlattr **tb, int status)
  {
  	const struct net_device_ops *ops = dev->netdev_ops;
+ 	char ifname[IFNAMSIZ];
  	int err;
  
 -	err = validate_linkmsg(dev, tb, extack);
 +	err = validate_linkmsg(dev, tb);
  	if (err < 0)
  		return err;
  
@@@ -2818,6 -3015,21 +2824,24 @@@ errout
  	return err;
  }
  
++<<<<<<< HEAD
++=======
+ static struct net_device *rtnl_dev_get(struct net *net,
+ 				       struct nlattr *tb[])
+ {
+ 	char ifname[ALTIFNAMSIZ];
+ 
+ 	if (tb[IFLA_IFNAME])
+ 		nla_strscpy(ifname, tb[IFLA_IFNAME], IFNAMSIZ);
+ 	else if (tb[IFLA_ALT_IFNAME])
+ 		nla_strscpy(ifname, tb[IFLA_ALT_IFNAME], ALTIFNAMSIZ);
+ 	else
+ 		return NULL;
+ 
+ 	return __dev_get_by_name(net, ifname);
+ }
+ 
++>>>>>>> 5ea08b5286f6 (rtnetlink: enable alt_ifname for setlink/newlink)
  static int rtnl_setlink(struct sk_buff *skb, struct nlmsghdr *nlh,
  			struct netlink_ext_ack *extack)
  {
@@@ -2846,8 -3052,8 +2864,13 @@@
  	ifm = nlmsg_data(nlh);
  	if (ifm->ifi_index > 0)
  		dev = __dev_get_by_index(net, ifm->ifi_index);
++<<<<<<< HEAD
 +	else if (tb[IFLA_IFNAME])
 +		dev = __dev_get_by_name(net, ifname);
++=======
+ 	else if (tb[IFLA_IFNAME] || tb[IFLA_ALT_IFNAME])
+ 		dev = rtnl_dev_get(net, tb);
++>>>>>>> 5ea08b5286f6 (rtnetlink: enable alt_ifname for setlink/newlink)
  	else
  		goto errout;
  
@@@ -2948,8 -3150,8 +2971,13 @@@ static int rtnl_dellink(struct sk_buff 
  	ifm = nlmsg_data(nlh);
  	if (ifm->ifi_index > 0)
  		dev = __dev_get_by_index(tgt_net, ifm->ifi_index);
++<<<<<<< HEAD
 +	else if (tb[IFLA_IFNAME])
 +		dev = __dev_get_by_name(tgt_net, ifname);
++=======
+ 	else if (tb[IFLA_IFNAME] || tb[IFLA_ALT_IFNAME])
+ 		dev = rtnl_dev_get(net, tb);
++>>>>>>> 5ea08b5286f6 (rtnetlink: enable alt_ifname for setlink/newlink)
  	else if (tb[IFLA_GROUP])
  		err = rtnl_group_dellink(tgt_net, nla_get_u32(tb[IFLA_GROUP]));
  	else
@@@ -3121,18 -3335,17 +3149,21 @@@ replay
  	if (err < 0)
  		return err;
  
- 	if (tb[IFLA_IFNAME])
- 		nla_strscpy(ifname, tb[IFLA_IFNAME], IFNAMSIZ);
- 	else
- 		ifname[0] = '\0';
- 
  	ifm = nlmsg_data(nlh);
 -	if (ifm->ifi_index > 0) {
 -		link_specified = true;
 +	if (ifm->ifi_index > 0)
  		dev = __dev_get_by_index(net, ifm->ifi_index);
++<<<<<<< HEAD
 +	else if (tb[IFLA_IFNAME])
 +		dev = __dev_get_by_name(net, ifname);
 +	else
++=======
+ 	} else if (tb[IFLA_IFNAME] || tb[IFLA_ALT_IFNAME]) {
+ 		link_specified = true;
+ 		dev = rtnl_dev_get(net, tb);
+ 	} else {
+ 		link_specified = false;
++>>>>>>> 5ea08b5286f6 (rtnetlink: enable alt_ifname for setlink/newlink)
  		dev = NULL;
 -	}
  
  	master_dev = NULL;
  	m_ops = NULL;
@@@ -3260,10 -3478,12 +3291,12 @@@
  		return -EOPNOTSUPP;
  	}
  
 -	if (!ops->alloc && !ops->setup)
 +	if (!ops->setup)
  		return -EOPNOTSUPP;
  
- 	if (!ifname[0]) {
+ 	if (tb[IFLA_IFNAME]) {
+ 		nla_strscpy(ifname, tb[IFLA_IFNAME], IFNAMSIZ);
+ 	} else {
  		snprintf(ifname, IFNAMSIZ, "%s%%d", ops->kind);
  		name_assign_type = NET_NAME_ENUM;
  	}
@@@ -3447,8 -3654,8 +3480,13 @@@ static int rtnl_getlink(struct sk_buff 
  	ifm = nlmsg_data(nlh);
  	if (ifm->ifi_index > 0)
  		dev = __dev_get_by_index(tgt_net, ifm->ifi_index);
++<<<<<<< HEAD
 +	else if (tb[IFLA_IFNAME])
 +		dev = __dev_get_by_name(tgt_net, ifname);
++=======
+ 	else if (tb[IFLA_IFNAME] || tb[IFLA_ALT_IFNAME])
+ 		dev = rtnl_dev_get(tgt_net, tb);
++>>>>>>> 5ea08b5286f6 (rtnetlink: enable alt_ifname for setlink/newlink)
  	else
  		goto out;
  
@@@ -3529,16 -3747,12 +3567,22 @@@ static int rtnl_linkprop(int cmd, struc
  		return err;
  
  	ifm = nlmsg_data(nlh);
 -	if (ifm->ifi_index > 0)
 +	if (ifm->ifi_index > 0) {
  		dev = __dev_get_by_index(net, ifm->ifi_index);
++<<<<<<< HEAD
 +	} else if (tb[IFLA_IFNAME]) {
 +		char ifname[IFNAMSIZ];
 +
 +		nla_strscpy(ifname, tb[IFLA_IFNAME], IFNAMSIZ);
 +		dev = __dev_get_by_name(net, ifname);
 +	} else {
++=======
+ 	else if (tb[IFLA_IFNAME] || tb[IFLA_ALT_IFNAME])
+ 		dev = rtnl_dev_get(net, tb);
+ 	else
++>>>>>>> 5ea08b5286f6 (rtnetlink: enable alt_ifname for setlink/newlink)
  		return -EINVAL;
 +	}
  
  	if (!dev)
  		return -ENODEV;
* Unmerged path net/core/rtnetlink.c
