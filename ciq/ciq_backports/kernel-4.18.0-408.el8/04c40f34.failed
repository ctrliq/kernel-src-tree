KVM: SVM: Inject #UD on attempted emulation for SEV guest w/o insn buffer

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Sean Christopherson <seanjc@google.com>
commit 04c40f344defdbd842d8a64fcfb47ef74b39ef4e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/04c40f34.failed

Inject #UD if KVM attempts emulation for an SEV guests without an insn
buffer and instruction decoding is required.  The previous behavior of
allowing emulation if there is no insn buffer is undesirable as doing so
means KVM is reading guest private memory and thus decoding cyphertext,
i.e. is emulating garbage.  The check was previously necessary as the
emulation type was not provided, i.e. SVM needed to allow emulation to
handle completion of emulation after exiting to userspace to handle I/O.

	Signed-off-by: Sean Christopherson <seanjc@google.com>
	Reviewed-by: Liam Merwick <liam.merwick@oracle.com>
Message-Id: <20220120010719.711476-8-seanjc@google.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 04c40f344defdbd842d8a64fcfb47ef74b39ef4e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/svm/svm.c
diff --cc arch/x86/kvm/svm/svm.c
index de9327a192dc,fb65bfabea25..000000000000
--- a/arch/x86/kvm/svm/svm.c
+++ b/arch/x86/kvm/svm/svm.c
@@@ -4289,45 -4321,29 +4326,42 @@@ static bool svm_can_emulate_instruction
  	 * Detect and workaround Errata 1096 Fam_17h_00_0Fh.
  	 *
  	 * Errata:
++<<<<<<< HEAD
 +	 * When CPU raise #NPF on guest data access and vCPU CR4.SMAP=1, it is
 +	 * possible that CPU microcode implementing DecodeAssist will fail
 +	 * to read bytes of instruction which caused #NPF. In this case,
 +	 * GuestIntrBytes field of the VMCB on a VMEXIT will incorrectly
 +	 * return 0 instead of the correct guest instruction bytes.
 +	 *
 +	 * This happens because CPU microcode reading instruction bytes
 +	 * uses a special opcode which attempts to read data using CPL=0
 +	 * priviledges. The microcode reads CS:RIP and if it hits a SMAP
 +	 * fault, it gives up and returns no instruction bytes.
++=======
+ 	 * When CPU raises #NPF on guest data access and vCPU CR4.SMAP=1, it is
+ 	 * possible that CPU microcode implementing DecodeAssist will fail to
+ 	 * read guest memory at CS:RIP and vmcb.GuestIntrBytes will incorrectly
+ 	 * be '0'.  This happens because microcode reads CS:RIP using a _data_
+ 	 * loap uop with CPL=0 privileges.  If the load hits a SMAP #PF, ucode
+ 	 * gives up and does not fill the instruction bytes buffer.
++>>>>>>> 04c40f344def (KVM: SVM: Inject #UD on attempted emulation for SEV guest w/o insn buffer)
  	 *
  	 * Detection:
- 	 * We reach here in case CPU supports DecodeAssist, raised #NPF and
- 	 * returned 0 in GuestIntrBytes field of the VMCB.
- 	 * First, errata can only be triggered in case vCPU CR4.SMAP=1.
- 	 * Second, if vCPU CR4.SMEP=1, errata could only be triggered
- 	 * in case vCPU CPL==3 (Because otherwise guest would have triggered
- 	 * a SMEP fault instead of #NPF).
- 	 * Otherwise, vCPU CR4.SMEP=0, errata could be triggered by any vCPU CPL.
- 	 * As most guests enable SMAP if they have also enabled SMEP, use above
- 	 * logic in order to attempt minimize false-positive of detecting errata
- 	 * while still preserving all cases semantic correctness.
- 	 *
- 	 * Workaround:
- 	 * To determine what instruction the guest was executing, the hypervisor
- 	 * will have to decode the instruction at the instruction pointer.
+ 	 * KVM reaches this point if the VM is an SEV guest, the CPU supports
+ 	 * DecodeAssist, a #NPF was raised, KVM's page fault handler triggered
+ 	 * emulation (e.g. for MMIO), and the CPU returned 0 in GuestIntrBytes
+ 	 * field of the VMCB.
  	 *
- 	 * In non SEV guest, hypervisor will be able to read the guest
- 	 * memory to decode the instruction pointer when insn_len is zero
- 	 * so we return true to indicate that decoding is possible.
+ 	 * This does _not_ mean that the erratum has been encountered, as the
+ 	 * DecodeAssist will also fail if the load for CS:RIP hits a legitimate
+ 	 * #PF, e.g. if the guest attempt to execute from emulated MMIO and
+ 	 * encountered a reserved/not-present #PF.
  	 *
- 	 * But in the SEV guest, the guest memory is encrypted with the
- 	 * guest specific key and hypervisor will not be able to decode the
- 	 * instruction pointer so we will not able to workaround it. Lets
- 	 * print the error and request to kill the guest.
+ 	 * To reduce the likelihood of false positives, take action if and only
+ 	 * if CR4.SMAP=1 (obviously required to hit the erratum) and CR4.SMEP=0
+ 	 * or CPL=3.  If SMEP=1 and CPL!=3, the erratum cannot have been hit as
+ 	 * the guest would have encountered a SMEP violation #PF, not a #NPF.
  	 */
- 	if (likely(!insn || insn_len))
- 		return true;
- 
  	cr4 = kvm_read_cr4(vcpu);
  	smep = cr4 & X86_CR4_SMEP;
  	smap = cr4 & X86_CR4_SMAP;
* Unmerged path arch/x86/kvm/svm/svm.c
