gfs2: Minor retry logic cleanup

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Andreas Gruenbacher <agruenba@redhat.com>
commit 124c458a401a2497f796e4f2d6cafac6edbea8e9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/124c458a.failed

Clean up the retry logic in the read and write functions somewhat.

	Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
(cherry picked from commit 124c458a401a2497f796e4f2d6cafac6edbea8e9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/gfs2/file.c
diff --cc fs/gfs2/file.c
index 226278d93231,44bb886eefce..000000000000
--- a/fs/gfs2/file.c
+++ b/fs/gfs2/file.c
@@@ -810,12 -834,36 +810,29 @@@ static ssize_t gfs2_file_direct_read(st
  	ret = gfs2_glock_nq(gh);
  	if (ret)
  		goto out_uninit;
 -retry_under_glock:
 -	pagefault_disable();
 -	to->nofault = true;
 -	ret = iomap_dio_rw(iocb, to, &gfs2_iomap_ops, NULL,
 -			   IOMAP_DIO_PARTIAL, written);
 -	to->nofault = false;
 -	pagefault_enable();
 -	if (ret > 0)
 -		written = ret;
  
++<<<<<<< HEAD
 +	ret = iomap_dio_rw(iocb, to, &gfs2_iomap_ops, NULL, 0);
 +	gfs2_glock_dq(gh);
++=======
+ 	if (should_fault_in_pages(ret, to, &prev_count, &window_size)) {
+ 		size_t leftover;
+ 
+ 		gfs2_holder_allow_demote(gh);
+ 		leftover = fault_in_iov_iter_writeable(to, window_size);
+ 		gfs2_holder_disallow_demote(gh);
+ 		if (leftover != window_size) {
+ 			if (gfs2_holder_queued(gh))
+ 				goto retry_under_glock;
+ 			goto retry;
+ 		}
+ 	}
+ 	if (gfs2_holder_queued(gh))
+ 		gfs2_glock_dq(gh);
++>>>>>>> 124c458a401a (gfs2: Minor retry logic cleanup)
  out_uninit:
  	gfs2_holder_uninit(gh);
 -	if (ret < 0)
 -		return ret;
 -	return written;
 +	return ret;
  }
  
  static ssize_t gfs2_file_direct_write(struct kiocb *iocb, struct iov_iter *from,
@@@ -840,19 -898,42 +857,37 @@@
  	ret = gfs2_glock_nq(gh);
  	if (ret)
  		goto out_uninit;
 -retry_under_glock:
 +
  	/* Silently fall back to buffered I/O when writing beyond EOF */
 -	if (iocb->ki_pos + iov_iter_count(from) > i_size_read(&ip->i_inode))
 +	if (offset + len > i_size_read(&ip->i_inode))
  		goto out;
  
 -	from->nofault = true;
 -	ret = iomap_dio_rw(iocb, from, &gfs2_iomap_ops, NULL,
 -			   IOMAP_DIO_PARTIAL, read);
 -	from->nofault = false;
 -
 +	ret = iomap_dio_rw(iocb, from, &gfs2_iomap_ops, NULL, 0);
  	if (ret == -ENOTBLK)
  		ret = 0;
++<<<<<<< HEAD
++=======
+ 	if (ret > 0)
+ 		read = ret;
+ 
+ 	if (should_fault_in_pages(ret, from, &prev_count, &window_size)) {
+ 		size_t leftover;
+ 
+ 		gfs2_holder_allow_demote(gh);
+ 		leftover = fault_in_iov_iter_readable(from, window_size);
+ 		gfs2_holder_disallow_demote(gh);
+ 		if (leftover != window_size) {
+ 			if (gfs2_holder_queued(gh))
+ 				goto retry_under_glock;
+ 			goto retry;
+ 		}
+ 	}
++>>>>>>> 124c458a401a (gfs2: Minor retry logic cleanup)
  out:
 -	if (gfs2_holder_queued(gh))
 -		gfs2_glock_dq(gh);
 +	gfs2_glock_dq(gh);
  out_uninit:
  	gfs2_holder_uninit(gh);
 -	if (ret < 0)
 -		return ret;
 -	return read;
 +	return ret;
  }
  
  static ssize_t gfs2_file_read_iter(struct kiocb *iocb, struct iov_iter *to)
* Unmerged path fs/gfs2/file.c
