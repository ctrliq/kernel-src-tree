KVM: SVM: Skip AVIC and IRTE updates when loading blocking vCPU

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Sean Christopherson <seanjc@google.com>
commit 782f64558de7bef84b90ea812deb38f0e53a8c7a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/782f6455.failed

Don't bother updating the Physical APIC table or IRTE when loading a vCPU
that is blocking, i.e. won't be marked IsRun{ning}=1, as the pCPU is
queried if and only if IsRunning is '1'.  If the vCPU was migrated, the
new pCPU will be picked up when avic_vcpu_load() is called by
svm_vcpu_unblocking().

	Signed-off-by: Sean Christopherson <seanjc@google.com>
Message-Id: <20211208015236.1616697-15-seanjc@google.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 782f64558de7bef84b90ea812deb38f0e53a8c7a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/svm/avic.c
diff --cc arch/x86/kvm/svm/avic.c
index ea2456874260,b7353e11da2e..000000000000
--- a/arch/x86/kvm/svm/avic.c
+++ b/arch/x86/kvm/svm/avic.c
@@@ -974,26 -974,36 +974,47 @@@ out
  void avic_vcpu_load(struct kvm_vcpu *vcpu, int cpu)
  {
  	u64 entry;
++<<<<<<< HEAD
 +
++=======
+ 	/* ID = 0xff (broadcast), ID > 0xff (reserved) */
++>>>>>>> 782f64558de7 (KVM: SVM: Skip AVIC and IRTE updates when loading blocking vCPU)
  	int h_physical_id = kvm_cpu_get_apicid(cpu);
  	struct vcpu_svm *svm = to_svm(vcpu);
  
 -	/*
 -	 * Since the host physical APIC id is 8 bits,
 -	 * we can support host APIC ID upto 255.
 -	 */
 -	if (WARN_ON(h_physical_id > AVIC_PHYSICAL_ID_ENTRY_HOST_PHYSICAL_ID_MASK))
 +	if (WARN_ON(h_physical_id & ~AVIC_PHYSICAL_ID_ENTRY_HOST_PHYSICAL_ID_MASK))
  		return;
  
+ 	/*
+ 	 * No need to update anything if the vCPU is blocking, i.e. if the vCPU
+ 	 * is being scheduled in after being preempted.  The CPU entries in the
+ 	 * Physical APIC table and IRTE are consumed iff IsRun{ning} is '1'.
+ 	 * If the vCPU was migrated, its new CPU value will be stuffed when the
+ 	 * vCPU unblocks.
+ 	 */
+ 	if (kvm_vcpu_is_blocking(vcpu))
+ 		return;
+ 
  	entry = READ_ONCE(*(svm->avic_physical_id_cache));
  	WARN_ON(entry & AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK);
  
  	entry &= ~AVIC_PHYSICAL_ID_ENTRY_HOST_PHYSICAL_ID_MASK;
  	entry |= (h_physical_id & AVIC_PHYSICAL_ID_ENTRY_HOST_PHYSICAL_ID_MASK);
++<<<<<<< HEAD
 +
 +	entry &= ~AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK;
 +	if (svm->avic_is_running)
 +		entry |= AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK;
 +
 +	WRITE_ONCE(*(svm->avic_physical_id_cache), entry);
 +	avic_update_iommu_vcpu_affinity(vcpu, h_physical_id,
 +					svm->avic_is_running);
++=======
+ 	entry |= AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK;
+ 
+ 	WRITE_ONCE(*(svm->avic_physical_id_cache), entry);
+ 	avic_update_iommu_vcpu_affinity(vcpu, h_physical_id, true);
++>>>>>>> 782f64558de7 (KVM: SVM: Skip AVIC and IRTE updates when loading blocking vCPU)
  }
  
  void avic_vcpu_put(struct kvm_vcpu *vcpu)
* Unmerged path arch/x86/kvm/svm/avic.c
