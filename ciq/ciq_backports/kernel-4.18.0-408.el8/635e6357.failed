KVM: VMX: Don't do full kick when handling posted interrupt wakeup

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Sean Christopherson <seanjc@google.com>
commit 635e6357f948d57bc98af8d37eb81896333822e9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/635e6357.failed

When waking vCPUs in the posted interrupt wakeup handling, do exactly
that and no more.  There is no need to kick the vCPU as the wakeup
handler just needs to get the vCPU task running, and if it's in the guest
then it's definitely running.

	Signed-off-by: Sean Christopherson <seanjc@google.com>
	Reviewed-by: Maxim Levitsky <mlevitsk@redhat.com>
Message-Id: <20211208015236.1616697-21-seanjc@google.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 635e6357f948d57bc98af8d37eb81896333822e9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/vmx/posted_intr.c
diff --cc arch/x86/kvm/vmx/posted_intr.c
index 359222f558f9,aa1fe9085d77..000000000000
--- a/arch/x86/kvm/vmx/posted_intr.c
+++ b/arch/x86/kvm/vmx/posted_intr.c
@@@ -213,18 -201,17 +213,23 @@@ void pi_post_block(struct kvm_vcpu *vcp
   */
  void pi_wakeup_handler(void)
  {
 +	struct kvm_vcpu *vcpu;
  	int cpu = smp_processor_id();
 -	struct vcpu_vmx *vmx;
  
 -	raw_spin_lock(&per_cpu(wakeup_vcpus_on_cpu_lock, cpu));
 -	list_for_each_entry(vmx, &per_cpu(wakeup_vcpus_on_cpu, cpu),
 -			    pi_wakeup_list) {
 +	raw_spin_lock(&per_cpu(blocked_vcpu_on_cpu_lock, cpu));
 +	list_for_each_entry(vcpu, &per_cpu(blocked_vcpu_on_cpu, cpu),
 +			blocked_vcpu_list) {
 +		struct pi_desc *pi_desc = vcpu_to_pi_desc(vcpu);
  
++<<<<<<< HEAD
 +		if (pi_test_on(pi_desc))
 +			kvm_vcpu_kick(vcpu);
++=======
+ 		if (pi_test_on(&vmx->pi_desc))
+ 			kvm_vcpu_wake_up(&vmx->vcpu);
++>>>>>>> 635e6357f948 (KVM: VMX: Don't do full kick when handling posted interrupt wakeup)
  	}
 -	raw_spin_unlock(&per_cpu(wakeup_vcpus_on_cpu_lock, cpu));
 +	raw_spin_unlock(&per_cpu(blocked_vcpu_on_cpu_lock, cpu));
  }
  
  void __init pi_init_cpu(int cpu)
* Unmerged path arch/x86/kvm/vmx/posted_intr.c
