selftests: kvm/x86: Introduce is_amd_cpu()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Jim Mattson <jmattson@google.com>
commit 21066101f42cfd86fdd835b70ce0e36c335f5f4d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/21066101.failed

Replace the one ad hoc "AuthenticAMD" CPUID vendor string comparison
with a new function, is_amd_cpu().

	Signed-off-by: Jim Mattson <jmattson@google.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
Message-Id: <20220115052431.447232-4-jmattson@google.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 21066101f42cfd86fdd835b70ce0e36c335f5f4d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/testing/selftests/kvm/lib/x86_64/processor.c
diff --cc tools/testing/selftests/kvm/lib/x86_64/processor.c
index 8faa2b8d982a,6bf01ded3776..000000000000
--- a/tools/testing/selftests/kvm/lib/x86_64/processor.c
+++ b/tools/testing/selftests/kvm/lib/x86_64/processor.c
@@@ -1509,3 -1515,63 +1517,66 @@@ struct kvm_cpuid2 *vcpu_get_supported_h
  
  	return cpuid;
  }
++<<<<<<< HEAD
++=======
+ 
+ static inline unsigned x86_family(unsigned int eax)
+ {
+         unsigned int x86;
+ 
+         x86 = (eax >> 8) & 0xf;
+ 
+         if (x86 == 0xf)
+                 x86 += (eax >> 20) & 0xff;
+ 
+         return x86;
+ }
+ 
+ unsigned long vm_compute_max_gfn(struct kvm_vm *vm)
+ {
+ 	const unsigned long num_ht_pages = 12 << (30 - vm->page_shift); /* 12 GiB */
+ 	unsigned long ht_gfn, max_gfn, max_pfn;
+ 	uint32_t eax, ebx, ecx, edx, max_ext_leaf;
+ 
+ 	max_gfn = (1ULL << (vm->pa_bits - vm->page_shift)) - 1;
+ 
+ 	/* Avoid reserved HyperTransport region on AMD processors.  */
+ 	if (!is_amd_cpu())
+ 		return max_gfn;
+ 
+ 	/* On parts with <40 physical address bits, the area is fully hidden */
+ 	if (vm->pa_bits < 40)
+ 		return max_gfn;
+ 
+ 	/* Before family 17h, the HyperTransport area is just below 1T.  */
+ 	ht_gfn = (1 << 28) - num_ht_pages;
+ 	eax = 1;
+ 	cpuid(&eax, &ebx, &ecx, &edx);
+ 	if (x86_family(eax) < 0x17)
+ 		goto done;
+ 
+ 	/*
+ 	 * Otherwise it's at the top of the physical address space, possibly
+ 	 * reduced due to SME by bits 11:6 of CPUID[0x8000001f].EBX.  Use
+ 	 * the old conservative value if MAXPHYADDR is not enumerated.
+ 	 */
+ 	eax = 0x80000000;
+ 	cpuid(&eax, &ebx, &ecx, &edx);
+ 	max_ext_leaf = eax;
+ 	if (max_ext_leaf < 0x80000008)
+ 		goto done;
+ 
+ 	eax = 0x80000008;
+ 	cpuid(&eax, &ebx, &ecx, &edx);
+ 	max_pfn = (1ULL << ((eax & 0xff) - vm->page_shift)) - 1;
+ 	if (max_ext_leaf >= 0x8000001f) {
+ 		eax = 0x8000001f;
+ 		cpuid(&eax, &ebx, &ecx, &edx);
+ 		max_pfn >>= (ebx >> 6) & 0x3f;
+ 	}
+ 
+ 	ht_gfn = max_pfn - num_ht_pages;
+ done:
+ 	return min(max_gfn, ht_gfn - 1);
+ }
++>>>>>>> 21066101f42c (selftests: kvm/x86: Introduce is_amd_cpu())
diff --git a/tools/testing/selftests/kvm/include/x86_64/processor.h b/tools/testing/selftests/kvm/include/x86_64/processor.h
index b67f6a0a565d..6e330fe8ba3c 100644
--- a/tools/testing/selftests/kvm/include/x86_64/processor.h
+++ b/tools/testing/selftests/kvm/include/x86_64/processor.h
@@ -364,6 +364,7 @@ static inline unsigned long get_xmm(int n)
 }
 
 bool is_intel_cpu(void);
+bool is_amd_cpu(void);
 
 struct kvm_x86_state *vcpu_save_state(struct kvm_vm *vm, uint32_t vcpuid);
 void vcpu_load_state(struct kvm_vm *vm, uint32_t vcpuid,
* Unmerged path tools/testing/selftests/kvm/lib/x86_64/processor.c
