KVM: x86: Report host tsc and realtime values in KVM_GET_CLOCK

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Oliver Upton <oupton@google.com>
commit c68dc1b577eabd5605c6c7c08f3e07ae18d30d5d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/c68dc1b5.failed

Handling the migration of TSCs correctly is difficult, in part because
Linux does not provide userspace with the ability to retrieve a (TSC,
realtime) clock pair for a single instant in time. In lieu of a more
convenient facility, KVM can report similar information in the kvm_clock
structure.

Provide userspace with a host TSC & realtime pair iff the realtime clock
is based on the TSC. If userspace provides KVM_SET_CLOCK with a valid
realtime value, advance the KVM clock by the amount of elapsed time. Do
not step the KVM clock backwards, though, as it is a monotonic
oscillator.

	Suggested-by: Paolo Bonzini <pbonzini@redhat.com>
	Signed-off-by: Oliver Upton <oupton@google.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
Message-Id: <20210916181538.968978-5-oupton@google.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit c68dc1b577eabd5605c6c7c08f3e07ae18d30d5d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/kvm_host.h
#	arch/x86/kvm/x86.c
diff --cc arch/x86/include/asm/kvm_host.h
index 45d5ce5def55,8b16fa504cd4..000000000000
--- a/arch/x86/include/asm/kvm_host.h
+++ b/arch/x86/include/asm/kvm_host.h
@@@ -1920,4 -1940,9 +1920,12 @@@ static inline int kvm_cpu_get_apicid(in
  
  int kvm_cpu_dirty_log_size(void);
  
++<<<<<<< HEAD
++=======
+ int alloc_all_memslots_rmaps(struct kvm *kvm);
+ 
+ #define KVM_CLOCK_VALID_FLAGS						\
+ 	(KVM_CLOCK_TSC_STABLE | KVM_CLOCK_REALTIME | KVM_CLOCK_HOST_TSC)
+ 
++>>>>>>> c68dc1b577ea (KVM: x86: Report host tsc and realtime values in KVM_GET_CLOCK)
  #endif /* _ASM_X86_KVM_HOST_H */
diff --cc arch/x86/kvm/x86.c
index 1b1a9834002b,d3631d149187..000000000000
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@@ -2845,17 -2786,19 +2845,22 @@@ u64 get_kvmclock_ns(struct kvm *kvm
  	struct kvm_arch *ka = &kvm->arch;
  	struct pvclock_vcpu_time_info hv_clock;
  	unsigned long flags;
 +	u64 ret;
  
++<<<<<<< HEAD
 +	raw_spin_lock_irqsave(&ka->pvclock_gtod_sync_lock, flags);
++=======
+ 	data->flags = 0;
+ 	spin_lock_irqsave(&ka->pvclock_gtod_sync_lock, flags);
++>>>>>>> c68dc1b577ea (KVM: x86: Report host tsc and realtime values in KVM_GET_CLOCK)
  	if (!ka->use_master_clock) {
 -		spin_unlock_irqrestore(&ka->pvclock_gtod_sync_lock, flags);
 -		data->clock = get_kvmclock_base_ns() + ka->kvmclock_offset;
 -		return;
 +		raw_spin_unlock_irqrestore(&ka->pvclock_gtod_sync_lock, flags);
 +		return get_kvmclock_base_ns() + ka->kvmclock_offset;
  	}
  
 -	data->flags |= KVM_CLOCK_TSC_STABLE;
  	hv_clock.tsc_timestamp = ka->master_cycle_now;
  	hv_clock.system_time = ka->master_kernel_ns + ka->kvmclock_offset;
 -	spin_unlock_irqrestore(&ka->pvclock_gtod_sync_lock, flags);
 +	raw_spin_unlock_irqrestore(&ka->pvclock_gtod_sync_lock, flags);
  
  	/* both __this_cpu_read() and rdtsc() should be on the same cpu */
  	get_cpu();
@@@ -2864,13 -2817,20 +2879,29 @@@
  		kvm_get_time_scale(NSEC_PER_SEC, __this_cpu_read(cpu_tsc_khz) * 1000LL,
  				   &hv_clock.tsc_shift,
  				   &hv_clock.tsc_to_system_mul);
++<<<<<<< HEAD
 +		ret = __pvclock_read_cycles(&hv_clock, rdtsc());
 +	} else
 +		ret = get_kvmclock_base_ns() + ka->kvmclock_offset;
++=======
+ 		data->clock = __pvclock_read_cycles(&hv_clock, data->host_tsc);
+ 	} else {
+ 		data->clock = get_kvmclock_base_ns() + ka->kvmclock_offset;
+ 	}
++>>>>>>> c68dc1b577ea (KVM: x86: Report host tsc and realtime values in KVM_GET_CLOCK)
  
  	put_cpu();
 -}
  
++<<<<<<< HEAD
 +	return ret;
++=======
+ u64 get_kvmclock_ns(struct kvm *kvm)
+ {
+ 	struct kvm_clock_data data;
+ 
+ 	get_kvmclock(kvm, &data);
+ 	return data.clock;
++>>>>>>> c68dc1b577ea (KVM: x86: Report host tsc and realtime values in KVM_GET_CLOCK)
  }
  
  static void kvm_setup_pvclock_page(struct kvm_vcpu *v,
@@@ -6013,6 -5836,64 +6044,67 @@@ int kvm_arch_pm_notifier(struct kvm *kv
  }
  #endif /* CONFIG_HAVE_KVM_PM_NOTIFIER */
  
++<<<<<<< HEAD
++=======
+ static int kvm_vm_ioctl_get_clock(struct kvm *kvm, void __user *argp)
+ {
+ 	struct kvm_clock_data data;
+ 
+ 	memset(&data, 0, sizeof(data));
+ 	get_kvmclock(kvm, &data);
+ 	if (copy_to_user(argp, &data, sizeof(data)))
+ 		return -EFAULT;
+ 
+ 	return 0;
+ }
+ 
+ static int kvm_vm_ioctl_set_clock(struct kvm *kvm, void __user *argp)
+ {
+ 	struct kvm_arch *ka = &kvm->arch;
+ 	struct kvm_clock_data data;
+ 	u64 now_raw_ns;
+ 
+ 	if (copy_from_user(&data, argp, sizeof(data)))
+ 		return -EFAULT;
+ 
+ 	/*
+ 	 * Only KVM_CLOCK_REALTIME is used, but allow passing the
+ 	 * result of KVM_GET_CLOCK back to KVM_SET_CLOCK.
+ 	 */
+ 	if (data.flags & ~KVM_CLOCK_VALID_FLAGS)
+ 		return -EINVAL;
+ 
+ 	kvm_hv_invalidate_tsc_page(kvm);
+ 	kvm_start_pvclock_update(kvm);
+ 	pvclock_update_vm_gtod_copy(kvm);
+ 
+ 	/*
+ 	 * This pairs with kvm_guest_time_update(): when masterclock is
+ 	 * in use, we use master_kernel_ns + kvmclock_offset to set
+ 	 * unsigned 'system_time' so if we use get_kvmclock_ns() (which
+ 	 * is slightly ahead) here we risk going negative on unsigned
+ 	 * 'system_time' when 'data.clock' is very small.
+ 	 */
+ 	if (data.flags & KVM_CLOCK_REALTIME) {
+ 		u64 now_real_ns = ktime_get_real_ns();
+ 
+ 		/*
+ 		 * Avoid stepping the kvmclock backwards.
+ 		 */
+ 		if (now_real_ns > data.realtime)
+ 			data.clock += now_real_ns - data.realtime;
+ 	}
+ 
+ 	if (ka->use_master_clock)
+ 		now_raw_ns = ka->master_kernel_ns;
+ 	else
+ 		now_raw_ns = get_kvmclock_base_ns();
+ 	ka->kvmclock_offset = data.clock - now_raw_ns;
+ 	kvm_end_pvclock_update(kvm);
+ 	return 0;
+ }
+ 
++>>>>>>> c68dc1b577ea (KVM: x86: Report host tsc and realtime values in KVM_GET_CLOCK)
  long kvm_arch_vm_ioctl(struct file *filp,
  		       unsigned int ioctl, unsigned long arg)
  {
diff --git a/Documentation/virt/kvm/api.rst b/Documentation/virt/kvm/api.rst
index 8e2334e73275..930af91e4097 100644
--- a/Documentation/virt/kvm/api.rst
+++ b/Documentation/virt/kvm/api.rst
@@ -993,20 +993,37 @@ such as migration.
 When KVM_CAP_ADJUST_CLOCK is passed to KVM_CHECK_EXTENSION, it returns the
 set of bits that KVM can return in struct kvm_clock_data's flag member.
 
-The only flag defined now is KVM_CLOCK_TSC_STABLE.  If set, the returned
-value is the exact kvmclock value seen by all VCPUs at the instant
-when KVM_GET_CLOCK was called.  If clear, the returned value is simply
-CLOCK_MONOTONIC plus a constant offset; the offset can be modified
-with KVM_SET_CLOCK.  KVM will try to make all VCPUs follow this clock,
-but the exact value read by each VCPU could differ, because the host
-TSC is not stable.
+The following flags are defined:
+
+KVM_CLOCK_TSC_STABLE
+  If set, the returned value is the exact kvmclock
+  value seen by all VCPUs at the instant when KVM_GET_CLOCK was called.
+  If clear, the returned value is simply CLOCK_MONOTONIC plus a constant
+  offset; the offset can be modified with KVM_SET_CLOCK.  KVM will try
+  to make all VCPUs follow this clock, but the exact value read by each
+  VCPU could differ, because the host TSC is not stable.
+
+KVM_CLOCK_REALTIME
+  If set, the `realtime` field in the kvm_clock_data
+  structure is populated with the value of the host's real time
+  clocksource at the instant when KVM_GET_CLOCK was called. If clear,
+  the `realtime` field does not contain a value.
+
+KVM_CLOCK_HOST_TSC
+  If set, the `host_tsc` field in the kvm_clock_data
+  structure is populated with the value of the host's timestamp counter (TSC)
+  at the instant when KVM_GET_CLOCK was called. If clear, the `host_tsc` field
+  does not contain a value.
 
 ::
 
   struct kvm_clock_data {
 	__u64 clock;  /* kvmclock current value */
 	__u32 flags;
-	__u32 pad[9];
+	__u32 pad0;
+	__u64 realtime;
+	__u64 host_tsc;
+	__u32 pad[4];
   };
 
 
@@ -1023,12 +1040,25 @@ Sets the current timestamp of kvmclock to the value specified in its parameter.
 In conjunction with KVM_GET_CLOCK, it is used to ensure monotonicity on scenarios
 such as migration.
 
+The following flags can be passed:
+
+KVM_CLOCK_REALTIME
+  If set, KVM will compare the value of the `realtime` field
+  with the value of the host's real time clocksource at the instant when
+  KVM_SET_CLOCK was called. The difference in elapsed time is added to the final
+  kvmclock value that will be provided to guests.
+
+Other flags returned by ``KVM_GET_CLOCK`` are accepted but ignored.
+
 ::
 
   struct kvm_clock_data {
 	__u64 clock;  /* kvmclock current value */
 	__u32 flags;
-	__u32 pad[9];
+	__u32 pad0;
+	__u64 realtime;
+	__u64 host_tsc;
+	__u32 pad[4];
   };
 
 
* Unmerged path arch/x86/include/asm/kvm_host.h
* Unmerged path arch/x86/kvm/x86.c
diff --git a/include/uapi/linux/kvm.h b/include/uapi/linux/kvm.h
index bf7907bc3b1b..3fd3388aaad3 100644
--- a/include/uapi/linux/kvm.h
+++ b/include/uapi/linux/kvm.h
@@ -1221,11 +1221,16 @@ struct kvm_irqfd {
 
 /* Do not use 1, KVM_CHECK_EXTENSION returned it before we had flags.  */
 #define KVM_CLOCK_TSC_STABLE		2
+#define KVM_CLOCK_REALTIME		(1 << 2)
+#define KVM_CLOCK_HOST_TSC		(1 << 3)
 
 struct kvm_clock_data {
 	__u64 clock;
 	__u32 flags;
-	__u32 pad[9];
+	__u32 pad0;
+	__u64 realtime;
+	__u64 host_tsc;
+	__u32 pad[4];
 };
 
 /* For KVM_CAP_SW_TLB */
