nvme-rdma: destroy cm id before destroy qp to avoid use after free

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Ruozhu Li <liruozhu@huawei.com>
commit 9817d763dbe15327b9b3ff4404fa6f27f927e744
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/9817d763.failed

We should always destroy cm_id before destroy qp to avoid to get cma
event after qp was destroyed, which may lead to use after free.
In RDMA connection establishment error flow, don't destroy qp in cm
event handler.Just report cm_error to upper level, qp will be destroy
in nvme_rdma_alloc_queue() after destroy cm id.

	Signed-off-by: Ruozhu Li <liruozhu@huawei.com>
	Reviewed-by: Max Gurtovoy <mgurtovoy@nvidia.com>
	Signed-off-by: Christoph Hellwig <hch@lst.de>
(cherry picked from commit 9817d763dbe15327b9b3ff4404fa6f27f927e744)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/nvme/host/rdma.c
diff --cc drivers/nvme/host/rdma.c
index 1e4f3d2441a7,042c594bc57e..000000000000
--- a/drivers/nvme/host/rdma.c
+++ b/drivers/nvme/host/rdma.c
@@@ -1976,8 -1946,6 +1968,11 @@@ static int nvme_rdma_cm_handler(struct 
  	case RDMA_CM_EVENT_ROUTE_ERROR:
  	case RDMA_CM_EVENT_CONNECT_ERROR:
  	case RDMA_CM_EVENT_UNREACHABLE:
++<<<<<<< HEAD
 +		nvme_rdma_destroy_queue_ib(queue);
 +		/* fall through */
++=======
++>>>>>>> 9817d763dbe1 (nvme-rdma: destroy cm id before destroy qp to avoid use after free)
  	case RDMA_CM_EVENT_ADDR_ERROR:
  		dev_dbg(queue->ctrl->ctrl.device,
  			"CM error event %d\n", ev->event);
* Unmerged path drivers/nvme/host/rdma.c
