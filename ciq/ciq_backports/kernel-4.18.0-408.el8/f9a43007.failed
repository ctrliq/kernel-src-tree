netfilter: nf_tables: double hook unregistration in netns path

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Pablo Neira Ayuso <pablo@netfilter.org>
commit f9a43007d3f7ba76d5e7f9421094f00f2ef202f8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/f9a43007.failed

__nft_release_hooks() is called from pre_netns exit path which
unregisters the hooks, then the NETDEV_UNREGISTER event is triggered
which unregisters the hooks again.

[  565.221461] WARNING: CPU: 18 PID: 193 at net/netfilter/core.c:495 __nf_unregister_net_hook+0x247/0x270
[...]
[  565.246890] CPU: 18 PID: 193 Comm: kworker/u64:1 Tainted: G            E     5.18.0-rc7+ #27
[  565.253682] Workqueue: netns cleanup_net
[  565.257059] RIP: 0010:__nf_unregister_net_hook+0x247/0x270
[...]
[  565.297120] Call Trace:
[  565.300900]  <TASK>
[  565.304683]  nf_tables_flowtable_event+0x16a/0x220 [nf_tables]
[  565.308518]  raw_notifier_call_chain+0x63/0x80
[  565.312386]  unregister_netdevice_many+0x54f/0xb50

Unregister and destroy netdev hook from netns pre_exit via kfree_rcu
so the NETDEV_UNREGISTER path see unregistered hooks.

Fixes: 767d1216bff8 ("netfilter: nftables: fix possible UAF over chains from packet path in netns")
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit f9a43007d3f7ba76d5e7f9421094f00f2ef202f8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/nf_tables_api.c
diff --cc net/netfilter/nf_tables_api.c
index 89cd36631acc,746be13438ef..000000000000
--- a/net/netfilter/nf_tables_api.c
+++ b/net/netfilter/nf_tables_api.c
@@@ -267,12 -276,27 +274,35 @@@ static void __nf_tables_unregister_hook
  	if (basechain->type->ops_unregister)
  		return basechain->type->ops_unregister(net, ops);
  
++<<<<<<< HEAD
 +	if (table->family == NFPROTO_NETDEV)
 +		nft_netdev_unregister_hooks(net, &basechain->hook_list);
++=======
+ 	if (nft_base_chain_netdev(table->family, basechain->ops.hooknum))
+ 		nft_netdev_unregister_hooks(net, &basechain->hook_list,
+ 					    release_netdev);
++>>>>>>> f9a43007d3f7 (netfilter: nf_tables: double hook unregistration in netns path)
  	else
  		nf_unregister_net_hook(net, &basechain->ops);
  }
  
++<<<<<<< HEAD
++=======
+ static void nf_tables_unregister_hook(struct net *net,
+ 				      const struct nft_table *table,
+ 				      struct nft_chain *chain)
+ {
+ 	return __nf_tables_unregister_hook(net, table, chain, false);
+ }
+ 
+ static void nft_trans_commit_list_add_tail(struct net *net, struct nft_trans *trans)
+ {
+ 	struct nftables_pernet *nft_net = nft_pernet(net);
+ 
+ 	list_add_tail(&trans->list, &nft_net->commit_list);
+ }
+ 
++>>>>>>> f9a43007d3f7 (netfilter: nf_tables: double hook unregistration in netns path)
  static int nft_trans_table_add(struct nft_ctx *ctx, int msg_type)
  {
  	struct nft_trans *trans;
@@@ -6555,13 -7322,25 +6585,32 @@@ static void nft_unregister_flowtable_ho
  				    FLOW_BLOCK_UNBIND);
  }
  
+ static void __nft_unregister_flowtable_net_hooks(struct net *net,
+ 						 struct list_head *hook_list,
+ 					         bool release_netdev)
+ {
+ 	struct nft_hook *hook, *next;
+ 
+ 	list_for_each_entry_safe(hook, next, hook_list, list) {
+ 		nf_unregister_net_hook(net, &hook->ops);
+ 		if (release_netdev) {
+ 			list_del(&hook->list);
+ 			kfree_rcu(hook);
+ 		}
+ 	}
+ }
+ 
  static void nft_unregister_flowtable_net_hooks(struct net *net,
 -					       struct list_head *hook_list)
 +					       struct nft_flowtable *flowtable)
  {
++<<<<<<< HEAD
 +	struct nft_hook *hook;
 +
 +	list_for_each_entry(hook, &flowtable->hook_list, list)
 +		nf_unregister_net_hook(net, &hook->ops);
++=======
+ 	__nft_unregister_flowtable_net_hooks(net, hook_list, false);
++>>>>>>> f9a43007d3f7 (netfilter: nf_tables: double hook unregistration in netns path)
  }
  
  static int nft_register_flowtable_net_hooks(struct net *net,
@@@ -8630,9 -9782,10 +8679,14 @@@ static void __nft_release_hook(struct n
  	struct nft_chain *chain;
  
  	list_for_each_entry(chain, &table->chains, list)
- 		nf_tables_unregister_hook(net, table, chain);
+ 		__nf_tables_unregister_hook(net, table, chain, true);
  	list_for_each_entry(flowtable, &table->flowtables, list)
++<<<<<<< HEAD
 +		nft_unregister_flowtable_net_hooks(net, flowtable);
++=======
+ 		__nft_unregister_flowtable_net_hooks(net, &flowtable->hook_list,
+ 						     true);
++>>>>>>> f9a43007d3f7 (netfilter: nf_tables: double hook unregistration in netns path)
  }
  
  static void __nft_release_hooks(struct net *net)
* Unmerged path net/netfilter/nf_tables_api.c
