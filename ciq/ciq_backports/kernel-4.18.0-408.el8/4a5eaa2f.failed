bnxt: revert hastily merged uAPI aberrations

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Jakub Kicinski <kuba@kernel.org>
commit 4a5eaa2fde59d08d0ca14f985a61c6c745555bbb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/4a5eaa2f.failed

This reverts:
 commit 02acd399533e ("bnxt_en: parse result field when NVRAM package install fails")
 commit 22f5dba5065d ("bnxt_en: add an nvm test for hw diagnose")
 commit bafed3f231f7 ("bnxt_en: implement hw health reporter")

These patches are still under discussion / I don't think they
are right, and since the authors don't reply promptly let me
lessen my load of "things I need to resolve before next release"
and revert them.

	Acked-by: Michael Chan <michael.chan@broadcom.com>
Link: https://lore.kernel.org/r/20220308173659.304915-1-kuba@kernel.org
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit 4a5eaa2fde59d08d0ca14f985a61c6c745555bbb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/broadcom/bnxt/bnxt.h
#	drivers/net/ethernet/broadcom/bnxt/bnxt_devlink.c
#	drivers/net/ethernet/broadcom/bnxt/bnxt_devlink.h
#	drivers/net/ethernet/broadcom/bnxt/bnxt_ethtool.h
diff --cc drivers/net/ethernet/broadcom/bnxt/bnxt.h
index 7c97be1d1085,447a9406b8a2..000000000000
--- a/drivers/net/ethernet/broadcom/bnxt/bnxt.h
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt.h
@@@ -1516,6 -1528,21 +1516,24 @@@ struct bnxt_ctx_mem_info 
  	struct bnxt_mem_init	mem_init[BNXT_CTX_MEM_INIT_MAX];
  };
  
++<<<<<<< HEAD
++=======
+ enum bnxt_health_severity {
+ 	SEVERITY_NORMAL = 0,
+ 	SEVERITY_WARNING,
+ 	SEVERITY_RECOVERABLE,
+ 	SEVERITY_FATAL,
+ };
+ 
+ enum bnxt_health_remedy {
+ 	REMEDY_DEVLINK_RECOVER,
+ 	REMEDY_POWER_CYCLE_DEVICE,
+ 	REMEDY_POWER_CYCLE_HOST,
+ 	REMEDY_FW_UPDATE,
+ 	REMEDY_HW_REPLACE,
+ };
+ 
++>>>>>>> 4a5eaa2fde59 (bnxt: revert hastily merged uAPI aberrations)
  struct bnxt_fw_health {
  	u32 flags;
  	u32 polling_dsecs;
diff --cc drivers/net/ethernet/broadcom/bnxt/bnxt_devlink.c
index 449597f7c74c,0c17f90d44a2..000000000000
--- a/drivers/net/ethernet/broadcom/bnxt/bnxt_devlink.c
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt_devlink.c
@@@ -18,6 -19,16 +18,19 @@@
  #include "bnxt_ethtool.h"
  #include "bnxt_ulp.h"
  #include "bnxt_ptp.h"
++<<<<<<< HEAD
++=======
+ #include "bnxt_coredump.h"
+ 
+ static void __bnxt_fw_recover(struct bnxt *bp)
+ {
+ 	if (test_bit(BNXT_STATE_FW_FATAL_COND, &bp->state) ||
+ 	    test_bit(BNXT_STATE_FW_NON_FATAL_COND, &bp->state))
+ 		bnxt_fw_reset(bp);
+ 	else
+ 		bnxt_fw_exception(bp);
+ }
++>>>>>>> 4a5eaa2fde59 (bnxt: revert hastily merged uAPI aberrations)
  
  static int
  bnxt_dl_flash_update(struct devlink *dl,
@@@ -51,44 -106,122 +64,45 @@@ static int bnxt_fw_reporter_diagnose(st
  	int rc;
  
  	if (test_bit(BNXT_STATE_IN_FW_RESET, &bp->state))
 -		return devlink_fmsg_string_pair_put(fmsg, "Status", "recovering");
 +		return 0;
  
 -	if (!h->status_reliable)
 -		return devlink_fmsg_string_pair_put(fmsg, "Status", "unknown");
 +	val = bnxt_fw_health_readl(bp, BNXT_FW_HEALTH_REG);
  
 -	mutex_lock(&h->lock);
 -	fw_status = bnxt_fw_health_readl(bp, BNXT_FW_HEALTH_REG);
 -	if (BNXT_FW_IS_BOOTING(fw_status)) {
 -		rc = devlink_fmsg_string_pair_put(fmsg, "Status", "initializing");
 -		if (rc)
 -			goto unlock;
 -	} else if (h->severity || fw_status != BNXT_FW_STATUS_HEALTHY) {
 -		if (!h->severity) {
 -			h->severity = SEVERITY_FATAL;
 -			h->remedy = REMEDY_POWER_CYCLE_DEVICE;
 -			h->diagnoses++;
 -			devlink_health_report(h->fw_reporter,
 -					      "FW error diagnosed", h);
 -		}
 -		rc = devlink_fmsg_string_pair_put(fmsg, "Status", "error");
 +	if (BNXT_FW_IS_BOOTING(val)) {
 +		rc = devlink_fmsg_string_pair_put(fmsg, "Description",
 +						  "Not yet completed initialization");
  		if (rc)
 -			goto unlock;
 -		rc = devlink_fmsg_u32_pair_put(fmsg, "Syndrome", fw_status);
 -		if (rc)
 -			goto unlock;
 -	} else {
 -		rc = devlink_fmsg_string_pair_put(fmsg, "Status", "healthy");
 +			return rc;
 +	} else if (BNXT_FW_IS_ERR(val)) {
 +		rc = devlink_fmsg_string_pair_put(fmsg, "Description",
 +						  "Encountered fatal error and cannot recover");
  		if (rc)
 -			goto unlock;
 +			return rc;
  	}
  
 -	rc = devlink_fmsg_string_pair_put(fmsg, "Severity",
 -					  bnxt_health_severity_str(h->severity));
 -	if (rc)
 -		goto unlock;
 -
 -	if (h->severity) {
 -		rc = devlink_fmsg_string_pair_put(fmsg, "Remedy",
 -						  bnxt_health_remedy_str(h->remedy));
 +	if (val >> 16) {
 +		rc = devlink_fmsg_u32_pair_put(fmsg, "Error code", val >> 16);
  		if (rc)
 -			goto unlock;
 -		if (h->remedy == REMEDY_DEVLINK_RECOVER) {
 -			rc = devlink_fmsg_string_pair_put(fmsg, "Impact",
 -							  "traffic+ntuple_cfg");
 -			if (rc)
 -				goto unlock;
 -		}
 +			return rc;
  	}
  
 -unlock:
 -	mutex_unlock(&h->lock);
 -	if (rc || !h->resets_reliable)
 -		return rc;
 -
 -	fw_resets = bnxt_fw_health_readl(bp, BNXT_FW_RESET_CNT_REG);
 -	rc = devlink_fmsg_u32_pair_put(fmsg, "Resets", fw_resets);
 -	if (rc)
 -		return rc;
 -	rc = devlink_fmsg_u32_pair_put(fmsg, "Arrests", h->arrests);
 -	if (rc)
 -		return rc;
 -	rc = devlink_fmsg_u32_pair_put(fmsg, "Survivals", h->survivals);
 +	val = bnxt_fw_health_readl(bp, BNXT_FW_RESET_CNT_REG);
 +	rc = devlink_fmsg_u32_pair_put(fmsg, "Reset count", val);
  	if (rc)
  		return rc;
 -	rc = devlink_fmsg_u32_pair_put(fmsg, "Discoveries", h->discoveries);
 -	if (rc)
 -		return rc;
 -	rc = devlink_fmsg_u32_pair_put(fmsg, "Fatalities", h->fatalities);
 -	if (rc)
 -		return rc;
 -	return devlink_fmsg_u32_pair_put(fmsg, "Diagnoses", h->diagnoses);
 -}
 -
 -static int bnxt_fw_dump(struct devlink_health_reporter *reporter,
 -			struct devlink_fmsg *fmsg, void *priv_ctx,
 -			struct netlink_ext_ack *extack)
 -{
 -	struct bnxt *bp = devlink_health_reporter_priv(reporter);
 -	u32 dump_len;
 -	void *data;
 -	int rc;
 -
 -	/* TODO: no firmware dump support in devlink_health_report() context */
 -	if (priv_ctx)
 -		return -EOPNOTSUPP;
 -
 -	dump_len = bnxt_get_coredump_length(bp, BNXT_DUMP_LIVE);
 -	if (!dump_len)
 -		return -EIO;
 -
 -	data = vmalloc(dump_len);
 -	if (!data)
 -		return -ENOMEM;
 -
 -	rc = bnxt_get_coredump(bp, BNXT_DUMP_LIVE, data, &dump_len);
 -	if (!rc) {
 -		rc = devlink_fmsg_pair_nest_start(fmsg, "core");
 -		if (rc)
 -			goto exit;
 -		rc = devlink_fmsg_binary_pair_put(fmsg, "data", data, dump_len);
 -		if (rc)
 -			goto exit;
 -		rc = devlink_fmsg_u32_pair_put(fmsg, "size", dump_len);
 -		if (rc)
 -			goto exit;
 -		rc = devlink_fmsg_pair_nest_end(fmsg);
 -	}
  
 -exit:
 -	vfree(data);
 -	return rc;
 +	return 0;
  }
  
 -static int bnxt_fw_recover(struct devlink_health_reporter *reporter,
 -			   void *priv_ctx,
 -			   struct netlink_ext_ack *extack)
 +static const struct devlink_health_reporter_ops bnxt_dl_fw_reporter_ops = {
 +	.name = "fw",
 +	.diagnose = bnxt_fw_reporter_diagnose,
 +};
 +
++<<<<<<< HEAD
 +static int bnxt_fw_reset_recover(struct devlink_health_reporter *reporter,
 +				 void *priv_ctx,
 +				 struct netlink_ext_ack *extack)
  {
  	struct bnxt *bp = devlink_health_reporter_priv(reporter);
  
@@@ -99,189 -234,227 +113,219 @@@
  	return -EINPROGRESS;
  }
  
 -static const struct devlink_health_reporter_ops bnxt_dl_fw_reporter_ops = {
 -	.name = "fw",
 -	.diagnose = bnxt_fw_diagnose,
 -	.dump = bnxt_fw_dump,
 -	.recover = bnxt_fw_recover,
 +static const
 +struct devlink_health_reporter_ops bnxt_dl_fw_reset_reporter_ops = {
 +	.name = "fw_reset",
 +	.recover = bnxt_fw_reset_recover,
  };
  
 +static int bnxt_fw_fatal_recover(struct devlink_health_reporter *reporter,
 +				 void *priv_ctx,
 +				 struct netlink_ext_ack *extack)
++=======
+ static struct devlink_health_reporter *
+ __bnxt_dl_reporter_create(struct bnxt *bp,
+ 			  const struct devlink_health_reporter_ops *ops)
++>>>>>>> 4a5eaa2fde59 (bnxt: revert hastily merged uAPI aberrations)
  {
 -	struct devlink_health_reporter *reporter;
 +	struct bnxt *bp = devlink_health_reporter_priv(reporter);
 +	struct bnxt_fw_reporter_ctx *fw_reporter_ctx = priv_ctx;
 +	unsigned long event;
  
 -	reporter = devlink_health_reporter_create(bp->dl, ops, 0, bp);
 -	if (IS_ERR(reporter)) {
 -		netdev_warn(bp->dev, "Failed to create %s health reporter, rc = %ld\n",
 -			    ops->name, PTR_ERR(reporter));
 -		return NULL;
 -	}
 +	if (!priv_ctx)
 +		return -EOPNOTSUPP;
 +
 +	bp->fw_health->fatal = true;
 +	event = fw_reporter_ctx->sp_event;
 +	if (event == BNXT_FW_RESET_NOTIFY_SP_EVENT)
 +		bnxt_fw_reset(bp);
 +	else if (event == BNXT_FW_EXCEPTION_SP_EVENT)
 +		bnxt_fw_exception(bp);
  
 -	return reporter;
 +	return -EINPROGRESS;
  }
  
 +static const
 +struct devlink_health_reporter_ops bnxt_dl_fw_fatal_reporter_ops = {
 +	.name = "fw_fatal",
 +	.recover = bnxt_fw_fatal_recover,
 +};
 +
  void bnxt_dl_fw_reporters_create(struct bnxt *bp)
  {
++<<<<<<< HEAD
 +	struct bnxt_fw_health *health = bp->fw_health;
 +
 +	if (!health)
++=======
+ 	struct bnxt_fw_health *fw_health = bp->fw_health;
+ 
+ 	if (fw_health && !fw_health->fw_reporter)
+ 		fw_health->fw_reporter = __bnxt_dl_reporter_create(bp, &bnxt_dl_fw_reporter_ops);
+ }
+ 
+ void bnxt_dl_fw_reporters_destroy(struct bnxt *bp)
+ {
+ 	struct bnxt_fw_health *fw_health = bp->fw_health;
+ 
+ 	if (fw_health && fw_health->fw_reporter) {
+ 		devlink_health_reporter_destroy(fw_health->fw_reporter);
+ 		fw_health->fw_reporter = NULL;
+ 	}
+ }
+ 
+ void bnxt_devlink_health_fw_report(struct bnxt *bp)
+ {
+ 	struct bnxt_fw_health *fw_health = bp->fw_health;
+ 	int rc;
+ 
+ 	if (!fw_health)
++>>>>>>> 4a5eaa2fde59 (bnxt: revert hastily merged uAPI aberrations)
  		return;
  
 -	if (!fw_health->fw_reporter) {
 -		__bnxt_fw_recover(bp);
 -		return;
 +	if (!(bp->fw_cap & BNXT_FW_CAP_HOT_RESET) || health->fw_reset_reporter)
 +		goto err_recovery;
 +
 +	health->fw_reset_reporter =
 +		devlink_health_reporter_create(bp->dl,
 +					       &bnxt_dl_fw_reset_reporter_ops,
 +					       0, bp);
 +	if (IS_ERR(health->fw_reset_reporter)) {
 +		netdev_warn(bp->dev, "Failed to create FW fatal health reporter, rc = %ld\n",
 +			    PTR_ERR(health->fw_reset_reporter));
 +		health->fw_reset_reporter = NULL;
 +		bp->fw_cap &= ~BNXT_FW_CAP_HOT_RESET;
  	}
  
 -	mutex_lock(&fw_health->lock);
 -	fw_health->severity = SEVERITY_RECOVERABLE;
 -	fw_health->remedy = REMEDY_DEVLINK_RECOVER;
 -	mutex_unlock(&fw_health->lock);
 -	rc = devlink_health_report(fw_health->fw_reporter, "FW error reported",
 -				   fw_health);
 -	if (rc == -ECANCELED)
 -		__bnxt_fw_recover(bp);
 -}
 +err_recovery:
 +	if (!(bp->fw_cap & BNXT_FW_CAP_ERROR_RECOVERY))
 +		return;
  
 -void bnxt_dl_health_fw_status_update(struct bnxt *bp, bool healthy)
 -{
 -	struct bnxt_fw_health *fw_health = bp->fw_health;
 -	u8 state;
 +	if (!health->fw_reporter) {
 +		health->fw_reporter =
 +			devlink_health_reporter_create(bp->dl,
 +						       &bnxt_dl_fw_reporter_ops,
 +						       0, bp);
 +		if (IS_ERR(health->fw_reporter)) {
 +			netdev_warn(bp->dev, "Failed to create FW health reporter, rc = %ld\n",
 +				    PTR_ERR(health->fw_reporter));
 +			health->fw_reporter = NULL;
 +			bp->fw_cap &= ~BNXT_FW_CAP_ERROR_RECOVERY;
 +			return;
 +		}
 +	}
  
 -	mutex_lock(&fw_health->lock);
 -	if (healthy) {
 -		fw_health->severity = SEVERITY_NORMAL;
 -		state = DEVLINK_HEALTH_REPORTER_STATE_HEALTHY;
 -	} else {
 -		fw_health->severity = SEVERITY_FATAL;
 -		fw_health->remedy = REMEDY_POWER_CYCLE_DEVICE;
 -		state = DEVLINK_HEALTH_REPORTER_STATE_ERROR;
 +	if (health->fw_fatal_reporter)
 +		return;
 +
 +	health->fw_fatal_reporter =
 +		devlink_health_reporter_create(bp->dl,
 +					       &bnxt_dl_fw_fatal_reporter_ops,
 +					       0, bp);
 +	if (IS_ERR(health->fw_fatal_reporter)) {
 +		netdev_warn(bp->dev, "Failed to create FW fatal health reporter, rc = %ld\n",
 +			    PTR_ERR(health->fw_fatal_reporter));
 +		health->fw_fatal_reporter = NULL;
 +		bp->fw_cap &= ~BNXT_FW_CAP_ERROR_RECOVERY;
  	}
 -	mutex_unlock(&fw_health->lock);
 -	devlink_health_reporter_state_update(fw_health->fw_reporter, state);
  }
  
 -void bnxt_dl_health_fw_recovery_done(struct bnxt *bp)
 +void bnxt_dl_fw_reporters_destroy(struct bnxt *bp, bool all)
  {
 -	struct bnxt_dl *dl = devlink_priv(bp->dl);
 +	struct bnxt_fw_health *health = bp->fw_health;
  
 -	devlink_health_reporter_recovery_done(bp->fw_health->fw_reporter);
 -	bnxt_hwrm_remote_dev_reset_set(bp, dl->remote_reset);
 -}
 +	if (!health)
 +		return;
  
 -static int bnxt_dl_info_get(struct devlink *dl, struct devlink_info_req *req,
 -			    struct netlink_ext_ack *extack);
 +	if ((all || !(bp->fw_cap & BNXT_FW_CAP_HOT_RESET)) &&
 +	    health->fw_reset_reporter) {
 +		devlink_health_reporter_destroy(health->fw_reset_reporter);
 +		health->fw_reset_reporter = NULL;
 +	}
  
 -static void
 -bnxt_dl_livepatch_report_err(struct bnxt *bp, struct netlink_ext_ack *extack,
 -			     struct hwrm_fw_livepatch_output *resp)
 -{
 -	int err = ((struct hwrm_err_output *)resp)->cmd_err;
 +	if ((bp->fw_cap & BNXT_FW_CAP_ERROR_RECOVERY) && !all)
 +		return;
  
 -	switch (err) {
 -	case FW_LIVEPATCH_CMD_ERR_CODE_INVALID_OPCODE:
 -		netdev_err(bp->dev, "Illegal live patch opcode");
 -		NL_SET_ERR_MSG_MOD(extack, "Invalid opcode");
 -		break;
 -	case FW_LIVEPATCH_CMD_ERR_CODE_NOT_SUPPORTED:
 -		NL_SET_ERR_MSG_MOD(extack, "Live patch operation not supported");
 -		break;
 -	case FW_LIVEPATCH_CMD_ERR_CODE_NOT_INSTALLED:
 -		NL_SET_ERR_MSG_MOD(extack, "Live patch not found");
 -		break;
 -	case FW_LIVEPATCH_CMD_ERR_CODE_NOT_PATCHED:
 -		NL_SET_ERR_MSG_MOD(extack,
 -				   "Live patch deactivation failed. Firmware not patched.");
 -		break;
 -	case FW_LIVEPATCH_CMD_ERR_CODE_AUTH_FAIL:
 -		NL_SET_ERR_MSG_MOD(extack, "Live patch not authenticated");
 -		break;
 -	case FW_LIVEPATCH_CMD_ERR_CODE_INVALID_HEADER:
 -		NL_SET_ERR_MSG_MOD(extack, "Incompatible live patch");
 -		break;
 -	case FW_LIVEPATCH_CMD_ERR_CODE_INVALID_SIZE:
 -		NL_SET_ERR_MSG_MOD(extack, "Live patch has invalid size");
 -		break;
 -	case FW_LIVEPATCH_CMD_ERR_CODE_ALREADY_PATCHED:
 -		NL_SET_ERR_MSG_MOD(extack, "Live patch already applied");
 -		break;
 -	default:
 -		netdev_err(bp->dev, "Unexpected live patch error: %d\n", err);
 -		NL_SET_ERR_MSG_MOD(extack, "Failed to activate live patch");
 -		break;
 +	if (health->fw_reporter) {
 +		devlink_health_reporter_destroy(health->fw_reporter);
 +		health->fw_reporter = NULL;
  	}
 -}
 -
 -/* Live patch status in NVM */
 -#define BNXT_LIVEPATCH_NOT_INSTALLED	0
 -#define BNXT_LIVEPATCH_INSTALLED	FW_LIVEPATCH_QUERY_RESP_STATUS_FLAGS_INSTALL
 -#define BNXT_LIVEPATCH_REMOVED		FW_LIVEPATCH_QUERY_RESP_STATUS_FLAGS_ACTIVE
 -#define BNXT_LIVEPATCH_MASK		(FW_LIVEPATCH_QUERY_RESP_STATUS_FLAGS_INSTALL | \
 -					 FW_LIVEPATCH_QUERY_RESP_STATUS_FLAGS_ACTIVE)
 -#define BNXT_LIVEPATCH_ACTIVATED	BNXT_LIVEPATCH_MASK
  
 -#define BNXT_LIVEPATCH_STATE(flags)	((flags) & BNXT_LIVEPATCH_MASK)
 +	if (health->fw_fatal_reporter) {
 +		devlink_health_reporter_destroy(health->fw_fatal_reporter);
 +		health->fw_fatal_reporter = NULL;
 +	}
 +}
  
 -static int
 -bnxt_dl_livepatch_activate(struct bnxt *bp, struct netlink_ext_ack *extack)
 +void bnxt_devlink_health_report(struct bnxt *bp, unsigned long event)
  {
 -	struct hwrm_fw_livepatch_query_output *query_resp;
 -	struct hwrm_fw_livepatch_query_input *query_req;
 -	struct hwrm_fw_livepatch_output *patch_resp;
 -	struct hwrm_fw_livepatch_input *patch_req;
 -	u16 flags, live_patch_state;
 -	bool activated = false;
 -	u32 installed = 0;
 -	u8 target;
 -	int rc;
 +	struct bnxt_fw_health *fw_health = bp->fw_health;
 +	struct bnxt_fw_reporter_ctx fw_reporter_ctx;
 +
 +	fw_reporter_ctx.sp_event = event;
 +	switch (event) {
 +	case BNXT_FW_RESET_NOTIFY_SP_EVENT:
 +		if (test_bit(BNXT_STATE_FW_FATAL_COND, &bp->state)) {
 +			if (!fw_health->fw_fatal_reporter)
 +				return;
 +
 +			devlink_health_report(fw_health->fw_fatal_reporter,
 +					      "FW fatal async event received",
 +					      &fw_reporter_ctx);
 +			return;
 +		}
 +		if (!fw_health->fw_reset_reporter)
 +			return;
  
 -	if (~bp->fw_cap & BNXT_FW_CAP_LIVEPATCH) {
 -		NL_SET_ERR_MSG_MOD(extack, "Device does not support live patch");
 -		return -EOPNOTSUPP;
 -	}
 +		devlink_health_report(fw_health->fw_reset_reporter,
 +				      "FW non-fatal reset event received",
 +				      &fw_reporter_ctx);
 +		return;
  
 -	rc = hwrm_req_init(bp, query_req, HWRM_FW_LIVEPATCH_QUERY);
 -	if (rc)
 -		return rc;
 -	query_resp = hwrm_req_hold(bp, query_req);
 +	case BNXT_FW_EXCEPTION_SP_EVENT:
 +		if (!fw_health->fw_fatal_reporter)
 +			return;
  
 -	rc = hwrm_req_init(bp, patch_req, HWRM_FW_LIVEPATCH);
 -	if (rc) {
 -		hwrm_req_drop(bp, query_req);
 -		return rc;
 +		devlink_health_report(fw_health->fw_fatal_reporter,
 +				      "FW fatal error reported",
 +				      &fw_reporter_ctx);
 +		return;
  	}
 -	patch_req->loadtype = FW_LIVEPATCH_REQ_LOADTYPE_NVM_INSTALL;
 -	patch_resp = hwrm_req_hold(bp, patch_req);
 -
 -	for (target = 1; target <= FW_LIVEPATCH_REQ_FW_TARGET_LAST; target++) {
 -		query_req->fw_target = target;
 -		rc = hwrm_req_send(bp, query_req);
 -		if (rc) {
 -			NL_SET_ERR_MSG_MOD(extack, "Failed to query packages");
 -			break;
 -		}
 +}
  
 -		flags = le16_to_cpu(query_resp->status_flags);
 -		live_patch_state = BNXT_LIVEPATCH_STATE(flags);
 +void bnxt_dl_health_status_update(struct bnxt *bp, bool healthy)
 +{
 +	struct bnxt_fw_health *health = bp->fw_health;
 +	u8 state;
  
 -		if (live_patch_state == BNXT_LIVEPATCH_NOT_INSTALLED)
 -			continue;
 +	if (healthy)
 +		state = DEVLINK_HEALTH_REPORTER_STATE_HEALTHY;
 +	else
 +		state = DEVLINK_HEALTH_REPORTER_STATE_ERROR;
  
 -		if (live_patch_state == BNXT_LIVEPATCH_ACTIVATED) {
 -			activated = true;
 -			continue;
 -		}
 +	if (health->fatal)
 +		devlink_health_reporter_state_update(health->fw_fatal_reporter,
 +						     state);
 +	else
 +		devlink_health_reporter_state_update(health->fw_reset_reporter,
 +						     state);
  
 -		if (live_patch_state == BNXT_LIVEPATCH_INSTALLED)
 -			patch_req->opcode = FW_LIVEPATCH_REQ_OPCODE_ACTIVATE;
 -		else if (live_patch_state == BNXT_LIVEPATCH_REMOVED)
 -			patch_req->opcode = FW_LIVEPATCH_REQ_OPCODE_DEACTIVATE;
 +	health->fatal = false;
 +}
  
 -		patch_req->fw_target = target;
 -		rc = hwrm_req_send(bp, patch_req);
 -		if (rc) {
 -			bnxt_dl_livepatch_report_err(bp, extack, patch_resp);
 -			break;
 -		}
 -		installed++;
 -	}
 +void bnxt_dl_health_recovery_done(struct bnxt *bp)
 +{
 +	struct bnxt_fw_health *hlth = bp->fw_health;
  
 -	if (!rc && !installed) {
 -		if (activated) {
 -			NL_SET_ERR_MSG_MOD(extack, "Live patch already activated");
 -			rc = -EEXIST;
 -		} else {
 -			NL_SET_ERR_MSG_MOD(extack, "No live patches found");
 -			rc = -ENOENT;
 -		}
 -	}
 -	hwrm_req_drop(bp, query_req);
 -	hwrm_req_drop(bp, patch_req);
 -	return rc;
 +	if (hlth->fatal)
 +		devlink_health_reporter_recovery_done(hlth->fw_fatal_reporter);
 +	else
 +		devlink_health_reporter_recovery_done(hlth->fw_reset_reporter);
  }
  
 +static int bnxt_dl_info_get(struct devlink *dl, struct devlink_info_req *req,
 +			    struct netlink_ext_ack *extack);
 +
  static int bnxt_dl_reload_down(struct devlink *dl, bool netns_change,
  			       enum devlink_reload_action action,
  			       enum devlink_reload_limit limit,
diff --cc drivers/net/ethernet/broadcom/bnxt/bnxt_devlink.h
index 406dc655a5fc,b8105065367b..000000000000
--- a/drivers/net/ethernet/broadcom/bnxt/bnxt_devlink.h
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt_devlink.h
@@@ -53,11 -71,11 +53,17 @@@ enum bnxt_dl_version_type 
  	BNXT_VERSION_STORED,
  };
  
++<<<<<<< HEAD
 +void bnxt_devlink_health_report(struct bnxt *bp, unsigned long event);
 +void bnxt_dl_health_status_update(struct bnxt *bp, bool healthy);
 +void bnxt_dl_health_recovery_done(struct bnxt *bp);
++=======
+ void bnxt_devlink_health_fw_report(struct bnxt *bp);
+ void bnxt_dl_health_fw_status_update(struct bnxt *bp, bool healthy);
+ void bnxt_dl_health_fw_recovery_done(struct bnxt *bp);
++>>>>>>> 4a5eaa2fde59 (bnxt: revert hastily merged uAPI aberrations)
  void bnxt_dl_fw_reporters_create(struct bnxt *bp);
 -void bnxt_dl_fw_reporters_destroy(struct bnxt *bp);
 +void bnxt_dl_fw_reporters_destroy(struct bnxt *bp, bool all);
  int bnxt_dl_register(struct bnxt *bp);
  void bnxt_dl_unregister(struct bnxt *bp);
  
diff --cc drivers/net/ethernet/broadcom/bnxt/bnxt_ethtool.h
index df9617aeea34,6aa44840f13a..000000000000
--- a/drivers/net/ethernet/broadcom/bnxt/bnxt_ethtool.h
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt_ethtool.h
@@@ -49,10 -49,13 +49,14 @@@ u32 bnxt_get_rxfh_indir_size(struct net
  u32 _bnxt_fw_to_ethtool_adv_spds(u16, u8);
  u32 bnxt_fw_to_ethtool_speed(u16);
  u16 bnxt_get_fw_auto_link_speeds(u32);
 -int bnxt_hwrm_nvm_get_dev_info(struct bnxt *bp,
 -			       struct hwrm_nvm_get_dev_info_output *nvm_dev_info);
 -int bnxt_hwrm_firmware_reset(struct net_device *dev, u8 proc_type,
 -			     u8 self_reset, u8 flags);
  int bnxt_flash_package_from_fw_obj(struct net_device *dev, const struct firmware *fw,
  				   u32 install_type);
++<<<<<<< HEAD
 +int bnxt_hwrm_nvm_get_dev_info(struct bnxt *bp,
 +			       struct hwrm_nvm_get_dev_info_output *nvm_dev_info);
++=======
+ int bnxt_get_pkginfo(struct net_device *dev, char *ver, int size);
++>>>>>>> 4a5eaa2fde59 (bnxt: revert hastily merged uAPI aberrations)
  void bnxt_ethtool_init(struct bnxt *bp);
  void bnxt_ethtool_free(struct bnxt *bp);
  
* Unmerged path drivers/net/ethernet/broadcom/bnxt/bnxt.h
* Unmerged path drivers/net/ethernet/broadcom/bnxt/bnxt_devlink.c
* Unmerged path drivers/net/ethernet/broadcom/bnxt/bnxt_devlink.h
diff --git a/drivers/net/ethernet/broadcom/bnxt/bnxt_ethtool.c b/drivers/net/ethernet/broadcom/bnxt/bnxt_ethtool.c
index acea2c24428a..6f2c1b440f68 100644
--- a/drivers/net/ethernet/broadcom/bnxt/bnxt_ethtool.c
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt_ethtool.c
@@ -2487,48 +2487,6 @@ static int bnxt_flash_firmware_from_file(struct net_device *dev,
 	return rc;
 }
 
-static int nvm_update_err_to_stderr(struct net_device *dev, u8 result)
-{
-	switch (result) {
-	case NVM_INSTALL_UPDATE_RESP_RESULT_INVALID_TYPE_PARAMETER:
-	case NVM_INSTALL_UPDATE_RESP_RESULT_INVALID_INDEX_PARAMETER:
-	case NVM_INSTALL_UPDATE_RESP_RESULT_INSTALL_DATA_ERROR:
-	case NVM_INSTALL_UPDATE_RESP_RESULT_INSTALL_CHECKSUM_ERROR:
-	case NVM_INSTALL_UPDATE_RESP_RESULT_ITEM_NOT_FOUND:
-	case NVM_INSTALL_UPDATE_RESP_RESULT_ITEM_LOCKED:
-		netdev_err(dev, "PKG install error : Data integrity on NVM\n");
-		return -EINVAL;
-	case NVM_INSTALL_UPDATE_RESP_RESULT_INVALID_PREREQUISITE:
-	case NVM_INSTALL_UPDATE_RESP_RESULT_INVALID_FILE_HEADER:
-	case NVM_INSTALL_UPDATE_RESP_RESULT_INVALID_SIGNATURE:
-	case NVM_INSTALL_UPDATE_RESP_RESULT_INVALID_PROP_STREAM:
-	case NVM_INSTALL_UPDATE_RESP_RESULT_INVALID_PROP_LENGTH:
-	case NVM_INSTALL_UPDATE_RESP_RESULT_INVALID_MANIFEST:
-	case NVM_INSTALL_UPDATE_RESP_RESULT_INVALID_TRAILER:
-	case NVM_INSTALL_UPDATE_RESP_RESULT_INVALID_CHECKSUM:
-	case NVM_INSTALL_UPDATE_RESP_RESULT_INVALID_ITEM_CHECKSUM:
-	case NVM_INSTALL_UPDATE_RESP_RESULT_INVALID_DATA_LENGTH:
-	case NVM_INSTALL_UPDATE_RESP_RESULT_INVALID_DIRECTIVE:
-	case NVM_INSTALL_UPDATE_RESP_RESULT_DUPLICATE_ITEM:
-	case NVM_INSTALL_UPDATE_RESP_RESULT_ZERO_LENGTH_ITEM:
-		netdev_err(dev, "PKG install error : Invalid package\n");
-		return -ENOPKG;
-	case NVM_INSTALL_UPDATE_RESP_RESULT_INSTALL_AUTHENTICATION_ERROR:
-		netdev_err(dev, "PKG install error : Authentication error\n");
-		return -EPERM;
-	case NVM_INSTALL_UPDATE_RESP_RESULT_UNSUPPORTED_CHIP_REV:
-	case NVM_INSTALL_UPDATE_RESP_RESULT_UNSUPPORTED_DEVICE_ID:
-	case NVM_INSTALL_UPDATE_RESP_RESULT_UNSUPPORTED_SUBSYS_VENDOR:
-	case NVM_INSTALL_UPDATE_RESP_RESULT_UNSUPPORTED_SUBSYS_ID:
-	case NVM_INSTALL_UPDATE_RESP_RESULT_UNSUPPORTED_PLATFORM:
-		netdev_err(dev, "PKG install error : Invalid device\n");
-		return -EOPNOTSUPP;
-	default:
-		netdev_err(dev, "PKG install error : Internal error\n");
-		return -EIO;
-	}
-}
-
 #define BNXT_PKG_DMA_SIZE	0x40000
 #define BNXT_NVM_MORE_FLAG	(cpu_to_le16(NVM_MODIFY_REQ_FLAGS_BATCH_MODE))
 #define BNXT_NVM_LAST_FLAG	(cpu_to_le16(NVM_MODIFY_REQ_FLAGS_BATCH_LAST))
@@ -2683,7 +2641,7 @@ int bnxt_flash_package_from_fw_obj(struct net_device *dev, const struct firmware
 	if (resp->result) {
 		netdev_err(dev, "PKG install error = %d, problem_item = %d\n",
 			   (s8)resp->result, (int)resp->problem_item);
-		rc = nvm_update_err_to_stderr(dev, resp->result);
+		rc = -ENOPKG;
 	}
 	if (rc == -EACCES)
 		bnxt_print_admin_err(bp);
* Unmerged path drivers/net/ethernet/broadcom/bnxt/bnxt_ethtool.h
