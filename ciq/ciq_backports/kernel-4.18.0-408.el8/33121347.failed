module: treat exit sections the same as init sections when !CONFIG_MODULE_UNLOAD

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Jessica Yu <jeyu@kernel.org>
commit 33121347fb1c359bd6e3e680b9f2c6ced5734a81
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/33121347.failed

Dynamic code patching (alternatives, jump_label and static_call) can
have sites in __exit code, even it __exit is never executed. Therefore
__exit must be present at runtime, at least for as long as __init code
is.

Additionally, for jump_label and static_call, the __exit sites must also
identify as within_module_init(), such that the infrastructure is aware
to never touch them after module init -- alternatives are only ran once
at init and hence don't have this particular constraint.

By making __exit identify as __init for MODULE_UNLOAD, the above is
satisfied.

So, when !CONFIG_MODULE_UNLOAD, the section ordering should look like the
following, with the .exit sections moved to the init region of the module.

Core section allocation order:
 	.text
 	.rodata
 	__ksymtab_gpl
 	__ksymtab_strings
 	.note.* sections
 	.bss
 	.data
 	.gnu.linkonce.this_module
 Init section allocation order:
 	.init.text
 	.exit.text
 	.symtab
 	.strtab

[jeyu: thanks to Peter Zijlstra for most of changelog]

Link: https://lore.kernel.org/lkml/YFiuphGw0RKehWsQ@gunter/
Link: https://lore.kernel.org/r/20210323142756.11443-1-jeyu@kernel.org
	Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>
	Signed-off-by: Jessica Yu <jeyu@kernel.org>
(cherry picked from commit 33121347fb1c359bd6e3e680b9f2c6ced5734a81)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/module.c
diff --cc kernel/module.c
index e07ea2b09d06,173a09175511..000000000000
--- a/kernel/module.c
+++ b/kernel/module.c
@@@ -2750,7 -2795,18 +2750,22 @@@ static void dynamic_debug_remove(struc
  
  void * __weak module_alloc(unsigned long size)
  {
++<<<<<<< HEAD
 +	return vmalloc_exec(size);
++=======
+ 	return __vmalloc_node_range(size, 1, VMALLOC_START, VMALLOC_END,
+ 			GFP_KERNEL, PAGE_KERNEL_EXEC, VM_FLUSH_RESET_PERMS,
+ 			NUMA_NO_NODE, __builtin_return_address(0));
+ }
+ 
+ bool __weak module_init_section(const char *name)
+ {
+ #ifndef CONFIG_MODULE_UNLOAD
+ 	return strstarts(name, ".init") || module_exit_section(name);
+ #else
+ 	return strstarts(name, ".init");
+ #endif
++>>>>>>> 33121347fb1c (module: treat exit sections the same as init sections when !CONFIG_MODULE_UNLOAD)
  }
  
  bool __weak module_exit_section(const char *name)
@@@ -2936,21 -3113,13 +2951,16 @@@ static int rewrite_section_headers(stru
  
  	for (i = 1; i < info->hdr->e_shnum; i++) {
  		Elf_Shdr *shdr = &info->sechdrs[i];
 +		if (shdr->sh_type != SHT_NOBITS
 +		    && info->len < shdr->sh_offset + shdr->sh_size) {
 +			pr_err("Module len %lu truncated\n", info->len);
 +			return -ENOEXEC;
 +		}
  
 -		/*
 -		 * Mark all sections sh_addr with their address in the
 -		 * temporary image.
 -		 */
 +		/* Mark all sections sh_addr with their address in the
 +		   temporary image. */
  		shdr->sh_addr = (size_t)info->hdr + shdr->sh_offset;
  
- #ifndef CONFIG_MODULE_UNLOAD
- 		/* Don't load .exit sections */
- 		if (module_exit_section(info->secstrings+shdr->sh_name))
- 			shdr->sh_flags &= ~(unsigned long)SHF_ALLOC;
- #endif
  	}
  
  	/* Track but don't keep modinfo and version sections. */
* Unmerged path kernel/module.c
