KVM: MMU: change tracepoints arguments to kvm_page_fault

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Paolo Bonzini <pbonzini@redhat.com>
commit f0066d94c92dc5cf7f1a272a1bd324b0fc575292
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/f0066d94.failed

Pass struct kvm_page_fault to tracepoints instead of extracting the
arguments from the struct.  This also lets the kvm_mmu_spte_requested
tracepoint pick the gfn directly from fault->gfn, instead of using
the address.

	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit f0066d94c92dc5cf7f1a272a1bd324b0fc575292)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/mmu/mmu.c
#	arch/x86/kvm/mmu/paging_tmpl.h
#	arch/x86/kvm/mmu/tdp_mmu.c
diff --cc arch/x86/kvm/mmu/mmu.c
index 4d7446c022d2,5ba0a844f576..000000000000
--- a/arch/x86/kvm/mmu/mmu.c
+++ b/arch/x86/kvm/mmu/mmu.c
@@@ -2952,25 -2977,17 +2952,30 @@@ void disallowed_hugepage_adjust(u64 spt
  	}
  }
  
 -static int __direct_map(struct kvm_vcpu *vcpu, struct kvm_page_fault *fault)
 +static int __direct_map(struct kvm_vcpu *vcpu, gpa_t gpa, u32 error_code,
 +			int map_writable, int max_level, kvm_pfn_t pfn,
 +			bool prefault, bool is_tdp)
  {
 +	bool nx_huge_page_workaround_enabled = is_nx_huge_page_enabled();
 +	bool write = error_code & PFERR_WRITE_MASK;
 +	bool exec = error_code & PFERR_FETCH_MASK;
 +	bool huge_page_disallowed = exec && nx_huge_page_workaround_enabled;
  	struct kvm_shadow_walk_iterator it;
  	struct kvm_mmu_page *sp;
 -	int ret;
 -	gfn_t base_gfn = fault->gfn;
 +	int level, req_level, ret;
 +	gfn_t gfn = gpa >> PAGE_SHIFT;
 +	gfn_t base_gfn = gfn;
  
 -	kvm_mmu_hugepage_adjust(vcpu, fault);
 +	level = kvm_mmu_hugepage_adjust(vcpu, gfn, max_level, &pfn,
 +					huge_page_disallowed, &req_level);
  
++<<<<<<< HEAD
 +	trace_kvm_mmu_spte_requested(gpa, level, pfn);
 +	for_each_shadow_entry(vcpu, gpa, it) {
++=======
+ 	trace_kvm_mmu_spte_requested(fault);
+ 	for_each_shadow_entry(vcpu, fault->addr, it) {
++>>>>>>> f0066d94c92d (KVM: MMU: change tracepoints arguments to kvm_page_fault)
  		/*
  		 * We cannot overwrite existing page tables with an NX
  		 * large page, as the leaf could be executable.
diff --cc arch/x86/kvm/mmu/paging_tmpl.h
index de3ee26beb48,6bc0dbc0baff..000000000000
--- a/arch/x86/kvm/mmu/paging_tmpl.h
+++ b/arch/x86/kvm/mmu/paging_tmpl.h
@@@ -733,10 -728,9 +733,14 @@@ static int FNAME(fetch)(struct kvm_vcp
  			link_shadow_page(vcpu, it.sptep, sp);
  	}
  
 -	kvm_mmu_hugepage_adjust(vcpu, fault);
 +	level = kvm_mmu_hugepage_adjust(vcpu, gw->gfn, max_level, &pfn,
 +					huge_page_disallowed, &req_level);
  
++<<<<<<< HEAD
 +	trace_kvm_mmu_spte_requested(addr, gw->level, pfn);
++=======
+ 	trace_kvm_mmu_spte_requested(fault);
++>>>>>>> f0066d94c92d (KVM: MMU: change tracepoints arguments to kvm_page_fault)
  
  	for (; shadow_walk_okay(&it); shadow_walk_next(&it)) {
  		clear_sp_write_flooding_count(it.sptep);
diff --cc arch/x86/kvm/mmu/tdp_mmu.c
index bc5924587138,3bf85a8c7d15..000000000000
--- a/arch/x86/kvm/mmu/tdp_mmu.c
+++ b/arch/x86/kvm/mmu/tdp_mmu.c
@@@ -932,14 -992,10 +932,18 @@@ int kvm_tdp_mmu_map(struct kvm_vcpu *vc
  	u64 *child_pt;
  	u64 new_spte;
  	int ret;
 +	gfn_t gfn = gpa >> PAGE_SHIFT;
 +	int level;
 +	int req_level;
  
 -	kvm_mmu_hugepage_adjust(vcpu, fault);
 +	level = kvm_mmu_hugepage_adjust(vcpu, gfn, max_level, &pfn,
 +					huge_page_disallowed, &req_level);
  
++<<<<<<< HEAD
 +	trace_kvm_mmu_spte_requested(gpa, level, pfn);
++=======
+ 	trace_kvm_mmu_spte_requested(fault);
++>>>>>>> f0066d94c92d (KVM: MMU: change tracepoints arguments to kvm_page_fault)
  
  	rcu_read_lock();
  
* Unmerged path arch/x86/kvm/mmu/mmu.c
diff --git a/arch/x86/kvm/mmu/mmutrace.h b/arch/x86/kvm/mmu/mmutrace.h
index 2924a4081a19..b8151bbca36a 100644
--- a/arch/x86/kvm/mmu/mmutrace.h
+++ b/arch/x86/kvm/mmu/mmutrace.h
@@ -252,9 +252,9 @@ TRACE_EVENT(
 
 TRACE_EVENT(
 	fast_page_fault,
-	TP_PROTO(struct kvm_vcpu *vcpu, gpa_t cr2_or_gpa, u32 error_code,
+	TP_PROTO(struct kvm_vcpu *vcpu, struct kvm_page_fault *fault,
 		 u64 *sptep, u64 old_spte, int ret),
-	TP_ARGS(vcpu, cr2_or_gpa, error_code, sptep, old_spte, ret),
+	TP_ARGS(vcpu, fault, sptep, old_spte, ret),
 
 	TP_STRUCT__entry(
 		__field(int, vcpu_id)
@@ -268,8 +268,8 @@ TRACE_EVENT(
 
 	TP_fast_assign(
 		__entry->vcpu_id = vcpu->vcpu_id;
-		__entry->cr2_or_gpa = cr2_or_gpa;
-		__entry->error_code = error_code;
+		__entry->cr2_or_gpa = fault->addr;
+		__entry->error_code = fault->error_code;
 		__entry->sptep = sptep;
 		__entry->old_spte = old_spte;
 		__entry->new_spte = *sptep;
@@ -367,8 +367,8 @@ TRACE_EVENT(
 
 TRACE_EVENT(
 	kvm_mmu_spte_requested,
-	TP_PROTO(gpa_t addr, int level, kvm_pfn_t pfn),
-	TP_ARGS(addr, level, pfn),
+	TP_PROTO(struct kvm_page_fault *fault),
+	TP_ARGS(fault),
 
 	TP_STRUCT__entry(
 		__field(u64, gfn)
@@ -377,9 +377,9 @@ TRACE_EVENT(
 	),
 
 	TP_fast_assign(
-		__entry->gfn = addr >> PAGE_SHIFT;
-		__entry->pfn = pfn | (__entry->gfn & (KVM_PAGES_PER_HPAGE(level) - 1));
-		__entry->level = level;
+		__entry->gfn = fault->gfn;
+		__entry->pfn = fault->pfn | (fault->gfn & (KVM_PAGES_PER_HPAGE(fault->goal_level) - 1));
+		__entry->level = fault->goal_level;
 	),
 
 	TP_printk("gfn %llx pfn %llx level %d",
* Unmerged path arch/x86/kvm/mmu/paging_tmpl.h
* Unmerged path arch/x86/kvm/mmu/tdp_mmu.c
