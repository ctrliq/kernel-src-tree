KVM: X86: fix lazy allocation of rmaps

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Paolo Bonzini <pbonzini@redhat.com>
commit fa13843d1565d4c5b3aeb9be3343b313416bef46
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/fa13843d.failed

If allocation of rmaps fails, but some of the pointers have already been written,
those pointers can be cleaned up when the memslot is freed, or even reused later
for another attempt at allocating the rmaps.  Therefore there is no need to
WARN, as done for example in memslot_rmap_alloc, but the allocation *must* be
skipped lest KVM will overwrite the previous pointer and will indeed leak memory.

	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit fa13843d1565d4c5b3aeb9be3343b313416bef46)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/x86.c
diff --cc arch/x86/kvm/x86.c
index 8637d2d61d5e,0c8b5129effd..000000000000
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@@ -11582,8 -11390,10 +11582,15 @@@ static int memslot_rmap_alloc(struct kv
  
  	for (i = 0; i < KVM_NR_PAGE_SIZES; ++i) {
  		int level = i + 1;
++<<<<<<< HEAD
 +		int lpages = gfn_to_index(slot->base_gfn + npages - 1,
 +					  slot->base_gfn, level) + 1;
++=======
+ 		int lpages = __kvm_mmu_slot_lpages(slot, npages, level);
+ 
+ 		if (slot->arch.rmap[i])
+ 			continue;
++>>>>>>> fa13843d1565 (KVM: X86: fix lazy allocation of rmaps)
  
  		slot->arch.rmap[i] = kvcalloc(lpages, sz, GFP_KERNEL_ACCOUNT);
  		if (!slot->arch.rmap[i]) {
* Unmerged path arch/x86/kvm/x86.c
