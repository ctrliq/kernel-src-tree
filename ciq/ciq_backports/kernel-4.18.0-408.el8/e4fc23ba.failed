KVM: x86: remove KVM_X86_OP_NULL and mark optional kvm_x86_ops

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Paolo Bonzini <pbonzini@redhat.com>
commit e4fc23bad813591417f466beb7e833cdd2089cf6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/e4fc23ba.failed

The original use of KVM_X86_OP_NULL, which was to mark calls
that do not follow a specific naming convention, is not in use
anymore.  Instead, let's mark calls that are optional because
they are always invoked within conditionals or with static_call_cond.
Those that are _not_, i.e. those that are defined with KVM_X86_OP,
must be defined by both vendor modules or some kind of NULL pointer
dereference is bound to happen at runtime.

	Reviewed-by: Sean Christopherson <seanjc@google.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit e4fc23bad813591417f466beb7e833cdd2089cf6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/kvm-x86-ops.h
diff --cc arch/x86/include/asm/kvm-x86-ops.h
index ab393e44c1e3,5e3296c07207..000000000000
--- a/arch/x86/include/asm/kvm-x86-ops.h
+++ b/arch/x86/include/asm/kvm-x86-ops.h
@@@ -4,18 -4,17 +4,24 @@@ BUILD_BUG_ON(1
  #endif
  
  /*
-  * KVM_X86_OP() and KVM_X86_OP_NULL() are used to help generate
-  * "static_call()"s. They are also intended for use when defining
-  * the vmx/svm kvm_x86_ops. KVM_X86_OP() can be used for those
-  * functions that follow the [svm|vmx]_func_name convention.
-  * KVM_X86_OP_NULL() can leave a NULL definition for the
-  * case where there is no definition or a function name that
-  * doesn't match the typical naming convention is supplied.
+  * KVM_X86_OP() and KVM_X86_OP_OPTIONAL() are used to help generate
+  * both DECLARE/DEFINE_STATIC_CALL() invocations and
+  * "static_call_update()" calls.
+  *
+  * KVM_X86_OP_OPTIONAL() can be used for those functions that can have
+  * a NULL definition, for example if "static_call_cond()" will be used
+  * at the call sites.
   */
++<<<<<<< HEAD
 +KVM_X86_OP_NULL(hardware_enable)
 +KVM_X86_OP_NULL(hardware_disable)
 +KVM_X86_OP_NULL(hardware_unsetup)
 +KVM_X86_OP_NULL(cpu_has_accelerated_tpr)
++=======
+ KVM_X86_OP(hardware_enable)
+ KVM_X86_OP(hardware_disable)
+ KVM_X86_OP(hardware_unsetup)
++>>>>>>> e4fc23bad813 (KVM: x86: remove KVM_X86_OP_NULL and mark optional kvm_x86_ops)
  KVM_X86_OP(has_emulated_msr)
  KVM_X86_OP(vcpu_after_set_cpuid)
  KVM_X86_OP(vm_init)
@@@ -96,27 -95,27 +102,47 @@@ KVM_X86_OP(write_tsc_multiplier
  KVM_X86_OP(get_exit_info)
  KVM_X86_OP(check_intercept)
  KVM_X86_OP(handle_exit_irqoff)
- KVM_X86_OP_NULL(request_immediate_exit)
+ KVM_X86_OP(request_immediate_exit)
  KVM_X86_OP(sched_in)
++<<<<<<< HEAD
 +KVM_X86_OP_NULL(update_cpu_dirty_logging)
 +KVM_X86_OP_NULL(pre_block)
 +KVM_X86_OP_NULL(post_block)
 +KVM_X86_OP_NULL(vcpu_blocking)
 +KVM_X86_OP_NULL(vcpu_unblocking)
 +KVM_X86_OP_NULL(pi_update_irte)
 +KVM_X86_OP_NULL(pi_start_assignment)
 +KVM_X86_OP_NULL(apicv_post_state_restore)
 +KVM_X86_OP_NULL(dy_apicv_has_pending_interrupt)
 +KVM_X86_OP_NULL(set_hv_timer)
 +KVM_X86_OP_NULL(cancel_hv_timer)
++=======
+ KVM_X86_OP_OPTIONAL(update_cpu_dirty_logging)
+ KVM_X86_OP_OPTIONAL(vcpu_blocking)
+ KVM_X86_OP_OPTIONAL(vcpu_unblocking)
+ KVM_X86_OP_OPTIONAL(pi_update_irte)
+ KVM_X86_OP_OPTIONAL(pi_start_assignment)
+ KVM_X86_OP(apicv_post_state_restore)
+ KVM_X86_OP_OPTIONAL(dy_apicv_has_pending_interrupt)
+ KVM_X86_OP_OPTIONAL(set_hv_timer)
+ KVM_X86_OP_OPTIONAL(cancel_hv_timer)
++>>>>>>> e4fc23bad813 (KVM: x86: remove KVM_X86_OP_NULL and mark optional kvm_x86_ops)
  KVM_X86_OP(setup_mce)
  KVM_X86_OP(smi_allowed)
  KVM_X86_OP(enter_smm)
  KVM_X86_OP(leave_smm)
  KVM_X86_OP(enable_smi_window)
++<<<<<<< HEAD
 +KVM_X86_OP_NULL(mem_enc_op)
 +KVM_X86_OP_NULL(mem_enc_reg_region)
 +KVM_X86_OP_NULL(mem_enc_unreg_region)
++=======
+ KVM_X86_OP_OPTIONAL(mem_enc_ioctl)
+ KVM_X86_OP_OPTIONAL(mem_enc_register_region)
+ KVM_X86_OP_OPTIONAL(mem_enc_unregister_region)
+ KVM_X86_OP_OPTIONAL(vm_copy_enc_context_from)
+ KVM_X86_OP_OPTIONAL(vm_move_enc_context_from)
++>>>>>>> e4fc23bad813 (KVM: x86: remove KVM_X86_OP_NULL and mark optional kvm_x86_ops)
  KVM_X86_OP(get_msr_feature)
  KVM_X86_OP(can_emulate_instruction)
  KVM_X86_OP(apic_init_signal_blocked)
* Unmerged path arch/x86/include/asm/kvm-x86-ops.h
diff --git a/arch/x86/include/asm/kvm_host.h b/arch/x86/include/asm/kvm_host.h
index 96ecf6f2c1a5..d8c61f9c5cb6 100644
--- a/arch/x86/include/asm/kvm_host.h
+++ b/arch/x86/include/asm/kvm_host.h
@@ -1532,14 +1532,14 @@ extern struct kvm_x86_ops kvm_x86_ops;
 
 #define KVM_X86_OP(func) \
 	DECLARE_STATIC_CALL(kvm_x86_##func, *(((struct kvm_x86_ops *)0)->func));
-#define KVM_X86_OP_NULL KVM_X86_OP
+#define KVM_X86_OP_OPTIONAL KVM_X86_OP
 #include <asm/kvm-x86-ops.h>
 
 static inline void kvm_ops_static_call_update(void)
 {
 #define KVM_X86_OP(func) \
 	static_call_update(kvm_x86_##func, kvm_x86_ops.func);
-#define KVM_X86_OP_NULL KVM_X86_OP
+#define KVM_X86_OP_OPTIONAL KVM_X86_OP
 #include <asm/kvm-x86-ops.h>
 }
 
diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c
index a3ef48365669..2e85a0adfcb1 100644
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@ -129,7 +129,7 @@ struct kvm_x86_ops kvm_x86_ops __read_mostly;
 #define KVM_X86_OP(func)					     \
 	DEFINE_STATIC_CALL_NULL(kvm_x86_##func,			     \
 				*(((struct kvm_x86_ops *)0)->func));
-#define KVM_X86_OP_NULL KVM_X86_OP
+#define KVM_X86_OP_OPTIONAL KVM_X86_OP
 #include <asm/kvm-x86-ops.h>
 EXPORT_STATIC_CALL_GPL(kvm_x86_get_cs_db_l_bits);
 EXPORT_STATIC_CALL_GPL(kvm_x86_cache_reg);
