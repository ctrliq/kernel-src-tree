ath11k: allocate dst ring descriptors from cacheable memory

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author P Praneesh <ppranees@codeaurora.org>
commit 6452f0a3d5651bb7edfd9c709e78973aaa4d3bfc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/6452f0a3.failed

tcl_data and reo_dst rings are currently being allocated using
dma_allocate_coherent() which is non cacheable.

Allocating ring memory from cacheable memory area allows cached descriptor
access and prefetch next descriptors to optimize CPU usage during
descriptor processing on NAPI. Based on the hardware param we can enable
or disable this feature for the corresponding platform.

Tested-on: QCN9074 hw1.0 PCI WLAN.HK.2.4.0.1.r2-00012-QCAHKSWPL_SILICONZ-1
Tested-on: IPQ8074 hw2.0 AHB WLAN.HK.2.4.0.1-01695-QCAHKSWPL_SILICONZ-1

Co-developed-by: Pradeep Kumar Chitrapu <pradeepc@codeaurora.org>
	Signed-off-by: Pradeep Kumar Chitrapu <pradeepc@codeaurora.org>
Co-developed-by: Sriram R <srirrama@codeaurora.org>
	Signed-off-by: Sriram R <srirrama@codeaurora.org>
	Signed-off-by: Jouni Malinen <jouni@codeaurora.org>
	Signed-off-by: P Praneesh <ppranees@codeaurora.org>
	Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
Link: https://lore.kernel.org/r/1630560820-21905-3-git-send-email-ppranees@codeaurora.org
(cherry picked from commit 6452f0a3d5651bb7edfd9c709e78973aaa4d3bfc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/wireless/ath/ath11k/core.c
#	drivers/net/wireless/ath/ath11k/hw.h
diff --cc drivers/net/wireless/ath/ath11k/core.c
index f89ed7e55993,2ba3bf8d3fde..000000000000
--- a/drivers/net/wireless/ath/ath11k/core.c
+++ b/drivers/net/wireless/ath/ath11k/core.c
@@@ -84,7 -84,7 +84,11 @@@ static const struct ath11k_hw_params at
  		.max_tx_ring = DP_TCL_NUM_RING_MAX,
  		.hal_params = &ath11k_hw_hal_params_ipq8074,
  		.supports_dynamic_smps_6ghz = false,
++<<<<<<< HEAD
 +		.wakeup_mhi = false,
++=======
+ 		.alloc_cacheable_memory = true,
++>>>>>>> 6452f0a3d565 (ath11k: allocate dst ring descriptors from cacheable memory)
  	},
  	{
  		.hw_rev = ATH11K_HW_IPQ6018_HW10,
@@@ -136,7 -136,7 +140,11 @@@
  		.max_tx_ring = DP_TCL_NUM_RING_MAX,
  		.hal_params = &ath11k_hw_hal_params_ipq8074,
  		.supports_dynamic_smps_6ghz = false,
++<<<<<<< HEAD
 +		.wakeup_mhi = false,
++=======
+ 		.alloc_cacheable_memory = true,
++>>>>>>> 6452f0a3d565 (ath11k: allocate dst ring descriptors from cacheable memory)
  	},
  	{
  		.name = "qca6390 hw2.0",
@@@ -187,7 -187,7 +195,11 @@@
  		.max_tx_ring = DP_TCL_NUM_RING_MAX_QCA6390,
  		.hal_params = &ath11k_hw_hal_params_qca6390,
  		.supports_dynamic_smps_6ghz = false,
++<<<<<<< HEAD
 +		.wakeup_mhi = true,
++=======
+ 		.alloc_cacheable_memory = false,
++>>>>>>> 6452f0a3d565 (ath11k: allocate dst ring descriptors from cacheable memory)
  	},
  	{
  		.name = "qcn9074 hw1.0",
@@@ -238,7 -238,7 +250,11 @@@
  		.max_tx_ring = DP_TCL_NUM_RING_MAX,
  		.hal_params = &ath11k_hw_hal_params_ipq8074,
  		.supports_dynamic_smps_6ghz = true,
++<<<<<<< HEAD
 +		.wakeup_mhi = false,
++=======
+ 		.alloc_cacheable_memory = true,
++>>>>>>> 6452f0a3d565 (ath11k: allocate dst ring descriptors from cacheable memory)
  	},
  	{
  		.name = "wcn6855 hw2.0",
@@@ -289,57 -289,7 +305,61 @@@
  		.max_tx_ring = DP_TCL_NUM_RING_MAX_QCA6390,
  		.hal_params = &ath11k_hw_hal_params_qca6390,
  		.supports_dynamic_smps_6ghz = false,
++<<<<<<< HEAD
 +		.wakeup_mhi = true,
 +	},
 +	{
 +		.name = "wcn6855 hw2.1",
 +		.hw_rev = ATH11K_HW_WCN6855_HW21,
 +		.fw = {
 +			.dir = "WCN6855/hw2.1",
 +			.board_size = 256 * 1024,
 +			.cal_offset = 128 * 1024,
 +		},
 +		.max_radios = 3,
 +		.bdf_addr = 0x4B0C0000,
 +		.hw_ops = &wcn6855_ops,
 +		.ring_mask = &ath11k_hw_ring_mask_qca6390,
 +		.internal_sleep_clock = true,
 +		.regs = &wcn6855_regs,
 +		.qmi_service_ins_id = ATH11K_QMI_WLFW_SERVICE_INS_ID_V01_QCA6390,
 +		.host_ce_config = ath11k_host_ce_config_qca6390,
 +		.ce_count = 9,
 +		.target_ce_config = ath11k_target_ce_config_wlan_qca6390,
 +		.target_ce_count = 9,
 +		.svc_to_ce_map = ath11k_target_service_to_ce_map_wlan_qca6390,
 +		.svc_to_ce_map_len = 14,
 +		.single_pdev_only = true,
 +		.rxdma1_enable = false,
 +		.num_rxmda_per_pdev = 2,
 +		.rx_mac_buf_ring = true,
 +		.vdev_start_delay = true,
 +		.htt_peer_map_v2 = false,
 +
 +		.spectral = {
 +			.fft_sz = 0,
 +			.fft_pad_sz = 0,
 +			.summary_pad_sz = 0,
 +			.fft_hdr_len = 0,
 +			.max_fft_bins = 0,
 +		},
 +
 +		.interface_modes = BIT(NL80211_IFTYPE_STATION) |
 +					BIT(NL80211_IFTYPE_AP),
 +		.supports_monitor = false,
 +		.supports_shadow_regs = true,
 +		.idle_ps = true,
 +		.cold_boot_calib = false,
 +		.supports_suspend = true,
 +		.hal_desc_sz = sizeof(struct hal_rx_desc_wcn6855),
 +		.fix_l1ss = false,
 +		.max_tx_ring = DP_TCL_NUM_RING_MAX_QCA6390,
 +		.hal_params = &ath11k_hw_hal_params_qca6390,
 +		.supports_dynamic_smps_6ghz = false,
 +		.wakeup_mhi = true,
++=======
+ 		.alloc_cacheable_memory = false,
++>>>>>>> 6452f0a3d565 (ath11k: allocate dst ring descriptors from cacheable memory)
  	},
  };
  
diff --cc drivers/net/wireless/ath/ath11k/hw.h
index 83b6240128e9,3e64c9b94db0..000000000000
--- a/drivers/net/wireless/ath/ath11k/hw.h
+++ b/drivers/net/wireless/ath/ath11k/hw.h
@@@ -178,7 -178,7 +178,11 @@@ struct ath11k_hw_params 
  	u8 max_tx_ring;
  	const struct ath11k_hw_hal_params *hal_params;
  	bool supports_dynamic_smps_6ghz;
++<<<<<<< HEAD
 +	bool wakeup_mhi;
++=======
+ 	bool alloc_cacheable_memory;
++>>>>>>> 6452f0a3d565 (ath11k: allocate dst ring descriptors from cacheable memory)
  };
  
  struct ath11k_hw_ops {
* Unmerged path drivers/net/wireless/ath/ath11k/core.c
diff --git a/drivers/net/wireless/ath/ath11k/dp.c b/drivers/net/wireless/ath/ath11k/dp.c
index 8baaeeb8cf82..8058b56028de 100644
--- a/drivers/net/wireless/ath/ath11k/dp.c
+++ b/drivers/net/wireless/ath/ath11k/dp.c
@@ -101,8 +101,11 @@ void ath11k_dp_srng_cleanup(struct ath11k_base *ab, struct dp_srng *ring)
 	if (!ring->vaddr_unaligned)
 		return;
 
-	dma_free_coherent(ab->dev, ring->size, ring->vaddr_unaligned,
-			  ring->paddr_unaligned);
+	if (ring->cached)
+		kfree(ring->vaddr_unaligned);
+	else
+		dma_free_coherent(ab->dev, ring->size, ring->vaddr_unaligned,
+				  ring->paddr_unaligned);
 
 	ring->vaddr_unaligned = NULL;
 }
@@ -222,6 +225,7 @@ int ath11k_dp_srng_setup(struct ath11k_base *ab, struct dp_srng *ring,
 	int entry_sz = ath11k_hal_srng_get_entrysize(ab, type);
 	int max_entries = ath11k_hal_srng_get_max_entries(ab, type);
 	int ret;
+	bool cached = false;
 
 	if (max_entries < 0 || entry_sz < 0)
 		return -EINVAL;
@@ -230,9 +234,28 @@ int ath11k_dp_srng_setup(struct ath11k_base *ab, struct dp_srng *ring,
 		num_entries = max_entries;
 
 	ring->size = (num_entries * entry_sz) + HAL_RING_BASE_ALIGN - 1;
-	ring->vaddr_unaligned = dma_alloc_coherent(ab->dev, ring->size,
-						   &ring->paddr_unaligned,
-						   GFP_KERNEL);
+
+	if (ab->hw_params.alloc_cacheable_memory) {
+		/* Allocate the reo dst and tx completion rings from cacheable memory */
+		switch (type) {
+		case HAL_REO_DST:
+			cached = true;
+			break;
+		default:
+			cached = false;
+		}
+
+		if (cached) {
+			ring->vaddr_unaligned = kzalloc(ring->size, GFP_KERNEL);
+			ring->paddr_unaligned = virt_to_phys(ring->vaddr_unaligned);
+		}
+	}
+
+	if (!cached)
+		ring->vaddr_unaligned = dma_alloc_coherent(ab->dev, ring->size,
+							   &ring->paddr_unaligned,
+							   GFP_KERNEL);
+
 	if (!ring->vaddr_unaligned)
 		return -ENOMEM;
 
@@ -292,6 +315,11 @@ int ath11k_dp_srng_setup(struct ath11k_base *ab, struct dp_srng *ring,
 		return -EINVAL;
 	}
 
+	if (cached) {
+		params.flags |= HAL_SRNG_FLAGS_CACHED;
+		ring->cached = 1;
+	}
+
 	ret = ath11k_hal_srng_setup(ab, type, ring_num, mac_id, &params);
 	if (ret < 0) {
 		ath11k_warn(ab, "failed to setup srng: %d ring_id %d\n",
diff --git a/drivers/net/wireless/ath/ath11k/dp.h b/drivers/net/wireless/ath/ath11k/dp.h
index f524d19aca34..a4c36a9be338 100644
--- a/drivers/net/wireless/ath/ath11k/dp.h
+++ b/drivers/net/wireless/ath/ath11k/dp.h
@@ -64,6 +64,7 @@ struct dp_srng {
 	dma_addr_t paddr;
 	int size;
 	u32 ring_id;
+	u8 cached;
 };
 
 struct dp_rxdma_ring {
diff --git a/drivers/net/wireless/ath/ath11k/hal.c b/drivers/net/wireless/ath/ath11k/hal.c
index eaa0edca5576..f04edafbd0f1 100644
--- a/drivers/net/wireless/ath/ath11k/hal.c
+++ b/drivers/net/wireless/ath/ath11k/hal.c
@@ -627,6 +627,21 @@ u32 *ath11k_hal_srng_dst_peek(struct ath11k_base *ab, struct hal_srng *srng)
 	return NULL;
 }
 
+static void ath11k_hal_srng_prefetch_desc(struct ath11k_base *ab,
+					  struct hal_srng *srng)
+{
+	u32 *desc;
+
+	/* prefetch only if desc is available */
+	desc = ath11k_hal_srng_dst_peek(ab, srng);
+	if (likely(desc)) {
+		dma_sync_single_for_cpu(ab->dev, virt_to_phys(desc),
+					(srng->entry_size * sizeof(u32)),
+					DMA_FROM_DEVICE);
+		prefetch(desc);
+	}
+}
+
 u32 *ath11k_hal_srng_dst_get_next_entry(struct ath11k_base *ab,
 					struct hal_srng *srng)
 {
@@ -642,6 +657,10 @@ u32 *ath11k_hal_srng_dst_get_next_entry(struct ath11k_base *ab,
 	srng->u.dst_ring.tp = (srng->u.dst_ring.tp + srng->entry_size) %
 			      srng->ring_size;
 
+	/* Try to prefetch the next descriptor in the ring */
+	if (srng->flags & HAL_SRNG_FLAGS_CACHED)
+		ath11k_hal_srng_prefetch_desc(ab, srng);
+
 	return desc;
 }
 
@@ -775,11 +794,16 @@ void ath11k_hal_srng_access_begin(struct ath11k_base *ab, struct hal_srng *srng)
 {
 	lockdep_assert_held(&srng->lock);
 
-	if (srng->ring_dir == HAL_SRNG_DIR_SRC)
+	if (srng->ring_dir == HAL_SRNG_DIR_SRC) {
 		srng->u.src_ring.cached_tp =
 			*(volatile u32 *)srng->u.src_ring.tp_addr;
-	else
+	} else {
 		srng->u.dst_ring.cached_hp = *srng->u.dst_ring.hp_addr;
+
+		/* Try to prefetch the next descriptor in the ring */
+		if (srng->flags & HAL_SRNG_FLAGS_CACHED)
+			ath11k_hal_srng_prefetch_desc(ab, srng);
+	}
 }
 
 /* Update cached ring head/tail pointers to HW. ath11k_hal_srng_access_begin()
diff --git a/drivers/net/wireless/ath/ath11k/hal.h b/drivers/net/wireless/ath/ath11k/hal.h
index 35ed3a14e200..0f4f9ce74354 100644
--- a/drivers/net/wireless/ath/ath11k/hal.h
+++ b/drivers/net/wireless/ath/ath11k/hal.h
@@ -513,6 +513,7 @@ enum hal_srng_dir {
 #define HAL_SRNG_FLAGS_DATA_TLV_SWAP		0x00000020
 #define HAL_SRNG_FLAGS_LOW_THRESH_INTR_EN	0x00010000
 #define HAL_SRNG_FLAGS_MSI_INTR			0x00020000
+#define HAL_SRNG_FLAGS_CACHED                   0x20000000
 #define HAL_SRNG_FLAGS_LMAC_RING		0x80000000
 
 #define HAL_SRNG_TLV_HDR_TAG		GENMASK(9, 1)
* Unmerged path drivers/net/wireless/ath/ath11k/hw.h
