x86/hyperv: Add ghcb hvcall support for SNP VM

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Tianyu Lan <Tianyu.Lan@microsoft.com>
commit 20c89a559e00dfe352b73e867211a669113ae881
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/20c89a55.failed

hyperv provides ghcb hvcall to handle VMBus
HVCALL_SIGNAL_EVENT and HVCALL_POST_MESSAGE
msg in SNP Isolation VM. Add such support.

	Reviewed-by: Michael Kelley <mikelley@microsoft.com>
	Signed-off-by: Tianyu Lan <Tianyu.Lan@microsoft.com>
Link: https://lore.kernel.org/r/20211025122116.264793-8-ltykernel@gmail.com
	Signed-off-by: Wei Liu <wei.liu@kernel.org>
(cherry picked from commit 20c89a559e00dfe352b73e867211a669113ae881)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/hyperv/ivm.c
#	include/asm-generic/mshyperv.h
diff --cc include/asm-generic/mshyperv.h
index a9b23e7e7e9f,3e2248ac328e..000000000000
--- a/include/asm-generic/mshyperv.h
+++ b/include/asm-generic/mshyperv.h
@@@ -264,9 -265,10 +264,14 @@@ bool hv_is_hyperv_initialized(void)
  bool hv_is_hibernation_supported(void);
  enum hv_isolation_type hv_get_isolation_type(void);
  bool hv_is_isolation_supported(void);
++<<<<<<< HEAD
++=======
+ bool hv_isolation_type_snp(void);
+ u64 hv_ghcb_hypercall(u64 control, void *input, void *output, u32 input_size);
++>>>>>>> 20c89a559e00 (x86/hyperv: Add ghcb hvcall support for SNP VM)
  void hyperv_cleanup(void);
  bool hv_query_ext_cap(u64 cap_query);
 +void hv_setup_dma_ops(struct device *dev, bool coherent);
  #else /* CONFIG_HYPERV */
  static inline bool hv_is_hyperv_initialized(void) { return false; }
  static inline bool hv_is_hibernation_supported(void) { return false; }
* Unmerged path arch/x86/hyperv/ivm.c
* Unmerged path arch/x86/hyperv/ivm.c
diff --git a/drivers/hv/connection.c b/drivers/hv/connection.c
index 299f8e981b34..1309f9d8e2bb 100644
--- a/drivers/hv/connection.c
+++ b/drivers/hv/connection.c
@@ -460,6 +460,10 @@ void vmbus_set_event(struct vmbus_channel *channel)
 
 	++channel->sig_events;
 
-	hv_do_fast_hypercall8(HVCALL_SIGNAL_EVENT, channel->sig_event);
+	if (hv_isolation_type_snp())
+		hv_ghcb_hypercall(HVCALL_SIGNAL_EVENT, &channel->sig_event,
+				NULL, sizeof(channel->sig_event));
+	else
+		hv_do_fast_hypercall8(HVCALL_SIGNAL_EVENT, channel->sig_event);
 }
 EXPORT_SYMBOL_GPL(vmbus_set_event);
diff --git a/drivers/hv/hv.c b/drivers/hv/hv.c
index 267b4b9078b3..6d1f89696ee1 100644
--- a/drivers/hv/hv.c
+++ b/drivers/hv/hv.c
@@ -110,7 +110,13 @@ int hv_post_message(union hv_connection_id connection_id,
 	aligned_msg->payload_size = payload_size;
 	memcpy((void *)aligned_msg->payload, payload, payload_size);
 
-	status = hv_do_hypercall(HVCALL_POST_MESSAGE, aligned_msg, NULL);
+	if (hv_isolation_type_snp())
+		status = hv_ghcb_hypercall(HVCALL_POST_MESSAGE,
+				(void *)aligned_msg, NULL,
+				sizeof(*aligned_msg));
+	else
+		status = hv_do_hypercall(HVCALL_POST_MESSAGE,
+				aligned_msg, NULL);
 
 	/* Preemption must remain disabled until after the hypercall
 	 * so some other thread can't get scheduled onto this cpu and
diff --git a/drivers/hv/hv_common.c b/drivers/hv/hv_common.c
index 171ccfcf81f1..1e042500a124 100644
--- a/drivers/hv/hv_common.c
+++ b/drivers/hv/hv_common.c
@@ -293,3 +293,9 @@ void __weak hyperv_cleanup(void)
 {
 }
 EXPORT_SYMBOL_GPL(hyperv_cleanup);
+
+u64 __weak hv_ghcb_hypercall(u64 control, void *input, void *output, u32 input_size)
+{
+	return HV_STATUS_INVALID_PARAMETER;
+}
+EXPORT_SYMBOL_GPL(hv_ghcb_hypercall);
* Unmerged path include/asm-generic/mshyperv.h
