scsi: mpi3mr: Add io_uring interface support in I/O-polled mode

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Sreekanth Reddy <sreekanth.reddy@broadcom.com>
commit afd3a5793fe2a217513bc5eb2228a5ca8e8b556a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/afd3a579.failed

Add support for the io_uring interface in I/O-polled mode.

This feature is disabled in the driver by default. To enable the feature, a
module parameter "poll_queues" has to be set with the desired number of
polling queues.

When the feature is enabled, the driver reserves a certain number of
operational queue pairs for the poll_queues either from the available queue
pairs or creates additional queue pairs based on the operational queue
availability.

The Polling queues will have corresponding IRQ and ISR functions as similar
to default queues. However, the IRQ line is disabled by the driver for
poll_queues.

Link: https://lore.kernel.org/r/20211220141159.16117-22-sreekanth.reddy@broadcom.com
	Signed-off-by: Sreekanth Reddy <sreekanth.reddy@broadcom.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit afd3a5793fe2a217513bc5eb2228a5ca8e8b556a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/mpi3mr/mpi3mr.h
#	drivers/scsi/mpi3mr/mpi3mr_fw.c
diff --cc drivers/scsi/mpi3mr/mpi3mr.h
index 117fda20dc7e,64783a8e05aa..000000000000
--- a/drivers/scsi/mpi3mr/mpi3mr.h
+++ b/drivers/scsi/mpi3mr/mpi3mr.h
@@@ -204,9 -216,16 +204,15 @@@ enum mpi3mr_reset_reason 
  	MPI3MR_RESET_FROM_GETPKGVER_TIMEOUT = 21,
  	MPI3MR_RESET_FROM_PELABORT_TIMEOUT = 22,
  	MPI3MR_RESET_FROM_SYSFS = 23,
 -	MPI3MR_RESET_FROM_SYSFS_TIMEOUT = 24,
 -	MPI3MR_RESET_FROM_FIRMWARE = 27,
 +	MPI3MR_RESET_FROM_SYSFS_TIMEOUT = 24
  };
  
+ /* Queue type definitions */
+ enum queue_type {
+ 	MPI3MR_DEFAULT_QUEUE = 0,
+ 	MPI3MR_POLL_QUEUE,
+ };
+ 
  /**
   * struct mpi3mr_compimg_ver - replica of component image
   * version defined in mpi30_image.h in host endianness
@@@ -910,8 -951,12 +925,18 @@@ void mpi3mr_cleanup_fwevt_list(struct m
  void mpi3mr_flush_host_io(struct mpi3mr_ioc *mrioc);
  void mpi3mr_invalidate_devhandles(struct mpi3mr_ioc *mrioc);
  void mpi3mr_rfresh_tgtdevs(struct mpi3mr_ioc *mrioc);
++<<<<<<< HEAD
 +void mpi3mr_flush_delayed_rmhs_list(struct mpi3mr_ioc *mrioc);
 +int mpi3mr_process_op_reply_q(struct mpi3mr_ioc *mrioc,
 +	struct mpi3mr_intr_info *intr_info);
++=======
+ void mpi3mr_flush_delayed_cmd_lists(struct mpi3mr_ioc *mrioc);
+ void mpi3mr_check_rh_fault_ioc(struct mpi3mr_ioc *mrioc, u32 reason_code);
+ void mpi3mr_print_fault_info(struct mpi3mr_ioc *mrioc);
+ void mpi3mr_check_rh_fault_ioc(struct mpi3mr_ioc *mrioc, u32 reason_code);
+ int mpi3mr_process_op_reply_q(struct mpi3mr_ioc *mrioc,
+ 	struct op_reply_qinfo *op_reply_q);
+ int mpi3mr_blk_mq_poll(struct Scsi_Host *shost, unsigned int queue_num);
++>>>>>>> afd3a5793fe2 (scsi: mpi3mr: Add io_uring interface support in I/O-polled mode)
  
  #endif /*MPI3MR_H_INCLUDED*/
diff --cc drivers/scsi/mpi3mr/mpi3mr_fw.c
index 00fb90ead7ae,0fa66b34f0a6..000000000000
--- a/drivers/scsi/mpi3mr/mpi3mr_fw.c
+++ b/drivers/scsi/mpi3mr/mpi3mr_fw.c
@@@ -455,10 -465,21 +459,26 @@@ mpi3mr_get_reply_desc(struct op_reply_q
  	return reply_desc;
  }
  
++<<<<<<< HEAD
 +int mpi3mr_process_op_reply_q(struct mpi3mr_ioc *mrioc,
 +	struct mpi3mr_intr_info *intr_info)
++=======
+ /**
+  * mpi3mr_process_op_reply_q - Operational reply queue handler
+  * @mrioc: Adapter instance reference
+  * @op_reply_q: Operational reply queue info
+  *
+  * Checks the specific operational reply queue and drains the
+  * reply queue entries until the queue is empty and process the
+  * individual reply descriptors.
+  *
+  * Return: 0 if queue is already processed,or number of reply
+  *	    descriptors processed.
+  */
+ int mpi3mr_process_op_reply_q(struct mpi3mr_ioc *mrioc,
+ 	struct op_reply_qinfo *op_reply_q)
++>>>>>>> afd3a5793fe2 (scsi: mpi3mr: Add io_uring interface support in I/O-polled mode)
  {
- 	struct op_reply_qinfo *op_reply_q = intr_info->op_reply_q;
  	struct op_req_qinfo *op_req_q;
  	u32 exp_phase;
  	u32 reply_ci;
* Unmerged path drivers/scsi/mpi3mr/mpi3mr.h
* Unmerged path drivers/scsi/mpi3mr/mpi3mr_fw.c
diff --git a/drivers/scsi/mpi3mr/mpi3mr_os.c b/drivers/scsi/mpi3mr/mpi3mr_os.c
index f32758ba9bfe..3bb9193d9b85 100644
--- a/drivers/scsi/mpi3mr/mpi3mr_os.c
+++ b/drivers/scsi/mpi3mr/mpi3mr_os.c
@@ -3072,17 +3072,49 @@ static int mpi3mr_bios_param(struct scsi_device *sdev,
  * mpi3mr_map_queues - Map queues callback handler
  * @shost: SCSI host reference
  *
- * Call the blk_mq_pci_map_queues with from which operational
- * queue the mapping has to be done
+ * Maps default and poll queues.
  *
- * Return: return of blk_mq_pci_map_queues
+ * Return: return zero.
  */
 static int mpi3mr_map_queues(struct Scsi_Host *shost)
 {
 	struct mpi3mr_ioc *mrioc = shost_priv(shost);
+	int i, qoff, offset;
+	struct blk_mq_queue_map *map = NULL;
+
+	offset = mrioc->op_reply_q_offset;
+
+	for (i = 0, qoff = 0; i < HCTX_MAX_TYPES; i++) {
+		map = &shost->tag_set.map[i];
+
+		map->nr_queues  = 0;
+
+		if (i == HCTX_TYPE_DEFAULT)
+			map->nr_queues = mrioc->default_qcount;
+		else if (i == HCTX_TYPE_POLL)
+			map->nr_queues = mrioc->active_poll_qcount;
+
+		if (!map->nr_queues) {
+			BUG_ON(i == HCTX_TYPE_DEFAULT);
+			continue;
+		}
+
+		/*
+		 * The poll queue(s) doesn't have an IRQ (and hence IRQ
+		 * affinity), so use the regular blk-mq cpu mapping
+		 */
+		map->queue_offset = qoff;
+		if (i != HCTX_TYPE_POLL)
+			blk_mq_pci_map_queues(map, mrioc->pdev, offset);
+		else
+			blk_mq_map_queues(map);
+
+		qoff += map->nr_queues;
+		offset += map->nr_queues;
+	}
+
+	return 0;
 
-	return blk_mq_pci_map_queues(&shost->tag_set.map[HCTX_TYPE_DEFAULT],
-	    mrioc->pdev, mrioc->op_reply_q_offset);
 }
 
 /**
@@ -3917,6 +3949,7 @@ static struct scsi_host_template mpi3mr_driver_template = {
 	.eh_host_reset_handler		= mpi3mr_eh_host_reset,
 	.bios_param			= mpi3mr_bios_param,
 	.map_queues			= mpi3mr_map_queues,
+	.mq_poll                        = mpi3mr_blk_mq_poll,
 	.no_write_same			= 1,
 	.can_queue			= 1,
 	.this_id			= -1,
@@ -4147,6 +4180,9 @@ mpi3mr_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 	}
 
 	shost->nr_hw_queues = mrioc->num_op_reply_q;
+	if (mrioc->active_poll_qcount)
+		shost->nr_maps = 3;
+
 	shost->can_queue = mrioc->max_host_ios;
 	shost->sg_tablesize = MPI3MR_SG_DEPTH;
 	shost->max_id = mrioc->facts.max_perids + 1;
