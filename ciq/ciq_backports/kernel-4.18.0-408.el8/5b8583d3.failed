thermal: netlink: Fix compilation error when CONFIG_NET=n

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Daniel Lezcano <daniel.lezcano@linaro.org>
commit 5b8583d3bd7fc10cea07e4a5bfa59465758a39dc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/5b8583d3.failed

When the network is not configured, the netlink is disabled on all
the system. The thermal framework assumed the netlink is always
opt-in.

Fix this by adding a Kconfig option for the netlink notification,
defaulting to yes and depending on CONFIG_NET.

As the change implies multiple stubs and in order to not pollute the
internal thermal header, the thermal_nelink.h has been added and
included in the thermal_core.h, so this one regain some kind of
clarity.

	Reported-by: Randy Dunlap <rdunlap@infradead.org>
	Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
	Reviewed-by: Amit Kucheria <amit.kucheria@linaro.org>
Link: https://lore.kernel.org/r/20200707090159.1018-1-daniel.lezcano@linaro.org
(cherry picked from commit 5b8583d3bd7fc10cea07e4a5bfa59465758a39dc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/thermal/Makefile
#	drivers/thermal/thermal_core.h
diff --cc drivers/thermal/Makefile
index 031f61e7dfe8,589f6fb0d381..000000000000
--- a/drivers/thermal/Makefile
+++ b/drivers/thermal/Makefile
@@@ -6,6 -6,9 +6,12 @@@
  obj-$(CONFIG_THERMAL)		+= thermal_sys.o
  thermal_sys-y			+= thermal_core.o thermal_sysfs.o \
  					thermal_helpers.o
++<<<<<<< HEAD
++=======
+ 
+ # netlink interface to manage the thermal framework
+ thermal_sys-$(CONFIG_THERMAL_NETLINK)		+= thermal_netlink.o
++>>>>>>> 5b8583d3bd7f (thermal: netlink: Fix compilation error when CONFIG_NET=n)
  
  # interface to/from other layers providing sensors
  thermal_sys-$(CONFIG_THERMAL_HWMON)		+= thermal_hwmon.o
diff --cc drivers/thermal/thermal_core.h
index 0df190ed82a7,e00fc5585ea8..000000000000
--- a/drivers/thermal/thermal_core.h
+++ b/drivers/thermal/thermal_core.h
@@@ -12,9 -12,86 +12,92 @@@
  #include <linux/device.h>
  #include <linux/thermal.h>
  
++<<<<<<< HEAD
 +/* Initial state of a cooling device during binding */
 +#define THERMAL_NO_TARGET -1UL
 +
++=======
+ #include "thermal_netlink.h"
+ 
+ /* Default Thermal Governor */
+ #if defined(CONFIG_THERMAL_DEFAULT_GOV_STEP_WISE)
+ #define DEFAULT_THERMAL_GOVERNOR       "step_wise"
+ #elif defined(CONFIG_THERMAL_DEFAULT_GOV_FAIR_SHARE)
+ #define DEFAULT_THERMAL_GOVERNOR       "fair_share"
+ #elif defined(CONFIG_THERMAL_DEFAULT_GOV_USER_SPACE)
+ #define DEFAULT_THERMAL_GOVERNOR       "user_space"
+ #elif defined(CONFIG_THERMAL_DEFAULT_GOV_POWER_ALLOCATOR)
+ #define DEFAULT_THERMAL_GOVERNOR       "power_allocator"
+ #endif
+ 
+ /* Initial state of a cooling device during binding */
+ #define THERMAL_NO_TARGET -1UL
+ 
+ /* Init section thermal table */
+ extern struct thermal_governor *__governor_thermal_table[];
+ extern struct thermal_governor *__governor_thermal_table_end[];
+ 
+ #define THERMAL_TABLE_ENTRY(table, name)			\
+ 	static typeof(name) *__thermal_table_entry_##name	\
+ 	__used __section(__##table##_thermal_table) = &name
+ 
+ #define THERMAL_GOVERNOR_DECLARE(name)	THERMAL_TABLE_ENTRY(governor, name)
+ 
+ #define for_each_governor_table(__governor)		\
+ 	for (__governor = __governor_thermal_table;	\
+ 	     __governor < __governor_thermal_table_end;	\
+ 	     __governor++)
+ 
+ int for_each_thermal_zone(int (*cb)(struct thermal_zone_device *, void *),
+ 			  void *);
+ 
+ int for_each_thermal_cooling_device(int (*cb)(struct thermal_cooling_device *,
+ 					      void *), void *);
+ 
+ int for_each_thermal_governor(int (*cb)(struct thermal_governor *, void *),
+ 			      void *thermal_governor);
+ 
+ struct thermal_zone_device *thermal_zone_get_by_id(int id);
+ 
+ struct thermal_attr {
+ 	struct device_attribute attr;
+ 	char name[THERMAL_NAME_LENGTH];
+ };
+ 
+ static inline bool cdev_is_power_actor(struct thermal_cooling_device *cdev)
+ {
+ 	return cdev->ops->get_requested_power && cdev->ops->state2power &&
+ 		cdev->ops->power2state;
+ }
+ 
+ int power_actor_get_max_power(struct thermal_cooling_device *cdev,
+ 			      struct thermal_zone_device *tz, u32 *max_power);
+ int power_actor_get_min_power(struct thermal_cooling_device *cdev,
+ 			      struct thermal_zone_device *tz, u32 *min_power);
+ int power_actor_set_power(struct thermal_cooling_device *cdev,
+ 			  struct thermal_instance *ti, u32 power);
+ /**
+  * struct thermal_trip - representation of a point in temperature domain
+  * @np: pointer to struct device_node that this trip point was created from
+  * @temperature: temperature value in miliCelsius
+  * @hysteresis: relative hysteresis in miliCelsius
+  * @type: trip point type
+  */
+ struct thermal_trip {
+ 	struct device_node *np;
+ 	int temperature;
+ 	int hysteresis;
+ 	enum thermal_trip_type type;
+ };
+ 
+ int get_tz_trend(struct thermal_zone_device *tz, int trip);
+ 
+ struct thermal_instance *
+ get_thermal_instance(struct thermal_zone_device *tz,
+ 		     struct thermal_cooling_device *cdev,
+ 		     int trip);
+ 
++>>>>>>> 5b8583d3bd7f (thermal: netlink: Fix compilation error when CONFIG_NET=n)
  /*
   * This structure is used to describe the behavior of
   * a certain cooling device on a certain trip point
diff --git a/drivers/thermal/Kconfig b/drivers/thermal/Kconfig
index 998921c73b0b..bb44076232c4 100644
--- a/drivers/thermal/Kconfig
+++ b/drivers/thermal/Kconfig
@@ -15,6 +15,16 @@ menuconfig THERMAL
 
 if THERMAL
 
+config THERMAL_NETLINK
+	bool "Thermal netlink management"
+	depends on NET
+	default y
+	help
+	  The thermal framework has a netlink interface to do thermal
+	  zones discovery, temperature readings and events such as
+	  trip point crossed, cooling device update or governor
+	  change. It is recommended to enable the feature.
+
 config THERMAL_STATISTICS
 	bool "Thermal state transition statistics"
 	help
* Unmerged path drivers/thermal/Makefile
* Unmerged path drivers/thermal/thermal_core.h
diff --git a/drivers/thermal/thermal_netlink.h b/drivers/thermal/thermal_netlink.h
new file mode 100644
index 000000000000..0ec28d105da5
--- /dev/null
+++ b/drivers/thermal/thermal_netlink.h
@@ -0,0 +1,98 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ *  Copyright (C) Linaro Ltd 2020
+ *  Author: Daniel Lezcano <daniel.lezcano@linaro.org>
+ */
+
+/* Netlink notification function */
+#ifdef CONFIG_THERMAL_NETLINK
+int thermal_notify_tz_create(int tz_id, const char *name);
+int thermal_notify_tz_delete(int tz_id);
+int thermal_notify_tz_enable(int tz_id);
+int thermal_notify_tz_disable(int tz_id);
+int thermal_notify_tz_trip_down(int tz_id, int id);
+int thermal_notify_tz_trip_up(int tz_id, int id);
+int thermal_notify_tz_trip_delete(int tz_id, int id);
+int thermal_notify_tz_trip_add(int tz_id, int id, int type,
+			       int temp, int hyst);
+int thermal_notify_tz_trip_change(int tz_id, int id, int type,
+				  int temp, int hyst);
+int thermal_notify_cdev_state_update(int cdev_id, int state);
+int thermal_notify_cdev_add(int cdev_id, const char *name, int max_state);
+int thermal_notify_cdev_delete(int cdev_id);
+int thermal_notify_tz_gov_change(int tz_id, const char *name);
+int thermal_genl_sampling_temp(int id, int temp);
+#else
+static inline int thermal_notify_tz_create(int tz_id, const char *name)
+{
+	return 0;
+}
+
+static inline int thermal_notify_tz_delete(int tz_id)
+{
+	return 0;
+}
+
+static inline int thermal_notify_tz_enable(int tz_id)
+{
+	return 0;
+}
+
+static inline int thermal_notify_tz_disable(int tz_id)
+{
+	return 0;
+}
+
+static inline int thermal_notify_tz_trip_down(int tz_id, int id)
+{
+	return 0;
+}
+
+static inline int thermal_notify_tz_trip_up(int tz_id, int id)
+{
+	return 0;
+}
+
+static inline int thermal_notify_tz_trip_delete(int tz_id, int id)
+{
+	return 0;
+}
+
+static inline int thermal_notify_tz_trip_add(int tz_id, int id, int type,
+					     int temp, int hyst)
+{
+	return 0;
+}
+
+static inline int thermal_notify_tz_trip_change(int tz_id, int id, int type,
+						int temp, int hyst)
+{
+	return 0;
+}
+
+static inline int thermal_notify_cdev_state_update(int cdev_id, int state)
+{
+	return 0;
+}
+
+static inline int thermal_notify_cdev_add(int cdev_id, const char *name,
+					  int max_state)
+{
+	return 0;
+}
+
+static inline int thermal_notify_cdev_delete(int cdev_id)
+{
+	return 0;
+}
+
+static inline int thermal_notify_tz_gov_change(int tz_id, const char *name)
+{
+	return 0;
+}
+
+static inline int thermal_genl_sampling_temp(int id, int temp)
+{
+	return 0;
+}
+#endif /* CONFIG_THERMAL_NETLINK */
