gfs2: Eliminate GIF_INVALID flag

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Bob Peterson <rpeterso@redhat.com>
commit ec1d398dd780d42f84d58acdc6cca599d4a12c16
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/ec1d398d.failed

With the addition of the new GLF_INSTANTIATE_NEEDED flag, the
GIF_INVALID flag is now redundant. This patch removes it.
Since inode_instantiate is only called when instantiation is needed,
the check in inode_instantiate is removed too.

	Signed-off-by: Bob Peterson <rpeterso@redhat.com>
	Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
(cherry picked from commit ec1d398dd780d42f84d58acdc6cca599d4a12c16)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/gfs2/glops.c
#	fs/gfs2/inode.c
#	fs/gfs2/super.c
diff --cc fs/gfs2/glops.c
index 2e08b899f53d,0b6a59f71eef..000000000000
--- a/fs/gfs2/glops.c
+++ b/fs/gfs2/glops.c
@@@ -356,7 -356,7 +356,11 @@@ static void inode_go_inval(struct gfs2_
  		struct address_space *mapping = gfs2_glock2aspace(gl);
  		truncate_inode_pages(mapping, 0);
  		if (ip) {
++<<<<<<< HEAD
 +			set_bit(GIF_INVALID, &ip->i_flags);
++=======
+ 			set_bit(GLF_INSTANTIATE_NEEDED, &gl->gl_flags);
++>>>>>>> ec1d398dd780 (gfs2: Eliminate GIF_INVALID flag)
  			forget_all_cached_acls(&ip->i_inode);
  			security_inode_invalidate_secctx(&ip->i_inode);
  			gfs2_dir_hash_inval(ip);
@@@ -490,14 -493,12 +492,20 @@@ static int inode_go_lock(struct gfs2_ho
  	struct gfs2_inode *ip = gl->gl_object;
  	int error = 0;
  
 -	if (!ip) /* no inode to populate - read it in later */
 -		goto out;
 +	if (!ip)
 +		return 0;
  
++<<<<<<< HEAD
 +	if (test_bit(GIF_INVALID, &ip->i_flags)) {
 +		error = gfs2_inode_refresh(ip);
 +		if (error)
 +			return error;
 +	}
++=======
+ 	error = gfs2_inode_refresh(ip);
+ 	if (error)
+ 		goto out;
++>>>>>>> ec1d398dd780 (gfs2: Eliminate GIF_INVALID flag)
  
  	if (gh->gh_state != LM_ST_DEFERRED)
  		inode_dio_wait(&ip->i_inode);
diff --cc fs/gfs2/inode.c
index e3dbddf2ae05,9c28b7090895..000000000000
--- a/fs/gfs2/inode.c
+++ b/fs/gfs2/inode.c
@@@ -184,7 -182,7 +184,11 @@@ struct inode *gfs2_inode_lookup(struct 
  		}
  
  		glock_set_object(ip->i_gl, ip);
++<<<<<<< HEAD
 +		set_bit(GIF_INVALID, &ip->i_flags);
++=======
+ 		set_bit(GLF_INSTANTIATE_NEEDED, &ip->i_gl->gl_flags);
++>>>>>>> ec1d398dd780 (gfs2: Eliminate GIF_INVALID flag)
  		error = gfs2_glock_nq_init(io_gl, LM_ST_SHARED, GL_EXACT, &ip->i_iopen_gh);
  		if (unlikely(error))
  			goto fail;
diff --cc fs/gfs2/super.c
index f0126d658b8c,5b121371508a..000000000000
--- a/fs/gfs2/super.c
+++ b/fs/gfs2/super.c
@@@ -1317,8 -1244,8 +1317,13 @@@ static enum dinode_demise evict_should_
  	if (ret)
  		return SHOULD_NOT_DELETE_DINODE;
  
++<<<<<<< HEAD
 +	if (test_bit(GIF_INVALID, &ip->i_flags)) {
 +		ret = gfs2_inode_refresh(ip);
++=======
+ 	if (test_bit(GLF_INSTANTIATE_NEEDED, &ip->i_gl->gl_flags)) {
+ 		ret = gfs2_instantiate(gh);
++>>>>>>> ec1d398dd780 (gfs2: Eliminate GIF_INVALID flag)
  		if (ret)
  			return SHOULD_NOT_DELETE_DINODE;
  	}
* Unmerged path fs/gfs2/glops.c
diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 105717b0019c..4945c5fa4ae0 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -376,7 +376,6 @@ struct gfs2_glock {
 #define GFS2_MIN_LVB_SIZE 32	/* Min size of LVB that gfs2 supports */
 
 enum {
-	GIF_INVALID		= 0,
 	GIF_QD_LOCKED		= 1,
 	GIF_ALLOC_FAILED	= 2,
 	GIF_SW_PAGED		= 3,
* Unmerged path fs/gfs2/inode.c
* Unmerged path fs/gfs2/super.c
