s390/qdio: split qdio_inspect_queue()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Julian Wiedmann <jwi@linux.ibm.com>
commit b44995e515227e68af8a337c0538e17b05ae560f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/b44995e5.failed

The callers know what type of queue they want to inspect. Introduce
type-specific variants to inspect an {Input,Output} queue, so that we
can avoid one function parameter and some conditional branches in the
hot paths.

	Signed-off-by: Julian Wiedmann <jwi@linux.ibm.com>
	Reviewed-by: Benjamin Block <bblock@linux.ibm.com>
	Signed-off-by: Heiko Carstens <hca@linux.ibm.com>
(cherry picked from commit b44995e515227e68af8a337c0538e17b05ae560f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/s390/include/asm/qdio.h
#	drivers/s390/cio/qdio_main.c
diff --cc arch/s390/include/asm/qdio.h
index 97bfcbd53275,5eb431f59ede..000000000000
--- a/arch/s390/include/asm/qdio.h
+++ b/arch/s390/include/asm/qdio.h
@@@ -356,10 -352,10 +356,17 @@@ extern int do_QDIO(struct ccw_device *c
  		   unsigned int bufnr, unsigned int count, struct qaob *aob);
  extern int qdio_start_irq(struct ccw_device *cdev);
  extern int qdio_stop_irq(struct ccw_device *cdev);
++<<<<<<< HEAD
 +extern int qdio_get_next_buffers(struct ccw_device *, int, int *, int *);
 +extern int qdio_inspect_queue(struct ccw_device *cdev, unsigned int nr,
 +			      bool is_input, unsigned int *bufnr,
 +			      unsigned int *error);
++=======
+ extern int qdio_inspect_input_queue(struct ccw_device *cdev, unsigned int nr,
+ 				    unsigned int *bufnr, unsigned int *error);
+ extern int qdio_inspect_output_queue(struct ccw_device *cdev, unsigned int nr,
+ 				     unsigned int *bufnr, unsigned int *error);
++>>>>>>> b44995e51522 (s390/qdio: split qdio_inspect_queue())
  extern int qdio_shutdown(struct ccw_device *, int);
  extern int qdio_free(struct ccw_device *);
  extern int qdio_get_ssqd_desc(struct ccw_device *, struct qdio_ssqd_desc *);
diff --cc drivers/s390/cio/qdio_main.c
index 70e5627982b2,3f047faf59f0..000000000000
--- a/drivers/s390/cio/qdio_main.c
+++ b/drivers/s390/cio/qdio_main.c
@@@ -600,11 -604,30 +625,38 @@@ static int get_outbound_buffer_frontier
  	}
  }
  
++<<<<<<< HEAD
 +/* all buffers processed? */
 +static inline int qdio_outbound_q_done(struct qdio_q *q)
 +{
 +	return atomic_read(&q->nr_buf_used) == 0;
 +}
++=======
+ int qdio_inspect_output_queue(struct ccw_device *cdev, unsigned int nr,
+ 			      unsigned int *bufnr, unsigned int *error)
+ {
+ 	struct qdio_irq *irq = cdev->private->qdio_data;
+ 	unsigned int start;
+ 	struct qdio_q *q;
+ 	int count;
+ 
+ 	if (!irq)
+ 		return -ENODEV;
+ 
+ 	q = irq->output_qs[nr];
+ 	start = q->first_to_check;
+ 	*error = 0;
+ 
+ 	count = get_outbound_buffer_frontier(q, start, error);
+ 	if (count == 0)
+ 		return 0;
+ 
+ 	*bufnr = start;
+ 	q->first_to_check = add_buf(start, count);
+ 	return count;
+ }
+ EXPORT_SYMBOL_GPL(qdio_inspect_output_queue);
++>>>>>>> b44995e51522 (s390/qdio: split qdio_inspect_queue())
  
  static int qdio_kick_outbound_q(struct qdio_q *q, unsigned int count,
  				unsigned long aob)
@@@ -1422,79 -1334,6 +1474,45 @@@ rescan
  }
  EXPORT_SYMBOL(qdio_start_irq);
  
- static int __qdio_inspect_queue(struct qdio_q *q, unsigned int *bufnr,
- 				unsigned int *error)
- {
- 	unsigned int start = q->first_to_check;
- 	int count;
- 
- 	*error = 0;
- 	count = q->is_input_q ? get_inbound_buffer_frontier(q, start, error) :
- 				get_outbound_buffer_frontier(q, start, error);
- 	if (count == 0)
- 		return 0;
- 
- 	*bufnr = start;
- 
- 	/* for the next time */
- 	q->first_to_check = add_buf(start, count);
- 
- 	return count;
- }
- 
- int qdio_inspect_queue(struct ccw_device *cdev, unsigned int nr, bool is_input,
- 		       unsigned int *bufnr, unsigned int *error)
- {
- 	struct qdio_irq *irq_ptr = cdev->private->qdio_data;
- 	struct qdio_q *q;
- 
- 	if (!irq_ptr)
- 		return -ENODEV;
- 	q = is_input ? irq_ptr->input_qs[nr] : irq_ptr->output_qs[nr];
- 
- 	return __qdio_inspect_queue(q, bufnr, error);
- }
- EXPORT_SYMBOL_GPL(qdio_inspect_queue);
- 
 +/**
 + * qdio_get_next_buffers - process input buffers
 + * @cdev: associated ccw_device for the qdio subchannel
 + * @nr: input queue number
 + * @bufnr: first filled buffer number
 + * @error: buffers are in error state
 + *
 + * Return codes
 + *   < 0 - error
 + *   = 0 - no new buffers found
 + *   > 0 - number of processed buffers
 + */
 +int qdio_get_next_buffers(struct ccw_device *cdev, int nr, int *bufnr,
 +			  int *error)
 +{
 +	struct qdio_q *q;
 +	struct qdio_irq *irq_ptr = cdev->private->qdio_data;
 +
 +	if (!irq_ptr)
 +		return -ENODEV;
 +	q = irq_ptr->input_qs[nr];
 +
 +	/*
 +	 * Cannot rely on automatic sync after interrupt since queues may
 +	 * also be examined without interrupt.
 +	 */
 +	if (need_siga_sync(q))
 +		qdio_sync_queues(q);
 +
 +	qdio_check_outbound_pci_queues(irq_ptr);
 +
 +	/* Note: upper-layer MUST stop processing immediately here ... */
 +	if (unlikely(q->irq_ptr->state != QDIO_IRQ_STATE_ACTIVE))
 +		return -EIO;
 +
 +	return __qdio_inspect_queue(q, bufnr, error);
 +}
 +EXPORT_SYMBOL(qdio_get_next_buffers);
 +
  /**
   * qdio_stop_irq - disable interrupt processing for the device
   * @cdev: associated ccw_device for the qdio subchannel
* Unmerged path arch/s390/include/asm/qdio.h
* Unmerged path drivers/s390/cio/qdio_main.c
diff --git a/drivers/s390/net/qeth_core_main.c b/drivers/s390/net/qeth_core_main.c
index b84043897803..96fe22e461ae 100644
--- a/drivers/s390/net/qeth_core_main.c
+++ b/drivers/s390/net/qeth_core_main.c
@@ -5896,10 +5896,10 @@ static unsigned int qeth_rx_poll(struct qeth_card *card, int budget)
 		/* Fetch completed RX buffers: */
 		if (!card->rx.b_count) {
 			card->rx.qdio_err = 0;
-			card->rx.b_count = qdio_inspect_queue(CARD_DDEV(card),
-							      0, true,
-							      &card->rx.b_index,
-							      &card->rx.qdio_err);
+			card->rx.b_count =
+				qdio_inspect_input_queue(CARD_DDEV(card), 0,
+							 &card->rx.b_index,
+							 &card->rx.qdio_err);
 			if (card->rx.b_count <= 0) {
 				card->rx.b_count = 0;
 				break;
@@ -5946,8 +5946,8 @@ static void qeth_cq_poll(struct qeth_card *card)
 		unsigned int start, error;
 		int completed;
 
-		completed = qdio_inspect_queue(CARD_DDEV(card), 1, true, &start,
-					       &error);
+		completed = qdio_inspect_input_queue(CARD_DDEV(card), 1, &start,
+						     &error);
 		if (completed <= 0)
 			return;
 
@@ -6084,8 +6084,8 @@ static int qeth_tx_poll(struct napi_struct *napi, int budget)
 			return 0;
 		}
 
-		completed = qdio_inspect_queue(CARD_DDEV(card), queue_no, false,
-					       &start, &error);
+		completed = qdio_inspect_output_queue(CARD_DDEV(card), queue_no,
+						      &start, &error);
 		if (completed <= 0) {
 			/* Ensure we see TX completion for pending work: */
 			if (napi_complete_done(napi, 0) &&
diff --git a/drivers/s390/scsi/zfcp_qdio.c b/drivers/s390/scsi/zfcp_qdio.c
index e450a22d3f21..a408fcc5badf 100644
--- a/drivers/s390/scsi/zfcp_qdio.c
+++ b/drivers/s390/scsi/zfcp_qdio.c
@@ -79,7 +79,7 @@ static void zfcp_qdio_request_tasklet(unsigned long data)
 	unsigned int start, error;
 	int completed;
 
-	completed = qdio_inspect_queue(cdev, 0, false, &start, &error);
+	completed = qdio_inspect_output_queue(cdev, 0, &start, &error);
 	if (completed > 0) {
 		if (error) {
 			zfcp_qdio_handler_error(qdio, "qdreqt1", error);
@@ -169,7 +169,7 @@ static void zfcp_qdio_irq_tasklet(unsigned long data)
 		tasklet_schedule(&qdio->request_tasklet);
 
 	/* Check the Response Queue: */
-	completed = qdio_inspect_queue(cdev, 0, true, &start, &error);
+	completed = qdio_inspect_input_queue(cdev, 0, &start, &error);
 	if (completed < 0)
 		return;
 	if (completed > 0)
