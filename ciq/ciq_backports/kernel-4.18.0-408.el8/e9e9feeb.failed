KVM: s390: Add optional storage key checking to MEMOP IOCTL

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Janis Schoetterl-Glausch <scgl@linux.ibm.com>
commit e9e9feebcbc14b174fef862842f8cc9a388e1db3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/e9e9feeb.failed

User space needs a mechanism to perform key checked accesses when
emulating instructions.

The key can be passed as an additional argument.
Having an additional argument is flexible, as user space can
pass the guest PSW's key, in order to make an access the same way the
CPU would, or pass another key if necessary.

	Signed-off-by: Janis Schoetterl-Glausch <scgl@linux.ibm.com>
	Reviewed-by: Claudio Imbrenda <imbrenda@linux.ibm.com>
	Reviewed-by: Christian Borntraeger <borntraeger@linux.ibm.com>
	Reviewed-by: Janosch Frank <frankja@linux.ibm.com>
Link: https://lore.kernel.org/r/20220211182215.2730017-6-scgl@linux.ibm.com
	Signed-off-by: Christian Borntraeger <borntraeger@linux.ibm.com>
(cherry picked from commit e9e9feebcbc14b174fef862842f8cc9a388e1db3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/s390/kvm/kvm-s390.c
diff --cc arch/s390/kvm/kvm-s390.c
index 3586a7dbed80,c31b40abfa23..000000000000
--- a/arch/s390/kvm/kvm-s390.c
+++ b/arch/s390/kvm/kvm-s390.c
@@@ -4716,11 -4721,12 +4725,17 @@@ static long kvm_s390_guest_mem_op(struc
  	switch (mop->op) {
  	case KVM_S390_MEMOP_LOGICAL_READ:
  		if (mop->flags & KVM_S390_MEMOP_F_CHECK_ONLY) {
++<<<<<<< HEAD
 +			r = check_gva_range(vcpu, mop->gaddr, mop->ar,
 +					    mop->size, GACC_FETCH);
++=======
+ 			r = check_gva_range(vcpu, mop->gaddr, mop->ar, mop->size,
+ 					    GACC_FETCH, mop->key);
++>>>>>>> e9e9feebcbc1 (KVM: s390: Add optional storage key checking to MEMOP IOCTL)
  			break;
  		}
- 		r = read_guest(vcpu, mop->gaddr, mop->ar, tmpbuf, mop->size);
+ 		r = read_guest_with_key(vcpu, mop->gaddr, mop->ar, tmpbuf,
+ 					mop->size, mop->key);
  		if (r == 0) {
  			if (copy_to_user(uaddr, tmpbuf, mop->size))
  				r = -EFAULT;
@@@ -4728,8 -4734,8 +4743,13 @@@
  		break;
  	case KVM_S390_MEMOP_LOGICAL_WRITE:
  		if (mop->flags & KVM_S390_MEMOP_F_CHECK_ONLY) {
++<<<<<<< HEAD
 +			r = check_gva_range(vcpu, mop->gaddr, mop->ar,
 +					    mop->size, GACC_STORE);
++=======
+ 			r = check_gva_range(vcpu, mop->gaddr, mop->ar, mop->size,
+ 					    GACC_STORE, mop->key);
++>>>>>>> e9e9feebcbc1 (KVM: s390: Add optional storage key checking to MEMOP IOCTL)
  			break;
  		}
  		if (copy_from_user(tmpbuf, uaddr, mop->size)) {
* Unmerged path arch/s390/kvm/kvm-s390.c
diff --git a/include/uapi/linux/kvm.h b/include/uapi/linux/kvm.h
index 610460f79466..5128a3e948b6 100644
--- a/include/uapi/linux/kvm.h
+++ b/include/uapi/linux/kvm.h
@@ -544,7 +544,10 @@ struct kvm_s390_mem_op {
 	__u32 op;		/* type of operation */
 	__u64 buf;		/* buffer in userspace */
 	union {
-		__u8 ar;	/* the access register number */
+		struct {
+			__u8 ar;	/* the access register number */
+			__u8 key;	/* access key, ignored if flag unset */
+		};
 		__u32 sida_offset; /* offset into the sida */
 		__u8 reserved[32]; /* should be set to 0 */
 	};
@@ -557,6 +560,7 @@ struct kvm_s390_mem_op {
 /* flags for kvm_s390_mem_op->flags */
 #define KVM_S390_MEMOP_F_CHECK_ONLY		(1ULL << 0)
 #define KVM_S390_MEMOP_F_INJECT_EXCEPTION	(1ULL << 1)
+#define KVM_S390_MEMOP_F_SKEY_PROTECTION	(1ULL << 2)
 
 /* for KVM_INTERRUPT */
 struct kvm_interrupt {
