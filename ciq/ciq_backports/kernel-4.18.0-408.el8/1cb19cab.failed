thermal: intel: hfi: Minimally initialize the Hardware Feedback Interface

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Ricardo Neri <ricardo.neri-calderon@linux.intel.com>
commit 1cb19cabeb0e187b6c244d0da73d27f7432c40dc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/1cb19cab.failed

The Intel Hardware Feedback Interface provides guidance to the operating
system about the performance and energy efficiency capabilities of each
CPU in the system. Capabilities are numbers between 0 and 255 where a
higher number represents a higher capability. For each CPU, energy
efficiency and performance are reported as separate capabilities.

Hardware computes these capabilities based on the operating conditions of
the system such as power and thermal limits. These capabilities are shared
with the operating system in a table resident in memory. Each package in
the system has its own HFI instance. Every logical CPU in the package is
represented in the table. More than one logical CPUs may be represented in
a single table entry. When the hardware updates the table, it generates a
package-level thermal interrupt.

The size and format of the HFI table depend on the supported features and
can only be determined at runtime. To minimally initialize the HFI, parse
its features and allocate one instance per package of a data structure with
the necessary parameters to read and navigate a local copy (i.e., owned by
the driver) of individual HFI tables.

A subsequent changeset will provide per-CPU initialization and interrupt
handling.

	Reviewed-by: Len Brown <len.brown@intel.com>
Co-developed by: Aubrey Li <aubrey.li@linux.intel.com>
	Signed-off-by: Aubrey Li <aubrey.li@linux.intel.com>
	Signed-off-by: Ricardo Neri <ricardo.neri-calderon@linux.intel.com>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 1cb19cabeb0e187b6c244d0da73d27f7432c40dc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/cpu/mce/therm_throt.c
#	drivers/thermal/intel/Kconfig
#	drivers/thermal/intel/Makefile
diff --cc arch/x86/kernel/cpu/mce/therm_throt.c
index ee229ceee745,ac408714d52b..000000000000
--- a/arch/x86/kernel/cpu/mce/therm_throt.c
+++ b/arch/x86/kernel/cpu/mce/therm_throt.c
@@@ -25,11 -26,14 +25,17 @@@
  #include <linux/cpu.h>
  
  #include <asm/processor.h>
 -#include <asm/thermal.h>
  #include <asm/traps.h>
  #include <asm/apic.h>
 -#include <asm/irq.h>
 +#include <asm/mce.h>
  #include <asm/msr.h>
++<<<<<<< HEAD:arch/x86/kernel/cpu/mce/therm_throt.c
 +#include <asm/trace/irq_vectors.h>
++=======
+ 
+ #include "intel_hfi.h"
+ #include "thermal_interrupt.h"
++>>>>>>> 1cb19cabeb0e (thermal: intel: hfi: Minimally initialize the Hardware Feedback Interface):drivers/thermal/intel/therm_throt.c
  
  /* How long to wait between reporting thermal events */
  #define CHECK_INTERVAL		(300 * HZ)
diff --cc drivers/thermal/intel/Kconfig
index ba3c1c5fe76d,e9d2925227d4..000000000000
--- a/drivers/thermal/intel/Kconfig
+++ b/drivers/thermal/intel/Kconfig
@@@ -76,3 -79,35 +76,38 @@@ config INTEL_PCH_THERMA
  	  Enable this to support thermal reporting on certain intel PCHs.
  	  Thermal reporting device will provide temperature reading,
  	  programmable trip points and other information.
++<<<<<<< HEAD
++=======
+ 
+ config INTEL_TCC_COOLING
+ 	tristate "Intel TCC offset cooling Driver"
+ 	depends on X86
+ 	help
+ 	  Enable this to support system cooling by adjusting the effective TCC
+ 	  activation temperature via the TCC Offset register, which is widely
+ 	  supported on modern Intel platforms.
+ 	  Note that, on different platforms, the behavior might be different
+ 	  on how fast the setting takes effect, and how much the CPU frequency
+ 	  is reduced.
+ 
+ config INTEL_MENLOW
+ 	tristate "Thermal Management driver for Intel menlow platform"
+ 	depends on ACPI_THERMAL
+ 	help
+ 	  ACPI thermal management enhancement driver on
+ 	  Intel Menlow platform.
+ 
+ 	  If unsure, say N.
+ 
+ config INTEL_HFI_THERMAL
+ 	bool "Intel Hardware Feedback Interface"
+ 	depends on CPU_SUP_INTEL
+ 	depends on X86_THERMAL_VECTOR
+ 	help
+ 	  Select this option to enable the Hardware Feedback Interface. If
+ 	  selected, hardware provides guidance to the operating system on
+ 	  the performance and energy efficiency capabilities of each CPU.
+ 	  These capabilities may change as a result of changes in the operating
+ 	  conditions of the system such power and thermal limits. If selected,
+ 	  the kernel relays updates in CPUs' capabilities to userspace.
++>>>>>>> 1cb19cabeb0e (thermal: intel: hfi: Minimally initialize the Hardware Feedback Interface)
diff --cc drivers/thermal/intel/Makefile
index 0d9736ced5d4,9a8d8054f316..000000000000
--- a/drivers/thermal/intel/Makefile
+++ b/drivers/thermal/intel/Makefile
@@@ -10,3 -10,7 +10,10 @@@ obj-$(CONFIG_INTEL_QUARK_DTS_THERMAL)	+
  obj-$(CONFIG_INT340X_THERMAL)  += int340x_thermal/
  obj-$(CONFIG_INTEL_BXT_PMIC_THERMAL) += intel_bxt_pmic_thermal.o
  obj-$(CONFIG_INTEL_PCH_THERMAL)	+= intel_pch_thermal.o
++<<<<<<< HEAD
++=======
+ obj-$(CONFIG_INTEL_TCC_COOLING)	+= intel_tcc_cooling.o
+ obj-$(CONFIG_X86_THERMAL_VECTOR) += therm_throt.o
+ obj-$(CONFIG_INTEL_MENLOW)	+= intel_menlow.o
+ obj-$(CONFIG_INTEL_HFI_THERMAL) += intel_hfi.o
++>>>>>>> 1cb19cabeb0e (thermal: intel: hfi: Minimally initialize the Hardware Feedback Interface)
* Unmerged path arch/x86/kernel/cpu/mce/therm_throt.c
* Unmerged path drivers/thermal/intel/Kconfig
* Unmerged path drivers/thermal/intel/Makefile
diff --git a/drivers/thermal/intel/intel_hfi.c b/drivers/thermal/intel/intel_hfi.c
new file mode 100644
index 000000000000..969f4a150973
--- /dev/null
+++ b/drivers/thermal/intel/intel_hfi.c
@@ -0,0 +1,181 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Hardware Feedback Interface Driver
+ *
+ * Copyright (c) 2021, Intel Corporation.
+ *
+ * Authors: Aubrey Li <aubrey.li@linux.intel.com>
+ *          Ricardo Neri <ricardo.neri-calderon@linux.intel.com>
+ *
+ *
+ * The Hardware Feedback Interface provides a performance and energy efficiency
+ * capability information for each CPU in the system. Depending on the processor
+ * model, hardware may periodically update these capabilities as a result of
+ * changes in the operating conditions (e.g., power limits or thermal
+ * constraints). On other processor models, there is a single HFI update
+ * at boot.
+ *
+ * This file provides functionality to process HFI updates and relay these
+ * updates to userspace.
+ */
+
+#define pr_fmt(fmt)  "intel-hfi: " fmt
+
+#include <linux/bitops.h>
+#include <linux/cpufeature.h>
+#include <linux/math.h>
+#include <linux/printk.h>
+#include <linux/processor.h>
+#include <linux/slab.h>
+#include <linux/topology.h>
+
+#include "intel_hfi.h"
+
+/* CPUID detection and enumeration definitions for HFI */
+
+#define CPUID_HFI_LEAF 6
+
+union hfi_capabilities {
+	struct {
+		u8	performance:1;
+		u8	energy_efficiency:1;
+		u8	__reserved:6;
+	} split;
+	u8 bits;
+};
+
+union cpuid6_edx {
+	struct {
+		union hfi_capabilities	capabilities;
+		u32			table_pages:4;
+		u32			__reserved:4;
+		s32			index:16;
+	} split;
+	u32 full;
+};
+
+/**
+ * struct hfi_cpu_data - HFI capabilities per CPU
+ * @perf_cap:		Performance capability
+ * @ee_cap:		Energy efficiency capability
+ *
+ * Capabilities of a logical processor in the HFI table. These capabilities are
+ * unitless.
+ */
+struct hfi_cpu_data {
+	u8	perf_cap;
+	u8	ee_cap;
+} __packed;
+
+/**
+ * struct hfi_hdr - Header of the HFI table
+ * @perf_updated:	Hardware updated performance capabilities
+ * @ee_updated:		Hardware updated energy efficiency capabilities
+ *
+ * Properties of the data in an HFI table.
+ */
+struct hfi_hdr {
+	u8	perf_updated;
+	u8	ee_updated;
+} __packed;
+
+/**
+ * struct hfi_instance - Representation of an HFI instance (i.e., a table)
+ * @local_table:	Base of the local copy of the HFI table
+ * @timestamp:		Timestamp of the last update of the local table.
+ *			Located at the base of the local table.
+ * @hdr:		Base address of the header of the local table
+ * @data:		Base address of the data of the local table
+ *
+ * A set of parameters to parse and navigate a specific HFI table.
+ */
+struct hfi_instance {
+	union {
+		void			*local_table;
+		u64			*timestamp;
+	};
+	void			*hdr;
+	void			*data;
+};
+
+/**
+ * struct hfi_features - Supported HFI features
+ * @nr_table_pages:	Size of the HFI table in 4KB pages
+ * @cpu_stride:		Stride size to locate the capability data of a logical
+ *			processor within the table (i.e., row stride)
+ * @hdr_size:		Size of the table header
+ *
+ * Parameters and supported features that are common to all HFI instances
+ */
+struct hfi_features {
+	unsigned int	nr_table_pages;
+	unsigned int	cpu_stride;
+	unsigned int	hdr_size;
+};
+
+static int max_hfi_instances;
+static struct hfi_instance *hfi_instances;
+
+static struct hfi_features hfi_features;
+
+static __init int hfi_parse_features(void)
+{
+	unsigned int nr_capabilities;
+	union cpuid6_edx edx;
+
+	if (!boot_cpu_has(X86_FEATURE_HFI))
+		return -ENODEV;
+
+	/*
+	 * If we are here we know that CPUID_HFI_LEAF exists. Parse the
+	 * supported capabilities and the size of the HFI table.
+	 */
+	edx.full = cpuid_edx(CPUID_HFI_LEAF);
+
+	if (!edx.split.capabilities.split.performance) {
+		pr_debug("Performance reporting not supported! Not using HFI\n");
+		return -ENODEV;
+	}
+
+	/*
+	 * The number of supported capabilities determines the number of
+	 * columns in the HFI table. Exclude the reserved bits.
+	 */
+	edx.split.capabilities.split.__reserved = 0;
+	nr_capabilities = hweight8(edx.split.capabilities.bits);
+
+	/* The number of 4KB pages required by the table */
+	hfi_features.nr_table_pages = edx.split.table_pages + 1;
+
+	/*
+	 * The header contains change indications for each supported feature.
+	 * The size of the table header is rounded up to be a multiple of 8
+	 * bytes.
+	 */
+	hfi_features.hdr_size = DIV_ROUND_UP(nr_capabilities, 8) * 8;
+
+	/*
+	 * Data of each logical processor is also rounded up to be a multiple
+	 * of 8 bytes.
+	 */
+	hfi_features.cpu_stride = DIV_ROUND_UP(nr_capabilities, 8) * 8;
+
+	return 0;
+}
+
+void __init intel_hfi_init(void)
+{
+	if (hfi_parse_features())
+		return;
+
+	/* There is one HFI instance per die/package. */
+	max_hfi_instances = topology_max_packages() *
+			    topology_max_die_per_package();
+
+	/*
+	 * This allocation may fail. CPU hotplug callbacks must check
+	 * for a null pointer.
+	 */
+	hfi_instances = kcalloc(max_hfi_instances, sizeof(*hfi_instances),
+				GFP_KERNEL);
+}
diff --git a/drivers/thermal/intel/intel_hfi.h b/drivers/thermal/intel/intel_hfi.h
new file mode 100644
index 000000000000..05f748b48a4e
--- /dev/null
+++ b/drivers/thermal/intel/intel_hfi.h
@@ -0,0 +1,11 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef _INTEL_HFI_H
+#define _INTEL_HFI_H
+
+#if defined(CONFIG_INTEL_HFI_THERMAL)
+void __init intel_hfi_init(void);
+#else
+static inline void intel_hfi_init(void) { }
+#endif /* CONFIG_INTEL_HFI_THERMAL */
+
+#endif /* _INTEL_HFI_H */
