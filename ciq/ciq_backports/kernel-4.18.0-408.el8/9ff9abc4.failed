selinux: move policy mutex to selinux_state, use in lockdep checks

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Stephen Smalley <stephen.smalley.work@gmail.com>
commit 9ff9abc4c6be27ff27b6df625501a46711730520
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/9ff9abc4.failed

Move the mutex used to synchronize policy changes (reloads and setting
of booleans) from selinux_fs_info to selinux_state and use it in
lockdep checks for rcu_dereference_protected() calls in the security
server functions.  This makes the dependency on the mutex explicit
in the code rather than relying on comments.

	Signed-off-by: Stephen Smalley <stephen.smalley.work@gmail.com>
	Reviewed-by: Ondrej Mosnacek <omosnace@redhat.com>
	Signed-off-by: Paul Moore <paul@paul-moore.com>
(cherry picked from commit 9ff9abc4c6be27ff27b6df625501a46711730520)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	security/selinux/include/security.h
#	security/selinux/ss/services.c
diff --cc security/selinux/include/security.h
index aedc0702f5dd,bbbf7141ccdb..000000000000
--- a/security/selinux/include/security.h
+++ b/security/selinux/include/security.h
@@@ -118,10 -102,10 +118,15 @@@ struct selinux_state 
  	struct mutex status_lock;
  
  	struct selinux_avc *avc;
++<<<<<<< HEAD
 +	struct selinux_ss *ss;
++=======
+ 	struct selinux_policy __rcu *policy;
+ 	struct mutex policy_mutex;
++>>>>>>> 9ff9abc4c6be (selinux: move policy mutex to selinux_state, use in lockdep checks)
  } __randomize_layout;
  
 +void selinux_ss_init(struct selinux_ss **ss);
  void selinux_avc_init(struct selinux_avc **avc);
  
  extern struct selinux_state selinux_state;
diff --cc security/selinux/ss/services.c
index 45cded883bbc,85cfd46836c7..000000000000
--- a/security/selinux/ss/services.c
+++ b/security/selinux/ss/services.c
@@@ -2147,8 -2161,12 +2147,15 @@@ static void selinux_policy_free(struct 
  void selinux_policy_cancel(struct selinux_state *state,
  			struct selinux_policy *policy)
  {
 -	struct selinux_policy *oldpolicy;
  
++<<<<<<< HEAD
 +	sidtab_cancel_convert(&state->ss->policy->sidtab);
++=======
+ 	oldpolicy = rcu_dereference_protected(state->policy,
+ 					lockdep_is_held(&state->policy_mutex));
+ 
+ 	sidtab_cancel_convert(oldpolicy->sidtab);
++>>>>>>> 9ff9abc4c6be (selinux: move policy mutex to selinux_state, use in lockdep checks)
  	selinux_policy_free(policy);
  }
  
@@@ -2158,15 -2187,10 +2165,20 @@@ void selinux_policy_commit(struct selin
  	struct selinux_policy *oldpolicy;
  	u32 seqno;
  
++<<<<<<< HEAD
 +	/*
 +	 * NOTE: We do not need to take the policy read-lock
 +	 * around the code below because other policy-modifying
 +	 * operations are already excluded by selinuxfs via
 +	 * fsi->mutex.
 +	 */
++=======
+ 	oldpolicy = rcu_dereference_protected(state->policy,
+ 					lockdep_is_held(&state->policy_mutex));
++>>>>>>> 9ff9abc4c6be (selinux: move policy mutex to selinux_state, use in lockdep checks)
  
  	/* If switching between different policy types, log MLS status */
 +	oldpolicy = state->ss->policy;
  	if (oldpolicy) {
  		if (oldpolicy->policydb.mls_enabled && !newpolicy->policydb.mls_enabled)
  			pr_info("SELinux: Disabling MLS support...\n");
@@@ -2250,11 -2281,14 +2262,17 @@@ int security_load_policy(struct selinux
  		return 0;
  	}
  
++<<<<<<< HEAD
++=======
+ 	oldpolicy = rcu_dereference_protected(state->policy,
+ 					lockdep_is_held(&state->policy_mutex));
+ 
++>>>>>>> 9ff9abc4c6be (selinux: move policy mutex to selinux_state, use in lockdep checks)
  	/* Preserve active boolean values from the old policy */
 -	rc = security_preserve_bools(oldpolicy, newpolicy);
 +	rc = security_preserve_bools(state, &newpolicy->policydb);
  	if (rc) {
  		pr_err("SELinux:  unable to preserve booleans\n");
 -		goto err_free_isids;
 +		goto err;
  	}
  
  	/*
@@@ -2902,65 -2991,73 +2920,80 @@@ err
  
  int security_set_bools(struct selinux_state *state, u32 len, int *values)
  {
 -	struct selinux_policy *newpolicy, *oldpolicy;
 +	struct policydb *policydb;
  	int rc;
 -	u32 i, seqno = 0;
 +	u32 i, lenp, seqno = 0;
 +	char **changed_names;
  
++<<<<<<< HEAD
 +	changed_names = kcalloc(len, sizeof(*changed_names), GFP_KERNEL);
 +	if (!changed_names)
++=======
+ 	if (!selinux_initialized(state))
+ 		return -EINVAL;
+ 
+ 	oldpolicy = rcu_dereference_protected(state->policy,
+ 					lockdep_is_held(&state->policy_mutex));
+ 
+ 	/* Consistency check on number of booleans, should never fail */
+ 	if (WARN_ON(len != oldpolicy->policydb.p_bools.nprim))
+ 		return -EINVAL;
+ 
+ 	newpolicy = kmemdup(oldpolicy, sizeof(*newpolicy), GFP_KERNEL);
+ 	if (!newpolicy)
++>>>>>>> 9ff9abc4c6be (selinux: move policy mutex to selinux_state, use in lockdep checks)
  		return -ENOMEM;
  
 -	/*
 -	 * Deep copy only the parts of the policydb that might be
 -	 * modified as a result of changing booleans.
 -	 */
 -	rc = cond_policydb_dup(&newpolicy->policydb, &oldpolicy->policydb);
 -	if (rc) {
 -		kfree(newpolicy);
 -		return -ENOMEM;
 -	}
 +	write_lock_irq(&state->ss->policy_rwlock);
 +
 +	policydb = &state->ss->policy->policydb;
 +
 +	rc = -EFAULT;
 +	lenp = policydb->p_bools.nprim;
 +	if (len != lenp)
 +		goto out;
  
 -	/* Update the boolean states in the copy */
  	for (i = 0; i < len; i++) {
 -		int new_state = !!values[i];
 -		int old_state = newpolicy->policydb.bool_val_to_struct[i]->state;
 -
 -		if (new_state != old_state) {
 -			audit_log(audit_context(), GFP_ATOMIC,
 -				AUDIT_MAC_CONFIG_CHANGE,
 -				"bool=%s val=%d old_val=%d auid=%u ses=%u",
 -				sym_name(&newpolicy->policydb, SYM_BOOLS, i),
 -				new_state,
 -				old_state,
 -				from_kuid(&init_user_ns, audit_get_loginuid(current)),
 -				audit_get_sessionid(current));
 -			newpolicy->policydb.bool_val_to_struct[i]->state = new_state;
 +		if (!!values[i] != policydb->bool_val_to_struct[i]->state) {
 +			changed_names[i] = kstrdup(sym_name(policydb, SYM_BOOLS, i),
 +						   GFP_ATOMIC);
 +			if (!changed_names[i]) {
 +				rc = -ENOMEM;
 +				goto out;
 +			}
  		}
 +		if (values[i])
 +			policydb->bool_val_to_struct[i]->state = 1;
 +		else
 +			policydb->bool_val_to_struct[i]->state = 0;
  	}
  
 -	/* Re-evaluate the conditional rules in the copy */
 -	evaluate_cond_nodes(&newpolicy->policydb);
 -
 -	/* Set latest granting seqno for new policy */
 -	newpolicy->latest_granting = oldpolicy->latest_granting + 1;
 -	seqno = newpolicy->latest_granting;
 -
 -	/* Install the new policy */
 -	rcu_assign_pointer(state->policy, newpolicy);
 -
 -	/*
 -	 * Free the conditional portions of the old policydb
 -	 * that were copied for the new policy, and the oldpolicy
 -	 * structure itself but not what it references.
 -	 */
 -	synchronize_rcu();
 -	selinux_policy_cond_free(oldpolicy);
 +	evaluate_cond_nodes(policydb);
  
 -	/* Notify others of the policy change */
 -	selinux_notify_policy_change(state, seqno);
 -	return 0;
 +	seqno = ++state->ss->latest_granting;
 +	rc = 0;
 +out:
 +	write_unlock_irq(&state->ss->policy_rwlock);
 +	if (!rc) {
 +		for (i = 0; i < len; i++) {
 +			if (changed_names[i]) {
 +				audit_log(audit_context(), GFP_KERNEL,
 +					AUDIT_MAC_CONFIG_CHANGE,
 +					"bool=%s val=%d old_val=%d auid=%u ses=%u",
 +					changed_names[i], !!values[i], !values[i],
 +					from_kuid(&init_user_ns, audit_get_loginuid(current)),
 +					audit_get_sessionid(current));
 +			}
 +		}
 +		avc_ss_reset(state->avc, seqno);
 +		selnl_notify_policyload(seqno);
 +		selinux_status_update_policyload(state, seqno);
 +		selinux_xfrm_notify_policyload();
 +	}
 +	for (i = 0; i < len; i++)
 +		kfree(changed_names[i]);
 +	kfree(changed_names);
 +	return rc;
  }
  
  int security_get_bool_value(struct selinux_state *state,
diff --git a/security/selinux/hooks.c b/security/selinux/hooks.c
index 523d4e774f87..384ef67557ed 100644
--- a/security/selinux/hooks.c
+++ b/security/selinux/hooks.c
@@ -7230,6 +7230,7 @@ static __init int selinux_init(void)
 	selinux_ss_init(&selinux_state.ss);
 	selinux_avc_init(&selinux_state.avc);
 	mutex_init(&selinux_state.status_lock);
+	mutex_init(&selinux_state.policy_mutex);
 
 	/* Set the security state for the initial task. */
 	cred_init_security();
* Unmerged path security/selinux/include/security.h
diff --git a/security/selinux/selinuxfs.c b/security/selinux/selinuxfs.c
index 6fc0621023f4..c04dab6e89f5 100644
--- a/security/selinux/selinuxfs.c
+++ b/security/selinux/selinuxfs.c
@@ -77,7 +77,6 @@ struct selinux_fs_info {
 	unsigned long last_class_ino;
 	bool policy_opened;
 	struct dentry *policycap_dir;
-	struct mutex mutex;
 	unsigned long last_ino;
 	struct selinux_state *state;
 	struct super_block *sb;
@@ -91,7 +90,6 @@ static int selinux_fs_info_create(struct super_block *sb)
 	if (!fsi)
 		return -ENOMEM;
 
-	mutex_init(&fsi->mutex);
 	fsi->last_ino = SEL_INO_NEXT - 1;
 	fsi->state = &selinux_state;
 	fsi->sb = sb;
@@ -395,7 +393,7 @@ static int sel_open_policy(struct inode *inode, struct file *filp)
 
 	BUG_ON(filp->private_data);
 
-	mutex_lock(&fsi->mutex);
+	mutex_lock(&fsi->state->policy_mutex);
 
 	rc = avc_has_perm(&selinux_state,
 			  current_sid(), SECINITSID_SECURITY,
@@ -426,11 +424,11 @@ static int sel_open_policy(struct inode *inode, struct file *filp)
 
 	filp->private_data = plm;
 
-	mutex_unlock(&fsi->mutex);
+	mutex_unlock(&fsi->state->policy_mutex);
 
 	return 0;
 err:
-	mutex_unlock(&fsi->mutex);
+	mutex_unlock(&fsi->state->policy_mutex);
 
 	if (plm)
 		vfree(plm->data);
@@ -617,7 +615,7 @@ static ssize_t sel_write_load(struct file *file, const char __user *buf,
 	ssize_t length;
 	void *data = NULL;
 
-	mutex_lock(&fsi->mutex);
+	mutex_lock(&fsi->state->policy_mutex);
 
 	length = avc_has_perm(&selinux_state,
 			      current_sid(), SECINITSID_SECURITY,
@@ -661,7 +659,7 @@ static ssize_t sel_write_load(struct file *file, const char __user *buf,
 		from_kuid(&init_user_ns, audit_get_loginuid(current)),
 		audit_get_sessionid(current));
 out:
-	mutex_unlock(&fsi->mutex);
+	mutex_unlock(&fsi->state->policy_mutex);
 	vfree(data);
 	return length;
 }
@@ -1258,7 +1256,7 @@ static ssize_t sel_read_bool(struct file *filep, char __user *buf,
 	unsigned index = file_inode(filep)->i_ino & SEL_INO_MASK;
 	const char *name = filep->f_path.dentry->d_name.name;
 
-	mutex_lock(&fsi->mutex);
+	mutex_lock(&fsi->state->policy_mutex);
 
 	ret = -EINVAL;
 	if (index >= fsi->bool_num || strcmp(name,
@@ -1277,14 +1275,14 @@ static ssize_t sel_read_bool(struct file *filep, char __user *buf,
 	}
 	length = scnprintf(page, PAGE_SIZE, "%d %d", cur_enforcing,
 			  fsi->bool_pending_values[index]);
-	mutex_unlock(&fsi->mutex);
+	mutex_unlock(&fsi->state->policy_mutex);
 	ret = simple_read_from_buffer(buf, count, ppos, page, length);
 out_free:
 	free_page((unsigned long)page);
 	return ret;
 
 out_unlock:
-	mutex_unlock(&fsi->mutex);
+	mutex_unlock(&fsi->state->policy_mutex);
 	goto out_free;
 }
 
@@ -1309,7 +1307,7 @@ static ssize_t sel_write_bool(struct file *filep, const char __user *buf,
 	if (IS_ERR(page))
 		return PTR_ERR(page);
 
-	mutex_lock(&fsi->mutex);
+	mutex_lock(&fsi->state->policy_mutex);
 
 	length = avc_has_perm(&selinux_state,
 			      current_sid(), SECINITSID_SECURITY,
@@ -1334,7 +1332,7 @@ static ssize_t sel_write_bool(struct file *filep, const char __user *buf,
 	length = count;
 
 out:
-	mutex_unlock(&fsi->mutex);
+	mutex_unlock(&fsi->state->policy_mutex);
 	kfree(page);
 	return length;
 }
@@ -1365,7 +1363,7 @@ static ssize_t sel_commit_bools_write(struct file *filep,
 	if (IS_ERR(page))
 		return PTR_ERR(page);
 
-	mutex_lock(&fsi->mutex);
+	mutex_lock(&fsi->state->policy_mutex);
 
 	length = avc_has_perm(&selinux_state,
 			      current_sid(), SECINITSID_SECURITY,
@@ -1387,7 +1385,7 @@ static ssize_t sel_commit_bools_write(struct file *filep,
 		length = count;
 
 out:
-	mutex_unlock(&fsi->mutex);
+	mutex_unlock(&fsi->state->policy_mutex);
 	kfree(page);
 	return length;
 }
* Unmerged path security/selinux/ss/services.c
