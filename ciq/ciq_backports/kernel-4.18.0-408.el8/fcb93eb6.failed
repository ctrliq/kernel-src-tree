kvm: x86/mmu: Flush TLB before zap_gfn_range releases RCU

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Paolo Bonzini <pbonzini@redhat.com>
commit fcb93eb6d09dd302cbef22bd95a5858af75e4156
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/fcb93eb6.failed

Since "KVM: x86/mmu: Zap only TDP MMU leafs in kvm_zap_gfn_range()"
is going to be reverted, it's not going to be true anymore that
the zap-page flow does not free any 'struct kvm_mmu_page'.  Introduce
an early flush before tdp_mmu_zap_leafs() returns, to preserve
bisectability.

	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit fcb93eb6d09dd302cbef22bd95a5858af75e4156)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/mmu/tdp_mmu.c
diff --cc arch/x86/kvm/mmu/tdp_mmu.c
index 97bb57fe39ca,7f63e1a704e3..000000000000
--- a/arch/x86/kvm/mmu/tdp_mmu.c
+++ b/arch/x86/kvm/mmu/tdp_mmu.c
@@@ -744,8 -941,17 +744,21 @@@ static bool zap_gfn_range(struct kvm *k
  		flush = true;
  	}
  
+ 	/*
+ 	 * Need to flush before releasing RCU.  TODO: do it only if intermediate
+ 	 * page tables were zapped; there is no need to flush under RCU protection
+ 	 * if no 'struct kvm_mmu_page' is freed.
+ 	 */
+ 	if (flush)
+ 		kvm_flush_remote_tlbs_with_address(kvm, start, end - start);
+ 
  	rcu_read_unlock();
++<<<<<<< HEAD
 +	return flush;
++=======
+ 
+ 	return false;
++>>>>>>> fcb93eb6d09d (kvm: x86/mmu: Flush TLB before zap_gfn_range releases RCU)
  }
  
  /*
* Unmerged path arch/x86/kvm/mmu/tdp_mmu.c
