x86/sgx: Add an attribute for the amount of SGX memory in a NUMA node

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Jarkko Sakkinen <jarkko@kernel.org>
commit 50468e4313355b161cac8a5155a45832995b7f25
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/50468e43.failed

== Problem ==

The amount of SGX memory on a system is determined by the BIOS and it
varies wildly between systems.  It can be as small as dozens of MB's
and as large as many GB's on servers.  Just like how applications need
to know how much regular RAM is available, enclave builders need to
know how much SGX memory an enclave can consume.

== Solution ==

Introduce a new sysfs file:

	/sys/devices/system/node/nodeX/x86/sgx_total_bytes

to enumerate the amount of SGX memory available in each NUMA node.
This serves the same function for SGX as /proc/meminfo or
/sys/devices/system/node/nodeX/meminfo does for normal RAM.

'sgx_total_bytes' is needed today to help drive the SGX selftests.
SGX-specific swap code is exercised by creating overcommitted enclaves
which are larger than the physical SGX memory on the system.  They
currently use a CPUID-based approach which can diverge from the actual
amount of SGX memory available.  'sgx_total_bytes' ensures that the
selftests can work efficiently and do not attempt stupid things like
creating a 100,000 MB enclave on a system with 128 MB of SGX memory.

== Implementation Details ==

Introduce CONFIG_HAVE_ARCH_NODE_DEV_GROUP opt-in flag to expose an
arch specific attribute group, and add an attribute for the amount of
SGX memory in bytes to each NUMA node:

== ABI Design Discussion ==

As opposed to the per-node ABI, a single, global ABI was considered.
However, this would prevent enclaves from being able to size
themselves so that they fit on a single NUMA node.  Essentially, a
single value would rule out NUMA optimizations for enclaves.

Create a new "x86/" directory inside each "nodeX/" sysfs directory.
'sgx_total_bytes' is expected to be the first of at least a few
sgx-specific files to be placed in the new directory.  Just scanning
/proc/meminfo, these are the no-brainers that we have for RAM, but we
need for SGX:

	MemTotal:       xxxx kB // sgx_total_bytes (implemented here)
	MemFree:        yyyy kB // sgx_free_bytes
	SwapTotal:      zzzz kB // sgx_swapped_bytes

So, at *least* three.  I think we will eventually end up needing
something more along the lines of a dozen.  A new directory (as
opposed to being in the nodeX/ "root") directory avoids cluttering the
root with several "sgx_*" files.

Place the new file in a new "nodeX/x86/" directory because SGX is
highly x86-specific.  It is very unlikely that any other architecture
(or even non-Intel x86 vendor) will ever implement SGX.  Using "sgx/"
as opposed to "x86/" was also considered.  But, there is a real chance
this can get used for other arch-specific purposes.

[ dhansen: rewrite changelog ]

	Signed-off-by: Jarkko Sakkinen <jarkko@kernel.org>
	Signed-off-by: Dave Hansen <dave.hansen@linux.intel.com>
	Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
	Acked-by: Borislav Petkov <bp@suse.de>
Link: https://lkml.kernel.org/r/20211116162116.93081-2-jarkko@kernel.org
(cherry picked from commit 50468e4313355b161cac8a5155a45832995b7f25)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/Kconfig
diff --cc arch/Kconfig
index d1c597007aaa,0a9dadb00b61..000000000000
--- a/arch/Kconfig
+++ b/arch/Kconfig
@@@ -1077,4 -1203,111 +1077,110 @@@ config HAVE_ARCH_COMPILER_
  	  linux/compiler-*.h in order to override macro definitions that those
  	  headers generally provide.
  
++<<<<<<< HEAD
++=======
+ config HAVE_ARCH_PREL32_RELOCATIONS
+ 	bool
+ 	help
+ 	  May be selected by an architecture if it supports place-relative
+ 	  32-bit relocations, both in the toolchain and in the module loader,
+ 	  in which case relative references can be used in special sections
+ 	  for PCI fixup, initcalls etc which are only half the size on 64 bit
+ 	  architectures, and don't require runtime relocation on relocatable
+ 	  kernels.
+ 
+ config ARCH_USE_MEMREMAP_PROT
+ 	bool
+ 
+ config LOCK_EVENT_COUNTS
+ 	bool "Locking event counts collection"
+ 	depends on DEBUG_FS
+ 	help
+ 	  Enable light-weight counting of various locking related events
+ 	  in the system with minimal performance impact. This reduces
+ 	  the chance of application behavior change because of timing
+ 	  differences. The counts are reported via debugfs.
+ 
+ # Select if the architecture has support for applying RELR relocations.
+ config ARCH_HAS_RELR
+ 	bool
+ 
+ config RELR
+ 	bool "Use RELR relocation packing"
+ 	depends on ARCH_HAS_RELR && TOOLS_SUPPORT_RELR
+ 	default y
+ 	help
+ 	  Store the kernel's dynamic relocations in the RELR relocation packing
+ 	  format. Requires a compatible linker (LLD supports this feature), as
+ 	  well as compatible NM and OBJCOPY utilities (llvm-nm and llvm-objcopy
+ 	  are compatible).
+ 
+ config ARCH_HAS_MEM_ENCRYPT
+ 	bool
+ 
+ config ARCH_HAS_CC_PLATFORM
+ 	bool
+ 
+ config HAVE_SPARSE_SYSCALL_NR
+        bool
+        help
+           An architecture should select this if its syscall numbering is sparse
+ 	  to save space. For example, MIPS architecture has a syscall array with
+ 	  entries at 4000, 5000 and 6000 locations. This option turns on syscall
+ 	  related optimizations for a given architecture.
+ 
+ config ARCH_HAS_VDSO_DATA
+ 	bool
+ 
+ config HAVE_STATIC_CALL
+ 	bool
+ 
+ config HAVE_STATIC_CALL_INLINE
+ 	bool
+ 	depends on HAVE_STATIC_CALL
+ 
+ config HAVE_PREEMPT_DYNAMIC
+ 	bool
+ 	depends on HAVE_STATIC_CALL
+ 	depends on GENERIC_ENTRY
+ 	help
+ 	   Select this if the architecture support boot time preempt setting
+ 	   on top of static calls. It is strongly advised to support inline
+ 	   static call to avoid any overhead.
+ 
+ config ARCH_WANT_LD_ORPHAN_WARN
+ 	bool
+ 	help
+ 	  An arch should select this symbol once all linker sections are explicitly
+ 	  included, size-asserted, or discarded in the linker scripts. This is
+ 	  important because we never want expected sections to be placed heuristically
+ 	  by the linker, since the locations of such sections can change between linker
+ 	  versions.
+ 
+ config HAVE_ARCH_PFN_VALID
+ 	bool
+ 
+ config ARCH_SUPPORTS_DEBUG_PAGEALLOC
+ 	bool
+ 
+ config ARCH_SPLIT_ARG64
+ 	bool
+ 	help
+ 	   If a 32-bit architecture requires 64-bit arguments to be split into
+ 	   pairs of 32-bit arguments, select this option.
+ 
+ config ARCH_HAS_ELFCORE_COMPAT
+ 	bool
+ 
+ config ARCH_HAS_PARANOID_L1D_FLUSH
+ 	bool
+ 
+ config DYNAMIC_SIGFRAME
+ 	bool
+ 
+ # Select, if arch has a named attribute group bound to NUMA device nodes.
+ config HAVE_ARCH_NODE_DEV_GROUP
+ 	bool
+ 
++>>>>>>> 50468e431335 (x86/sgx: Add an attribute for the amount of SGX memory in a NUMA node)
  source "kernel/gcov/Kconfig"
 -
 -source "scripts/gcc-plugins/Kconfig"
 -
 -endmenu
diff --git a/Documentation/ABI/stable/sysfs-devices-node b/Documentation/ABI/stable/sysfs-devices-node
index f7ce68fbd4b9..94d151ef5f2c 100644
--- a/Documentation/ABI/stable/sysfs-devices-node
+++ b/Documentation/ABI/stable/sysfs-devices-node
@@ -176,3 +176,9 @@ Contact:	Keith Busch <keith.busch@intel.com>
 Description:
 		The cache write policy: 0 for write-back, 1 for write-through,
 		other or unknown.
+
+What:		/sys/devices/system/node/nodeX/x86/sgx_total_bytes
+Date:		November 2021
+Contact:	Jarkko Sakkinen <jarkko@kernel.org>
+Description:
+		The total amount of SGX physical memory in bytes.
* Unmerged path arch/Kconfig
diff --git a/arch/x86/Kconfig b/arch/x86/Kconfig
index 249fb2c19ce3..0dc200d019d5 100644
--- a/arch/x86/Kconfig
+++ b/arch/x86/Kconfig
@@ -230,6 +230,7 @@ config X86
 	select HAVE_ARCH_KCSAN			if X86_64
 	select X86_FEATURE_NAMES		if PROC_FS
 	select PROC_PID_ARCH_STATUS		if PROC_FS
+	select HAVE_ARCH_NODE_DEV_GROUP		if X86_SGX
 	imply IMA_SECURE_AND_OR_TRUSTED_BOOT    if EFI
 
 config INSTRUCTION_DECODER
diff --git a/arch/x86/kernel/cpu/sgx/main.c b/arch/x86/kernel/cpu/sgx/main.c
index a7b0469d77e9..a26359a4c54d 100644
--- a/arch/x86/kernel/cpu/sgx/main.c
+++ b/arch/x86/kernel/cpu/sgx/main.c
@@ -825,9 +825,11 @@ static bool __init sgx_page_cache_init(void)
 			INIT_LIST_HEAD(&sgx_numa_nodes[nid].free_page_list);
 			INIT_LIST_HEAD(&sgx_numa_nodes[nid].sgx_poison_page_list);
 			node_set(nid, sgx_numa_mask);
+			sgx_numa_nodes[nid].size = 0;
 		}
 
 		sgx_epc_sections[i].node =  &sgx_numa_nodes[nid];
+		sgx_numa_nodes[nid].size += size;
 
 		sgx_nr_epc_sections++;
 	}
@@ -901,6 +903,24 @@ int sgx_set_attribute(unsigned long *allowed_attributes,
 }
 EXPORT_SYMBOL_GPL(sgx_set_attribute);
 
+#ifdef CONFIG_NUMA
+static ssize_t sgx_total_bytes_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return sysfs_emit(buf, "%lu\n", sgx_numa_nodes[dev->id].size);
+}
+static DEVICE_ATTR_RO(sgx_total_bytes);
+
+static struct attribute *arch_node_dev_attrs[] = {
+	&dev_attr_sgx_total_bytes.attr,
+	NULL,
+};
+
+const struct attribute_group arch_node_dev_group = {
+	.name = "x86",
+	.attrs = arch_node_dev_attrs,
+};
+#endif /* CONFIG_NUMA */
+
 static int __init sgx_init(void)
 {
 	int ret;
diff --git a/arch/x86/kernel/cpu/sgx/sgx.h b/arch/x86/kernel/cpu/sgx/sgx.h
index 9ec3136c7800..0f17def9fe6f 100644
--- a/arch/x86/kernel/cpu/sgx/sgx.h
+++ b/arch/x86/kernel/cpu/sgx/sgx.h
@@ -44,6 +44,7 @@ struct sgx_epc_page {
 struct sgx_numa_node {
 	struct list_head free_page_list;
 	struct list_head sgx_poison_page_list;
+	unsigned long size;
 	spinlock_t lock;
 };
 
diff --git a/drivers/base/node.c b/drivers/base/node.c
index 1413002c782c..937523558391 100644
--- a/drivers/base/node.c
+++ b/drivers/base/node.c
@@ -580,6 +580,9 @@ static const struct attribute_group node_dev_group = {
 
 static const struct attribute_group *node_dev_groups[] = {
 	&node_dev_group,
+#ifdef CONFIG_HAVE_ARCH_NODE_DEV_GROUP
+	&arch_node_dev_group,
+#endif
 	NULL
 };
 
diff --git a/include/linux/numa.h b/include/linux/numa.h
index a42df804679e..f8bd68110d33 100644
--- a/include/linux/numa.h
+++ b/include/linux/numa.h
@@ -41,4 +41,8 @@ static inline int phys_to_target_node(phys_addr_t addr)
 }
 #endif
 
+#ifdef CONFIG_HAVE_ARCH_NODE_DEV_GROUP
+extern const struct attribute_group arch_node_dev_group;
+#endif
+
 #endif /* _LINUX_NUMA_H */
