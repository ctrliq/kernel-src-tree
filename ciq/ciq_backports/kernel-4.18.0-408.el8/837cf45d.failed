mptcp: fix race in incoming ADD_ADDR option processing

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Paolo Abeni <pabeni@redhat.com>
commit 837cf45df163a3780bc04b555700231e95b31dc9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/837cf45d.failed

If an MPTCP endpoint received multiple consecutive incoming
ADD_ADDR options, mptcp_pm_add_addr_received() can overwrite
the current remote address value after the PM lock is released
in mptcp_pm_nl_add_addr_received() and before such address
is echoed.

Fix the issue caching the remote address value a little earlier
and always using the cached value after releasing the PM lock.

Fixes: f7efc7771eac ("mptcp: drop argument port from mptcp_pm_announce_addr")
	Reviewed-by: Matthieu Baerts <matthieu.baerts@tessares.net>
	Signed-off-by: Paolo Abeni <pabeni@redhat.com>
	Signed-off-by: Mat Martineau <mathew.j.martineau@linux.intel.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 837cf45df163a3780bc04b555700231e95b31dc9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/mptcp/pm_netlink.c
diff --cc net/mptcp/pm_netlink.c
index 2514cccb0d7a,4b5d795383cd..000000000000
--- a/net/mptcp/pm_netlink.c
+++ b/net/mptcp/pm_netlink.c
@@@ -489,8 -658,10 +489,13 @@@ static void mptcp_pm_nl_add_addr_receiv
  	struct sock *sk = (struct sock *)msk;
  	unsigned int add_addr_accept_max;
  	struct mptcp_addr_info remote;
 +	struct mptcp_addr_info local;
  	unsigned int subflows_max;
++<<<<<<< HEAD
++=======
+ 	bool reset_port = false;
+ 	int i, nr;
++>>>>>>> 837cf45df163 (mptcp: fix race in incoming ADD_ADDR option processing)
  
  	add_addr_accept_max = mptcp_pm_get_add_addr_accept_max(msk);
  	subflows_max = mptcp_pm_get_subflows_max(msk);
@@@ -499,30 -670,37 +504,52 @@@
  		 msk->pm.add_addr_accepted, add_addr_accept_max,
  		 msk->pm.remote.family);
  
- 	if (lookup_subflow_by_daddr(&msk->conn_list, &msk->pm.remote))
+ 	remote = msk->pm.remote;
+ 	if (lookup_subflow_by_daddr(&msk->conn_list, &remote))
  		goto add_addr_echo;
  
++<<<<<<< HEAD
 +	msk->pm.add_addr_accepted++;
 +	msk->pm.subflows++;
 +	if (msk->pm.add_addr_accepted >= add_addr_accept_max ||
 +	    msk->pm.subflows >= subflows_max)
 +		WRITE_ONCE(msk->pm.accept_addr, false);
++=======
+ 	/* pick id 0 port, if none is provided the remote address */
+ 	if (!remote.port) {
+ 		reset_port = true;
+ 		remote.port = sk->sk_dport;
+ 	}
++>>>>>>> 837cf45df163 (mptcp: fix race in incoming ADD_ADDR option processing)
  
  	/* connect to the specified remote address, using whatever
  	 * local address the routing configuration will pick.
  	 */
++<<<<<<< HEAD
 +	remote = msk->pm.remote;
 +	if (!remote.port)
 +		remote.port = sk->sk_dport;
 +	memset(&local, 0, sizeof(local));
 +	local.family = remote.family;
++=======
+ 	nr = fill_local_addresses_vec(msk, addrs);
+ 
+ 	msk->pm.add_addr_accepted++;
+ 	if (msk->pm.add_addr_accepted >= add_addr_accept_max ||
+ 	    msk->pm.subflows >= subflows_max)
+ 		WRITE_ONCE(msk->pm.accept_addr, false);
++>>>>>>> 837cf45df163 (mptcp: fix race in incoming ADD_ADDR option processing)
  
  	spin_unlock_bh(&msk->pm.lock);
 -	for (i = 0; i < nr; i++)
 -		__mptcp_subflow_connect(sk, &addrs[i], &remote);
 +	__mptcp_subflow_connect(sk, &local, &remote, 0, 0);
  	spin_lock_bh(&msk->pm.lock);
  
+ 	/* be sure to echo exactly the received address */
+ 	if (reset_port)
+ 		remote.port = 0;
+ 
  add_addr_echo:
- 	mptcp_pm_announce_addr(msk, &msk->pm.remote, true);
+ 	mptcp_pm_announce_addr(msk, &remote, true);
  	mptcp_pm_nl_addr_send_ack(msk);
  }
  
* Unmerged path net/mptcp/pm_netlink.c
