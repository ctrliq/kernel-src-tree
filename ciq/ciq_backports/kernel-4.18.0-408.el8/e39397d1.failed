x86/hyperv: implement an MSI domain for root partition

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Wei Liu <wei.liu@kernel.org>
commit e39397d1fd6851bef4dfb63a631b8e15d1f43329
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/e39397d1.failed

When Linux runs as the root partition on Microsoft Hypervisor, its
interrupts are remapped.  Linux will need to explicitly map and unmap
interrupts for hardware.

Implement an MSI domain to issue the correct hypercalls. And initialize
this irq domain as the default MSI irq domain.

	Signed-off-by: Sunil Muthuswamy <sunilmut@microsoft.com>
Co-Developed-by: Sunil Muthuswamy <sunilmut@microsoft.com>
	Signed-off-by: Wei Liu <wei.liu@kernel.org>
	Reviewed-by: Michael Kelley <mikelley@microsoft.com>
Link: https://lore.kernel.org/r/20210203150435.27941-16-wei.liu@kernel.org
(cherry picked from commit e39397d1fd6851bef4dfb63a631b8e15d1f43329)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/hyperv/Makefile
#	arch/x86/hyperv/hv_init.c
#	arch/x86/hyperv/irqdomain.c
#	arch/x86/include/asm/mshyperv.h
diff --cc arch/x86/hyperv/Makefile
index ea66981581b2,48e2c51464e8..000000000000
--- a/arch/x86/hyperv/Makefile
+++ b/arch/x86/hyperv/Makefile
@@@ -1,4 -1,5 +1,9 @@@
++<<<<<<< HEAD
 +obj-y			:= hv_init.o mmu.o nested.o
++=======
+ # SPDX-License-Identifier: GPL-2.0-only
+ obj-y			:= hv_init.o mmu.o nested.o irqdomain.o
++>>>>>>> e39397d1fd68 (x86/hyperv: implement an MSI domain for root partition)
  obj-$(CONFIG_X86_64)	+= hv_apic.o hv_proc.o
  
  ifdef CONFIG_X86_64
diff --cc arch/x86/hyperv/hv_init.c
index 2a13a6c9e0f2,b81047dec1da..000000000000
--- a/arch/x86/hyperv/hv_init.c
+++ b/arch/x86/hyperv/hv_init.c
@@@ -430,8 -511,15 +430,20 @@@ void __init hyperv_init(void
  
  	BUG_ON(hv_root_partition && hv_current_partition_id == ~0ull);
  
++<<<<<<< HEAD
 +	/* Query the VMs extended capability once, so that it can be cached. */
 +	hv_query_ext_cap(0);
++=======
+ #ifdef CONFIG_PCI_MSI
+ 	/*
+ 	 * If we're running as root, we want to create our own PCI MSI domain.
+ 	 * We can't set this in hv_pci_init because that would be too late.
+ 	 */
+ 	if (hv_root_partition)
+ 		x86_init.irqs.create_pci_msi_domain = hv_create_pci_msi_domain;
+ #endif
+ 
++>>>>>>> e39397d1fd68 (x86/hyperv: implement an MSI domain for root partition)
  	return;
  
  remove_cpuhp_state:
diff --cc arch/x86/hyperv/irqdomain.c
index 514fc64e23d5,bddcf1d6860d..000000000000
--- a/arch/x86/hyperv/irqdomain.c
+++ b/arch/x86/hyperv/irqdomain.c
@@@ -63,10 -63,10 +63,17 @@@ static int hv_map_interrupt(union hv_de
  
  	local_irq_restore(flags);
  
++<<<<<<< HEAD
 +	if (!hv_result_success(status))
 +		pr_err("%s: hypercall failed, status %lld\n", __func__, status);
 +
 +	return hv_result(status);
++=======
+ 	if ((status & HV_HYPERCALL_RESULT_MASK) != HV_STATUS_SUCCESS)
+ 		pr_err("%s: hypercall failed, status %lld\n", __func__, status);
+ 
+ 	return status & HV_HYPERCALL_RESULT_MASK;
++>>>>>>> e39397d1fd68 (x86/hyperv: implement an MSI domain for root partition)
  }
  
  static int hv_unmap_interrupt(u64 id, struct hv_interrupt_entry *old_entry)
@@@ -88,7 -88,7 +95,11 @@@
  	status = hv_do_hypercall(HVCALL_UNMAP_DEVICE_INTERRUPT, input, NULL);
  	local_irq_restore(flags);
  
++<<<<<<< HEAD
 +	return hv_result(status);
++=======
+ 	return status & HV_HYPERCALL_RESULT_MASK;
++>>>>>>> e39397d1fd68 (x86/hyperv: implement an MSI domain for root partition)
  }
  
  #ifdef CONFIG_PCI_MSI
@@@ -358,28 -358,3 +369,31 @@@ struct irq_domain * __init hv_create_pc
  }
  
  #endif /* CONFIG_PCI_MSI */
++<<<<<<< HEAD
 +
 +int hv_unmap_ioapic_interrupt(int ioapic_id, struct hv_interrupt_entry *entry)
 +{
 +	union hv_device_id device_id;
 +
 +	device_id.as_uint64 = 0;
 +	device_id.device_type = HV_DEVICE_TYPE_IOAPIC;
 +	device_id.ioapic.ioapic_id = (u8)ioapic_id;
 +
 +	return hv_unmap_interrupt(device_id.as_uint64, entry);
 +}
 +EXPORT_SYMBOL_GPL(hv_unmap_ioapic_interrupt);
 +
 +int hv_map_ioapic_interrupt(int ioapic_id, bool level, int cpu, int vector,
 +		struct hv_interrupt_entry *entry)
 +{
 +	union hv_device_id device_id;
 +
 +	device_id.as_uint64 = 0;
 +	device_id.device_type = HV_DEVICE_TYPE_IOAPIC;
 +	device_id.ioapic.ioapic_id = (u8)ioapic_id;
 +
 +	return hv_map_interrupt(device_id, level, cpu, vector, entry);
 +}
 +EXPORT_SYMBOL_GPL(hv_map_ioapic_interrupt);
++=======
++>>>>>>> e39397d1fd68 (x86/hyperv: implement an MSI domain for root partition)
diff --cc arch/x86/include/asm/mshyperv.h
index 50ff5ae8218d,4533773115ea..000000000000
--- a/arch/x86/include/asm/mshyperv.h
+++ b/arch/x86/include/asm/mshyperv.h
@@@ -189,6 -256,15 +189,18 @@@ bool hv_vcpu_is_preempted(int vcpu)
  static inline void hv_apic_init(void) {}
  #endif
  
++<<<<<<< HEAD
++=======
+ static inline void hv_set_msi_entry_from_desc(union hv_msi_entry *msi_entry,
+ 					      struct msi_desc *msi_desc)
+ {
+ 	msi_entry->address.as_uint32 = msi_desc->msg.address_lo;
+ 	msi_entry->data.as_uint32 = msi_desc->msg.data;
+ }
+ 
+ struct irq_domain *hv_create_pci_msi_domain(void);
+ 
++>>>>>>> e39397d1fd68 (x86/hyperv: implement an MSI domain for root partition)
  #else /* CONFIG_HYPERV */
  static inline void hyperv_init(void) {}
  static inline void hyperv_setup_mmu_ops(void) {}
* Unmerged path arch/x86/hyperv/Makefile
* Unmerged path arch/x86/hyperv/hv_init.c
* Unmerged path arch/x86/hyperv/irqdomain.c
* Unmerged path arch/x86/include/asm/mshyperv.h
