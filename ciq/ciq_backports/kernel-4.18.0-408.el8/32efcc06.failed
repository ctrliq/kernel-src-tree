tcp: export count for rehash attempts

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Abdul Kabbani <akabbani@google.com>
commit 32efcc06d2a15fa87585614d12d6c2308cc2d3f3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/32efcc06.failed

Using IPv6 flow-label to swiftly route around avoid congested or
disconnected network path can greatly improve TCP reliability.

This patch adds SNMP counters and a OPT_STATS counter to track both
host-level and connection-level statistics. Network administrators
can use these counters to evaluate the impact of this new ability better.

Export count for rehash attempts to
1) two SNMP counters: TcpTimeoutRehash (rehash due to timeouts),
   and TcpDuplicateDataRehash (rehash due to receiving duplicate
   packets)
2) Timestamping API SOF_TIMESTAMPING_OPT_STATS.

	Signed-off-by: Abdul Kabbani <akabbani@google.com>
	Signed-off-by: Neal Cardwell <ncardwell@google.com>
	Signed-off-by: Yuchung Cheng <ycheng@google.com>
	Signed-off-by: Kevin(Yudong) Yang <yyd@google.com>
	Signed-off-by: Eric Dumazet <edumazet@google.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 32efcc06d2a15fa87585614d12d6c2308cc2d3f3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/uapi/linux/snmp.h
#	net/ipv4/proc.c
#	net/ipv4/tcp_input.c
diff --cc include/uapi/linux/snmp.h
index b3db0c8fba73,7d91f4debc48..000000000000
--- a/include/uapi/linux/snmp.h
+++ b/include/uapi/linux/snmp.h
@@@ -284,9 -281,12 +284,15 @@@ enu
  	LINUX_MIB_TCPDELIVERED,			/* TCPDelivered */
  	LINUX_MIB_TCPDELIVEREDCE,		/* TCPDeliveredCE */
  	LINUX_MIB_TCPACKCOMPRESSED,		/* TCPAckCompressed */
 -	LINUX_MIB_TCPZEROWINDOWDROP,		/* TCPZeroWindowDrop */
 -	LINUX_MIB_TCPRCVQDROP,			/* TCPRcvQDrop */
 +#ifndef __GENKSYMS__
  	LINUX_MIB_TCPWQUEUETOOBIG,		/* TCPWqueueTooBig */
++<<<<<<< HEAD
 +#endif
++=======
+ 	LINUX_MIB_TCPFASTOPENPASSIVEALTKEY,	/* TCPFastOpenPassiveAltKey */
+ 	LINUX_MIB_TCPTIMEOUTREHASH,		/* TCPTimeoutRehash */
+ 	LINUX_MIB_TCPDUPLICATEDATAREHASH,	/* TCPDuplicateDataRehash */
++>>>>>>> 32efcc06d2a1 (tcp: export count for rehash attempts)
  	__LINUX_MIB_MAX
  };
  
diff --cc net/ipv4/proc.c
index 980c3770381b,2580303249e2..000000000000
--- a/net/ipv4/proc.c
+++ b/net/ipv4/proc.c
@@@ -291,7 -285,12 +291,13 @@@ static const struct snmp_mib snmp4_net_
  	SNMP_MIB_ITEM("TCPDelivered", LINUX_MIB_TCPDELIVERED),
  	SNMP_MIB_ITEM("TCPDeliveredCE", LINUX_MIB_TCPDELIVEREDCE),
  	SNMP_MIB_ITEM("TCPAckCompressed", LINUX_MIB_TCPACKCOMPRESSED),
 -	SNMP_MIB_ITEM("TCPZeroWindowDrop", LINUX_MIB_TCPZEROWINDOWDROP),
 -	SNMP_MIB_ITEM("TCPRcvQDrop", LINUX_MIB_TCPRCVQDROP),
  	SNMP_MIB_ITEM("TCPWqueueTooBig", LINUX_MIB_TCPWQUEUETOOBIG),
++<<<<<<< HEAD
++=======
+ 	SNMP_MIB_ITEM("TCPFastOpenPassiveAltKey", LINUX_MIB_TCPFASTOPENPASSIVEALTKEY),
+ 	SNMP_MIB_ITEM("TcpTimeoutRehash", LINUX_MIB_TCPTIMEOUTREHASH),
+ 	SNMP_MIB_ITEM("TcpDuplicateDataRehash", LINUX_MIB_TCPDUPLICATEDATAREHASH),
++>>>>>>> 32efcc06d2a1 (tcp: export count for rehash attempts)
  	SNMP_MIB_SENTINEL
  };
  
diff --cc net/ipv4/tcp_input.c
index 040dc4f9858b,e8b840a4767e..000000000000
--- a/net/ipv4/tcp_input.c
+++ b/net/ipv4/tcp_input.c
@@@ -4347,6 -4264,19 +4347,22 @@@ static void tcp_dsack_extend(struct soc
  		tcp_sack_extend(tp->duplicate_sack, seq, end_seq);
  }
  
++<<<<<<< HEAD
++=======
+ static void tcp_rcv_spurious_retrans(struct sock *sk, const struct sk_buff *skb)
+ {
+ 	/* When the ACK path fails or drops most ACKs, the sender would
+ 	 * timeout and spuriously retransmit the same segment repeatedly.
+ 	 * The receiver remembers and reflects via DSACKs. Leverage the
+ 	 * DSACK state and change the txhash to re-route speculatively.
+ 	 */
+ 	if (TCP_SKB_CB(skb)->seq == tcp_sk(sk)->duplicate_sack[0].start_seq) {
+ 		sk_rethink_txhash(sk);
+ 		NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPDUPLICATEDATAREHASH);
+ 	}
+ }
+ 
++>>>>>>> 32efcc06d2a1 (tcp: export count for rehash attempts)
  static void tcp_send_dupack(struct sock *sk, const struct sk_buff *skb)
  {
  	struct tcp_sock *tp = tcp_sk(sk);
diff --git a/include/linux/tcp.h b/include/linux/tcp.h
index 4260a4e64658..d039de590d62 100644
--- a/include/linux/tcp.h
+++ b/include/linux/tcp.h
@@ -367,6 +367,8 @@ struct tcp_sock {
 #define BPF_SOCK_OPS_TEST_FLAG(TP, ARG) 0
 #endif
 
+	u16 timeout_rehash;	/* Timeout-triggered rehash attempts */
+
 	u32 rcv_ooopack; /* Received out-of-order packets, for tcpinfo */
 
 /* Receiver side RTT estimation */
* Unmerged path include/uapi/linux/snmp.h
diff --git a/include/uapi/linux/tcp.h b/include/uapi/linux/tcp.h
index ec1bb2c84686..57330cfc0bda 100644
--- a/include/uapi/linux/tcp.h
+++ b/include/uapi/linux/tcp.h
@@ -273,6 +273,7 @@ enum {
 	TCP_NLA_DSACK_DUPS,	/* DSACK blocks received */
 	TCP_NLA_REORD_SEEN,	/* reordering events seen */
 	TCP_NLA_SRTT,		/* smoothed RTT in usecs */
+	TCP_NLA_TIMEOUT_REHASH, /* Timeout-triggered rehash attempts */
 };
 
 /* for TCP_MD5SIG socket option */
* Unmerged path net/ipv4/proc.c
diff --git a/net/ipv4/tcp.c b/net/ipv4/tcp.c
index db57cdc3bec7..17b34b0bcd2b 100644
--- a/net/ipv4/tcp.c
+++ b/net/ipv4/tcp.c
@@ -3396,6 +3396,7 @@ static size_t tcp_opt_stats_get_size(void)
 		nla_total_size(sizeof(u32)) + /* TCP_NLA_DSACK_DUPS */
 		nla_total_size(sizeof(u32)) + /* TCP_NLA_REORD_SEEN */
 		nla_total_size(sizeof(u32)) + /* TCP_NLA_SRTT */
+		nla_total_size(sizeof(u16)) + /* TCP_NLA_TIMEOUT_REHASH */
 		0;
 }
 
@@ -3450,6 +3451,7 @@ struct sk_buff *tcp_get_timestamping_opt_stats(const struct sock *sk)
 	nla_put_u32(stats, TCP_NLA_DSACK_DUPS, tp->dsack_dups);
 	nla_put_u32(stats, TCP_NLA_REORD_SEEN, tp->reord_seen);
 	nla_put_u32(stats, TCP_NLA_SRTT, tp->srtt_us >> 3);
+	nla_put_u16(stats, TCP_NLA_TIMEOUT_REHASH, tp->timeout_rehash);
 
 	return stats;
 }
* Unmerged path net/ipv4/tcp_input.c
diff --git a/net/ipv4/tcp_timer.c b/net/ipv4/tcp_timer.c
index df6b3cec1d87..0f8f99a4802f 100644
--- a/net/ipv4/tcp_timer.c
+++ b/net/ipv4/tcp_timer.c
@@ -232,6 +232,9 @@ static int tcp_write_timeout(struct sock *sk)
 			dst_negative_advice(sk);
 		} else {
 			sk_rethink_txhash(sk);
+			tp->timeout_rehash++;
+			__NET_INC_STATS(sock_net(sk),
+					LINUX_MIB_TCPTIMEOUTREHASH);
 		}
 		retry_until = icsk->icsk_syn_retries ? : net->ipv4.sysctl_tcp_syn_retries;
 		expired = icsk->icsk_retransmits >= retry_until;
@@ -243,6 +246,9 @@ static int tcp_write_timeout(struct sock *sk)
 			dst_negative_advice(sk);
 		} else {
 			sk_rethink_txhash(sk);
+			tp->timeout_rehash++;
+			__NET_INC_STATS(sock_net(sk),
+					LINUX_MIB_TCPTIMEOUTREHASH);
 		}
 
 		retry_until = net->ipv4.sysctl_tcp_retries2;
