KVM: VMX: Clean up PI pre/post-block WARNs

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Sean Christopherson <seanjc@google.com>
commit 45af1bb99b72e36c16714390a8a3c9445e432938
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/45af1bb9.failed

Move the WARN sanity checks out of the PI descriptor update loop so as
not to spam the kernel log if the condition is violated and the update
takes multiple attempts due to another writer.  This also eliminates a
few extra uops from the retry path.

Technically not checking every attempt could mean KVM will now fail to
WARN in a scenario that would have failed before, but any such failure
would be inherently racy as some other agent (CPU or device) would have
to concurrent modify the PI descriptor.

Add a helper to handle the actual write and more importantly to document
why the write may need to be retried.

	Signed-off-by: Sean Christopherson <seanjc@google.com>
Message-Id: <20211208015236.1616697-4-seanjc@google.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 45af1bb99b72e36c16714390a8a3c9445e432938)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/vmx/posted_intr.c
diff --cc arch/x86/kvm/vmx/posted_intr.c
index 359222f558f9,88c53c521094..000000000000
--- a/arch/x86/kvm/vmx/posted_intr.c
+++ b/arch/x86/kvm/vmx/posted_intr.c
@@@ -117,15 -151,9 +131,14 @@@ static void __pi_post_block(struct kvm_
  
  		/* set 'NV' to 'notification vector' */
  		new.nv = POSTED_INTR_VECTOR;
- 	} while (cmpxchg64(&pi_desc->control, old.control,
- 			   new.control) != old.control);
+ 	} while (pi_try_set_control(pi_desc, old.control, new.control));
  
 -	vcpu->pre_pcpu = -1;
 +	if (!WARN_ON_ONCE(vcpu->pre_pcpu == -1)) {
 +		raw_spin_lock(&per_cpu(blocked_vcpu_on_cpu_lock, vcpu->pre_pcpu));
 +		list_del(&vcpu->blocked_vcpu_list);
 +		raw_spin_unlock(&per_cpu(blocked_vcpu_on_cpu_lock, vcpu->pre_pcpu));
 +		vcpu->pre_pcpu = -1;
 +	}
  }
  
  /*
@@@ -151,43 -178,23 +164,48 @@@ int pi_pre_block(struct kvm_vcpu *vcpu
  	    vmx_interrupt_blocked(vcpu))
  		return 0;
  
 -	local_irq_save(flags);
 -
 -	vcpu->pre_pcpu = vcpu->cpu;
 -	spin_lock(&per_cpu(blocked_vcpu_on_cpu_lock, vcpu->cpu));
 -	list_add_tail(&vcpu->blocked_vcpu_list,
 -		      &per_cpu(blocked_vcpu_on_cpu, vcpu->cpu));
 -	spin_unlock(&per_cpu(blocked_vcpu_on_cpu_lock, vcpu->cpu));
 +	WARN_ON(irqs_disabled());
 +	local_irq_disable();
 +	if (!WARN_ON_ONCE(vcpu->pre_pcpu != -1)) {
 +		vcpu->pre_pcpu = vcpu->cpu;
 +		raw_spin_lock(&per_cpu(blocked_vcpu_on_cpu_lock, vcpu->pre_pcpu));
 +		list_add_tail(&vcpu->blocked_vcpu_list,
 +			      &per_cpu(blocked_vcpu_on_cpu,
 +				       vcpu->pre_pcpu));
 +		raw_spin_unlock(&per_cpu(blocked_vcpu_on_cpu_lock, vcpu->pre_pcpu));
 +	}
  
+ 	WARN(pi_desc->sn == 1,
+ 	     "Posted Interrupt Suppress Notification set before blocking");
+ 
  	do {
  		old.control = new.control = READ_ONCE(pi_desc->control);
  
++<<<<<<< HEAD
 +		WARN((pi_desc->sn == 1),
 +		     "Warning: SN field of posted-interrupts "
 +		     "is set before blocking\n");
 +
 +		/*
 +		 * Since vCPU can be preempted during this process,
 +		 * vcpu->cpu could be different with pre_pcpu, we
 +		 * need to set pre_pcpu as the destination of wakeup
 +		 * notification event, then we can find the right vCPU
 +		 * to wakeup in wakeup handler if interrupts happen
 +		 * when the vCPU is in blocked state.
 +		 */
 +		dest = cpu_physical_id(vcpu->pre_pcpu);
 +
 +		if (x2apic_mode)
 +			new.ndst = dest;
 +		else
 +			new.ndst = (dest << 8) & 0xFF00;
 +
++=======
++>>>>>>> 45af1bb99b72 (KVM: VMX: Clean up PI pre/post-block WARNs)
  		/* set 'NV' to 'wakeup vector' */
  		new.nv = POSTED_INTR_WAKEUP_VECTOR;
- 	} while (cmpxchg64(&pi_desc->control, old.control,
- 			   new.control) != old.control);
+ 	} while (pi_try_set_control(pi_desc, old.control, new.control));
  
  	/* We should not block the vCPU if an interrupt is posted for it.  */
  	if (pi_test_on(pi_desc))
* Unmerged path arch/x86/kvm/vmx/posted_intr.c
