gfs2: further simplify do_promote

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Bob Peterson <rpeterso@redhat.com>
commit 60d8bae9d16a52346ba738518bd43702d15eb834
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/60d8bae9.failed

This patch further simplifies function do_promote by eliminating some
redundant code in favor of using a lock_released flag. This is just
prep work for a future patch.

	Signed-off-by: Bob Peterson <rpeterso@redhat.com>
	Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
(cherry picked from commit 60d8bae9d16a52346ba738518bd43702d15eb834)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/gfs2/glock.c
diff --cc fs/gfs2/glock.c
index ea487d5365d7,db213f0ef960..000000000000
--- a/fs/gfs2/glock.c
+++ b/fs/gfs2/glock.c
@@@ -496,50 -493,51 +497,96 @@@ __acquires(&gl->gl_lockref.lock
  restart:
  	first_gh = find_first_strong_holder(gl);
  	list_for_each_entry_safe(gh, tmp, &gl->gl_holders, gh_list) {
- 		if (!test_bit(HIF_WAIT, &gh->gh_iflags))
+ 		lock_released = false;
+ 		if (test_bit(HIF_HOLDER, &gh->gh_iflags))
  			continue;
++<<<<<<< HEAD
 +		if (may_grant(gl, first_gh, gh)) {
 +			if (!incompat_holders_demoted) {
 +				demote_incompat_holders(gl, first_gh);
 +				incompat_holders_demoted = true;
 +				first_gh = gh;
 +			}
 +			if (gh->gh_list.prev == &gl->gl_holders &&
 +			    glops->go_lock) {
 +				if (!(gh->gh_flags & GL_SKIP)) {
 +					spin_unlock(&gl->gl_lockref.lock);
 +					/* FIXME: eliminate this eventually */
 +					ret = glops->go_lock(gh);
 +					spin_lock(&gl->gl_lockref.lock);
 +					if (ret) {
 +						if (ret == 1)
 +							return 2;
 +						gh->gh_error = ret;
 +						list_del_init(&gh->gh_list);
 +						trace_gfs2_glock_queue(gh, 0);
 +						gfs2_holder_wake(gh);
 +						goto restart;
 +					}
 +				}
 +				set_bit(HIF_HOLDER, &gh->gh_iflags);
 +				trace_gfs2_promote(gh);
 +				gfs2_holder_wake(gh);
 +				goto restart;
 +			}
 +			set_bit(HIF_HOLDER, &gh->gh_iflags);
 +			trace_gfs2_promote(gh);
 +			gfs2_holder_wake(gh);
 +			continue;
 +		}
 +		/*
 +		 * If we get here, it means we may not grant this holder for
 +		 * some reason. If this holder is the head of the list, it
 +		 * means we have a blocked holder at the head, so return 1.
 +		 */
 +		if (gh->gh_list.prev == &gl->gl_holders)
 +			return 1;
 +		do_error(gl, 0);
 +		break;
++=======
+ 		if (!may_grant(gl, first_gh, gh)) {
+ 			/*
+ 			 * If we get here, it means we may not grant this holder for
+ 			 * some reason. If this holder is the head of the list, it
+ 			 * means we have a blocked holder at the head, so return 1.
+ 			 */
+ 			if (gh->gh_list.prev == &gl->gl_holders)
+ 				return 1;
+ 			do_error(gl, 0);
+ 			break;
+ 		}
+ 		if (!incompat_holders_demoted) {
+ 			demote_incompat_holders(gl, first_gh);
+ 			incompat_holders_demoted = true;
+ 			first_gh = gh;
+ 		}
+ 		if (gh->gh_list.prev == &gl->gl_holders &&
+ 		    !(gh->gh_flags & GL_SKIP) && glops->go_instantiate) {
+ 			lock_released = true;
+ 			spin_unlock(&gl->gl_lockref.lock);
+ 			ret = glops->go_instantiate(gh);
+ 			spin_lock(&gl->gl_lockref.lock);
+ 			if (ret) {
+ 				if (ret == 1)
+ 					return 2;
+ 				gh->gh_error = ret;
+ 				list_del_init(&gh->gh_list);
+ 				trace_gfs2_glock_queue(gh, 0);
+ 				gfs2_holder_wake(gh);
+ 				goto restart;
+ 			}
+ 		}
+ 		set_bit(HIF_HOLDER, &gh->gh_iflags);
+ 		trace_gfs2_promote(gh);
+ 		gfs2_holder_wake(gh);
+ 		/*
+ 		 * If we released the gl_lockref.lock the holders list may have
+ 		 * changed. For that reason, we start again at the start of
+ 		 * the holders queue.
+ 		 */
+ 		if (lock_released)
+ 			goto restart;
++>>>>>>> 60d8bae9d16a (gfs2: further simplify do_promote)
  	}
  	return 0;
  }
* Unmerged path fs/gfs2/glock.c
