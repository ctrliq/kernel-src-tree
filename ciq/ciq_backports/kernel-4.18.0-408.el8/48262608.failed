net/smc: Introduce tracepoint for fallback

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Tony Lu <tonylu@linux.alibaba.com>
commit 4826260868202246a4dba1c682491d7f4b90d747
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/48262608.failed

This introduces tracepoint for smc fallback to TCP, so that we can track
which connection and why it fallbacks, and map the clcsocks' pointer with
/proc/net/tcp to find more details about TCP connections. Compared with
kprobe or other dynamic tracing, tracepoints are stable and easy to use.

	Signed-off-by: Tony Lu <tonylu@linux.alibaba.com>
	Reviewed-by: Wen Gu <guwen@linux.alibaba.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 4826260868202246a4dba1c682491d7f4b90d747)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/smc/Makefile
diff --cc net/smc/Makefile
index 7b2c6b5175ec,196fb6f01b14..000000000000
--- a/net/smc/Makefile
+++ b/net/smc/Makefile
@@@ -1,3 -1,5 +1,8 @@@
++<<<<<<< HEAD
++=======
+ # SPDX-License-Identifier: GPL-2.0-only
+ ccflags-y += -I$(src)
++>>>>>>> 482626086820 (net/smc: Introduce tracepoint for fallback)
  obj-$(CONFIG_SMC)	+= smc.o
  obj-$(CONFIG_SMC_DIAG)	+= smc_diag.o
  smc-y := af_smc.o smc_pnet.o smc_ib.o smc_clc.o smc_core.o smc_wr.o smc_llc.o
* Unmerged path net/smc/Makefile
diff --git a/net/smc/af_smc.c b/net/smc/af_smc.c
index 3a24c8131523..03a23839be4d 100644
--- a/net/smc/af_smc.c
+++ b/net/smc/af_smc.c
@@ -49,6 +49,7 @@
 #include "smc_rx.h"
 #include "smc_close.h"
 #include "smc_stats.h"
+#include "smc_tracepoint.h"
 
 static DEFINE_MUTEX(smc_server_lgr_pending);	/* serialize link group
 						 * creation on server
@@ -562,6 +563,7 @@ static void smc_switch_to_fallback(struct smc_sock *smc, int reason_code)
 	smc->use_fallback = true;
 	smc->fallback_rsn = reason_code;
 	smc_stat_fallback(smc);
+	trace_smc_switch_to_fallback(smc, reason_code);
 	if (smc->sk.sk_socket && smc->sk.sk_socket->file) {
 		smc->clcsock->file = smc->sk.sk_socket->file;
 		smc->clcsock->file->private_data = smc->clcsock;
diff --git a/net/smc/smc_tracepoint.c b/net/smc/smc_tracepoint.c
new file mode 100644
index 000000000000..861a41644971
--- /dev/null
+++ b/net/smc/smc_tracepoint.c
@@ -0,0 +1,6 @@
+// SPDX-License-Identifier: GPL-2.0-only
+
+#define CREATE_TRACE_POINTS
+#include "smc_tracepoint.h"
+
+EXPORT_TRACEPOINT_SYMBOL(smc_switch_to_fallback);
diff --git a/net/smc/smc_tracepoint.h b/net/smc/smc_tracepoint.h
new file mode 100644
index 000000000000..3bc97f5f2134
--- /dev/null
+++ b/net/smc/smc_tracepoint.h
@@ -0,0 +1,49 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+
+#undef TRACE_SYSTEM
+#define TRACE_SYSTEM smc
+
+#if !defined(_TRACE_SMC_H) || defined(TRACE_HEADER_MULTI_READ)
+#define _TRACE_SMC_H
+
+#include <linux/ipv6.h>
+#include <linux/tcp.h>
+#include <linux/tracepoint.h>
+#include <net/ipv6.h>
+#include "smc.h"
+#include "smc_core.h"
+
+TRACE_EVENT(smc_switch_to_fallback,
+
+	    TP_PROTO(const struct smc_sock *smc, int fallback_rsn),
+
+	    TP_ARGS(smc, fallback_rsn),
+
+	    TP_STRUCT__entry(
+			     __field(const void *, sk)
+			     __field(const void *, clcsk)
+			     __field(int, fallback_rsn)
+	    ),
+
+	    TP_fast_assign(
+			   const struct sock *sk = &smc->sk;
+			   const struct sock *clcsk = smc->clcsock->sk;
+
+			   __entry->sk = sk;
+			   __entry->clcsk = clcsk;
+			   __entry->fallback_rsn = fallback_rsn;
+	    ),
+
+	    TP_printk("sk=%p clcsk=%p fallback_rsn=%d",
+		      __entry->sk, __entry->clcsk, __entry->fallback_rsn)
+);
+
+#endif /* _TRACE_SMC_H */
+
+#undef TRACE_INCLUDE_PATH
+#define TRACE_INCLUDE_PATH .
+
+#undef TRACE_INCLUDE_FILE
+#define TRACE_INCLUDE_FILE smc_tracepoint
+
+#include <trace/define_trace.h>
