nvme: don't print verbose errors for internal passthrough requests

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Chaitanya Kulkarni <kch@nvidia.com>
commit b42b6f4485e3f0970e11f73df6202eeaf9f53a3e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/b42b6f44.failed

Use the RQF_QUIET flag to skip the newly added verbose error reporting,
and set the flag in __nvme_submit_sync_cmd, which is used for most
internal passthrough requests where we do expect errors (e.g. due to
probing for optional functionality).  This is similar to what the SCSI
verbose error logging does.

	Signed-off-by: Chaitanya Kulkarni <kch@nvidia.com>
	Reviewed-by: Alan Adamson <alan.adamson@oracle.com>
	Reviewed-by: Keith Busch <kbusch@kernel.org>
	Reviewed-by: Sagi Grimberg <sagi@grimberg.me>
	Tested-by: Alan Adamson <alan.adamson@oracle.com>
	Tested-by: Yi Zhang <yi.zhang@redhat.com>
	Signed-off-by: Christoph Hellwig <hch@lst.de>
(cherry picked from commit b42b6f4485e3f0970e11f73df6202eeaf9f53a3e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/nvme/host/core.c
diff --cc drivers/nvme/host/core.c
index 26cba19e6f7d,be9fc9818e65..000000000000
--- a/drivers/nvme/host/core.c
+++ b/drivers/nvme/host/core.c
@@@ -379,26 -364,13 +379,34 @@@ static inline void __nvme_end_req(struc
  
  static inline void nvme_end_req(struct request *req)
  {
 -	blk_status_t status = nvme_error_status(nvme_req(req)->status);
 +	__nvme_end_req(req, nvme_error_status(nvme_req(req)->status));
 +}
 +
++<<<<<<< HEAD
 +static inline void nvme_end_req_with_failover(struct request *req)
 +{
 +	u16 nvme_status = nvme_req(req)->status;
 +	blk_status_t status = nvme_error_status(nvme_status);
 +
 +	if (unlikely(nvme_status & NVME_SC_DNR))
 +		goto out;
  
 +	nvme_update_ana(req);
 +
 +	if (!blk_path_error(status)) {
 +		pr_debug("Request meant for failover but blk_status_t (errno=%d) was not retryable.\n",
 +			 blk_status_to_errno(status));
 +		status = BLK_STS_IOERR;
 +	}
 +out:
 +	__nvme_end_req(req, status);
++=======
+ 	if (unlikely(nvme_req(req)->status && !(req->rq_flags & RQF_QUIET)))
+ 		nvme_log_error(req);
+ 	nvme_end_req_zoned(req);
+ 	nvme_trace_bio_complete(req);
+ 	blk_mq_end_request(req, status);
++>>>>>>> b42b6f4485e3 (nvme: don't print verbose errors for internal passthrough requests)
  }
  
  void nvme_complete_rq(struct request *req)
@@@ -1138,7 -1015,8 +1146,12 @@@ int __nvme_submit_sync_cmd(struct reque
  			goto out;
  	}
  
++<<<<<<< HEAD
 +	ret = nvme_execute_rq(NULL, req, at_head);
++=======
+ 	req->rq_flags |= RQF_QUIET;
+ 	ret = nvme_execute_rq(req, at_head);
++>>>>>>> b42b6f4485e3 (nvme: don't print verbose errors for internal passthrough requests)
  	if (result && ret >= 0)
  		*result = nvme_req(req)->result;
   out:
* Unmerged path drivers/nvme/host/core.c
