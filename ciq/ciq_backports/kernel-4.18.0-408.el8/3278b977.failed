gfs2: change go_lock to go_instantiate

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Bob Peterson <rpeterso@redhat.com>
commit 3278b977c9c4c51a4e5e04fb40a991fb28edc2b7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/3278b977.failed

Before this patch, the go_lock glock operations (glops) did not do
any actual locking. They were used to instantiate objects, like reading
in dinodes and rgrps from the media.

This patch renames the functions to go_instantiate for clarity.

	Signed-off-by: Bob Peterson <rpeterso@redhat.com>
	Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
(cherry picked from commit 3278b977c9c4c51a4e5e04fb40a991fb28edc2b7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/gfs2/glops.c
diff --cc fs/gfs2/glops.c
index 2e08b899f53d,8452a83bd55a..000000000000
--- a/fs/gfs2/glops.c
+++ b/fs/gfs2/glops.c
@@@ -476,9 -482,8 +476,14 @@@ int gfs2_inode_refresh(struct gfs2_inod
  }
  
  /**
++<<<<<<< HEAD
 + * inode_go_lock - operation done after an inode lock is locked by a process
 + * @gl: the glock
 + * @flags:
++=======
+  * inode_go_instantiate - read in an inode if necessary
+  * @gh: The glock holder
++>>>>>>> 3278b977c9c4 (gfs2: change go_lock to go_instantiate)
   *
   * Returns: errno
   */
diff --git a/fs/gfs2/glock.c b/fs/gfs2/glock.c
index dbd844cb03cc..31316fb79397 100644
--- a/fs/gfs2/glock.c
+++ b/fs/gfs2/glock.c
@@ -505,11 +505,11 @@ __acquires(&gl->gl_lockref.lock)
 				first_gh = gh;
 			}
 			if (gh->gh_list.prev == &gl->gl_holders &&
-			    glops->go_lock) {
+			    glops->go_instantiate) {
 				if (!(gh->gh_flags & GL_SKIP)) {
 					spin_unlock(&gl->gl_lockref.lock);
 					/* FIXME: eliminate this eventually */
-					ret = glops->go_lock(gh);
+					ret = glops->go_instantiate(gh);
 					spin_lock(&gl->gl_lockref.lock);
 					if (ret) {
 						if (ret == 1)
* Unmerged path fs/gfs2/glops.c
diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 105717b0019c..84461a798838 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -223,7 +223,7 @@ struct gfs2_glock_operations {
 	int (*go_xmote_bh)(struct gfs2_glock *gl);
 	void (*go_inval) (struct gfs2_glock *gl, int flags);
 	int (*go_demote_ok) (const struct gfs2_glock *gl);
-	int (*go_lock) (struct gfs2_holder *gh);
+	int (*go_instantiate) (struct gfs2_holder *gh);
 	void (*go_dump)(struct seq_file *seq, struct gfs2_glock *gl,
 			const char *fs_id_buf);
 	void (*go_callback)(struct gfs2_glock *gl, bool remote);
diff --git a/fs/gfs2/rgrp.c b/fs/gfs2/rgrp.c
index 7e8aeb333719..21f64d0d2951 100644
--- a/fs/gfs2/rgrp.c
+++ b/fs/gfs2/rgrp.c
@@ -1291,7 +1291,7 @@ static int update_rgrp_lvb(struct gfs2_rgrpd *rgd)
 	return 0;
 }
 
-int gfs2_rgrp_go_lock(struct gfs2_holder *gh)
+int gfs2_rgrp_go_instantiate(struct gfs2_holder *gh)
 {
 	struct gfs2_rgrpd *rgd = gh->gh_gl->gl_object;
 
diff --git a/fs/gfs2/rgrp.h b/fs/gfs2/rgrp.h
index 9ab3133a6b64..593d2230d8e5 100644
--- a/fs/gfs2/rgrp.h
+++ b/fs/gfs2/rgrp.h
@@ -34,7 +34,7 @@ extern struct gfs2_rgrpd *gfs2_rgrpd_get_next(struct gfs2_rgrpd *rgd);
 extern void gfs2_clear_rgrpd(struct gfs2_sbd *sdp);
 extern int gfs2_rindex_update(struct gfs2_sbd *sdp);
 extern void gfs2_free_clones(struct gfs2_rgrpd *rgd);
-extern int gfs2_rgrp_go_lock(struct gfs2_holder *gh);
+extern int gfs2_rgrp_go_instantiate(struct gfs2_holder *gh);
 extern void gfs2_rgrp_brelse(struct gfs2_rgrpd *rgd);
 
 extern struct gfs2_alloc *gfs2_alloc_get(struct gfs2_inode *ip);
