mm/memory_hotplug: handle memblock_add_node() failures in add_memory_resource()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author David Hildenbrand <david@redhat.com>
commit 53d38316ab2017a7c0d733765b521700aa357ec9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/53d38316.failed

Patch series "mm/memory_hotplug: full support for add_memory_driver_managed() with CONFIG_ARCH_KEEP_MEMBLOCK", v2.

Architectures that require CONFIG_ARCH_KEEP_MEMBLOCK=y, such as arm64,
don't cleanly support add_memory_driver_managed() yet.  Most
prominently, kexec_file can still end up placing kexec images on such
driver-managed memory, resulting in undesired behavior, for example,
having kexec images located on memory not part of the firmware-provided
memory map.

Teaching kexec to not place images on driver-managed memory is
especially relevant for virtio-mem.  Details can be found in commit
7b7b27214bba ("mm/memory_hotplug: introduce
add_memory_driver_managed()").

Extend memblock with a new flag and set it from memory hotplug code when
applicable.  This is required to fully support virtio-mem on arm64,
making also kexec_file behave like on x86-64.

This patch (of 2):

If memblock_add_node() fails, we're most probably running out of memory.
While this is unlikely to happen, it can happen and having memory added
without a memblock can be problematic for architectures that use
memblock to detect valid memory.  Let's fail in a nice way instead of
silently ignoring the error.

Link: https://lkml.kernel.org/r/20211004093605.5830-1-david@redhat.com
Link: https://lkml.kernel.org/r/20211004093605.5830-2-david@redhat.com
	Signed-off-by: David Hildenbrand <david@redhat.com>
	Cc: Mike Rapoport <rppt@kernel.org>
	Cc: Michal Hocko <mhocko@suse.com>
	Cc: Oscar Salvador <osalvador@suse.de>
	Cc: Jianyong Wu <Jianyong.Wu@arm.com>
	Cc: "Aneesh Kumar K . V" <aneesh.kumar@linux.ibm.com>
	Cc: Vineet Gupta <vgupta@kernel.org>
	Cc: Geert Uytterhoeven <geert@linux-m68k.org>
	Cc: Huacai Chen <chenhuacai@kernel.org>
	Cc: Jiaxun Yang <jiaxun.yang@flygoat.com>
	Cc: Thomas Bogendoerfer <tsbogend@alpha.franken.de>
	Cc: Heiko Carstens <hca@linux.ibm.com>
	Cc: Vasily Gorbik <gor@linux.ibm.com>
	Cc: Christian Borntraeger <borntraeger@de.ibm.com>
	Cc: Eric Biederman <ebiederm@xmission.com>
	Cc: Arnd Bergmann <arnd@arndb.de>
	Cc: Shahab Vahedi <shahab@synopsys.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 53d38316ab2017a7c0d733765b521700aa357ec9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/memory_hotplug.c
diff --cc mm/memory_hotplug.c
index 27b7636cc032,9d254e88221e..000000000000
--- a/mm/memory_hotplug.c
+++ b/mm/memory_hotplug.c
@@@ -1104,15 -1355,25 +1104,23 @@@ int __ref add_memory_resource(int nid, 
  	if (ret)
  		return ret;
  
 -	if (mhp_flags & MHP_NID_IS_MGID) {
 -		group = memory_group_find_by_id(nid);
 -		if (!group)
 -			return -EINVAL;
 -		nid = group->nid;
 -	}
 -
 -	if (!node_possible(nid)) {
 -		WARN(1, "node %d was absent from the node_possible_map\n", nid);
 -		return -EINVAL;
 -	}
 -
  	mem_hotplug_begin();
  
++<<<<<<< HEAD
 +	/*
 +	 * Add new range to memblock so that when hotadd_new_pgdat() is called
 +	 * to allocate new pgdat, get_pfn_range_for_nid() will be able to find
 +	 * this new range and calculate total pages correctly.  The range will
 +	 * be removed at hot-remove time.
 +	 */
 +	memblock_add_node(start, size, nid);
++=======
+ 	if (IS_ENABLED(CONFIG_ARCH_KEEP_MEMBLOCK)) {
+ 		ret = memblock_add_node(start, size, nid);
+ 		if (ret)
+ 			goto error_mem_hotplug_end;
+ 	}
++>>>>>>> 53d38316ab20 (mm/memory_hotplug: handle memblock_add_node() failures in add_memory_resource())
  
  	ret = __try_online_node(nid, false);
  	if (ret < 0)
@@@ -1162,7 -1444,9 +1170,13 @@@ error
  	/* rollback pgdat allocation and others */
  	if (new_node)
  		rollback_node_hotadd(nid);
++<<<<<<< HEAD
 +	memblock_remove(start, size);
++=======
+ 	if (IS_ENABLED(CONFIG_ARCH_KEEP_MEMBLOCK))
+ 		memblock_remove(start, size);
+ error_mem_hotplug_end:
++>>>>>>> 53d38316ab20 (mm/memory_hotplug: handle memblock_add_node() failures in add_memory_resource())
  	mem_hotplug_done();
  	return ret;
  }
* Unmerged path mm/memory_hotplug.c
