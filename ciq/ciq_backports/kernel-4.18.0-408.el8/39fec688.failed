ext4: fix lazy initialization next schedule time computation in more granular unit

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Shaoying Xu <shaoyi@amazon.com>
commit 39fec6889d15a658c3a3ebb06fd69d3584ddffd3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/39fec688.failed

Ext4 file system has default lazy inode table initialization setup once
it is mounted. However, it has issue on computing the next schedule time
that makes the timeout same amount in jiffies but different real time in
secs if with various HZ values. Therefore, fix by measuring the current
time in a more granular unit nanoseconds and make the next schedule time
independent of the HZ value.

Fixes: bfff68738f1c ("ext4: add support for lazy inode table initialization")
	Signed-off-by: Shaoying Xu <shaoyi@amazon.com>
	Cc: stable@vger.kernel.org
	Signed-off-by: Theodore Ts'o <tytso@mit.edu>
Link: https://lore.kernel.org/r/20210902164412.9994-2-shaoyi@amazon.com
	Signed-off-by: Theodore Ts'o <tytso@mit.edu>
(cherry picked from commit 39fec6889d15a658c3a3ebb06fd69d3584ddffd3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ext4/super.c
diff --cc fs/ext4/super.c
index 60648e7cb0cb,8a67e5f3f576..000000000000
--- a/fs/ext4/super.c
+++ b/fs/ext4/super.c
@@@ -3134,15 -3260,34 +3134,23 @@@ static void print_daily_error_info(stru
  static int ext4_run_li_request(struct ext4_li_request *elr)
  {
  	struct ext4_group_desc *gdp = NULL;
++<<<<<<< HEAD
 +	ext4_group_t group, ngroups;
 +	struct super_block *sb;
 +	unsigned long timeout = 0;
++=======
+ 	struct super_block *sb = elr->lr_super;
+ 	ext4_group_t ngroups = EXT4_SB(sb)->s_groups_count;
+ 	ext4_group_t group = elr->lr_next_group;
+ 	unsigned int prefetch_ios = 0;
++>>>>>>> 39fec6889d15 (ext4: fix lazy initialization next schedule time computation in more granular unit)
  	int ret = 0;
+ 	u64 start_time;
  
 -	if (elr->lr_mode == EXT4_LI_MODE_PREFETCH_BBITMAP) {
 -		elr->lr_next_group = ext4_mb_prefetch(sb, group,
 -				EXT4_SB(sb)->s_mb_prefetch, &prefetch_ios);
 -		if (prefetch_ios)
 -			ext4_mb_prefetch_fini(sb, elr->lr_next_group,
 -					      prefetch_ios);
 -		trace_ext4_prefetch_bitmaps(sb, group, elr->lr_next_group,
 -					    prefetch_ios);
 -		if (group >= elr->lr_next_group) {
 -			ret = 1;
 -			if (elr->lr_first_not_zeroed != ngroups &&
 -			    !sb_rdonly(sb) && test_opt(sb, INIT_INODE_TABLE)) {
 -				elr->lr_next_group = elr->lr_first_not_zeroed;
 -				elr->lr_mode = EXT4_LI_MODE_ITABLE;
 -				ret = 0;
 -			}
 -		}
 -		return ret;
 -	}
 +	sb = elr->lr_super;
 +	ngroups = EXT4_SB(sb)->s_groups_count;
  
 -	for (; group < ngroups; group++) {
 +	for (group = elr->lr_next_group; group < ngroups; group++) {
  		gdp = ext4_get_group_desc(sb, group, NULL);
  		if (!gdp) {
  			ret = 1;
@@@ -3157,13 -3302,13 +3165,18 @@@
  		ret = 1;
  
  	if (!ret) {
- 		timeout = jiffies;
+ 		start_time = ktime_get_real_ns();
  		ret = ext4_init_inode_table(sb, group,
  					    elr->lr_timeout ? 0 : 1);
 -		trace_ext4_lazy_itable_init(sb, group);
  		if (elr->lr_timeout == 0) {
++<<<<<<< HEAD
 +			timeout = (jiffies - timeout) *
 +				  elr->lr_sbi->s_li_wait_mult;
 +			elr->lr_timeout = timeout;
++=======
+ 			elr->lr_timeout = nsecs_to_jiffies((ktime_get_real_ns() - start_time) *
+ 				EXT4_SB(elr->lr_super)->s_li_wait_mult);
++>>>>>>> 39fec6889d15 (ext4: fix lazy initialization next schedule time computation in more granular unit)
  		}
  		elr->lr_next_sched = jiffies + elr->lr_timeout;
  		elr->lr_next_group = group + 1;
* Unmerged path fs/ext4/super.c
