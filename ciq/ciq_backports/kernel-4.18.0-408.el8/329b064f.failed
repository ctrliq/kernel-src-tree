thermal: core: Get thermal zone by id

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Daniel Lezcano <daniel.lezcano@linaro.org>
commit 329b064fbd13d6526fdc35d4a220adedeadf0816
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/329b064f.failed

The next patch will introduce the generic netlink protocol to handle
events, sampling and command from the thermal framework. In order to
deal with the thermal zone, it uses its unique identifier to
characterize it in the message. Passing an integer is more efficient
than passing an entire string.

This change provides a function returning back a thermal zone pointer
corresponding to the identifier passed as parameter.

	Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
	Reviewed-by: Amit Kucheria <amit.kucheria@linaro.org>
	Acked-by: Zhang Rui <rui.zhang@intel.com>
Link: https://lore.kernel.org/r/20200706105538.2159-2-daniel.lezcano@linaro.org
(cherry picked from commit 329b064fbd13d6526fdc35d4a220adedeadf0816)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/thermal/thermal_core.c
#	drivers/thermal/thermal_core.h
diff --cc drivers/thermal/thermal_core.c
index cf139cb114db,fc1270c8ce11..000000000000
--- a/drivers/thermal/thermal_core.c
+++ b/drivers/thermal/thermal_core.c
@@@ -696,6 -681,71 +696,74 @@@ void thermal_zone_device_rebind_excepti
  	mutex_unlock(&thermal_list_lock);
  }
  
++<<<<<<< HEAD
++=======
+ int for_each_thermal_governor(int (*cb)(struct thermal_governor *, void *),
+ 			      void *data)
+ {
+ 	struct thermal_governor *gov;
+ 	int ret = 0;
+ 
+ 	mutex_lock(&thermal_governor_lock);
+ 	list_for_each_entry(gov, &thermal_governor_list, governor_list) {
+ 		ret = cb(gov, data);
+ 		if (ret)
+ 			break;
+ 	}
+ 	mutex_unlock(&thermal_governor_lock);
+ 
+ 	return ret;
+ }
+ 
+ int for_each_thermal_cooling_device(int (*cb)(struct thermal_cooling_device *,
+ 					      void *), void *data)
+ {
+ 	struct thermal_cooling_device *cdev;
+ 	int ret = 0;
+ 
+ 	mutex_lock(&thermal_list_lock);
+ 	list_for_each_entry(cdev, &thermal_cdev_list, node) {
+ 		ret = cb(cdev, data);
+ 		if (ret)
+ 			break;
+ 	}
+ 	mutex_unlock(&thermal_list_lock);
+ 
+ 	return ret;
+ }
+ 
+ int for_each_thermal_zone(int (*cb)(struct thermal_zone_device *, void *),
+ 			  void *data)
+ {
+ 	struct thermal_zone_device *tz;
+ 	int ret = 0;
+ 
+ 	mutex_lock(&thermal_list_lock);
+ 	list_for_each_entry(tz, &thermal_tz_list, node) {
+ 		ret = cb(tz, data);
+ 		if (ret)
+ 			break;
+ 	}
+ 	mutex_unlock(&thermal_list_lock);
+ 
+ 	return ret;
+ }
+ 
+ struct thermal_zone_device *thermal_zone_get_by_id(int id)
+ {
+ 	struct thermal_zone_device *tz = NULL;
+ 
+ 	mutex_lock(&thermal_list_lock);
+ 	list_for_each_entry(tz, &thermal_tz_list, node) {
+ 		if (tz->id == id)
+ 			break;
+ 	}
+ 	mutex_unlock(&thermal_list_lock);
+ 
+ 	return tz;
+ }
+ 
++>>>>>>> 329b064fbd13 (thermal: core: Get thermal zone by id)
  void thermal_zone_device_unbind_exception(struct thermal_zone_device *tz,
  					  const char *cdev_type, size_t size)
  {
diff --cc drivers/thermal/thermal_core.h
index 0df190ed82a7,967b0ba6593e..000000000000
--- a/drivers/thermal/thermal_core.h
+++ b/drivers/thermal/thermal_core.h
@@@ -15,6 -15,81 +15,73 @@@
  /* Initial state of a cooling device during binding */
  #define THERMAL_NO_TARGET -1UL
  
++<<<<<<< HEAD
++=======
+ /* Init section thermal table */
+ extern struct thermal_governor *__governor_thermal_table[];
+ extern struct thermal_governor *__governor_thermal_table_end[];
+ 
+ #define THERMAL_TABLE_ENTRY(table, name)			\
+ 	static typeof(name) *__thermal_table_entry_##name	\
+ 	__used __section(__##table##_thermal_table) = &name
+ 
+ #define THERMAL_GOVERNOR_DECLARE(name)	THERMAL_TABLE_ENTRY(governor, name)
+ 
+ #define for_each_governor_table(__governor)		\
+ 	for (__governor = __governor_thermal_table;	\
+ 	     __governor < __governor_thermal_table_end;	\
+ 	     __governor++)
+ 
+ int for_each_thermal_zone(int (*cb)(struct thermal_zone_device *, void *),
+ 			  void *);
+ 
+ int for_each_thermal_cooling_device(int (*cb)(struct thermal_cooling_device *,
+ 					      void *), void *);
+ 
+ int for_each_thermal_governor(int (*cb)(struct thermal_governor *, void *),
+ 			      void *thermal_governor);
+ 
+ struct thermal_zone_device *thermal_zone_get_by_id(int id);
+ 
+ struct thermal_attr {
+ 	struct device_attribute attr;
+ 	char name[THERMAL_NAME_LENGTH];
+ };
+ 
+ static inline bool cdev_is_power_actor(struct thermal_cooling_device *cdev)
+ {
+ 	return cdev->ops->get_requested_power && cdev->ops->state2power &&
+ 		cdev->ops->power2state;
+ }
+ 
+ int power_actor_get_max_power(struct thermal_cooling_device *cdev,
+ 			      struct thermal_zone_device *tz, u32 *max_power);
+ int power_actor_get_min_power(struct thermal_cooling_device *cdev,
+ 			      struct thermal_zone_device *tz, u32 *min_power);
+ int power_actor_set_power(struct thermal_cooling_device *cdev,
+ 			  struct thermal_instance *ti, u32 power);
+ /**
+  * struct thermal_trip - representation of a point in temperature domain
+  * @np: pointer to struct device_node that this trip point was created from
+  * @temperature: temperature value in miliCelsius
+  * @hysteresis: relative hysteresis in miliCelsius
+  * @type: trip point type
+  */
+ struct thermal_trip {
+ 	struct device_node *np;
+ 	int temperature;
+ 	int hysteresis;
+ 	enum thermal_trip_type type;
+ };
+ 
+ int get_tz_trend(struct thermal_zone_device *tz, int trip);
+ 
+ struct thermal_instance *
+ get_thermal_instance(struct thermal_zone_device *tz,
+ 		     struct thermal_cooling_device *cdev,
+ 		     int trip);
+ 
++>>>>>>> 329b064fbd13 (thermal: core: Get thermal zone by id)
  /*
   * This structure is used to describe the behavior of
   * a certain cooling device on a certain trip point
* Unmerged path drivers/thermal/thermal_core.c
* Unmerged path drivers/thermal/thermal_core.h
