dmaengine: idxd: add type to driver in order to allow device matching

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Dave Jiang <dave.jiang@intel.com>
commit 5fee6567ec387088ec965ee60c63051bbe102cac
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/5fee6567.failed

Add an array of support device types to the idxd_device_driver
definition in order to enable simple matching of device type to a
given driver. The deprecated / omnibus dsa_drv driver specifies
IDXD_DEV_NONE as its only role is to service legacy userspace (old
accel-config) directed bind requests and route them to them the proper
driver. It need not attach to a device when the bus is autoprobed. The
accel-config tooling is being updated to drop its dependency on this
deprecated bind scheme.

	Reviewed-by: Dan Willliams <dan.j.williams@intel.com>
	Signed-off-by: Dave Jiang <dave.jiang@intel.com>
Link: https://lore.kernel.org/r/162637465882.744545.17456174666211577867.stgit@djiang5-desk3.ch.intel.com
	Signed-off-by: Vinod Koul <vkoul@kernel.org>
(cherry picked from commit 5fee6567ec387088ec965ee60c63051bbe102cac)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/dma/idxd/idxd.h
#	drivers/dma/idxd/sysfs.c
diff --cc drivers/dma/idxd/idxd.h
index 813e19b4ecc8,4bb5a65ec237..000000000000
--- a/drivers/dma/idxd/idxd.h
+++ b/drivers/dma/idxd/idxd.h
@@@ -35,6 -51,9 +35,12 @@@ enum idxd_type 
  
  struct idxd_device_driver {
  	const char *name;
++<<<<<<< HEAD
++=======
+ 	enum idxd_dev_type *type;
+ 	int (*probe)(struct idxd_dev *idxd_dev);
+ 	void (*remove)(struct idxd_dev *idxd_dev);
++>>>>>>> 5fee6567ec38 (dmaengine: idxd: add type to driver in order to allow device matching)
  	struct device_driver drv;
  };
  
diff --cc drivers/dma/idxd/sysfs.c
index e25f04f3917e,8d48903df131..000000000000
--- a/drivers/dma/idxd/sysfs.c
+++ b/drivers/dma/idxd/sysfs.c
@@@ -19,145 -19,17 +19,159 @@@ static char *idxd_wq_type_names[] = 
  static int idxd_config_bus_match(struct device *dev,
  				 struct device_driver *drv)
  {
++<<<<<<< HEAD
 +	int matched = 0;
 +
 +	if (is_idxd_dev(dev)) {
 +		matched = 1;
 +	} else if (is_idxd_wq_dev(dev)) {
 +		struct idxd_wq *wq = confdev_to_wq(dev);
 +
 +		if (wq->state != IDXD_WQ_DISABLED) {
 +			dev_dbg(dev, "%s not disabled\n", dev_name(dev));
 +			return 0;
 +		}
 +		matched = 1;
 +	}
 +
 +	if (matched)
 +		dev_dbg(dev, "%s matched\n", dev_name(dev));
 +
 +	return matched;
 +}
 +
 +static int enable_wq(struct idxd_wq *wq)
 +{
 +	struct idxd_device *idxd = wq->idxd;
 +	struct device *dev = &idxd->pdev->dev;
 +	unsigned long flags;
 +	int rc;
 +
 +	mutex_lock(&wq->wq_lock);
 +
 +	if (idxd->state != IDXD_DEV_ENABLED) {
 +		mutex_unlock(&wq->wq_lock);
 +		dev_warn(dev, "Enabling while device not enabled.\n");
 +		return -EPERM;
 +	}
 +
 +	if (wq->state != IDXD_WQ_DISABLED) {
 +		mutex_unlock(&wq->wq_lock);
 +		dev_warn(dev, "WQ %d already enabled.\n", wq->id);
 +		return -EBUSY;
 +	}
 +
 +	if (!wq->group) {
 +		mutex_unlock(&wq->wq_lock);
 +		dev_warn(dev, "WQ not attached to group.\n");
 +		return -EINVAL;
 +	}
 +
 +	if (strlen(wq->name) == 0) {
 +		mutex_unlock(&wq->wq_lock);
 +		dev_warn(dev, "WQ name not set.\n");
 +		return -EINVAL;
 +	}
 +
 +	/* Shared WQ checks */
 +	if (wq_shared(wq)) {
 +		if (!device_swq_supported(idxd)) {
 +			dev_warn(dev, "PASID not enabled and shared WQ.\n");
 +			mutex_unlock(&wq->wq_lock);
 +			return -ENXIO;
 +		}
 +		/*
 +		 * Shared wq with the threshold set to 0 means the user
 +		 * did not set the threshold or transitioned from a
 +		 * dedicated wq but did not set threshold. A value
 +		 * of 0 would effectively disable the shared wq. The
 +		 * driver does not allow a value of 0 to be set for
 +		 * threshold via sysfs.
 +		 */
 +		if (wq->threshold == 0) {
 +			dev_warn(dev, "Shared WQ and threshold 0.\n");
 +			mutex_unlock(&wq->wq_lock);
 +			return -EINVAL;
 +		}
 +	}
 +
 +	rc = idxd_wq_alloc_resources(wq);
 +	if (rc < 0) {
 +		mutex_unlock(&wq->wq_lock);
 +		dev_warn(dev, "WQ resource alloc failed\n");
 +		return rc;
 +	}
 +
 +	spin_lock_irqsave(&idxd->dev_lock, flags);
 +	if (test_bit(IDXD_FLAG_CONFIGURABLE, &idxd->flags))
 +		rc = idxd_device_config(idxd);
 +	spin_unlock_irqrestore(&idxd->dev_lock, flags);
 +	if (rc < 0) {
 +		mutex_unlock(&wq->wq_lock);
 +		dev_warn(dev, "Writing WQ %d config failed: %d\n", wq->id, rc);
 +		return rc;
 +	}
 +
 +	rc = idxd_wq_enable(wq);
 +	if (rc < 0) {
 +		mutex_unlock(&wq->wq_lock);
 +		dev_warn(dev, "WQ %d enabling failed: %d\n", wq->id, rc);
 +		return rc;
 +	}
 +
 +	rc = idxd_wq_map_portal(wq);
 +	if (rc < 0) {
 +		dev_warn(dev, "wq portal mapping failed: %d\n", rc);
 +		rc = idxd_wq_disable(wq, false);
 +		if (rc < 0)
 +			dev_warn(dev, "IDXD wq disable failed\n");
 +		mutex_unlock(&wq->wq_lock);
 +		return rc;
 +	}
 +
 +	wq->client_count = 0;
 +
 +	if (wq->type == IDXD_WQT_KERNEL) {
 +		rc = idxd_wq_init_percpu_ref(wq);
 +		if (rc < 0) {
 +			dev_dbg(dev, "percpu_ref setup failed\n");
 +			mutex_unlock(&wq->wq_lock);
 +			return rc;
 +		}
 +	}
 +
 +	if (is_idxd_wq_dmaengine(wq)) {
 +		rc = idxd_register_dma_channel(wq);
 +		if (rc < 0) {
 +			dev_dbg(dev, "DMA channel register failed\n");
 +			mutex_unlock(&wq->wq_lock);
 +			return rc;
 +		}
 +	} else if (is_idxd_wq_cdev(wq)) {
 +		rc = idxd_wq_add_cdev(wq);
 +		if (rc < 0) {
 +			dev_dbg(dev, "Cdev creation failed\n");
 +			mutex_unlock(&wq->wq_lock);
 +			return rc;
 +		}
 +	}
 +
 +	mutex_unlock(&wq->wq_lock);
 +	dev_info(dev, "wq %s enabled\n", dev_name(&wq->conf_dev));
 +
++=======
+ 	struct idxd_device_driver *idxd_drv =
+ 		container_of(drv, struct idxd_device_driver, drv);
+ 	struct idxd_dev *idxd_dev = confdev_to_idxd_dev(dev);
+ 	int i = 0;
+ 
+ 	while (idxd_drv->type[i] != IDXD_DEV_NONE) {
+ 		if (idxd_dev->type == idxd_drv->type[i])
+ 			return 1;
+ 		i++;
+ 	}
+ 
++>>>>>>> 5fee6567ec38 (dmaengine: idxd: add type to driver in order to allow device matching)
  	return 0;
  }
  
@@@ -291,21 -59,46 +305,62 @@@ struct bus_type dsa_bus_type = 
  	.remove = idxd_config_bus_remove,
  };
  
++<<<<<<< HEAD
 +static struct idxd_device_driver dsa_drv = {
 +	.name = "dsa",
++=======
+ static int idxd_dsa_drv_probe(struct idxd_dev *idxd_dev)
+ {
+ 	if (is_idxd_dev(idxd_dev))
+ 		return idxd_device_drv_probe(idxd_dev);
+ 
+ 	if (is_idxd_wq_dev(idxd_dev)) {
+ 		struct idxd_wq *wq = idxd_dev_to_wq(idxd_dev);
+ 
+ 		return drv_enable_wq(wq);
+ 	}
+ 
+ 	return -ENODEV;
+ }
+ 
+ static void idxd_dsa_drv_remove(struct idxd_dev *idxd_dev)
+ {
+ 	if (is_idxd_dev(idxd_dev)) {
+ 		idxd_device_drv_remove(idxd_dev);
+ 		return;
+ 	}
+ 
+ 	if (is_idxd_wq_dev(idxd_dev)) {
+ 		struct idxd_wq *wq = idxd_dev_to_wq(idxd_dev);
+ 
+ 		drv_disable_wq(wq);
+ 		return;
+ 	}
+ }
+ 
+ static enum idxd_dev_type dev_types[] = {
+ 	IDXD_DEV_NONE,
+ };
+ 
+ struct idxd_device_driver dsa_drv = {
+ 	.name = "dsa",
+ 	.probe = idxd_dsa_drv_probe,
+ 	.remove = idxd_dsa_drv_remove,
+ 	.type = dev_types,
++>>>>>>> 5fee6567ec38 (dmaengine: idxd: add type to driver in order to allow device matching)
  };
  
 +/* IDXD generic driver setup */
 +int idxd_register_driver(void)
 +{
 +	return idxd_driver_register(&dsa_drv);
 +}
 +
 +void idxd_unregister_driver(void)
 +{
 +	idxd_driver_unregister(&dsa_drv);
 +}
 +
  /* IDXD engine attributes */
  static ssize_t engine_group_id_show(struct device *dev,
  				    struct device_attribute *attr, char *buf)
* Unmerged path drivers/dma/idxd/idxd.h
diff --git a/drivers/dma/idxd/init.c b/drivers/dma/idxd/init.c
index 20eae71edab4..6bd5fd8c09e1 100644
--- a/drivers/dma/idxd/init.c
+++ b/drivers/dma/idxd/init.c
@@ -859,6 +859,11 @@ int __idxd_driver_register(struct idxd_device_driver *idxd_drv, struct module *o
 {
 	struct device_driver *drv = &idxd_drv->drv;
 
+	if (!idxd_drv->type) {
+		pr_debug("driver type not set (%ps)\n", __builtin_return_address(0));
+		return -EINVAL;
+	}
+
 	drv->name = idxd_drv->name;
 	drv->bus = &dsa_bus_type;
 	drv->owner = owner;
* Unmerged path drivers/dma/idxd/sysfs.c
