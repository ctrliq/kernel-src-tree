scsi: mpi3mr: Add support for PEL commands

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Sumit Saxena <sumit.saxena@broadcom.com>
commit 43ca110050988c7a0e581d24ce212ef34a4cdf29
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/43ca1100.failed

Implement driver support for management applications to enable persistent
event log (PEL) notifications. Upon receipt of events, the driver will
increment a sysfs variable named event_counter. The management application
will poll for event_counter value changes and signal the application about
events.

Link: https://lore.kernel.org/r/20220429211641.642010-6-sumit.saxena@broadcom.com
	Reviewed-by: Himanshu Madhani <himanshu.madhani@oracle.com>
	Signed-off-by: Sumit Saxena <sumit.saxena@broadcom.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 43ca110050988c7a0e581d24ce212ef34a4cdf29)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/mpi3mr/mpi3mr.h
#	drivers/scsi/mpi3mr/mpi3mr_app.c
#	drivers/scsi/mpi3mr/mpi3mr_fw.c
diff --cc drivers/scsi/mpi3mr/mpi3mr.h
index 054d5f025cbf,ad1270cba280..000000000000
--- a/drivers/scsi/mpi3mr/mpi3mr.h
+++ b/drivers/scsi/mpi3mr/mpi3mr.h
@@@ -89,7 -91,9 +90,13 @@@ extern atomic64_t event_counter
  /* Reserved Host Tag definitions */
  #define MPI3MR_HOSTTAG_INVALID		0xFFFF
  #define MPI3MR_HOSTTAG_INITCMDS		1
++<<<<<<< HEAD
 +#define MPI3MR_HOSTTAG_IOCTLCMDS	2
++=======
+ #define MPI3MR_HOSTTAG_BSG_CMDS		2
+ #define MPI3MR_HOSTTAG_PEL_ABORT	3
+ #define MPI3MR_HOSTTAG_PEL_WAIT		4
++>>>>>>> 43ca11005098 (scsi: mpi3mr: Add support for PEL commands)
  #define MPI3MR_HOSTTAG_BLK_TMS		5
  
  #define MPI3MR_NUM_DEVRMCMD		16
@@@ -142,8 -152,10 +149,9 @@@
  
  #define MPI3MR_DEFAULT_MDTS	(128 * 1024)
  #define MPI3MR_DEFAULT_PGSZEXP         (12)
 -
  /* Command retry count definitions */
  #define MPI3MR_DEV_RMHS_RETRY_COUNT 3
+ #define MPI3MR_PEL_RETRY_COUNT 3
  
  /* Default target device queue depth */
  #define MPI3MR_DEFAULT_SDEV_QD	32
@@@ -689,7 -752,26 +697,17 @@@ struct scmd_priv 
   * @current_event: Firmware event currently in process
   * @driver_info: Driver, Kernel, OS information to firmware
   * @change_count: Topology change count
+  * @pel_enabled: Persistent Event Log(PEL) enabled or not
+  * @pel_abort_requested: PEL abort is requested or not
+  * @pel_class: PEL Class identifier
+  * @pel_locale: PEL Locale identifier
+  * @pel_cmds: Command tracker for PEL wait command
+  * @pel_abort_cmd: Command tracker for PEL abort command
+  * @pel_newest_seqnum: Newest PEL sequenece number
+  * @pel_seqnum_virt: PEL sequence number virtual address
+  * @pel_seqnum_dma: PEL sequence number DMA address
+  * @pel_seqnum_sz: PEL sequenece number size
   * @op_reply_q_offset: Operational reply queue offset with MSIx
 - * @default_qcount: Total Default queues
 - * @active_poll_qcount: Currently active poll queue count
 - * @requested_poll_qcount: User requested poll queue count
 - * @bsg_dev: BSG device structure
 - * @bsg_queue: Request queue for BSG device
 - * @stop_bsgs: Stop BSG request flag
 - * @logdata_buf: Circular buffer to store log data entries
 - * @logdata_buf_idx: Index of entry in buffer to store
 - * @logdata_entry_sz: log data entry size
   */
  struct mpi3mr_ioc {
  	struct list_head list;
@@@ -818,7 -908,30 +836,34 @@@
  	struct mpi3mr_fwevt *current_event;
  	struct mpi3_driver_info_layout driver_info;
  	u16 change_count;
++<<<<<<< HEAD
 +	u16 op_reply_q_offset;
++=======
+ 
+ 	u8 pel_enabled;
+ 	u8 pel_abort_requested;
+ 	u8 pel_class;
+ 	u16 pel_locale;
+ 	struct mpi3mr_drv_cmd pel_cmds;
+ 	struct mpi3mr_drv_cmd pel_abort_cmd;
+ 
+ 	u32 pel_newest_seqnum;
+ 	void *pel_seqnum_virt;
+ 	dma_addr_t pel_seqnum_dma;
+ 	u32 pel_seqnum_sz;
+ 
+ 	u16 op_reply_q_offset;
+ 	u16 default_qcount;
+ 	u16 active_poll_qcount;
+ 	u16 requested_poll_qcount;
+ 
+ 	struct device *bsg_dev;
+ 	struct request_queue *bsg_queue;
+ 	u8 stop_bsgs;
+ 	u8 *logdata_buf;
+ 	u16 logdata_buf_idx;
+ 	u16 logdata_entry_sz;
++>>>>>>> 43ca11005098 (scsi: mpi3mr: Add support for PEL commands)
  };
  
  /**
@@@ -910,8 -1035,26 +957,27 @@@ void mpi3mr_cleanup_fwevt_list(struct m
  void mpi3mr_flush_host_io(struct mpi3mr_ioc *mrioc);
  void mpi3mr_invalidate_devhandles(struct mpi3mr_ioc *mrioc);
  void mpi3mr_rfresh_tgtdevs(struct mpi3mr_ioc *mrioc);
 -void mpi3mr_flush_delayed_cmd_lists(struct mpi3mr_ioc *mrioc);
 -void mpi3mr_check_rh_fault_ioc(struct mpi3mr_ioc *mrioc, u32 reason_code);
 -void mpi3mr_print_fault_info(struct mpi3mr_ioc *mrioc);
 -void mpi3mr_check_rh_fault_ioc(struct mpi3mr_ioc *mrioc, u32 reason_code);
 +void mpi3mr_flush_delayed_rmhs_list(struct mpi3mr_ioc *mrioc);
  int mpi3mr_process_op_reply_q(struct mpi3mr_ioc *mrioc,
++<<<<<<< HEAD
 +	struct mpi3mr_intr_info *intr_info);
++=======
+ 	struct op_reply_qinfo *op_reply_q);
+ int mpi3mr_blk_mq_poll(struct Scsi_Host *shost, unsigned int queue_num);
+ void mpi3mr_bsg_init(struct mpi3mr_ioc *mrioc);
+ void mpi3mr_bsg_exit(struct mpi3mr_ioc *mrioc);
+ int mpi3mr_issue_tm(struct mpi3mr_ioc *mrioc, u8 tm_type,
+ 	u16 handle, uint lun, u16 htag, ulong timeout,
+ 	struct mpi3mr_drv_cmd *drv_cmd,
+ 	u8 *resp_code, struct scsi_cmnd *scmd);
+ struct mpi3mr_tgt_dev *mpi3mr_get_tgtdev_by_handle(
+ 	struct mpi3mr_ioc *mrioc, u16 handle);
+ void mpi3mr_pel_get_seqnum_complete(struct mpi3mr_ioc *mrioc,
+ 	struct mpi3mr_drv_cmd *drv_cmd);
+ int mpi3mr_pel_get_seqnum_post(struct mpi3mr_ioc *mrioc,
+ 	struct mpi3mr_drv_cmd *drv_cmd);
+ void mpi3mr_app_save_logdata(struct mpi3mr_ioc *mrioc, char *event_data,
+ 	u16 event_data_size);
++>>>>>>> 43ca11005098 (scsi: mpi3mr: Add support for PEL commands)
  
  #endif /*MPI3MR_H_INCLUDED*/
diff --cc drivers/scsi/mpi3mr/mpi3mr_fw.c
index dd27bae528b9,74e09727a1b8..000000000000
--- a/drivers/scsi/mpi3mr/mpi3mr_fw.c
+++ b/drivers/scsi/mpi3mr/mpi3mr_fw.c
@@@ -15,7 -15,13 +15,9 @@@ mpi3mr_issue_reset(struct mpi3mr_ioc *m
  static int mpi3mr_setup_admin_qpair(struct mpi3mr_ioc *mrioc);
  static void mpi3mr_process_factsdata(struct mpi3mr_ioc *mrioc,
  	struct mpi3_ioc_facts_data *facts_data);
+ static void mpi3mr_pel_wait_complete(struct mpi3mr_ioc *mrioc,
+ 	struct mpi3mr_drv_cmd *drv_cmd);
  
 -static int poll_queues;
 -module_param(poll_queues, int, 0444);
 -MODULE_PARM_DESC(poll_queues, "Number of queues for io_uring poll mode. (Range 1 - 126)");
 -
  #if defined(writeq) && defined(CONFIG_64BIT)
  static inline void mpi3mr_writeq(__u64 b, volatile void __iomem *addr)
  {
@@@ -293,8 -299,14 +295,12 @@@ mpi3mr_get_drv_cmd(struct mpi3mr_ioc *m
  	switch (host_tag) {
  	case MPI3MR_HOSTTAG_INITCMDS:
  		return &mrioc->init_cmds;
 -	case MPI3MR_HOSTTAG_BSG_CMDS:
 -		return &mrioc->bsg_cmds;
  	case MPI3MR_HOSTTAG_BLK_TMS:
  		return &mrioc->host_tm_cmds;
+ 	case MPI3MR_HOSTTAG_PEL_ABORT:
+ 		return &mrioc->pel_abort_cmd;
+ 	case MPI3MR_HOSTTAG_PEL_WAIT:
+ 		return &mrioc->pel_cmds;
  	case MPI3MR_HOSTTAG_INVALID:
  		if (def_reply && def_reply->function ==
  		    MPI3_FUNCTION_EVENT_NOTIFICATION)
@@@ -3701,9 -3867,19 +3725,19 @@@ retry_init
  		goto out_failed;
  	}
  
+ 	if (!mrioc->pel_seqnum_virt) {
+ 		dprint_reset(mrioc, "allocating memory for pel_seqnum_virt\n");
+ 		mrioc->pel_seqnum_sz = sizeof(struct mpi3_pel_seq);
+ 		mrioc->pel_seqnum_virt = dma_alloc_coherent(&mrioc->pdev->dev,
+ 		    mrioc->pel_seqnum_sz, &mrioc->pel_seqnum_dma,
+ 		    GFP_KERNEL);
+ 		if (!mrioc->pel_seqnum_virt)
+ 			goto out_failed_noretry;
+ 	}
+ 
  	if (mrioc->shost->nr_hw_queues > mrioc->num_op_reply_q) {
  		ioc_err(mrioc,
 -		    "cannot create minimum number of operational queues expected:%d created:%d\n",
 +		    "cannot create minimum number of operatioanl queues expected:%d created:%d\n",
  		    mrioc->shost->nr_hw_queues, mrioc->num_op_reply_q);
  		goto out_failed_noretry;
  	}
@@@ -3810,8 -3988,14 +3844,12 @@@ void mpi3mr_memset_buffers(struct mpi3m
  
  	if (mrioc->init_cmds.reply) {
  		memset(mrioc->init_cmds.reply, 0, sizeof(*mrioc->init_cmds.reply));
 -		memset(mrioc->bsg_cmds.reply, 0,
 -		    sizeof(*mrioc->bsg_cmds.reply));
  		memset(mrioc->host_tm_cmds.reply, 0,
  		    sizeof(*mrioc->host_tm_cmds.reply));
+ 		memset(mrioc->pel_cmds.reply, 0,
+ 		    sizeof(*mrioc->pel_cmds.reply));
+ 		memset(mrioc->pel_abort_cmd.reply, 0,
+ 		    sizeof(*mrioc->pel_abort_cmd.reply));
  		for (i = 0; i < MPI3MR_NUM_DEVRMCMD; i++)
  			memset(mrioc->dev_rmhs_cmds[i].reply, 0,
  			    sizeof(*mrioc->dev_rmhs_cmds[i].reply));
@@@ -3910,6 -4099,20 +3948,20 @@@ void mpi3mr_free_mem(struct mpi3mr_ioc 
  	kfree(mrioc->host_tm_cmds.reply);
  	mrioc->host_tm_cmds.reply = NULL;
  
++<<<<<<< HEAD
++=======
+ 	kfree(mrioc->pel_cmds.reply);
+ 	mrioc->pel_cmds.reply = NULL;
+ 
+ 	kfree(mrioc->pel_abort_cmd.reply);
+ 	mrioc->pel_abort_cmd.reply = NULL;
+ 
+ 	for (i = 0; i < MPI3MR_NUM_EVTACKCMD; i++) {
+ 		kfree(mrioc->evtack_cmds[i].reply);
+ 		mrioc->evtack_cmds[i].reply = NULL;
+ 	}
+ 
++>>>>>>> 43ca11005098 (scsi: mpi3mr: Add support for PEL commands)
  	kfree(mrioc->removepend_bitmap);
  	mrioc->removepend_bitmap = NULL;
  
@@@ -4091,41 -4309,259 +4153,292 @@@ static void mpi3mr_flush_drv_cmds(struc
  		cmdptr = &mrioc->dev_rmhs_cmds[i];
  		mpi3mr_drv_cmd_comp_reset(mrioc, cmdptr);
  	}
 +}
  
 -	for (i = 0; i < MPI3MR_NUM_EVTACKCMD; i++) {
 -		cmdptr = &mrioc->evtack_cmds[i];
 -		mpi3mr_drv_cmd_comp_reset(mrioc, cmdptr);
 +/**
 + * mpi3mr_diagfault_reset_handler - Diag fault reset handler
 + * @mrioc: Adapter instance reference
 + * @reset_reason: Reset reason code
 + *
 + * This is an handler for issuing diag fault reset from the
 + * applications through IOCTL path to stop the execution of the
 + * controller
 + *
 + * Return: 0 on success, non-zero on failure.
 + */
 +int mpi3mr_diagfault_reset_handler(struct mpi3mr_ioc *mrioc,
 +	u32 reset_reason)
 +{
 +	int retval = 0;
 +
 +	ioc_info(mrioc, "Entry: reason code: %s\n",
 +	    mpi3mr_reset_rc_name(reset_reason));
 +	mrioc->reset_in_progress = 1;
 +
 +	mpi3mr_ioc_disable_intr(mrioc);
 +
 +	retval = mpi3mr_issue_reset(mrioc,
 +	    MPI3_SYSIF_HOST_DIAG_RESET_ACTION_DIAG_FAULT, reset_reason);
 +
 +	if (retval) {
 +		ioc_err(mrioc, "The diag fault reset failed: reason %d\n",
 +		    reset_reason);
 +		mpi3mr_ioc_enable_intr(mrioc);
  	}
++<<<<<<< HEAD
 +	ioc_info(mrioc, "%s\n", ((retval == 0) ? "SUCCESS" : "FAILED"));
 +	mrioc->reset_in_progress = 0;
 +	return retval;
++=======
+ 
+ 	cmdptr = &mrioc->pel_cmds;
+ 	mpi3mr_drv_cmd_comp_reset(mrioc, cmdptr);
+ 
+ 	cmdptr = &mrioc->pel_abort_cmd;
+ 	mpi3mr_drv_cmd_comp_reset(mrioc, cmdptr);
+ 
+ }
+ 
+ /**
+  * mpi3mr_pel_wait_post - Issue PEL Wait
+  * @mrioc: Adapter instance reference
+  * @drv_cmd: Internal command tracker
+  *
+  * Issue PEL Wait MPI request through admin queue and return.
+  *
+  * Return: Nothing.
+  */
+ static void mpi3mr_pel_wait_post(struct mpi3mr_ioc *mrioc,
+ 	struct mpi3mr_drv_cmd *drv_cmd)
+ {
+ 	struct mpi3_pel_req_action_wait pel_wait;
+ 
+ 	mrioc->pel_abort_requested = false;
+ 
+ 	memset(&pel_wait, 0, sizeof(pel_wait));
+ 	drv_cmd->state = MPI3MR_CMD_PENDING;
+ 	drv_cmd->is_waiting = 0;
+ 	drv_cmd->callback = mpi3mr_pel_wait_complete;
+ 	drv_cmd->ioc_status = 0;
+ 	drv_cmd->ioc_loginfo = 0;
+ 	pel_wait.host_tag = cpu_to_le16(MPI3MR_HOSTTAG_PEL_WAIT);
+ 	pel_wait.function = MPI3_FUNCTION_PERSISTENT_EVENT_LOG;
+ 	pel_wait.action = MPI3_PEL_ACTION_WAIT;
+ 	pel_wait.starting_sequence_number = cpu_to_le32(mrioc->pel_newest_seqnum);
+ 	pel_wait.locale = cpu_to_le16(mrioc->pel_locale);
+ 	pel_wait.class = cpu_to_le16(mrioc->pel_class);
+ 	pel_wait.wait_time = MPI3_PEL_WAITTIME_INFINITE_WAIT;
+ 	dprint_bsg_info(mrioc, "sending pel_wait seqnum(%d), class(%d), locale(0x%08x)\n",
+ 	    mrioc->pel_newest_seqnum, mrioc->pel_class, mrioc->pel_locale);
+ 
+ 	if (mpi3mr_admin_request_post(mrioc, &pel_wait, sizeof(pel_wait), 0)) {
+ 		dprint_bsg_err(mrioc,
+ 			    "Issuing PELWait: Admin post failed\n");
+ 		drv_cmd->state = MPI3MR_CMD_NOTUSED;
+ 		drv_cmd->callback = NULL;
+ 		drv_cmd->retry_count = 0;
+ 		mrioc->pel_enabled = false;
+ 	}
+ }
+ 
+ /**
+  * mpi3mr_pel_get_seqnum_post - Issue PEL Get Sequence number
+  * @mrioc: Adapter instance reference
+  * @drv_cmd: Internal command tracker
+  *
+  * Issue PEL get sequence number MPI request through admin queue
+  * and return.
+  *
+  * Return: 0 on success, non-zero on failure.
+  */
+ int mpi3mr_pel_get_seqnum_post(struct mpi3mr_ioc *mrioc,
+ 	struct mpi3mr_drv_cmd *drv_cmd)
+ {
+ 	struct mpi3_pel_req_action_get_sequence_numbers pel_getseq_req;
+ 	u8 sgl_flags = MPI3MR_SGEFLAGS_SYSTEM_SIMPLE_END_OF_LIST;
+ 	int retval = 0;
+ 
+ 	memset(&pel_getseq_req, 0, sizeof(pel_getseq_req));
+ 	mrioc->pel_cmds.state = MPI3MR_CMD_PENDING;
+ 	mrioc->pel_cmds.is_waiting = 0;
+ 	mrioc->pel_cmds.ioc_status = 0;
+ 	mrioc->pel_cmds.ioc_loginfo = 0;
+ 	mrioc->pel_cmds.callback = mpi3mr_pel_get_seqnum_complete;
+ 	pel_getseq_req.host_tag = cpu_to_le16(MPI3MR_HOSTTAG_PEL_WAIT);
+ 	pel_getseq_req.function = MPI3_FUNCTION_PERSISTENT_EVENT_LOG;
+ 	pel_getseq_req.action = MPI3_PEL_ACTION_GET_SEQNUM;
+ 	mpi3mr_add_sg_single(&pel_getseq_req.sgl, sgl_flags,
+ 	    mrioc->pel_seqnum_sz, mrioc->pel_seqnum_dma);
+ 
+ 	retval = mpi3mr_admin_request_post(mrioc, &pel_getseq_req,
+ 			sizeof(pel_getseq_req), 0);
+ 	if (retval) {
+ 		if (drv_cmd) {
+ 			drv_cmd->state = MPI3MR_CMD_NOTUSED;
+ 			drv_cmd->callback = NULL;
+ 			drv_cmd->retry_count = 0;
+ 		}
+ 		mrioc->pel_enabled = false;
+ 	}
+ 
+ 	return retval;
+ }
+ 
+ /**
+  * mpi3mr_pel_wait_complete - PELWait Completion callback
+  * @mrioc: Adapter instance reference
+  * @drv_cmd: Internal command tracker
+  *
+  * This is a callback handler for the PELWait request and
+  * firmware completes a PELWait request when it is aborted or a
+  * new PEL entry is available. This sends AEN to the application
+  * and if the PELwait completion is not due to PELAbort then
+  * this will send a request for new PEL Sequence number
+  *
+  * Return: Nothing.
+  */
+ static void mpi3mr_pel_wait_complete(struct mpi3mr_ioc *mrioc,
+ 	struct mpi3mr_drv_cmd *drv_cmd)
+ {
+ 	struct mpi3_pel_reply *pel_reply = NULL;
+ 	u16 ioc_status, pe_log_status;
+ 	bool do_retry = false;
+ 
+ 	if (drv_cmd->state & MPI3MR_CMD_RESET)
+ 		goto cleanup_drv_cmd;
+ 
+ 	ioc_status = drv_cmd->ioc_status & MPI3_IOCSTATUS_STATUS_MASK;
+ 	if (ioc_status != MPI3_IOCSTATUS_SUCCESS) {
+ 		ioc_err(mrioc, "%s: Failed ioc_status(0x%04x) Loginfo(0x%08x)\n",
+ 			__func__, ioc_status, drv_cmd->ioc_loginfo);
+ 		dprint_bsg_err(mrioc,
+ 		    "pel_wait: failed with ioc_status(0x%04x), log_info(0x%08x)\n",
+ 		    ioc_status, drv_cmd->ioc_loginfo);
+ 		do_retry = true;
+ 	}
+ 
+ 	if (drv_cmd->state & MPI3MR_CMD_REPLY_VALID)
+ 		pel_reply = (struct mpi3_pel_reply *)drv_cmd->reply;
+ 
+ 	if (!pel_reply) {
+ 		dprint_bsg_err(mrioc,
+ 		    "pel_wait: failed due to no reply\n");
+ 		goto out_failed;
+ 	}
+ 
+ 	pe_log_status = le16_to_cpu(pel_reply->pe_log_status);
+ 	if ((pe_log_status != MPI3_PEL_STATUS_SUCCESS) &&
+ 	    (pe_log_status != MPI3_PEL_STATUS_ABORTED)) {
+ 		ioc_err(mrioc, "%s: Failed pe_log_status(0x%04x)\n",
+ 			__func__, pe_log_status);
+ 		dprint_bsg_err(mrioc,
+ 		    "pel_wait: failed due to pel_log_status(0x%04x)\n",
+ 		    pe_log_status);
+ 		do_retry = true;
+ 	}
+ 
+ 	if (do_retry) {
+ 		if (drv_cmd->retry_count < MPI3MR_PEL_RETRY_COUNT) {
+ 			drv_cmd->retry_count++;
+ 			dprint_bsg_err(mrioc, "pel_wait: retrying(%d)\n",
+ 			    drv_cmd->retry_count);
+ 			mpi3mr_pel_wait_post(mrioc, drv_cmd);
+ 			return;
+ 		}
+ 		dprint_bsg_err(mrioc,
+ 		    "pel_wait: failed after all retries(%d)\n",
+ 		    drv_cmd->retry_count);
+ 		goto out_failed;
+ 	}
+ 	atomic64_inc(&event_counter);
+ 	if (!mrioc->pel_abort_requested) {
+ 		mrioc->pel_cmds.retry_count = 0;
+ 		mpi3mr_pel_get_seqnum_post(mrioc, &mrioc->pel_cmds);
+ 	}
+ 
+ 	return;
+ out_failed:
+ 	mrioc->pel_enabled = false;
+ cleanup_drv_cmd:
+ 	drv_cmd->state = MPI3MR_CMD_NOTUSED;
+ 	drv_cmd->callback = NULL;
+ 	drv_cmd->retry_count = 0;
+ }
+ 
+ /**
+  * mpi3mr_pel_get_seqnum_complete - PELGetSeqNum Completion callback
+  * @mrioc: Adapter instance reference
+  * @drv_cmd: Internal command tracker
+  *
+  * This is a callback handler for the PEL get sequence number
+  * request and a new PEL wait request will be issued to the
+  * firmware from this
+  *
+  * Return: Nothing.
+  */
+ void mpi3mr_pel_get_seqnum_complete(struct mpi3mr_ioc *mrioc,
+ 	struct mpi3mr_drv_cmd *drv_cmd)
+ {
+ 	struct mpi3_pel_reply *pel_reply = NULL;
+ 	struct mpi3_pel_seq *pel_seqnum_virt;
+ 	u16 ioc_status;
+ 	bool do_retry = false;
+ 
+ 	pel_seqnum_virt = (struct mpi3_pel_seq *)mrioc->pel_seqnum_virt;
+ 
+ 	if (drv_cmd->state & MPI3MR_CMD_RESET)
+ 		goto cleanup_drv_cmd;
+ 
+ 	ioc_status = drv_cmd->ioc_status & MPI3_IOCSTATUS_STATUS_MASK;
+ 	if (ioc_status != MPI3_IOCSTATUS_SUCCESS) {
+ 		dprint_bsg_err(mrioc,
+ 		    "pel_get_seqnum: failed with ioc_status(0x%04x), log_info(0x%08x)\n",
+ 		    ioc_status, drv_cmd->ioc_loginfo);
+ 		do_retry = true;
+ 	}
+ 
+ 	if (drv_cmd->state & MPI3MR_CMD_REPLY_VALID)
+ 		pel_reply = (struct mpi3_pel_reply *)drv_cmd->reply;
+ 	if (!pel_reply) {
+ 		dprint_bsg_err(mrioc,
+ 		    "pel_get_seqnum: failed due to no reply\n");
+ 		goto out_failed;
+ 	}
+ 
+ 	if (le16_to_cpu(pel_reply->pe_log_status) != MPI3_PEL_STATUS_SUCCESS) {
+ 		dprint_bsg_err(mrioc,
+ 		    "pel_get_seqnum: failed due to pel_log_status(0x%04x)\n",
+ 		    le16_to_cpu(pel_reply->pe_log_status));
+ 		do_retry = true;
+ 	}
+ 
+ 	if (do_retry) {
+ 		if (drv_cmd->retry_count < MPI3MR_PEL_RETRY_COUNT) {
+ 			drv_cmd->retry_count++;
+ 			dprint_bsg_err(mrioc,
+ 			    "pel_get_seqnum: retrying(%d)\n",
+ 			    drv_cmd->retry_count);
+ 			mpi3mr_pel_get_seqnum_post(mrioc, drv_cmd);
+ 			return;
+ 		}
+ 
+ 		dprint_bsg_err(mrioc,
+ 		    "pel_get_seqnum: failed after all retries(%d)\n",
+ 		    drv_cmd->retry_count);
+ 		goto out_failed;
+ 	}
+ 	mrioc->pel_newest_seqnum = le32_to_cpu(pel_seqnum_virt->newest) + 1;
+ 	drv_cmd->retry_count = 0;
+ 	mpi3mr_pel_wait_post(mrioc, drv_cmd);
+ 
+ 	return;
+ out_failed:
+ 	mrioc->pel_enabled = false;
+ cleanup_drv_cmd:
+ 	drv_cmd->state = MPI3MR_CMD_NOTUSED;
+ 	drv_cmd->callback = NULL;
+ 	drv_cmd->retry_count = 0;
++>>>>>>> 43ca11005098 (scsi: mpi3mr: Add support for PEL commands)
  }
  
  /**
@@@ -4231,8 -4683,14 +4544,17 @@@ int mpi3mr_soft_reset_handler(struct mp
  
  out:
  	if (!retval) {
 -		mrioc->diagsave_timeout = 0;
  		mrioc->reset_in_progress = 0;
++<<<<<<< HEAD
 +		scsi_unblock_requests(mrioc->shost);
++=======
+ 		mrioc->pel_abort_requested = 0;
+ 		if (mrioc->pel_enabled) {
+ 			mrioc->pel_cmds.retry_count = 0;
+ 			mpi3mr_pel_wait_post(mrioc, &mrioc->pel_cmds);
+ 		}
+ 
++>>>>>>> 43ca11005098 (scsi: mpi3mr: Add support for PEL commands)
  		mpi3mr_rfresh_tgtdevs(mrioc);
  		mrioc->ts_update_counter = 0;
  		spin_lock_irqsave(&mrioc->watchdog_lock, flags);
@@@ -4241,6 -4699,9 +4563,12 @@@
  			    &mrioc->watchdog_work,
  			    msecs_to_jiffies(MPI3MR_WATCHDOG_INTERVAL));
  		spin_unlock_irqrestore(&mrioc->watchdog_lock, flags);
++<<<<<<< HEAD
++=======
+ 		mrioc->stop_bsgs = 0;
+ 		if (mrioc->pel_enabled)
+ 			atomic64_inc(&event_counter);
++>>>>>>> 43ca11005098 (scsi: mpi3mr: Add support for PEL commands)
  	} else {
  		mpi3mr_issue_reset(mrioc,
  		    MPI3_SYSIF_HOST_DIAG_RESET_ACTION_DIAG_FAULT, reset_reason);
* Unmerged path drivers/scsi/mpi3mr/mpi3mr_app.c
* Unmerged path drivers/scsi/mpi3mr/mpi3mr.h
* Unmerged path drivers/scsi/mpi3mr/mpi3mr_app.c
* Unmerged path drivers/scsi/mpi3mr/mpi3mr_fw.c
diff --git a/drivers/scsi/mpi3mr/mpi3mr_os.c b/drivers/scsi/mpi3mr/mpi3mr_os.c
index 4dd7893b5dad..ec6085315099 100644
--- a/drivers/scsi/mpi3mr/mpi3mr_os.c
+++ b/drivers/scsi/mpi3mr/mpi3mr_os.c
@@ -14,6 +14,7 @@ LIST_HEAD(mrioc_list);
 DEFINE_SPINLOCK(mrioc_list_lock);
 static int mrioc_ids;
 static int warn_non_secure_ctlr;
+atomic64_t event_counter;
 
 MODULE_AUTHOR(MPI3MR_DRIVER_AUTHOR);
 MODULE_DESCRIPTION(MPI3MR_DRIVER_DESC);
@@ -1412,6 +1413,23 @@ static void mpi3mr_pcietopochg_evt_bh(struct mpi3mr_ioc *mrioc,
 	}
 }
 
+/**
+ * mpi3mr_logdata_evt_bh -  Log data event bottomhalf
+ * @mrioc: Adapter instance reference
+ * @fwevt: Firmware event reference
+ *
+ * Extracts the event data and calls application interfacing
+ * function to process the event further.
+ *
+ * Return: Nothing.
+ */
+static void mpi3mr_logdata_evt_bh(struct mpi3mr_ioc *mrioc,
+	struct mpi3mr_fwevt *fwevt)
+{
+	mpi3mr_app_save_logdata(mrioc, fwevt->event_data,
+	    fwevt->event_data_size);
+}
+
 /**
  * mpi3mr_fwevt_bh - Firmware event bottomhalf handler
  * @mrioc: Adapter instance reference
@@ -1464,6 +1482,11 @@ static void mpi3mr_fwevt_bh(struct mpi3mr_ioc *mrioc,
 		mpi3mr_pcietopochg_evt_bh(mrioc, fwevt);
 		break;
 	}
+	case MPI3_EVENT_LOG_DATA:
+	{
+		mpi3mr_logdata_evt_bh(mrioc, fwevt);
+		break;
+	}
 	default:
 		break;
 	}
@@ -2107,6 +2130,7 @@ void mpi3mr_os_handle_events(struct mpi3mr_ioc *mrioc,
 		break;
 	}
 	case MPI3_EVENT_DEVICE_INFO_CHANGED:
+	case MPI3_EVENT_LOG_DATA:
 	{
 		process_evt_bh = 1;
 		break;
@@ -4348,6 +4372,12 @@ static struct pci_driver mpi3mr_pci_driver = {
 #endif
 };
 
+static ssize_t event_counter_show(struct device_driver *dd, char *buf)
+{
+	return sprintf(buf, "%llu\n", atomic64_read(&event_counter));
+}
+static DRIVER_ATTR_RO(event_counter);
+
 static int __init mpi3mr_init(void)
 {
 	int ret_val;
@@ -4356,6 +4386,16 @@ static int __init mpi3mr_init(void)
 	    MPI3MR_DRIVER_VERSION);
 
 	ret_val = pci_register_driver(&mpi3mr_pci_driver);
+	if (ret_val) {
+		pr_err("%s failed to load due to pci register driver failure\n",
+		    MPI3MR_DRIVER_NAME);
+		return ret_val;
+	}
+
+	ret_val = driver_create_file(&mpi3mr_pci_driver.driver,
+				     &driver_attr_event_counter);
+	if (ret_val)
+		pci_unregister_driver(&mpi3mr_pci_driver);
 
 	return ret_val;
 }
@@ -4370,6 +4410,8 @@ static void __exit mpi3mr_exit(void)
 		pr_info("Unloading %s version %s\n", MPI3MR_DRIVER_NAME,
 		    MPI3MR_DRIVER_VERSION);
 
+	driver_remove_file(&mpi3mr_pci_driver.driver,
+			   &driver_attr_event_counter);
 	pci_unregister_driver(&mpi3mr_pci_driver);
 }
 
