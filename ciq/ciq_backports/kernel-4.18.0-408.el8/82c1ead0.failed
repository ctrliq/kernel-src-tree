KVM: x86: hyper-v: Drop redundant 'ex' parameter from kvm_hv_flush_tlb()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Vitaly Kuznetsov <vkuznets@redhat.com>
commit 82c1ead0d678af31e5d883656c12096a0004178b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/82c1ead0.failed

'struct kvm_hv_hcall' has all the required information already,
there's no need to pass 'ex' additionally.

No functional change intended.

	Cc: stable@vger.kernel.org # 5.14.x
	Signed-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>
Message-Id: <20220222154642.684285-3-vkuznets@redhat.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 82c1ead0d678af31e5d883656c12096a0004178b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/hyperv.c
diff --cc arch/x86/kvm/hyperv.c
index 2ec52ff76a36,c28a268ec937..000000000000
--- a/arch/x86/kvm/hyperv.c
+++ b/arch/x86/kvm/hyperv.c
@@@ -1753,24 -1749,10 +1753,28 @@@ struct kvm_hv_hcall 
  	sse128_t xmm[HV_HYPERCALL_MAX_XMM_REGISTERS];
  };
  
++<<<<<<< HEAD
 +static u64 kvm_get_sparse_vp_set(struct kvm *kvm, struct kvm_hv_hcall *hc,
 +				 u64 *sparse_banks, gpa_t offset)
 +{
 +	u16 var_cnt;
 +
 +	if (hc->var_cnt > 64)
 +		return -EINVAL;
 +
 +	/* Ignore banks that cannot possibly contain a legal VP index. */
 +	var_cnt = min_t(u16, hc->var_cnt, KVM_HV_MAX_SPARSE_VCPU_SET_BITS);
 +
 +	return kvm_read_guest(kvm, hc->ingpa + offset, sparse_banks,
 +			      var_cnt * sizeof(*sparse_banks));
 +}
 +
 +static u64 kvm_hv_flush_tlb(struct kvm_vcpu *vcpu, struct kvm_hv_hcall *hc, bool ex)
++=======
+ static u64 kvm_hv_flush_tlb(struct kvm_vcpu *vcpu, struct kvm_hv_hcall *hc)
++>>>>>>> 82c1ead0d678 (KVM: x86: hyper-v: Drop redundant 'ex' parameter from kvm_hv_flush_tlb())
  {
  	int i;
 -	gpa_t gpa;
  	struct kvm *kvm = vcpu->kvm;
  	struct hv_tlb_flush_ex flush_ex;
  	struct hv_tlb_flush flush;
@@@ -1778,18 -1760,12 +1782,23 @@@
  	DECLARE_BITMAP(vcpu_bitmap, KVM_MAX_VCPUS);
  	unsigned long *vcpu_mask;
  	u64 valid_bank_mask;
 -	u64 sparse_banks[64];
 -	int sparse_banks_len;
 +	u64 sparse_banks[KVM_HV_MAX_SPARSE_VCPU_SET_BITS];
  	bool all_cpus;
  
++<<<<<<< HEAD
 +	/*
 +	 * The Hyper-V TLFS doesn't allow more than 64 sparse banks, e.g. the
 +	 * valid mask is a u64.  Fail the build if KVM's max allowed number of
 +	 * vCPUs (>4096) would exceed this limit, KVM will additional changes
 +	 * for Hyper-V support to avoid setting the guest up to fail.
 +	 */
 +	BUILD_BUG_ON(KVM_HV_MAX_SPARSE_VCPU_SET_BITS > 64);
 +
 +	if (!ex) {
++=======
+ 	if (hc->code == HVCALL_FLUSH_VIRTUAL_ADDRESS_LIST ||
+ 	    hc->code == HVCALL_FLUSH_VIRTUAL_ADDRESS_SPACE) {
++>>>>>>> 82c1ead0d678 (KVM: x86: hyper-v: Drop redundant 'ex' parameter from kvm_hv_flush_tlb())
  		if (hc->fast) {
  			flush.address_space = hc->ingpa;
  			flush.flags = hc->outgpa;
@@@ -2271,19 -2247,6 +2280,22 @@@ int kvm_hv_hypercall(struct kvm_vcpu *v
  				kvm_hv_hypercall_complete_userspace;
  		return 0;
  	case HVCALL_FLUSH_VIRTUAL_ADDRESS_LIST:
++<<<<<<< HEAD
 +		if (unlikely(!hc.rep_cnt || hc.rep_idx || hc.var_cnt)) {
 +			ret = HV_STATUS_INVALID_HYPERCALL_INPUT;
 +			break;
 +		}
 +		ret = kvm_hv_flush_tlb(vcpu, &hc, false);
 +		break;
 +	case HVCALL_FLUSH_VIRTUAL_ADDRESS_SPACE:
 +		if (unlikely(hc.rep || hc.var_cnt)) {
 +			ret = HV_STATUS_INVALID_HYPERCALL_INPUT;
 +			break;
 +		}
 +		ret = kvm_hv_flush_tlb(vcpu, &hc, false);
 +		break;
++=======
++>>>>>>> 82c1ead0d678 (KVM: x86: hyper-v: Drop redundant 'ex' parameter from kvm_hv_flush_tlb())
  	case HVCALL_FLUSH_VIRTUAL_ADDRESS_LIST_EX:
  		if (unlikely(!hc.rep_cnt || hc.rep_idx)) {
  			ret = HV_STATUS_INVALID_HYPERCALL_INPUT;
@@@ -2296,10 -2260,10 +2309,10 @@@
  			ret = HV_STATUS_INVALID_HYPERCALL_INPUT;
  			break;
  		}
- 		ret = kvm_hv_flush_tlb(vcpu, &hc, true);
+ 		ret = kvm_hv_flush_tlb(vcpu, &hc);
  		break;
  	case HVCALL_SEND_IPI:
 -		if (unlikely(hc.rep)) {
 +		if (unlikely(hc.rep || hc.var_cnt)) {
  			ret = HV_STATUS_INVALID_HYPERCALL_INPUT;
  			break;
  		}
* Unmerged path arch/x86/kvm/hyperv.c
