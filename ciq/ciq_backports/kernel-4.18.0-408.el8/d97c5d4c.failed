PCI: ACPI: PM: Do not use pci_platform_pm_ops for ACPI

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Rafael J. Wysocki <rafael.j.wysocki@intel.com>
commit d97c5d4c622f6acfd5eddac81799d37c9a4e6a92
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/d97c5d4c.failed

Using struct pci_platform_pm_ops for ACPI adds unnecessary
indirection to the interactions between the PCI core and ACPI PM,
which is also subject to retpolines.

Moreover, it is not particularly clear from the current code that,
as far as PCI PM is concerned, "platform" really means just ACPI
except for the special casess when Intel MID PCI PM is used or when
ACPI support is disabled (through the kernel config or command line,
or because there are no usable ACPI tables on the system).

To address the above, rework the PCI PM code to invoke ACPI PM
functions directly as needed and drop the acpi_pci_platform_pm
object that is not necessary any more.

Accordingly, update some of the ACPI PM functions in question to do
extra checks in case the ACPI support is disabled (which previously
was taken care of by avoiding to set the pci_platform_ops pointer
in those cases).

	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
	Tested-by: Ferry Toth <fntoth@gmail.com>
(cherry picked from commit d97c5d4c622f6acfd5eddac81799d37c9a4e6a92)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/pci/pci-acpi.c
#	drivers/pci/pci.c
#	drivers/pci/pci.h
diff --cc drivers/pci/pci-acpi.c
index 885f8886b0c1,141ed146e271..000000000000
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@@ -942,7 -945,30 +945,34 @@@ void pci_set_acpi_fwnode(struct pci_de
  				   acpi_pci_find_companion(&dev->dev));
  }
  
++<<<<<<< HEAD
 +static bool acpi_pci_power_manageable(struct pci_dev *dev)
++=======
+ /**
+  * pci_dev_acpi_reset - do a function level reset using _RST method
+  * @dev: device to reset
+  * @probe: if true, return 0 if device supports _RST
+  */
+ int pci_dev_acpi_reset(struct pci_dev *dev, bool probe)
+ {
+ 	acpi_handle handle = ACPI_HANDLE(&dev->dev);
+ 
+ 	if (!handle || !acpi_has_method(handle, "_RST"))
+ 		return -ENOTTY;
+ 
+ 	if (probe)
+ 		return 0;
+ 
+ 	if (ACPI_FAILURE(acpi_evaluate_object(handle, "_RST", NULL, NULL))) {
+ 		pci_warn(dev, "ACPI _RST failed\n");
+ 		return -ENOTTY;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ bool acpi_pci_power_manageable(struct pci_dev *dev)
++>>>>>>> d97c5d4c622f (PCI: ACPI: PM: Do not use pci_platform_pm_ops for ACPI)
  {
  	struct acpi_device *adev = ACPI_COMPANION(&dev->dev);
  
@@@ -1090,10 -1121,10 +1126,11 @@@ bool acpi_pci_need_resume(struct pci_de
  	 * devices are expected to be in D3 before invoking the S3 entry path
  	 * from the firmware, so they should not be affected by this issue.
  	 */
 -	if (pci_is_bridge(dev) && acpi_target_system_state() != ACPI_STATE_S0)
 +	if (pci_is_bridge(dev) && !dev->driver &&
 +	    acpi_target_system_state() != ACPI_STATE_S0)
  		return true;
  
+ 	adev = ACPI_COMPANION(&dev->dev);
  	if (!adev || !acpi_device_power_manageable(adev))
  		return false;
  
diff --cc drivers/pci/pci.c
index c3df2812af1a,925f275daa54..000000000000
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@@ -944,48 -985,65 +944,102 @@@ int pci_set_platform_pm(const struct pc
  
  static inline bool platform_pci_power_manageable(struct pci_dev *dev)
  {
++<<<<<<< HEAD
 +	return pci_platform_pm ? pci_platform_pm->is_manageable(dev) : false;
++=======
+ 	if (pci_use_mid_pm())
+ 		return true;
+ 
+ 	return acpi_pci_power_manageable(dev);
++>>>>>>> d97c5d4c622f (PCI: ACPI: PM: Do not use pci_platform_pm_ops for ACPI)
  }
  
  static inline int platform_pci_set_power_state(struct pci_dev *dev,
  					       pci_power_t t)
  {
++<<<<<<< HEAD
 +	return pci_platform_pm ? pci_platform_pm->set_state(dev, t) : -ENOSYS;
++=======
+ 	if (pci_use_mid_pm())
+ 		return mid_pci_set_power_state(dev, t);
+ 
+ 	return acpi_pci_set_power_state(dev, t);
++>>>>>>> d97c5d4c622f (PCI: ACPI: PM: Do not use pci_platform_pm_ops for ACPI)
  }
  
  static inline pci_power_t platform_pci_get_power_state(struct pci_dev *dev)
  {
++<<<<<<< HEAD
 +	return pci_platform_pm ? pci_platform_pm->get_state(dev) : PCI_UNKNOWN;
++=======
+ 	if (pci_use_mid_pm())
+ 		return mid_pci_get_power_state(dev);
+ 
+ 	return acpi_pci_get_power_state(dev);
++>>>>>>> d97c5d4c622f (PCI: ACPI: PM: Do not use pci_platform_pm_ops for ACPI)
  }
  
  static inline void platform_pci_refresh_power_state(struct pci_dev *dev)
  {
++<<<<<<< HEAD
 +	if (pci_platform_pm && pci_platform_pm->refresh_state)
 +		pci_platform_pm->refresh_state(dev);
++=======
+ 	if (!pci_use_mid_pm())
+ 		acpi_pci_refresh_power_state(dev);
++>>>>>>> d97c5d4c622f (PCI: ACPI: PM: Do not use pci_platform_pm_ops for ACPI)
  }
  
  static inline pci_power_t platform_pci_choose_state(struct pci_dev *dev)
  {
++<<<<<<< HEAD
 +	return pci_platform_pm ?
 +			pci_platform_pm->choose_state(dev) : PCI_POWER_ERROR;
++=======
+ 	if (pci_use_mid_pm())
+ 		return PCI_POWER_ERROR;
+ 
+ 	return acpi_pci_choose_state(dev);
++>>>>>>> d97c5d4c622f (PCI: ACPI: PM: Do not use pci_platform_pm_ops for ACPI)
  }
  
  static inline int platform_pci_set_wakeup(struct pci_dev *dev, bool enable)
  {
++<<<<<<< HEAD
 +	return pci_platform_pm ?
 +			pci_platform_pm->set_wakeup(dev, enable) : -ENODEV;
++=======
+ 	if (pci_use_mid_pm())
+ 		return PCI_POWER_ERROR;
+ 
+ 	return acpi_pci_wakeup(dev, enable);
++>>>>>>> d97c5d4c622f (PCI: ACPI: PM: Do not use pci_platform_pm_ops for ACPI)
  }
  
  static inline bool platform_pci_need_resume(struct pci_dev *dev)
  {
++<<<<<<< HEAD
 +	return pci_platform_pm ? pci_platform_pm->need_resume(dev) : false;
++=======
+ 	if (pci_use_mid_pm())
+ 		return false;
+ 
+ 	return acpi_pci_need_resume(dev);
++>>>>>>> d97c5d4c622f (PCI: ACPI: PM: Do not use pci_platform_pm_ops for ACPI)
  }
  
  static inline bool platform_pci_bridge_d3(struct pci_dev *dev)
  {
++<<<<<<< HEAD
 +	if (pci_platform_pm && pci_platform_pm->bridge_d3)
 +		return pci_platform_pm->bridge_d3(dev);
 +	return false;
++=======
+ 	if (pci_use_mid_pm())
+ 		return false;
+ 
+ 	return acpi_pci_bridge_d3(dev);
++>>>>>>> d97c5d4c622f (PCI: ACPI: PM: Do not use pci_platform_pm_ops for ACPI)
  }
  
  /**
diff --cc drivers/pci/pci.h
index ff387d8e7bf8,e6fc14d87a07..000000000000
--- a/drivers/pci/pci.h
+++ b/drivers/pci/pci.h
@@@ -707,7 -724,20 +707,24 @@@ static inline int pci_aer_raw_clear_sta
  int pci_acpi_program_hp_params(struct pci_dev *dev);
  extern const struct attribute_group pci_dev_acpi_attr_group;
  void pci_set_acpi_fwnode(struct pci_dev *dev);
++<<<<<<< HEAD
 +#else
++=======
+ int pci_dev_acpi_reset(struct pci_dev *dev, bool probe);
+ bool acpi_pci_power_manageable(struct pci_dev *dev);
+ bool acpi_pci_bridge_d3(struct pci_dev *dev);
+ int acpi_pci_set_power_state(struct pci_dev *dev, pci_power_t state);
+ pci_power_t acpi_pci_get_power_state(struct pci_dev *dev);
+ void acpi_pci_refresh_power_state(struct pci_dev *dev);
+ int acpi_pci_wakeup(struct pci_dev *dev, bool enable);
+ bool acpi_pci_need_resume(struct pci_dev *dev);
+ pci_power_t acpi_pci_choose_state(struct pci_dev *pdev);
+ #else
+ static inline int pci_dev_acpi_reset(struct pci_dev *dev, bool probe)
+ {
+ 	return -ENOTTY;
+ }
++>>>>>>> d97c5d4c622f (PCI: ACPI: PM: Do not use pci_platform_pm_ops for ACPI)
  static inline void pci_set_acpi_fwnode(struct pci_dev *dev) {}
  static inline int pci_acpi_program_hp_params(struct pci_dev *dev)
  {
* Unmerged path drivers/pci/pci-acpi.c
* Unmerged path drivers/pci/pci.c
* Unmerged path drivers/pci/pci.h
