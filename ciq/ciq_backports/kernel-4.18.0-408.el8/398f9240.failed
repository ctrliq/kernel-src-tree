selftests: kvm/x86: Export x86_family() for use outside of processor.c

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Jim Mattson <jmattson@google.com>
commit 398f9240f90f4168f5882180723f743f7b682049
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/398f9240.failed

Move this static inline function to processor.h, so that it can be
used in individual tests, as needed.

Opportunistically replace the bare 'unsigned' with 'unsigned int.'

	Signed-off-by: Jim Mattson <jmattson@google.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
Message-Id: <20220115052431.447232-5-jmattson@google.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 398f9240f90f4168f5882180723f743f7b682049)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/testing/selftests/kvm/lib/x86_64/processor.c
diff --cc tools/testing/selftests/kvm/lib/x86_64/processor.c
index 8faa2b8d982a,59dcfe1967cc..000000000000
--- a/tools/testing/selftests/kvm/lib/x86_64/processor.c
+++ b/tools/testing/selftests/kvm/lib/x86_64/processor.c
@@@ -1509,3 -1515,51 +1509,54 @@@ struct kvm_cpuid2 *vcpu_get_supported_h
  
  	return cpuid;
  }
++<<<<<<< HEAD
++=======
+ 
+ unsigned long vm_compute_max_gfn(struct kvm_vm *vm)
+ {
+ 	const unsigned long num_ht_pages = 12 << (30 - vm->page_shift); /* 12 GiB */
+ 	unsigned long ht_gfn, max_gfn, max_pfn;
+ 	uint32_t eax, ebx, ecx, edx, max_ext_leaf;
+ 
+ 	max_gfn = (1ULL << (vm->pa_bits - vm->page_shift)) - 1;
+ 
+ 	/* Avoid reserved HyperTransport region on AMD processors.  */
+ 	if (!is_amd_cpu())
+ 		return max_gfn;
+ 
+ 	/* On parts with <40 physical address bits, the area is fully hidden */
+ 	if (vm->pa_bits < 40)
+ 		return max_gfn;
+ 
+ 	/* Before family 17h, the HyperTransport area is just below 1T.  */
+ 	ht_gfn = (1 << 28) - num_ht_pages;
+ 	eax = 1;
+ 	cpuid(&eax, &ebx, &ecx, &edx);
+ 	if (x86_family(eax) < 0x17)
+ 		goto done;
+ 
+ 	/*
+ 	 * Otherwise it's at the top of the physical address space, possibly
+ 	 * reduced due to SME by bits 11:6 of CPUID[0x8000001f].EBX.  Use
+ 	 * the old conservative value if MAXPHYADDR is not enumerated.
+ 	 */
+ 	eax = 0x80000000;
+ 	cpuid(&eax, &ebx, &ecx, &edx);
+ 	max_ext_leaf = eax;
+ 	if (max_ext_leaf < 0x80000008)
+ 		goto done;
+ 
+ 	eax = 0x80000008;
+ 	cpuid(&eax, &ebx, &ecx, &edx);
+ 	max_pfn = (1ULL << ((eax & 0xff) - vm->page_shift)) - 1;
+ 	if (max_ext_leaf >= 0x8000001f) {
+ 		eax = 0x8000001f;
+ 		cpuid(&eax, &ebx, &ecx, &edx);
+ 		max_pfn >>= (ebx >> 6) & 0x3f;
+ 	}
+ 
+ 	ht_gfn = max_pfn - num_ht_pages;
+ done:
+ 	return min(max_gfn, ht_gfn - 1);
+ }
++>>>>>>> 398f9240f90f (selftests: kvm/x86: Export x86_family() for use outside of processor.c)
diff --git a/tools/testing/selftests/kvm/include/x86_64/processor.h b/tools/testing/selftests/kvm/include/x86_64/processor.h
index b67f6a0a565d..eab7b3e4161c 100644
--- a/tools/testing/selftests/kvm/include/x86_64/processor.h
+++ b/tools/testing/selftests/kvm/include/x86_64/processor.h
@@ -365,6 +365,18 @@ static inline unsigned long get_xmm(int n)
 
 bool is_intel_cpu(void);
 
+static inline unsigned int x86_family(unsigned int eax)
+{
+        unsigned int x86;
+
+        x86 = (eax >> 8) & 0xf;
+
+        if (x86 == 0xf)
+                x86 += (eax >> 20) & 0xff;
+
+        return x86;
+}
+
 struct kvm_x86_state *vcpu_save_state(struct kvm_vm *vm, uint32_t vcpuid);
 void vcpu_load_state(struct kvm_vm *vm, uint32_t vcpuid,
 		     struct kvm_x86_state *state);
* Unmerged path tools/testing/selftests/kvm/lib/x86_64/processor.c
