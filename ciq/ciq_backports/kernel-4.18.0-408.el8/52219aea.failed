mm/memory_hotplug: handle memblocks only with CONFIG_ARCH_KEEP_MEMBLOCK

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author David Hildenbrand <david@redhat.com>
commit 52219aeaf2dc6f7607704af2c40e3866fb04aed2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/52219aea.failed

The comment in add_memory_resource() is stale: hotadd_new_pgdat() will no
longer call get_pfn_range_for_nid(), as a hotadded pgdat will simply span
no pages at all, until memory is moved to the zone/node via
move_pfn_range_to_zone() - e.g., when onlining memory blocks.

The only archs that care about memblocks for hotplugged memory (either for
iterating over all system RAM or testing for memory validity) are arm64,
s390x, and powerpc - due to CONFIG_ARCH_KEEP_MEMBLOCK.  Without
CONFIG_ARCH_KEEP_MEMBLOCK, we can simply stop messing with memblocks.

	Signed-off-by: David Hildenbrand <david@redhat.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Acked-by: Mike Rapoport <rppt@linux.ibm.com>
	Acked-by: Michal Hocko <mhocko@suse.com>
	Cc: Michal Hocko <mhocko@kernel.org>
	Cc: Baoquan He <bhe@redhat.com>
	Cc: Oscar Salvador <osalvador@suse.de>
	Cc: Pankaj Gupta <pankaj.gupta.linux@gmail.com>
	Cc: Mike Rapoport <rppt@linux.ibm.com>
	Cc: Anshuman Khandual <anshuman.khandual@arm.com>
Link: http://lkml.kernel.org/r/20200422155353.25381-3-david@redhat.com
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 52219aeaf2dc6f7607704af2c40e3866fb04aed2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/Kconfig
diff --cc mm/Kconfig
index 01b290fad284,5b28240d2af8..000000000000
--- a/mm/Kconfig
+++ b/mm/Kconfig
@@@ -131,7 -133,10 +131,14 @@@ config HAVE_FAST_GU
  	depends on MMU
  	bool
  
++<<<<<<< HEAD
 +config ARCH_DISCARD_MEMBLOCK
++=======
+ # Don't discard allocated memory used to track "memory" and "reserved" memblocks
+ # after early boot, so it can still be used to test for validity of memory.
+ # Also, memblocks are updated with memory hot(un)plug.
+ config ARCH_KEEP_MEMBLOCK
++>>>>>>> 52219aeaf2dc (mm/memory_hotplug: handle memblocks only with CONFIG_ARCH_KEEP_MEMBLOCK)
  	bool
  
  # Keep arch NUMA mapping infrastructure post-init.
* Unmerged path mm/Kconfig
diff --git a/mm/memory_hotplug.c b/mm/memory_hotplug.c
index b427ecd09452..995cede5e5c9 100644
--- a/mm/memory_hotplug.c
+++ b/mm/memory_hotplug.c
@@ -1103,13 +1103,8 @@ int __ref add_memory_resource(int nid, struct resource *res)
 
 	mem_hotplug_begin();
 
-	/*
-	 * Add new range to memblock so that when hotadd_new_pgdat() is called
-	 * to allocate new pgdat, get_pfn_range_for_nid() will be able to find
-	 * this new range and calculate total pages correctly.  The range will
-	 * be removed at hot-remove time.
-	 */
-	memblock_add_node(start, size, nid);
+	if (IS_ENABLED(CONFIG_ARCH_KEEP_MEMBLOCK))
+		memblock_add_node(start, size, nid);
 
 	ret = __try_online_node(nid, false);
 	if (ret < 0)
@@ -1158,7 +1153,8 @@ int __ref add_memory_resource(int nid, struct resource *res)
 	/* rollback pgdat allocation and others */
 	if (new_node)
 		rollback_node_hotadd(nid);
-	memblock_remove(start, size);
+	if (IS_ENABLED(CONFIG_ARCH_KEEP_MEMBLOCK))
+		memblock_remove(start, size);
 	mem_hotplug_done();
 	return ret;
 }
@@ -1774,8 +1770,12 @@ static int __ref try_remove_memory(int nid, u64 start, u64 size)
 	mem_hotplug_begin();
 
 	arch_remove_memory(nid, start, size, NULL);
-	memblock_free(start, size);
-	memblock_remove(start, size);
+
+	if (IS_ENABLED(CONFIG_ARCH_KEEP_MEMBLOCK)) {
+		memblock_free(start, size);
+		memblock_remove(start, size);
+	}
+
 	__release_memory_resource(start, size);
 
 	try_offline_node(nid);
