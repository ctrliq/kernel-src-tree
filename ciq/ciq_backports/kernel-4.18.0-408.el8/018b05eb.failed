dm: move duplicate code from callers of alloc_tio into alloc_tio

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Mike Snitzer <snitzer@redhat.com>
commit 018b05ebbff4f3ed611e950fe5f8760d2348b814
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/018b05eb.failed

	Suggested-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Mikulas Patocka <mpatocka@redhat.com>
	Signed-off-by: Mike Snitzer <snitzer@redhat.com>
(cherry picked from commit 018b05ebbff4f3ed611e950fe5f8760d2348b814)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/md/dm.c
diff --cc drivers/md/dm.c
index b06624dd4339,ec230d3a99da..000000000000
--- a/drivers/md/dm.c
+++ b/drivers/md/dm.c
@@@ -630,16 -561,20 +630,24 @@@ static void free_io(struct mapped_devic
  	bio_put(&io->tio.clone);
  }
  
 -static struct bio *alloc_tio(struct clone_info *ci, struct dm_target *ti,
 -		unsigned target_bio_nr, unsigned *len, gfp_t gfp_mask)
 +static struct dm_target_io *alloc_tio(struct clone_info *ci, struct dm_target *ti,
 +				      unsigned target_bio_nr, gfp_t gfp_mask)
  {
  	struct dm_target_io *tio;
+ 	struct bio *clone;
  
  	if (!ci->io->tio.io) {
  		/* the dm_target_io embedded in ci->io is available */
  		tio = &ci->io->tio;
+ 		/* alloc_io() already initialized embedded clone */
+ 		clone = &tio->clone;
  	} else {
++<<<<<<< HEAD
 +		struct bio *clone = bio_alloc_bioset(gfp_mask, 0, &ci->io->md->bs);
++=======
+ 		clone = bio_alloc_clone(ci->bio->bi_bdev, ci->bio,
+ 					gfp_mask, &ci->io->md->bs);
++>>>>>>> 018b05ebbff4 (dm: move duplicate code from callers of alloc_tio into alloc_tio)
  		if (!clone)
  			return NULL;
  
@@@ -651,15 -586,23 +659,25 @@@
  	tio->io = ci->io;
  	tio->ti = ti;
  	tio->target_bio_nr = target_bio_nr;
 -	tio->len_ptr = len;
 -	tio->old_sector = 0;
  
++<<<<<<< HEAD
 +	return tio;
++=======
+ 	if (len) {
+ 		clone->bi_iter.bi_size = to_bytes(*len);
+ 		if (bio_integrity(clone))
+ 			bio_integrity_trim(clone);
+ 	}
+ 
+ 	return clone;
++>>>>>>> 018b05ebbff4 (dm: move duplicate code from callers of alloc_tio into alloc_tio)
  }
  
 -static void free_tio(struct bio *clone)
 +static void free_tio(struct dm_target_io *tio)
  {
 -	if (clone_to_tio(clone)->inside_dm_io)
 +	if (tio->inside_dm_io)
  		return;
 -	bio_put(clone);
 +	bio_put(&tio->clone);
  }
  
  /*
@@@ -1428,14 -1239,20 +1446,29 @@@ static void __send_duplicate_bios(struc
  				  unsigned num_bios, unsigned *len)
  {
  	struct bio_list blist = BIO_EMPTY_LIST;
 -	struct bio *clone;
 +	struct bio *bio;
 +	struct dm_target_io *tio;
  
++<<<<<<< HEAD
 +	alloc_multiple_bios(&blist, ci, ti, num_bios);
 +
 +	while ((bio = bio_list_pop(&blist))) {
 +		tio = container_of(bio, struct dm_target_io, clone);
 +		(void) __clone_and_map_simple_bio(ci, tio, len);
++=======
+ 	switch (num_bios) {
+ 	case 0:
+ 		break;
+ 	case 1:
+ 		clone = alloc_tio(ci, ti, 0, len, GFP_NOIO);
+ 		__map_bio(clone);
+ 		break;
+ 	default:
+ 		alloc_multiple_bios(&blist, ci, ti, num_bios, len);
+ 		while ((clone = bio_list_pop(&blist)))
+ 			__map_bio(clone);
+ 		break;
++>>>>>>> 018b05ebbff4 (dm: move duplicate code from callers of alloc_tio into alloc_tio)
  	}
  }
  
@@@ -1586,10 -1366,8 +1619,15 @@@ static int __split_and_process_non_flus
  		return r;
  
  	len = min_t(sector_t, max_io_len(ti, ci->sector), ci->sector_count);
++<<<<<<< HEAD
 +
 +	r = __clone_and_map_data_bio(ci, ti, ci->sector, &len);
 +	if (r < 0)
 +		return r;
++=======
+ 	clone = alloc_tio(ci, ti, 0, &len, GFP_NOIO);
+ 	__map_bio(clone);
++>>>>>>> 018b05ebbff4 (dm: move duplicate code from callers of alloc_tio into alloc_tio)
  
  	ci->sector += len;
  	ci->sector_count -= len;
* Unmerged path drivers/md/dm.c
