netdevsim: move details of vf config to dev

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Jakub Kicinski <kuba@kernel.org>
commit 1c401078bcf34e91e183b61b2d926972fc03b548
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/1c401078.failed

Since "eswitch" configuration was added bus.c contains
a lot of device details which really belong to dev.c.

Restructure the code while moving it.

	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 1c401078bcf34e91e183b61b2d926972fc03b548)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/netdevsim/bus.c
#	drivers/net/netdevsim/dev.c
diff --cc drivers/net/netdevsim/bus.c
index bc0396d4e72f,d037600c0f0c..000000000000
--- a/drivers/net/netdevsim/bus.c
+++ b/drivers/net/netdevsim/bus.c
@@@ -24,47 -23,6 +23,50 @@@ static struct nsim_bus_dev *to_nsim_bus
  	return container_of(dev, struct nsim_bus_dev, dev);
  }
  
++<<<<<<< HEAD
 +static void
 +nsim_bus_dev_set_vfs(struct nsim_bus_dev *nsim_bus_dev, unsigned int num_vfs)
 +{
 +	rtnl_lock();
 +	nsim_bus_dev->num_vfs = num_vfs;
 +	rtnl_unlock();
 +}
 +
 +static int nsim_bus_dev_vfs_enable(struct nsim_bus_dev *nsim_bus_dev,
 +				   unsigned int num_vfs)
 +{
 +	struct nsim_dev *nsim_dev;
 +	int err = 0;
 +
 +	if (nsim_bus_dev->max_vfs < num_vfs)
 +		return -ENOMEM;
 +
 +	if (!nsim_bus_dev->vfconfigs)
 +		return -ENOMEM;
 +	nsim_bus_dev_set_vfs(nsim_bus_dev, num_vfs);
 +
 +	nsim_dev = dev_get_drvdata(&nsim_bus_dev->dev);
 +	if (nsim_esw_mode_is_switchdev(nsim_dev)) {
 +		err = nsim_esw_switchdev_enable(nsim_dev, NULL);
 +		if (err)
 +			nsim_bus_dev_set_vfs(nsim_bus_dev, 0);
 +	}
 +
 +	return err;
 +}
 +
 +void nsim_bus_dev_vfs_disable(struct nsim_bus_dev *nsim_bus_dev)
 +{
 +	struct nsim_dev *nsim_dev;
 +
 +	nsim_bus_dev_set_vfs(nsim_bus_dev, 0);
 +	nsim_dev = dev_get_drvdata(&nsim_bus_dev->dev);
 +	if (nsim_esw_mode_is_switchdev(nsim_dev))
 +		nsim_esw_legacy_enable(nsim_dev, NULL);
 +}
 +
++=======
++>>>>>>> 1c401078bcf3 (netdevsim: move details of vf config to dev)
  static ssize_t
  nsim_bus_dev_numvfs_store(struct device *dev, struct device_attribute *attr,
  			  const char *buf, size_t count)
@@@ -77,27 -35,13 +79,35 @@@
  	if (ret)
  		return ret;
  
++<<<<<<< HEAD
 +	mutex_lock(&nsim_bus_dev->vfs_lock);
 +	if (nsim_bus_dev->num_vfs == num_vfs)
 +		goto exit_good;
 +	if (nsim_bus_dev->num_vfs && num_vfs) {
 +		ret = -EBUSY;
 +		goto exit_unlock;
 +	}
 +
 +	if (num_vfs) {
 +		ret = nsim_bus_dev_vfs_enable(nsim_bus_dev, num_vfs);
 +		if (ret)
 +			goto exit_unlock;
 +	} else {
 +		nsim_bus_dev_vfs_disable(nsim_bus_dev);
 +	}
 +exit_good:
 +	ret = count;
 +exit_unlock:
 +	mutex_unlock(&nsim_bus_dev->vfs_lock);
- 
- 	return ret;
++=======
+ 	device_lock(dev);
+ 	ret = -ENOENT;
+ 	if (dev_get_drvdata(dev))
+ 		ret = nsim_drv_configure_vfs(nsim_bus_dev, num_vfs);
+ 	device_unlock(dev);
++>>>>>>> 1c401078bcf3 (netdevsim: move details of vf config to dev)
+ 
+ 	return ret ? ret : count;
  }
  
  static ssize_t
diff --cc drivers/net/netdevsim/dev.c
index 79ed736717c1,c19f36c9e0a1..000000000000
--- a/drivers/net/netdevsim/dev.c
+++ b/drivers/net/netdevsim/dev.c
@@@ -56,6 -56,22 +56,25 @@@ static inline unsigned int nsim_dev_por
  
  static struct dentry *nsim_dev_ddir;
  
++<<<<<<< HEAD
++=======
+ unsigned int nsim_dev_get_vfs(struct nsim_dev *nsim_dev)
+ {
+ 	WARN_ON(!lockdep_rtnl_is_held() &&
+ 		!lockdep_is_held(&nsim_dev->vfs_lock));
+ 
+ 	return nsim_dev->nsim_bus_dev->num_vfs;
+ }
+ 
+ static void
+ nsim_bus_dev_set_vfs(struct nsim_bus_dev *nsim_bus_dev, unsigned int num_vfs)
+ {
+ 	rtnl_lock();
+ 	nsim_bus_dev->num_vfs = num_vfs;
+ 	rtnl_unlock();
+ }
+ 
++>>>>>>> 1c401078bcf3 (netdevsim: move details of vf config to dev)
  #define NSIM_DEV_DUMMY_REGION_SIZE (1024 * 32)
  
  static int
@@@ -1539,10 -1575,13 +1561,20 @@@ static void nsim_dev_reload_destroy(str
  		return;
  	debugfs_remove(nsim_dev->take_snapshot);
  
++<<<<<<< HEAD
 +	mutex_lock(&nsim_dev->nsim_bus_dev->vfs_lock);
 +	if (nsim_dev->nsim_bus_dev->num_vfs)
 +		nsim_bus_dev_vfs_disable(nsim_dev->nsim_bus_dev);
 +	mutex_unlock(&nsim_dev->nsim_bus_dev->vfs_lock);
++=======
+ 	mutex_lock(&nsim_dev->vfs_lock);
+ 	if (nsim_dev_get_vfs(nsim_dev)) {
+ 		nsim_bus_dev_set_vfs(nsim_dev->nsim_bus_dev, 0);
+ 		if (nsim_esw_mode_is_switchdev(nsim_dev))
+ 			nsim_esw_legacy_enable(nsim_dev, NULL);
+ 	}
+ 	mutex_unlock(&nsim_dev->vfs_lock);
++>>>>>>> 1c401078bcf3 (netdevsim: move details of vf config to dev)
  
  	nsim_dev_port_del_all(nsim_dev);
  	nsim_dev_psample_exit(nsim_dev);
* Unmerged path drivers/net/netdevsim/bus.c
* Unmerged path drivers/net/netdevsim/dev.c
diff --git a/drivers/net/netdevsim/netdevsim.h b/drivers/net/netdevsim/netdevsim.h
index 0b12e725cc14..25f54d655e13 100644
--- a/drivers/net/netdevsim/netdevsim.h
+++ b/drivers/net/netdevsim/netdevsim.h
@@ -262,9 +262,6 @@ struct nsim_dev {
 	u16 esw_mode;
 };
 
-int nsim_esw_legacy_enable(struct nsim_dev *nsim_dev, struct netlink_ext_ack *extack);
-int nsim_esw_switchdev_enable(struct nsim_dev *nsim_dev, struct netlink_ext_ack *extack);
-
 static inline bool nsim_esw_mode_is_legacy(struct nsim_dev *nsim_dev)
 {
 	return nsim_dev->esw_mode == DEVLINK_ESWITCH_MODE_LEGACY;
@@ -290,6 +287,8 @@ int nsim_dev_port_add(struct nsim_bus_dev *nsim_bus_dev,
 int nsim_dev_port_del(struct nsim_bus_dev *nsim_bus_dev,
 		      enum nsim_dev_port_type type,
 		      unsigned int port_index);
+int nsim_drv_configure_vfs(struct nsim_bus_dev *nsim_bus_dev,
+			   unsigned int num_vfs);
 
 struct nsim_fib_data *nsim_fib_create(struct devlink *devlink,
 				      struct netlink_ext_ack *extack);
@@ -303,7 +302,6 @@ ssize_t nsim_bus_dev_max_vfs_read(struct file *file,
 ssize_t nsim_bus_dev_max_vfs_write(struct file *file,
 				   const char __user *data,
 				   size_t count, loff_t *ppos);
-void nsim_bus_dev_vfs_disable(struct nsim_bus_dev *nsim_bus_dev);
 
 static inline bool nsim_dev_port_is_pf(struct nsim_dev_port *nsim_dev_port)
 {
