bnxt_en: Do not destroy health reporters during reset

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Edwin Peer <edwin.peer@broadcom.com>
commit f16a9169286691d23906a1bb1c8e07e53113586c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/f16a9169.failed

Health reporter state should be maintained over resets. Previously
reporters were destroyed if the device capabilities changed, but
since none of the reporters depend on capabilities anymore, this
logic should be removed.

	Signed-off-by: Edwin Peer <edwin.peer@broadcom.com>
	Signed-off-by: Michael Chan <michael.chan@broadcom.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit f16a9169286691d23906a1bb1c8e07e53113586c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/broadcom/bnxt/bnxt_devlink.c
diff --cc drivers/net/ethernet/broadcom/bnxt/bnxt_devlink.c
index 449597f7c74c,0c17f90d44a2..000000000000
--- a/drivers/net/ethernet/broadcom/bnxt/bnxt_devlink.c
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt_devlink.c
@@@ -126,161 -234,226 +126,180 @@@ static int bnxt_fw_fatal_recover(struc
  	return -EINPROGRESS;
  }
  
 -static const struct devlink_health_reporter_ops bnxt_dl_fw_reporter_ops = {
 -	.name = "fw",
 -	.diagnose = bnxt_fw_diagnose,
 -	.dump = bnxt_fw_dump,
 -	.recover = bnxt_fw_recover,
 +static const
 +struct devlink_health_reporter_ops bnxt_dl_fw_fatal_reporter_ops = {
 +	.name = "fw_fatal",
 +	.recover = bnxt_fw_fatal_recover,
  };
  
- void bnxt_dl_fw_reporters_create(struct bnxt *bp)
+ static struct devlink_health_reporter *
+ __bnxt_dl_reporter_create(struct bnxt *bp,
+ 			  const struct devlink_health_reporter_ops *ops)
  {
- 	struct bnxt_fw_health *health = bp->fw_health;
+ 	struct devlink_health_reporter *reporter;
  
++<<<<<<< HEAD
 +	if (!health)
 +		return;
 +
 +	if (!(bp->fw_cap & BNXT_FW_CAP_HOT_RESET) || health->fw_reset_reporter)
 +		goto err_recovery;
 +
 +	health->fw_reset_reporter =
 +		devlink_health_reporter_create(bp->dl,
 +					       &bnxt_dl_fw_reset_reporter_ops,
 +					       0, bp);
 +	if (IS_ERR(health->fw_reset_reporter)) {
 +		netdev_warn(bp->dev, "Failed to create FW fatal health reporter, rc = %ld\n",
 +			    PTR_ERR(health->fw_reset_reporter));
 +		health->fw_reset_reporter = NULL;
 +		bp->fw_cap &= ~BNXT_FW_CAP_HOT_RESET;
 +	}
 +
 +err_recovery:
 +	if (!(bp->fw_cap & BNXT_FW_CAP_ERROR_RECOVERY))
 +		return;
 +
 +	if (!health->fw_reporter) {
 +		health->fw_reporter =
 +			devlink_health_reporter_create(bp->dl,
 +						       &bnxt_dl_fw_reporter_ops,
 +						       0, bp);
 +		if (IS_ERR(health->fw_reporter)) {
 +			netdev_warn(bp->dev, "Failed to create FW health reporter, rc = %ld\n",
 +				    PTR_ERR(health->fw_reporter));
 +			health->fw_reporter = NULL;
 +			bp->fw_cap &= ~BNXT_FW_CAP_ERROR_RECOVERY;
 +			return;
 +		}
 +	}
 +
 +	if (health->fw_fatal_reporter)
 +		return;
 +
 +	health->fw_fatal_reporter =
 +		devlink_health_reporter_create(bp->dl,
 +					       &bnxt_dl_fw_fatal_reporter_ops,
 +					       0, bp);
 +	if (IS_ERR(health->fw_fatal_reporter)) {
 +		netdev_warn(bp->dev, "Failed to create FW fatal health reporter, rc = %ld\n",
 +			    PTR_ERR(health->fw_fatal_reporter));
 +		health->fw_fatal_reporter = NULL;
 +		bp->fw_cap &= ~BNXT_FW_CAP_ERROR_RECOVERY;
++=======
+ 	reporter = devlink_health_reporter_create(bp->dl, ops, 0, bp);
+ 	if (IS_ERR(reporter)) {
+ 		netdev_warn(bp->dev, "Failed to create %s health reporter, rc = %ld\n",
+ 			    ops->name, PTR_ERR(reporter));
+ 		return NULL;
++>>>>>>> f16a91692866 (bnxt_en: Do not destroy health reporters during reset)
  	}
+ 
+ 	return reporter;
  }
  
- void bnxt_dl_fw_reporters_destroy(struct bnxt *bp, bool all)
+ void bnxt_dl_fw_reporters_create(struct bnxt *bp)
  {
- 	struct bnxt_fw_health *health = bp->fw_health;
+ 	struct bnxt_fw_health *fw_health = bp->fw_health;
  
- 	if (!health)
- 		return;
+ 	if (fw_health && !fw_health->fw_reporter)
+ 		fw_health->fw_reporter = __bnxt_dl_reporter_create(bp, &bnxt_dl_fw_reporter_ops);
+ }
  
++<<<<<<< HEAD
 +	if ((all || !(bp->fw_cap & BNXT_FW_CAP_HOT_RESET)) &&
 +	    health->fw_reset_reporter) {
 +		devlink_health_reporter_destroy(health->fw_reset_reporter);
 +		health->fw_reset_reporter = NULL;
 +	}
 +
 +	if ((bp->fw_cap & BNXT_FW_CAP_ERROR_RECOVERY) && !all)
 +		return;
++=======
+ void bnxt_dl_fw_reporters_destroy(struct bnxt *bp)
+ {
+ 	struct bnxt_fw_health *fw_health = bp->fw_health;
++>>>>>>> f16a91692866 (bnxt_en: Do not destroy health reporters during reset)
  
- 	if (health->fw_reporter) {
- 		devlink_health_reporter_destroy(health->fw_reporter);
- 		health->fw_reporter = NULL;
+ 	if (fw_health && fw_health->fw_reporter) {
+ 		devlink_health_reporter_destroy(fw_health->fw_reporter);
+ 		fw_health->fw_reporter = NULL;
  	}
 +
 +	if (health->fw_fatal_reporter) {
 +		devlink_health_reporter_destroy(health->fw_fatal_reporter);
 +		health->fw_fatal_reporter = NULL;
 +	}
  }
  
 -void bnxt_devlink_health_fw_report(struct bnxt *bp)
 +void bnxt_devlink_health_report(struct bnxt *bp, unsigned long event)
  {
  	struct bnxt_fw_health *fw_health = bp->fw_health;
 -	int rc;
 +	struct bnxt_fw_reporter_ctx fw_reporter_ctx;
 +
 +	fw_reporter_ctx.sp_event = event;
 +	switch (event) {
 +	case BNXT_FW_RESET_NOTIFY_SP_EVENT:
 +		if (test_bit(BNXT_STATE_FW_FATAL_COND, &bp->state)) {
 +			if (!fw_health->fw_fatal_reporter)
 +				return;
 +
 +			devlink_health_report(fw_health->fw_fatal_reporter,
 +					      "FW fatal async event received",
 +					      &fw_reporter_ctx);
 +			return;
 +		}
 +		if (!fw_health->fw_reset_reporter)
 +			return;
  
 -	if (!fw_health)
 +		devlink_health_report(fw_health->fw_reset_reporter,
 +				      "FW non-fatal reset event received",
 +				      &fw_reporter_ctx);
  		return;
  
 -	if (!fw_health->fw_reporter) {
 -		__bnxt_fw_recover(bp);
 +	case BNXT_FW_EXCEPTION_SP_EVENT:
 +		if (!fw_health->fw_fatal_reporter)
 +			return;
 +
 +		devlink_health_report(fw_health->fw_fatal_reporter,
 +				      "FW fatal error reported",
 +				      &fw_reporter_ctx);
  		return;
  	}
 -
 -	mutex_lock(&fw_health->lock);
 -	fw_health->severity = SEVERITY_RECOVERABLE;
 -	fw_health->remedy = REMEDY_DEVLINK_RECOVER;
 -	mutex_unlock(&fw_health->lock);
 -	rc = devlink_health_report(fw_health->fw_reporter, "FW error reported",
 -				   fw_health);
 -	if (rc == -ECANCELED)
 -		__bnxt_fw_recover(bp);
  }
  
 -void bnxt_dl_health_fw_status_update(struct bnxt *bp, bool healthy)
 +void bnxt_dl_health_status_update(struct bnxt *bp, bool healthy)
  {
 -	struct bnxt_fw_health *fw_health = bp->fw_health;
 +	struct bnxt_fw_health *health = bp->fw_health;
  	u8 state;
  
 -	mutex_lock(&fw_health->lock);
 -	if (healthy) {
 -		fw_health->severity = SEVERITY_NORMAL;
 +	if (healthy)
  		state = DEVLINK_HEALTH_REPORTER_STATE_HEALTHY;
 -	} else {
 -		fw_health->severity = SEVERITY_FATAL;
 -		fw_health->remedy = REMEDY_POWER_CYCLE_DEVICE;
 +	else
  		state = DEVLINK_HEALTH_REPORTER_STATE_ERROR;
 -	}
 -	mutex_unlock(&fw_health->lock);
 -	devlink_health_reporter_state_update(fw_health->fw_reporter, state);
 -}
  
 -void bnxt_dl_health_fw_recovery_done(struct bnxt *bp)
 -{
 -	struct bnxt_dl *dl = devlink_priv(bp->dl);
 +	if (health->fatal)
 +		devlink_health_reporter_state_update(health->fw_fatal_reporter,
 +						     state);
 +	else
 +		devlink_health_reporter_state_update(health->fw_reset_reporter,
 +						     state);
  
 -	devlink_health_reporter_recovery_done(bp->fw_health->fw_reporter);
 -	bnxt_hwrm_remote_dev_reset_set(bp, dl->remote_reset);
 +	health->fatal = false;
  }
  
 -static int bnxt_dl_info_get(struct devlink *dl, struct devlink_info_req *req,
 -			    struct netlink_ext_ack *extack);
 -
 -static void
 -bnxt_dl_livepatch_report_err(struct bnxt *bp, struct netlink_ext_ack *extack,
 -			     struct hwrm_fw_livepatch_output *resp)
 +void bnxt_dl_health_recovery_done(struct bnxt *bp)
  {
 -	int err = ((struct hwrm_err_output *)resp)->cmd_err;
 +	struct bnxt_fw_health *hlth = bp->fw_health;
  
 -	switch (err) {
 -	case FW_LIVEPATCH_CMD_ERR_CODE_INVALID_OPCODE:
 -		netdev_err(bp->dev, "Illegal live patch opcode");
 -		NL_SET_ERR_MSG_MOD(extack, "Invalid opcode");
 -		break;
 -	case FW_LIVEPATCH_CMD_ERR_CODE_NOT_SUPPORTED:
 -		NL_SET_ERR_MSG_MOD(extack, "Live patch operation not supported");
 -		break;
 -	case FW_LIVEPATCH_CMD_ERR_CODE_NOT_INSTALLED:
 -		NL_SET_ERR_MSG_MOD(extack, "Live patch not found");
 -		break;
 -	case FW_LIVEPATCH_CMD_ERR_CODE_NOT_PATCHED:
 -		NL_SET_ERR_MSG_MOD(extack,
 -				   "Live patch deactivation failed. Firmware not patched.");
 -		break;
 -	case FW_LIVEPATCH_CMD_ERR_CODE_AUTH_FAIL:
 -		NL_SET_ERR_MSG_MOD(extack, "Live patch not authenticated");
 -		break;
 -	case FW_LIVEPATCH_CMD_ERR_CODE_INVALID_HEADER:
 -		NL_SET_ERR_MSG_MOD(extack, "Incompatible live patch");
 -		break;
 -	case FW_LIVEPATCH_CMD_ERR_CODE_INVALID_SIZE:
 -		NL_SET_ERR_MSG_MOD(extack, "Live patch has invalid size");
 -		break;
 -	case FW_LIVEPATCH_CMD_ERR_CODE_ALREADY_PATCHED:
 -		NL_SET_ERR_MSG_MOD(extack, "Live patch already applied");
 -		break;
 -	default:
 -		netdev_err(bp->dev, "Unexpected live patch error: %d\n", err);
 -		NL_SET_ERR_MSG_MOD(extack, "Failed to activate live patch");
 -		break;
 -	}
 +	if (hlth->fatal)
 +		devlink_health_reporter_recovery_done(hlth->fw_fatal_reporter);
 +	else
 +		devlink_health_reporter_recovery_done(hlth->fw_reset_reporter);
  }
  
 -/* Live patch status in NVM */
 -#define BNXT_LIVEPATCH_NOT_INSTALLED	0
 -#define BNXT_LIVEPATCH_INSTALLED	FW_LIVEPATCH_QUERY_RESP_STATUS_FLAGS_INSTALL
 -#define BNXT_LIVEPATCH_REMOVED		FW_LIVEPATCH_QUERY_RESP_STATUS_FLAGS_ACTIVE
 -#define BNXT_LIVEPATCH_MASK		(FW_LIVEPATCH_QUERY_RESP_STATUS_FLAGS_INSTALL | \
 -					 FW_LIVEPATCH_QUERY_RESP_STATUS_FLAGS_ACTIVE)
 -#define BNXT_LIVEPATCH_ACTIVATED	BNXT_LIVEPATCH_MASK
 -
 -#define BNXT_LIVEPATCH_STATE(flags)	((flags) & BNXT_LIVEPATCH_MASK)
 -
 -static int
 -bnxt_dl_livepatch_activate(struct bnxt *bp, struct netlink_ext_ack *extack)
 -{
 -	struct hwrm_fw_livepatch_query_output *query_resp;
 -	struct hwrm_fw_livepatch_query_input *query_req;
 -	struct hwrm_fw_livepatch_output *patch_resp;
 -	struct hwrm_fw_livepatch_input *patch_req;
 -	u16 flags, live_patch_state;
 -	bool activated = false;
 -	u32 installed = 0;
 -	u8 target;
 -	int rc;
 -
 -	if (~bp->fw_cap & BNXT_FW_CAP_LIVEPATCH) {
 -		NL_SET_ERR_MSG_MOD(extack, "Device does not support live patch");
 -		return -EOPNOTSUPP;
 -	}
 -
 -	rc = hwrm_req_init(bp, query_req, HWRM_FW_LIVEPATCH_QUERY);
 -	if (rc)
 -		return rc;
 -	query_resp = hwrm_req_hold(bp, query_req);
 -
 -	rc = hwrm_req_init(bp, patch_req, HWRM_FW_LIVEPATCH);
 -	if (rc) {
 -		hwrm_req_drop(bp, query_req);
 -		return rc;
 -	}
 -	patch_req->loadtype = FW_LIVEPATCH_REQ_LOADTYPE_NVM_INSTALL;
 -	patch_resp = hwrm_req_hold(bp, patch_req);
 -
 -	for (target = 1; target <= FW_LIVEPATCH_REQ_FW_TARGET_LAST; target++) {
 -		query_req->fw_target = target;
 -		rc = hwrm_req_send(bp, query_req);
 -		if (rc) {
 -			NL_SET_ERR_MSG_MOD(extack, "Failed to query packages");
 -			break;
 -		}
 -
 -		flags = le16_to_cpu(query_resp->status_flags);
 -		live_patch_state = BNXT_LIVEPATCH_STATE(flags);
 -
 -		if (live_patch_state == BNXT_LIVEPATCH_NOT_INSTALLED)
 -			continue;
 -
 -		if (live_patch_state == BNXT_LIVEPATCH_ACTIVATED) {
 -			activated = true;
 -			continue;
 -		}
 -
 -		if (live_patch_state == BNXT_LIVEPATCH_INSTALLED)
 -			patch_req->opcode = FW_LIVEPATCH_REQ_OPCODE_ACTIVATE;
 -		else if (live_patch_state == BNXT_LIVEPATCH_REMOVED)
 -			patch_req->opcode = FW_LIVEPATCH_REQ_OPCODE_DEACTIVATE;
 -
 -		patch_req->fw_target = target;
 -		rc = hwrm_req_send(bp, patch_req);
 -		if (rc) {
 -			bnxt_dl_livepatch_report_err(bp, extack, patch_resp);
 -			break;
 -		}
 -		installed++;
 -	}
 -
 -	if (!rc && !installed) {
 -		if (activated) {
 -			NL_SET_ERR_MSG_MOD(extack, "Live patch already activated");
 -			rc = -EEXIST;
 -		} else {
 -			NL_SET_ERR_MSG_MOD(extack, "No live patches found");
 -			rc = -ENOENT;
 -		}
 -	}
 -	hwrm_req_drop(bp, query_req);
 -	hwrm_req_drop(bp, patch_req);
 -	return rc;
 -}
 +static int bnxt_dl_info_get(struct devlink *dl, struct devlink_info_req *req,
 +			    struct netlink_ext_ack *extack);
  
  static int bnxt_dl_reload_down(struct devlink *dl, bool netns_change,
  			       enum devlink_reload_action action,
diff --git a/drivers/net/ethernet/broadcom/bnxt/bnxt.c b/drivers/net/ethernet/broadcom/bnxt/bnxt.c
index 48a415455c5e..4395685d75d1 100644
--- a/drivers/net/ethernet/broadcom/bnxt/bnxt.c
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt.c
@@ -12092,11 +12092,6 @@ int bnxt_fw_init_one(struct bnxt *bp)
 	if (rc)
 		return rc;
 
-	/* In case fw capabilities have changed, destroy the unneeded
-	 * reporters and create newly capable ones.
-	 */
-	bnxt_dl_fw_reporters_destroy(bp, false);
-	bnxt_dl_fw_reporters_create(bp);
 	bnxt_fw_init_one_p3(bp);
 	return 0;
 }
@@ -12899,7 +12894,7 @@ static void bnxt_remove_one(struct pci_dev *pdev)
 	cancel_delayed_work_sync(&bp->fw_reset_task);
 	bp->sp_event = 0;
 
-	bnxt_dl_fw_reporters_destroy(bp, true);
+	bnxt_dl_fw_reporters_destroy(bp);
 	bnxt_dl_unregister(bp);
 	bnxt_shutdown_tc(bp);
 
* Unmerged path drivers/net/ethernet/broadcom/bnxt/bnxt_devlink.c
diff --git a/drivers/net/ethernet/broadcom/bnxt/bnxt_devlink.h b/drivers/net/ethernet/broadcom/bnxt/bnxt_devlink.h
index 406dc655a5fc..508d8e969f66 100644
--- a/drivers/net/ethernet/broadcom/bnxt/bnxt_devlink.h
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt_devlink.h
@@ -57,7 +57,7 @@ void bnxt_devlink_health_report(struct bnxt *bp, unsigned long event);
 void bnxt_dl_health_status_update(struct bnxt *bp, bool healthy);
 void bnxt_dl_health_recovery_done(struct bnxt *bp);
 void bnxt_dl_fw_reporters_create(struct bnxt *bp);
-void bnxt_dl_fw_reporters_destroy(struct bnxt *bp, bool all);
+void bnxt_dl_fw_reporters_destroy(struct bnxt *bp);
 int bnxt_dl_register(struct bnxt *bp);
 void bnxt_dl_unregister(struct bnxt *bp);
 
