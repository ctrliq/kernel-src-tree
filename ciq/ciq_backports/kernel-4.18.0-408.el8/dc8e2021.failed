dm: move cloning the bio into alloc_tio

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Christoph Hellwig <hch@lst.de>
commit dc8e2021da71f6b2d5971f98ee3e528cf30c409c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/dc8e2021.failed

Move the call to __bio_clone_fast and the assignment of ->len_ptr from
the callers into alloc_tio to prepare for changes to the bio clone API.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Mike Snitzer <snitzer@redhat.com>
Link: https://lore.kernel.org/r/20220202160109.108149-6-hch@lst.de
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit dc8e2021da71f6b2d5971f98ee3e528cf30c409c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/md/dm.c
diff --cc drivers/md/dm.c
index d626b645f571,90341b7fa580..000000000000
--- a/drivers/md/dm.c
+++ b/drivers/md/dm.c
@@@ -643,9 -558,10 +643,10 @@@ static struct dm_target_io *alloc_tio(s
  		if (!clone)
  			return NULL;
  
 -		tio = clone_to_tio(clone);
 +		tio = container_of(clone, struct dm_target_io, clone);
  		tio->inside_dm_io = false;
  	}
+ 	__bio_clone_fast(&tio->clone, ci->bio);
  
  	tio->magic = DM_TIO_MAGIC;
  	tio->io = ci->io;
@@@ -1338,16 -1192,21 +1340,21 @@@ static void bio_setup_sector(struct bi
  /*
   * Creates a bio that consists of range of complete bvecs.
   */
 -static int __clone_and_map_data_bio(struct clone_info *ci, struct dm_target *ti,
 -				    sector_t sector, unsigned *len)
 +static int clone_bio(struct dm_target_io *tio, struct bio *bio,
 +		     sector_t sector, unsigned len)
  {
 -	struct bio *bio = ci->bio, *clone;
 -	struct dm_target_io *tio;
 -	int r;
 +	struct bio *clone = &tio->clone;
  
++<<<<<<< HEAD
 +	__bio_clone_fast(clone, bio);
++=======
+ 	tio = alloc_tio(ci, ti, 0, len, GFP_NOIO);
+ 	clone = &tio->clone;
 -
 -	r = bio_crypt_clone(clone, bio, GFP_NOIO);
 -	if (r < 0)
 -		goto free_tio;
++>>>>>>> dc8e2021da71 (dm: move cloning the bio into alloc_tio)
  
  	if (bio_integrity(bio)) {
 +		int r;
 +
  		if (unlikely(!dm_target_has_integrity(tio->ti->type) &&
  			     !dm_target_passes_integrity(tio->ti->type))) {
  			DMWARN("%s: the target %s doesn't support integrity data.",
@@@ -1428,14 -1278,16 +1437,23 @@@ static void __send_duplicate_bios(struc
  				  unsigned num_bios, unsigned *len)
  {
  	struct bio_list blist = BIO_EMPTY_LIST;
 -	struct bio *clone;
 +	struct bio *bio;
 +	struct dm_target_io *tio;
  
- 	alloc_multiple_bios(&blist, ci, ti, num_bios);
+ 	alloc_multiple_bios(&blist, ci, ti, num_bios, len);
  
++<<<<<<< HEAD
 +	while ((bio = bio_list_pop(&blist))) {
 +		tio = container_of(bio, struct dm_target_io, clone);
 +		(void) __clone_and_map_simple_bio(ci, tio, len);
++=======
+ 	while ((clone = bio_list_pop(&blist))) {
+ 		struct dm_target_io *tio = clone_to_tio(clone);
+ 
+ 		if (len)
+ 			bio_setup_sector(clone, ci->sector, *len);
+ 		__map_bio(tio);
++>>>>>>> dc8e2021da71 (dm: move cloning the bio into alloc_tio)
  	}
  }
  
* Unmerged path drivers/md/dm.c
