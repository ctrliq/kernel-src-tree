KVM: Split out a kvm_vcpu_block() helper from kvm_vcpu_halt()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Sean Christopherson <seanjc@google.com>
commit fac4268894394213127e43856f41d10f29131e69
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/fac42688.failed

Factor out the "block" part of kvm_vcpu_halt() so that x86 can emulate
non-halt wait/sleep/block conditions that should not be subjected to
halt-polling.

No functional change intended.

	Reviewed-by: Christian Borntraeger <borntraeger@de.ibm.com>
	Reviewed-by: David Matlack <dmatlack@google.com>
	Signed-off-by: Sean Christopherson <seanjc@google.com>
Message-Id: <20211009021236.4122790-15-seanjc@google.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit fac4268894394213127e43856f41d10f29131e69)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/kvm_host.h
#	virt/kvm/kvm_main.c
diff --cc include/linux/kvm_host.h
index 6f79c17e60ed,bd13c5b5bd1d..000000000000
--- a/include/linux/kvm_host.h
+++ b/include/linux/kvm_host.h
@@@ -918,7 -1102,8 +918,12 @@@ void kvm_vcpu_mark_page_dirty(struct kv
  void kvm_sigset_activate(struct kvm_vcpu *vcpu);
  void kvm_sigset_deactivate(struct kvm_vcpu *vcpu);
  
++<<<<<<< HEAD
 +void kvm_vcpu_block(struct kvm_vcpu *vcpu);
++=======
+ void kvm_vcpu_halt(struct kvm_vcpu *vcpu);
+ bool kvm_vcpu_block(struct kvm_vcpu *vcpu);
++>>>>>>> fac426889439 (KVM: Split out a kvm_vcpu_block() helper from kvm_vcpu_halt())
  void kvm_arch_vcpu_blocking(struct kvm_vcpu *vcpu);
  void kvm_arch_vcpu_unblocking(struct kvm_vcpu *vcpu);
  bool kvm_vcpu_wake_up(struct kvm_vcpu *vcpu);
diff --cc virt/kvm/kvm_main.c
index 8d37c7cdca84,370b95ad5f03..000000000000
--- a/virt/kvm/kvm_main.c
+++ b/virt/kvm/kvm_main.c
@@@ -3024,11 -3324,13 +3053,19 @@@ static inline void update_halt_poll_sta
  }
  
  /*
++<<<<<<< HEAD
 + * The vCPU has executed a HLT instruction with in-kernel mode enabled.
 + */
 +void kvm_vcpu_block(struct kvm_vcpu *vcpu)
++=======
+  * Emulate a vCPU halt condition, e.g. HLT on x86, WFI on arm, etc...  If halt
+  * polling is enabled, busy wait for a short time before blocking to avoid the
+  * expensive block+unblock sequence if a wake event arrives soon after the vCPU
+  * is halted.
+  */
+ void kvm_vcpu_halt(struct kvm_vcpu *vcpu)
++>>>>>>> fac426889439 (KVM: Split out a kvm_vcpu_block() helper from kvm_vcpu_halt())
  {
- 	struct rcuwait *wait = kvm_arch_vcpu_get_wait(vcpu);
  	bool halt_poll_allowed = !kvm_arch_no_poll(vcpu);
  	bool do_halt_poll = halt_poll_allowed && vcpu->halt_poll_ns;
  	ktime_t start, cur, poll_end;
* Unmerged path include/linux/kvm_host.h
* Unmerged path virt/kvm/kvm_main.c
