KVM: x86: Remove defunct setting of XCR0 for guest during vCPU create

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Sean Christopherson <seanjc@google.com>
commit e8f65b9bb4832028cdbd5927ddb67f66c6ccdd27
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/e8f65b9b.failed

Drop code to initialize XCR0 during fx_init(), a.k.a. vCPU creation, as
XCR0 has been initialized during kvm_vcpu_reset() (for RESET) since
commit a554d207dc46 ("KVM: X86: Processor States following Reset or INIT").

Back when XCR0 support was added by commit 2acf923e38fb ("KVM: VMX:
Enable XSAVE/XRSTOR for guest"), KVM didn't differentiate between RESET
and INIT.  Ignoring the fact that calling fx_init() for INIT is obviously
wrong, e.g. FPU state after INIT is not the same as after RESET, setting
XCR0 in fx_init() was correct.

Eventually fx_init() got moved to kvm_arch_vcpu_init(), a.k.a. vCPU
creation (ignore the terrible name) by commit 0ee6a5172573 ("x86/fpu,
kvm: Simplify fx_init()").  Finally, commit 95a0d01eef7a ("KVM: x86: Move
all vcpu init code into kvm_arch_vcpu_create()") killed off
kvm_arch_vcpu_init(), leaving behind the oddity of redundant setting of
guest state during vCPU creation.

No functional change intended.

	Signed-off-by: Sean Christopherson <seanjc@google.com>
	Reviewed-by: Vitaly Kuznetsov <vkuznets@redhat.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
Message-Id: <20210921000303.400537-6-seanjc@google.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit e8f65b9bb4832028cdbd5927ddb67f66c6ccdd27)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/x86.c
diff --cc arch/x86/kvm/x86.c
index 7556113401c8,da0d48d10769..000000000000
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@@ -982,9 -973,9 +982,9 @@@ static int __kvm_set_xcr(struct kvm_vcp
  	/*
  	 * Do not allow the guest to set bits that we do not support
  	 * saving.  However, xcr0 bit 0 is always set, even if the
- 	 * emulated CPU does not support XSAVE (see fx_init).
+ 	 * emulated CPU does not support XSAVE (see kvm_vcpu_reset()).
  	 */
 -	valid_bits = vcpu->arch.guest_supported_xcr0 | XFEATURE_MASK_FP;
 +	valid_bits = kvm_guest_supported_xcr0(vcpu) | XFEATURE_MASK_FP;
  	if (xcr0 & ~valid_bits)
  		return 1;
  
@@@ -10825,12 -10599,24 +10825,22 @@@ static int sync_regs(struct kvm_vcpu *v
  
  static void fx_init(struct kvm_vcpu *vcpu)
  {
++<<<<<<< HEAD
 +	/*
 +	 * Ensure guest xcr0 is valid for loading
 +	 */
 +	vcpu->arch.xcr0 = XFEATURE_MASK_FP;
++=======
+ 	if (!vcpu->arch.guest_fpu)
+ 		return;
+ 
+ 	fpstate_init(&vcpu->arch.guest_fpu->state);
+ 	if (boot_cpu_has(X86_FEATURE_XSAVES))
+ 		vcpu->arch.guest_fpu->state.xsave.header.xcomp_bv =
+ 			host_xcr0 | XSTATE_COMPACTION_ENABLED;
++>>>>>>> e8f65b9bb483 (KVM: x86: Remove defunct setting of XCR0 for guest during vCPU create)
  }
  
 -void kvm_free_guest_fpu(struct kvm_vcpu *vcpu)
 -{
 -	if (vcpu->arch.guest_fpu) {
 -		kmem_cache_free(x86_fpu_cache, vcpu->arch.guest_fpu);
 -		vcpu->arch.guest_fpu = NULL;
 -	}
 -}
 -EXPORT_SYMBOL_GPL(kvm_free_guest_fpu);
 -
  int kvm_arch_vcpu_precreate(struct kvm *kvm, unsigned int id)
  {
  	if (kvm_check_tsc_unstable() && atomic_read(&kvm->online_vcpus) != 0)
* Unmerged path arch/x86/kvm/x86.c
