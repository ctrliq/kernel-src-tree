thermal: core: Fix thermal zone lookup by ID

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Thierry Reding <treding@nvidia.com>
commit 82aa68afa16819d9f05b899a5fcf174c2f1fb889
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/82aa68af.failed

When a thermal zone is looked up by an ID and no zone is found matching
that ID, the thermal_zone_get_by_id() function will return a pointer to
the thermal zone list head which isn't actually a valid thermal zone.

This can lead to a subsequent crash because a valid pointer is returned
to the called, but dereferencing that pointer as struct thermal_zone is
not safe.

Fixes: 329b064fbd13 ("thermal: core: Get thermal zone by id")
	Signed-off-by: Thierry Reding <treding@nvidia.com>
	Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
Link: https://lore.kernel.org/r/20200724170105.2705467-1-thierry.reding@gmail.com
(cherry picked from commit 82aa68afa16819d9f05b899a5fcf174c2f1fb889)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/thermal/thermal_core.c
diff --cc drivers/thermal/thermal_core.c
index cf139cb114db,9748fbb9a3a1..000000000000
--- a/drivers/thermal/thermal_core.c
+++ b/drivers/thermal/thermal_core.c
@@@ -696,6 -698,73 +696,76 @@@ void thermal_zone_device_rebind_excepti
  	mutex_unlock(&thermal_list_lock);
  }
  
++<<<<<<< HEAD
++=======
+ int for_each_thermal_governor(int (*cb)(struct thermal_governor *, void *),
+ 			      void *data)
+ {
+ 	struct thermal_governor *gov;
+ 	int ret = 0;
+ 
+ 	mutex_lock(&thermal_governor_lock);
+ 	list_for_each_entry(gov, &thermal_governor_list, governor_list) {
+ 		ret = cb(gov, data);
+ 		if (ret)
+ 			break;
+ 	}
+ 	mutex_unlock(&thermal_governor_lock);
+ 
+ 	return ret;
+ }
+ 
+ int for_each_thermal_cooling_device(int (*cb)(struct thermal_cooling_device *,
+ 					      void *), void *data)
+ {
+ 	struct thermal_cooling_device *cdev;
+ 	int ret = 0;
+ 
+ 	mutex_lock(&thermal_list_lock);
+ 	list_for_each_entry(cdev, &thermal_cdev_list, node) {
+ 		ret = cb(cdev, data);
+ 		if (ret)
+ 			break;
+ 	}
+ 	mutex_unlock(&thermal_list_lock);
+ 
+ 	return ret;
+ }
+ 
+ int for_each_thermal_zone(int (*cb)(struct thermal_zone_device *, void *),
+ 			  void *data)
+ {
+ 	struct thermal_zone_device *tz;
+ 	int ret = 0;
+ 
+ 	mutex_lock(&thermal_list_lock);
+ 	list_for_each_entry(tz, &thermal_tz_list, node) {
+ 		ret = cb(tz, data);
+ 		if (ret)
+ 			break;
+ 	}
+ 	mutex_unlock(&thermal_list_lock);
+ 
+ 	return ret;
+ }
+ 
+ struct thermal_zone_device *thermal_zone_get_by_id(int id)
+ {
+ 	struct thermal_zone_device *tz, *match = NULL;
+ 
+ 	mutex_lock(&thermal_list_lock);
+ 	list_for_each_entry(tz, &thermal_tz_list, node) {
+ 		if (tz->id == id) {
+ 			match = tz;
+ 			break;
+ 		}
+ 	}
+ 	mutex_unlock(&thermal_list_lock);
+ 
+ 	return match;
+ }
+ 
++>>>>>>> 82aa68afa168 (thermal: core: Fix thermal zone lookup by ID)
  void thermal_zone_device_unbind_exception(struct thermal_zone_device *tz,
  					  const char *cdev_type, size_t size)
  {
* Unmerged path drivers/thermal/thermal_core.c
