bnxt_en: add enable_remote_dev_reset devlink parameter

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Edwin Peer <edwin.peer@broadcom.com>
commit 892a662f04736ba40e241c794b15f1b2ee489dc3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/892a662f.failed

The reported parameter value should not take into account the state
of remote drivers. Firmware will reject remote resets as appropriate,
thus it is not strictly necessary to check HOT_RESET_ALLOWED before
attempting to initiate a reset. But we add the check so that we can
provide more intuitive messages when reset is not permitted.

This firmware setting needs to be restored from all functions after
a firmware reset.

	Signed-off-by: Edwin Peer <edwin.peer@broadcom.com>
	Signed-off-by: Michael Chan <michael.chan@broadcom.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 892a662f04736ba40e241c794b15f1b2ee489dc3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/broadcom/bnxt/bnxt_devlink.c
#	drivers/net/ethernet/broadcom/bnxt/bnxt_devlink.h
diff --cc drivers/net/ethernet/broadcom/bnxt/bnxt_devlink.c
index d875469f72ce,8673f3c4b581..000000000000
--- a/drivers/net/ethernet/broadcom/bnxt/bnxt_devlink.c
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt_devlink.c
@@@ -327,6 -349,35 +349,38 @@@ static int bnxt_dl_reload_down(struct d
  		bp->ctx = NULL;
  		break;
  	}
++<<<<<<< HEAD
++=======
+ 	case DEVLINK_RELOAD_ACTION_FW_ACTIVATE: {
+ 		if (~bp->fw_cap & BNXT_FW_CAP_HOT_RESET) {
+ 			NL_SET_ERR_MSG_MOD(extack, "Device not capable, requires reboot");
+ 			return -EOPNOTSUPP;
+ 		}
+ 		if (!bnxt_hwrm_reset_permitted(bp)) {
+ 			NL_SET_ERR_MSG_MOD(extack,
+ 					   "Reset denied by firmware, it may be inhibited by remote driver");
+ 			return -EPERM;
+ 		}
+ 		rtnl_lock();
+ 		if (bp->dev->reg_state == NETREG_UNREGISTERED) {
+ 			rtnl_unlock();
+ 			return -ENODEV;
+ 		}
+ 		if (netif_running(bp->dev))
+ 			set_bit(BNXT_STATE_FW_ACTIVATE, &bp->state);
+ 		rc = bnxt_hwrm_firmware_reset(bp->dev,
+ 					      FW_RESET_REQ_EMBEDDED_PROC_TYPE_CHIP,
+ 					      FW_RESET_REQ_SELFRST_STATUS_SELFRSTASAP,
+ 					      FW_RESET_REQ_FLAGS_RESET_GRACEFUL |
+ 					      FW_RESET_REQ_FLAGS_FW_ACTIVATION);
+ 		if (rc) {
+ 			NL_SET_ERR_MSG_MOD(extack, "Failed to activate firmware");
+ 			clear_bit(BNXT_STATE_FW_ACTIVATE, &bp->state);
+ 			rtnl_unlock();
+ 		}
+ 		break;
+ 	}
++>>>>>>> 892a662f0473 (bnxt_en: add enable_remote_dev_reset devlink parameter)
  	default:
  		rc = -EOPNOTSUPP;
  	}
diff --cc drivers/net/ethernet/broadcom/bnxt/bnxt_devlink.h
index 406dc655a5fc,456e18c4badf..000000000000
--- a/drivers/net/ethernet/broadcom/bnxt/bnxt_devlink.h
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt_devlink.h
@@@ -20,6 -21,23 +21,26 @@@ static inline struct bnxt *bnxt_get_bp_
  	return ((struct bnxt_dl *)devlink_priv(dl))->bp;
  }
  
++<<<<<<< HEAD
++=======
+ static inline void bnxt_dl_remote_reload(struct bnxt *bp)
+ {
+ 	devlink_remote_reload_actions_performed(bp->dl, 0,
+ 						BIT(DEVLINK_RELOAD_ACTION_DRIVER_REINIT) |
+ 						BIT(DEVLINK_RELOAD_ACTION_FW_ACTIVATE));
+ }
+ 
+ static inline bool bnxt_dl_get_remote_reset(struct devlink *dl)
+ {
+ 	return ((struct bnxt_dl *)devlink_priv(dl))->remote_reset;
+ }
+ 
+ static inline void bnxt_dl_set_remote_reset(struct devlink *dl, bool value)
+ {
+ 	((struct bnxt_dl *)devlink_priv(dl))->remote_reset = value;
+ }
+ 
++>>>>>>> 892a662f0473 (bnxt_en: add enable_remote_dev_reset devlink parameter)
  #define NVM_OFF_MSIX_VEC_PER_PF_MAX	108
  #define NVM_OFF_MSIX_VEC_PER_PF_MIN	114
  #define NVM_OFF_IGNORE_ARI		164
diff --git a/drivers/net/ethernet/broadcom/bnxt/bnxt.c b/drivers/net/ethernet/broadcom/bnxt/bnxt.c
index e0610b187ca8..32bc2c07b2fc 100644
--- a/drivers/net/ethernet/broadcom/bnxt/bnxt.c
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt.c
@@ -7477,6 +7477,8 @@ static int __bnxt_hwrm_func_qcaps(struct bnxt *bp)
 		bp->fw_cap |= BNXT_FW_CAP_EXT_HW_STATS_SUPPORTED;
 	if (BNXT_PF(bp) && (flags_ext & FUNC_QCAPS_RESP_FLAGS_EXT_PTP_PPS_SUPPORTED))
 		bp->fw_cap |= BNXT_FW_CAP_PTP_PPS;
+	if (BNXT_PF(bp) && (flags_ext & FUNC_QCAPS_RESP_FLAGS_EXT_HOT_RESET_IF_SUPPORT))
+		bp->fw_cap |= BNXT_FW_CAP_HOT_RESET_IF;
 
 	bp->tx_push_thresh = 0;
 	if ((flags & FUNC_QCAPS_RESP_FLAGS_PUSH_MODE_SUPPORTED) &&
@@ -12012,6 +12014,27 @@ static void bnxt_fw_reset_writel(struct bnxt *bp, int reg_idx)
 	}
 }
 
+bool bnxt_hwrm_reset_permitted(struct bnxt *bp)
+{
+	struct hwrm_func_qcfg_output *resp;
+	struct hwrm_func_qcfg_input *req;
+	bool result = true; /* firmware will enforce if unknown */
+
+	if (~bp->fw_cap & BNXT_FW_CAP_HOT_RESET_IF)
+		return result;
+
+	if (hwrm_req_init(bp, req, HWRM_FUNC_QCFG))
+		return result;
+
+	req->fid = cpu_to_le16(0xffff);
+	resp = hwrm_req_hold(bp, req);
+	if (!hwrm_req_send(bp, req))
+		result = !!(le16_to_cpu(resp->flags) &
+			    FUNC_QCFG_RESP_FLAGS_HOT_RESET_ALLOWED);
+	hwrm_req_drop(bp, req);
+	return result;
+}
+
 static void bnxt_reset_all(struct bnxt *bp)
 {
 	struct bnxt_fw_health *fw_health = bp->fw_health;
diff --git a/drivers/net/ethernet/broadcom/bnxt/bnxt.h b/drivers/net/ethernet/broadcom/bnxt/bnxt.h
index deaac7c33081..32ff1e60fd43 100644
--- a/drivers/net/ethernet/broadcom/bnxt/bnxt.h
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt.h
@@ -1925,6 +1925,7 @@ struct bnxt {
 	#define BNXT_FW_CAP_VLAN_TX_INSERT		0x02000000
 	#define BNXT_FW_CAP_EXT_HW_STATS_SUPPORTED	0x04000000
 	#define BNXT_FW_CAP_PTP_PPS			0x10000000
+	#define BNXT_FW_CAP_HOT_RESET_IF		0x20000000
 	#define BNXT_FW_CAP_RING_MONITOR		0x40000000
 
 #define BNXT_NEW_RM(bp)		((bp)->fw_cap & BNXT_FW_CAP_NEW_RM)
@@ -2264,6 +2265,7 @@ void bnxt_fw_reset(struct bnxt *bp);
 int bnxt_check_rings(struct bnxt *bp, int tx, int rx, bool sh, int tcs,
 		     int tx_xdp);
 int bnxt_fw_init_one(struct bnxt *bp);
+bool bnxt_hwrm_reset_permitted(struct bnxt *bp);
 int bnxt_setup_mq_tc(struct net_device *dev, u8 tc);
 int bnxt_get_max_rings(struct bnxt *, int *, int *, bool);
 int bnxt_restore_pf_fw_resources(struct bnxt *bp);
* Unmerged path drivers/net/ethernet/broadcom/bnxt/bnxt_devlink.c
* Unmerged path drivers/net/ethernet/broadcom/bnxt/bnxt_devlink.h
diff --git a/drivers/net/ethernet/broadcom/bnxt/bnxt_ethtool.c b/drivers/net/ethernet/broadcom/bnxt/bnxt_ethtool.c
index 196623c451fc..723a3f91d7f4 100644
--- a/drivers/net/ethernet/broadcom/bnxt/bnxt_ethtool.c
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt_ethtool.c
@@ -2187,6 +2187,11 @@ static int bnxt_hwrm_firmware_reset(struct net_device *dev, u8 proc_type,
 	struct hwrm_fw_reset_input *req;
 	int rc;
 
+	if (!bnxt_hwrm_reset_permitted(bp)) {
+		netdev_warn(bp->dev, "Reset denied by firmware, it may be inhibited by remote driver");
+		return -EPERM;
+	}
+
 	rc = hwrm_req_init(bp, req, HWRM_FW_RESET);
 	if (rc)
 		return rc;
