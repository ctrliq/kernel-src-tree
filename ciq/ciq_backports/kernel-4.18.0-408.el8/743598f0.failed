dm: record old_sector in dm_target_io before calling map function

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Mike Snitzer <snitzer@redhat.com>
commit 743598f049df473869138d599d6ad3b7c740a73f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/743598f0.failed

Prep for being able to defer trace_block_bio_remap() until when the
bio is remapped and submitted by the DM target.

	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Mikulas Patocka <mpatocka@redhat.com>
	Signed-off-by: Mike Snitzer <snitzer@redhat.com>
(cherry picked from commit 743598f049df473869138d599d6ad3b7c740a73f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/md/dm.c
diff --cc drivers/md/dm.c
index b06624dd4339,08689b3e501a..000000000000
--- a/drivers/md/dm.c
+++ b/drivers/md/dm.c
@@@ -651,15 -583,17 +651,20 @@@ static struct dm_target_io *alloc_tio(s
  	tio->io = ci->io;
  	tio->ti = ti;
  	tio->target_bio_nr = target_bio_nr;
++<<<<<<< HEAD
++=======
+ 	tio->len_ptr = len;
+ 	tio->old_sector = 0;
++>>>>>>> 743598f049df (dm: record old_sector in dm_target_io before calling map function)
  
 -	return &tio->clone;
 +	return tio;
  }
  
 -static void free_tio(struct bio *clone)
 +static void free_tio(struct dm_target_io *tio)
  {
 -	if (clone_to_tio(clone)->inside_dm_io)
 +	if (tio->inside_dm_io)
  		return;
 -	bio_put(clone);
 +	bio_put(&tio->clone);
  }
  
  /*
@@@ -1268,14 -1136,12 +1273,17 @@@ static noinline void __set_swap_bios_li
  	mutex_unlock(&md->swap_bios_lock);
  }
  
 -static void __map_bio(struct bio *clone)
 +static blk_qc_t __map_bio(struct dm_target_io *tio)
  {
 -	struct dm_target_io *tio = clone_to_tio(clone);
  	int r;
++<<<<<<< HEAD
 +	sector_t sector;
 +	struct bio *clone = &tio->clone;
++=======
++>>>>>>> 743598f049df (dm: record old_sector in dm_target_io before calling map function)
  	struct dm_io *io = tio->io;
  	struct dm_target *ti = tio->ti;
 +	blk_qc_t ret = BLK_QC_T_NONE;
  
  	clone->bi_end_io = clone_endio;
  
@@@ -1301,25 -1176,19 +1309,31 @@@
  		break;
  	case DM_MAPIO_REMAPPED:
  		/* the bio has been remapped so dispatch it */
++<<<<<<< HEAD
 +		trace_block_bio_remap(clone->bi_disk->queue, clone,
 +				      bio_dev(io->orig_bio), sector);
 +		ret = generic_make_request(clone);
++=======
+ 		trace_block_bio_remap(clone, bio_dev(io->orig_bio),
+ 				      tio->old_sector);
+ 		submit_bio_noacct(clone);
++>>>>>>> 743598f049df (dm: record old_sector in dm_target_io before calling map function)
  		break;
  	case DM_MAPIO_KILL:
 +		if (unlikely(swap_bios_limit(ti, clone))) {
 +			struct mapped_device *md = io->md;
 +			up(&md->swap_bios_semaphore);
 +		}
 +		free_tio(tio);
 +		dm_io_dec_pending(io, BLK_STS_IOERR);
 +		break;
  	case DM_MAPIO_REQUEUE:
 -		if (unlikely(swap_bios_limit(ti, clone)))
 -			up(&io->md->swap_bios_semaphore);
 -		free_tio(clone);
 -		if (r == DM_MAPIO_KILL)
 -			dm_io_dec_pending(io, BLK_STS_IOERR);
 -		else
 -			dm_io_dec_pending(io, BLK_STS_DM_REQUEUE);
 +		if (unlikely(swap_bios_limit(ti, clone))) {
 +			struct mapped_device *md = io->md;
 +			up(&md->swap_bios_semaphore);
 +		}
 +		free_tio(tio);
 +		dm_io_dec_pending(io, BLK_STS_DM_REQUEUE);
  		break;
  	default:
  		DMWARN("unimplemented target map return value: %d", r);
diff --git a/drivers/md/dm-core.h b/drivers/md/dm-core.h
index 77175ea7ef3b..81d8c4af4af7 100644
--- a/drivers/md/dm-core.h
+++ b/drivers/md/dm-core.h
@@ -203,6 +203,7 @@ struct dm_target_io {
 	unsigned int target_bio_nr;
 	unsigned int *len_ptr;
 	bool inside_dm_io;
+	sector_t old_sector;
 	struct bio clone;
 };
 
* Unmerged path drivers/md/dm.c
