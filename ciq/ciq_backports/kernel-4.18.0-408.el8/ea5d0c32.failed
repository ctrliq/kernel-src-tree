tcp: add new SNMP counter for drops when try to queue in rcv queue

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Yafang Shao <laoar.shao@gmail.com>
commit ea5d0c32498e1a08ff5f3dbeafa4d74895851b0d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/ea5d0c32.failed

When sk_rmem_alloc is larger than the receive buffer and we can't
schedule more memory for it, the skb will be dropped.

In above situation, if this skb is put into the ofo queue,
LINUX_MIB_TCPOFODROP is incremented to track it.

While if this skb is put into the receive queue, there's no record.
So a new SNMP counter is introduced to track this behavior.

LINUX_MIB_TCPRCVQDROP:  Number of packets meant to be queued in rcv queue
			but dropped because socket rcvbuf limit hit.

	Signed-off-by: Yafang Shao <laoar.shao@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit ea5d0c32498e1a08ff5f3dbeafa4d74895851b0d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/uapi/linux/snmp.h
#	net/ipv4/proc.c
#	net/ipv4/tcp_input.c
diff --cc include/uapi/linux/snmp.h
index b3db0c8fba73,e5ebc83827ab..000000000000
--- a/include/uapi/linux/snmp.h
+++ b/include/uapi/linux/snmp.h
@@@ -284,9 -279,8 +284,14 @@@ enu
  	LINUX_MIB_TCPDELIVERED,			/* TCPDelivered */
  	LINUX_MIB_TCPDELIVEREDCE,		/* TCPDeliveredCE */
  	LINUX_MIB_TCPACKCOMPRESSED,		/* TCPAckCompressed */
++<<<<<<< HEAD
 +#ifndef __GENKSYMS__
 +	LINUX_MIB_TCPWQUEUETOOBIG,		/* TCPWqueueTooBig */
 +#endif
++=======
+ 	LINUX_MIB_TCPZEROWINDOWDROP,		/* TCPZeroWindowDrop */
+ 	LINUX_MIB_TCPRCVQDROP,			/* TCPRcvQDrop */
++>>>>>>> ea5d0c32498e (tcp: add new SNMP counter for drops when try to queue in rcv queue)
  	__LINUX_MIB_MAX
  };
  
diff --cc net/ipv4/proc.c
index 980c3770381b,b46e4cf9a55a..000000000000
--- a/net/ipv4/proc.c
+++ b/net/ipv4/proc.c
@@@ -291,7 -287,8 +291,12 @@@ static const struct snmp_mib snmp4_net_
  	SNMP_MIB_ITEM("TCPDelivered", LINUX_MIB_TCPDELIVERED),
  	SNMP_MIB_ITEM("TCPDeliveredCE", LINUX_MIB_TCPDELIVEREDCE),
  	SNMP_MIB_ITEM("TCPAckCompressed", LINUX_MIB_TCPACKCOMPRESSED),
++<<<<<<< HEAD
 +	SNMP_MIB_ITEM("TCPWqueueTooBig", LINUX_MIB_TCPWQUEUETOOBIG),
++=======
+ 	SNMP_MIB_ITEM("TCPZeroWindowDrop", LINUX_MIB_TCPZEROWINDOWDROP),
+ 	SNMP_MIB_ITEM("TCPRcvQDrop", LINUX_MIB_TCPRCVQDROP),
++>>>>>>> ea5d0c32498e (tcp: add new SNMP counter for drops when try to queue in rcv queue)
  	SNMP_MIB_SENTINEL
  };
  
diff --cc net/ipv4/tcp_input.c
index 040dc4f9858b,eecd359595fc..000000000000
--- a/net/ipv4/tcp_input.c
+++ b/net/ipv4/tcp_input.c
@@@ -4890,7 -4680,7 +4892,11 @@@ queue_and_out
  		if (skb_queue_len(&sk->sk_receive_queue) == 0)
  			sk_forced_mem_schedule(sk, skb->truesize);
  		else if (tcp_try_rmem_schedule(sk, skb, skb->truesize)) {
++<<<<<<< HEAD
 +			sk->sk_data_ready(sk);
++=======
+ 			NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPRCVQDROP);
++>>>>>>> ea5d0c32498e (tcp: add new SNMP counter for drops when try to queue in rcv queue)
  			goto drop;
  		}
  
* Unmerged path include/uapi/linux/snmp.h
* Unmerged path net/ipv4/proc.c
* Unmerged path net/ipv4/tcp_input.c
