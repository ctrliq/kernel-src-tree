s390/qeth: fine-tune .ndo_select_queue()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Julian Wiedmann <jwi@linux.ibm.com>
commit 1b9e410f45bf68c068fa3422ca7b65ce4d08e5ed
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/1b9e410f.failed

Avoid a conditional branch for L2 devices when selecting the TX queue,
and have shared logic for OSA devices.

	Signed-off-by: Julian Wiedmann <jwi@linux.ibm.com>
	Signed-off-by: Alexandra Winter <wintera@linux.ibm.com>
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit 1b9e410f45bf68c068fa3422ca7b65ce4d08e5ed)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/s390/net/qeth_core.h
#	drivers/s390/net/qeth_l2_main.c
#	drivers/s390/net/qeth_l3_main.c
diff --cc drivers/s390/net/qeth_core.h
index 7eb7dbed8300,de25d7ac41da..000000000000
--- a/drivers/s390/net/qeth_core.h
+++ b/drivers/s390/net/qeth_core.h
@@@ -1135,8 -1096,9 +1133,14 @@@ netdev_features_t qeth_features_check(s
  void qeth_get_stats64(struct net_device *dev, struct rtnl_link_stats64 *stats);
  int qeth_set_real_num_tx_queues(struct qeth_card *card, unsigned int count);
  u16 qeth_iqd_select_queue(struct net_device *dev, struct sk_buff *skb,
++<<<<<<< HEAD
 +			  u8 cast_type, struct net_device *sb_dev,
 +			  select_queue_fallback_t fallback);
++=======
+ 			  u8 cast_type, struct net_device *sb_dev);
+ u16 qeth_osa_select_queue(struct net_device *dev, struct sk_buff *skb,
+ 			  struct net_device *sb_dev);
++>>>>>>> 1b9e410f45bf (s390/qeth: fine-tune .ndo_select_queue())
  int qeth_open(struct net_device *dev);
  int qeth_stop(struct net_device *dev);
  
diff --cc drivers/s390/net/qeth_l2_main.c
index bb3ea211aae1,303461d70af3..000000000000
--- a/drivers/s390/net/qeth_l2_main.c
+++ b/drivers/s390/net/qeth_l2_main.c
@@@ -562,20 -519,11 +562,28 @@@ static netdev_tx_t qeth_l2_hard_start_x
  	return NETDEV_TX_OK;
  }
  
++<<<<<<< HEAD
 +static u16 qeth_l2_select_queue(struct net_device *dev, struct sk_buff *skb,
 +				struct net_device *sb_dev,
 +				select_queue_fallback_t fallback)
 +{
 +	struct qeth_card *card = dev->ml_priv;
 +
 +	if (IS_IQD(card))
 +		return qeth_iqd_select_queue(dev, skb,
 +					     qeth_get_ether_cast_type(skb),
 +					     sb_dev, fallback);
 +	if (qeth_uses_tx_prio_queueing(card))
 +		return qeth_get_priority_queue(card, skb);
 +
 +	return fallback(dev, skb, sb_dev);
++=======
+ static u16 qeth_l2_iqd_select_queue(struct net_device *dev, struct sk_buff *skb,
+ 				    struct net_device *sb_dev)
+ {
+ 	return qeth_iqd_select_queue(dev, skb, qeth_get_ether_cast_type(skb),
+ 				     sb_dev);
++>>>>>>> 1b9e410f45bf (s390/qeth: fine-tune .ndo_select_queue())
  }
  
  static void qeth_l2_set_rx_mode(struct net_device *dev)
@@@ -1101,10 -1051,32 +1109,36 @@@ static const struct net_device_ops qeth
  	.ndo_get_stats64	= qeth_get_stats64,
  	.ndo_start_xmit		= qeth_l2_hard_start_xmit,
  	.ndo_features_check	= qeth_features_check,
- 	.ndo_select_queue	= qeth_l2_select_queue,
+ 	.ndo_select_queue	= qeth_l2_iqd_select_queue,
  	.ndo_validate_addr	= qeth_l2_validate_addr,
  	.ndo_set_rx_mode	= qeth_l2_set_rx_mode,
++<<<<<<< HEAD
 +	.ndo_do_ioctl		= qeth_do_ioctl,
++=======
+ 	.ndo_eth_ioctl		= qeth_do_ioctl,
+ 	.ndo_siocdevprivate	= qeth_siocdevprivate,
+ 	.ndo_set_mac_address	= qeth_l2_set_mac_address,
+ 	.ndo_vlan_rx_add_vid	= qeth_l2_vlan_rx_add_vid,
+ 	.ndo_vlan_rx_kill_vid	= qeth_l2_vlan_rx_kill_vid,
+ 	.ndo_tx_timeout		= qeth_tx_timeout,
+ 	.ndo_fix_features	= qeth_fix_features,
+ 	.ndo_set_features	= qeth_set_features,
+ 	.ndo_bridge_getlink	= qeth_l2_bridge_getlink,
+ 	.ndo_bridge_setlink	= qeth_l2_bridge_setlink,
+ };
+ 
+ static const struct net_device_ops qeth_l2_osa_netdev_ops = {
+ 	.ndo_open		= qeth_open,
+ 	.ndo_stop		= qeth_stop,
+ 	.ndo_get_stats64	= qeth_get_stats64,
+ 	.ndo_start_xmit		= qeth_l2_hard_start_xmit,
+ 	.ndo_features_check	= qeth_features_check,
+ 	.ndo_select_queue	= qeth_osa_select_queue,
+ 	.ndo_validate_addr	= qeth_l2_validate_addr,
+ 	.ndo_set_rx_mode	= qeth_l2_set_rx_mode,
+ 	.ndo_eth_ioctl		= qeth_do_ioctl,
+ 	.ndo_siocdevprivate	= qeth_siocdevprivate,
++>>>>>>> 1b9e410f45bf (s390/qeth: fine-tune .ndo_select_queue())
  	.ndo_set_mac_address    = qeth_l2_set_mac_address,
  	.ndo_vlan_rx_add_vid	= qeth_l2_vlan_rx_add_vid,
  	.ndo_vlan_rx_kill_vid   = qeth_l2_vlan_rx_kill_vid,
diff --cc drivers/s390/net/qeth_l3_main.c
index 6f08ef2e1f4e,9251ad276ee8..000000000000
--- a/drivers/s390/net/qeth_l3_main.c
+++ b/drivers/s390/net/qeth_l3_main.c
@@@ -1820,22 -1819,9 +1820,25 @@@ static u16 qeth_l3_iqd_select_queue(str
  	__be16 proto = vlan_get_protocol(skb);
  
  	return qeth_iqd_select_queue(dev, skb,
 -				     qeth_l3_get_cast_type(skb, proto), sb_dev);
 +				     qeth_l3_get_cast_type(skb, proto),
 +				     sb_dev, fallback);
 +}
 +
++<<<<<<< HEAD
 +static u16 qeth_l3_osa_select_queue(struct net_device *dev, struct sk_buff *skb,
 +				    struct net_device *sb_dev,
 +				    select_queue_fallback_t fallback)
 +{
 +	struct qeth_card *card = dev->ml_priv;
 +
 +	if (qeth_uses_tx_prio_queueing(card))
 +		return qeth_get_priority_queue(card, skb);
 +
 +	return fallback(dev, skb, sb_dev);
  }
  
++=======
++>>>>>>> 1b9e410f45bf (s390/qeth: fine-tune .ndo_select_queue())
  static const struct net_device_ops qeth_l3_netdev_ops = {
  	.ndo_open		= qeth_open,
  	.ndo_stop		= qeth_stop,
@@@ -1856,10 -1843,11 +1859,10 @@@ static const struct net_device_ops qeth
  	.ndo_get_stats64	= qeth_get_stats64,
  	.ndo_start_xmit		= qeth_l3_hard_start_xmit,
  	.ndo_features_check	= qeth_l3_osa_features_check,
- 	.ndo_select_queue	= qeth_l3_osa_select_queue,
+ 	.ndo_select_queue	= qeth_osa_select_queue,
  	.ndo_validate_addr	= eth_validate_addr,
  	.ndo_set_rx_mode	= qeth_l3_set_rx_mode,
 -	.ndo_eth_ioctl		= qeth_do_ioctl,
 -	.ndo_siocdevprivate	= qeth_l3_ndo_siocdevprivate,
 +	.ndo_do_ioctl		= qeth_do_ioctl,
  	.ndo_fix_features	= qeth_fix_features,
  	.ndo_set_features	= qeth_set_features,
  	.ndo_tx_timeout		= qeth_tx_timeout,
* Unmerged path drivers/s390/net/qeth_core.h
diff --git a/drivers/s390/net/qeth_core_main.c b/drivers/s390/net/qeth_core_main.c
index 97d4bb154094..c752b1aef33b 100644
--- a/drivers/s390/net/qeth_core_main.c
+++ b/drivers/s390/net/qeth_core_main.c
@@ -3792,7 +3792,7 @@ static void qeth_qdio_output_handler(struct ccw_device *ccwdev,
 /*
  * Note: Function assumes that we have 4 outbound queues.
  */
-int qeth_get_priority_queue(struct qeth_card *card, struct sk_buff *skb)
+static int qeth_get_priority_queue(struct qeth_card *card, struct sk_buff *skb)
 {
 	struct vlan_ethhdr *veth = vlan_eth_hdr(skb);
 	u8 tos;
@@ -3837,7 +3837,6 @@ int qeth_get_priority_queue(struct qeth_card *card, struct sk_buff *skb)
 	}
 	return card->qdio.default_out_queue;
 }
-EXPORT_SYMBOL_GPL(qeth_get_priority_queue);
 
 /**
  * qeth_get_elements_for_frags() -	find number of SBALEs for skb frags.
@@ -7192,6 +7191,18 @@ u16 qeth_iqd_select_queue(struct net_device *dev, struct sk_buff *skb,
 }
 EXPORT_SYMBOL_GPL(qeth_iqd_select_queue);
 
+u16 qeth_osa_select_queue(struct net_device *dev, struct sk_buff *skb,
+			  struct net_device *sb_dev)
+{
+	struct qeth_card *card = dev->ml_priv;
+
+	if (qeth_uses_tx_prio_queueing(card))
+		return qeth_get_priority_queue(card, skb);
+
+	return netdev_pick_tx(dev, skb, sb_dev);
+}
+EXPORT_SYMBOL_GPL(qeth_osa_select_queue);
+
 int qeth_open(struct net_device *dev)
 {
 	struct qeth_card *card = dev->ml_priv;
* Unmerged path drivers/s390/net/qeth_l2_main.c
* Unmerged path drivers/s390/net/qeth_l3_main.c
