KVM: x86: Trace all APICv inhibit changes and capture overall status

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Sean Christopherson <seanjc@google.com>
commit 4f4c4a3ee53cc20569158a05f99b6c2d1f9c998a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/4f4c4a3e.failed

Trace all APICv inhibit changes instead of just those that result in
APICv being (un)inhibited, and log the current state.  Debugging why
APICv isn't working is frustrating as it's hard to see why APICv is still
inhibited, and logging only the first inhibition means unnecessary onion
peeling.

Opportunistically drop the export of the tracepoint, it is not and should
not be used by vendor code due to the need to serialize toggling via
apicv_update_lock.

Note, using the common flow means kvm_apicv_init() switched from atomic
to non-atomic bitwise operations.  The VM is unreachable at init, so
non-atomic is perfectly ok.

	Signed-off-by: Sean Christopherson <seanjc@google.com>
Message-Id: <20220311043517.17027-4-seanjc@google.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 4f4c4a3ee53cc20569158a05f99b6c2d1f9c998a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/trace.h
#	arch/x86/kvm/x86.c
diff --cc arch/x86/kvm/trace.h
index 193f5ba930d1,e3a24b8f04be..000000000000
--- a/arch/x86/kvm/trace.h
+++ b/arch/x86/kvm/trace.h
@@@ -1339,23 -1339,25 +1339,45 @@@ TRACE_EVENT(kvm_hv_stimer_cleanup
  		  __entry->vcpu_id, __entry->timer_index)
  );
  
++<<<<<<< HEAD
 +TRACE_EVENT(kvm_apicv_update_request,
 +	    TP_PROTO(bool activate, unsigned long bit),
 +	    TP_ARGS(activate, bit),
 +
 +	TP_STRUCT__entry(
 +		__field(bool, activate)
 +		__field(unsigned long, bit)
 +	),
 +
 +	TP_fast_assign(
 +		__entry->activate = activate;
 +		__entry->bit = bit;
 +	),
 +
 +	TP_printk("%s bit=%lu",
 +		  __entry->activate ? "activate" : "deactivate",
 +		  __entry->bit)
++=======
+ TRACE_EVENT(kvm_apicv_inhibit_changed,
+ 	    TP_PROTO(int reason, bool set, unsigned long inhibits),
+ 	    TP_ARGS(reason, set, inhibits),
+ 
+ 	TP_STRUCT__entry(
+ 		__field(int, reason)
+ 		__field(bool, set)
+ 		__field(unsigned long, inhibits)
+ 	),
+ 
+ 	TP_fast_assign(
+ 		__entry->reason = reason;
+ 		__entry->set = set;
+ 		__entry->inhibits = inhibits;
+ 	),
+ 
+ 	TP_printk("%s reason=%u, inhibits=0x%lx",
+ 		  __entry->set ? "set" : "cleared",
+ 		  __entry->reason, __entry->inhibits)
++>>>>>>> 4f4c4a3ee53c (KVM: x86: Trace all APICv inhibit changes and capture overall status)
  );
  
  TRACE_EVENT(kvm_apicv_accept_irq,
diff --cc arch/x86/kvm/x86.c
index e014b7ea74df,129003ad3784..000000000000
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@@ -9711,13 -9770,9 +9725,19 @@@ void __kvm_request_apicv_update(struct 
  
  	old = new = kvm->arch.apicv_inhibit_reasons;
  
++<<<<<<< HEAD
 +	if (activate)
 +		__clear_bit(bit, &new);
 +	else
 +		__set_bit(bit, &new);
 +
 +	if (!!old != !!new) {
 +		trace_kvm_apicv_update_request(activate, bit);
++=======
+ 	set_or_clear_apicv_inhibit(&new, reason, set);
+ 
+ 	if (!!old != !!new) {
++>>>>>>> 4f4c4a3ee53c (KVM: x86: Trace all APICv inhibit changes and capture overall status)
  		/*
  		 * Kick all vCPUs before setting apicv_inhibit_reasons to avoid
  		 * false positives in the sanity check WARN in svm_vcpu_run().
* Unmerged path arch/x86/kvm/trace.h
* Unmerged path arch/x86/kvm/x86.c
