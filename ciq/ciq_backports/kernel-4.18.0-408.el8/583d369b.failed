KVM: x86: Fold fx_init() into kvm_arch_vcpu_create()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Sean Christopherson <seanjc@google.com>
commit 583d369b36a90753d8b169f041b39078ac4e1633
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/583d369b.failed

Move the few bits of relevant fx_init() code into kvm_arch_vcpu_create(),
dropping the superfluous check on vcpu->arch.guest_fpu that was blindly
and wrongly added by commit ed02b213098a ("KVM: SVM: Guest FPU state
save/restore not needed for SEV-ES guest").

Note, KVM currently allocates and then frees FPU state for SEV-ES guests,
rather than avoid the allocation in the first place.  While that approach
is inarguably inefficient and unnecessary, it's a cleanup for the future.

No functional change intended.

	Signed-off-by: Sean Christopherson <seanjc@google.com>
	Reviewed-by: Vitaly Kuznetsov <vkuznets@redhat.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
Message-Id: <20210921000303.400537-7-seanjc@google.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 583d369b36a90753d8b169f041b39078ac4e1633)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/x86.c
diff --cc arch/x86/kvm/x86.c
index 7556113401c8,1ab0caa97f30..000000000000
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@@ -10823,13 -10597,14 +10823,24 @@@ static int sync_regs(struct kvm_vcpu *v
  	return 0;
  }
  
++<<<<<<< HEAD
 +static void fx_init(struct kvm_vcpu *vcpu)
 +{
 +	/*
 +	 * Ensure guest xcr0 is valid for loading
 +	 */
 +	vcpu->arch.xcr0 = XFEATURE_MASK_FP;
 +}
++=======
+ void kvm_free_guest_fpu(struct kvm_vcpu *vcpu)
+ {
+ 	if (vcpu->arch.guest_fpu) {
+ 		kmem_cache_free(x86_fpu_cache, vcpu->arch.guest_fpu);
+ 		vcpu->arch.guest_fpu = NULL;
+ 	}
+ }
+ EXPORT_SYMBOL_GPL(kvm_free_guest_fpu);
++>>>>>>> 583d369b36a9 (KVM: x86: Fold fx_init() into kvm_arch_vcpu_create())
  
  int kvm_arch_vcpu_precreate(struct kvm *kvm, unsigned int id)
  {
@@@ -10892,7 -10669,16 +10903,20 @@@ int kvm_arch_vcpu_create(struct kvm_vcp
  		goto free_emulate_ctxt;
  	}
  
++<<<<<<< HEAD
 +	fx_init(vcpu);
++=======
+ 	vcpu->arch.guest_fpu = kmem_cache_zalloc(x86_fpu_cache,
+ 						 GFP_KERNEL_ACCOUNT);
+ 	if (!vcpu->arch.guest_fpu) {
+ 		pr_err("kvm: failed to allocate vcpu's fpu\n");
+ 		goto free_user_fpu;
+ 	}
+ 	fpstate_init(&vcpu->arch.guest_fpu->state);
+ 	if (boot_cpu_has(X86_FEATURE_XSAVES))
+ 		vcpu->arch.guest_fpu->state.xsave.header.xcomp_bv =
+ 			host_xcr0 | XSTATE_COMPACTION_ENABLED;
++>>>>>>> 583d369b36a9 (KVM: x86: Fold fx_init() into kvm_arch_vcpu_create())
  
  	vcpu->arch.maxphyaddr = cpuid_query_maxphyaddr(vcpu);
  	vcpu->arch.reserved_gpa_bits = kvm_vcpu_reserved_gpa_bits_raw(vcpu);
* Unmerged path arch/x86/kvm/x86.c
