s390/zcrypt: handle checkstopped cards with new state

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Harald Freudenberger <freude@linux.ibm.com>
commit a7e701dba1234adbfbacad5ce19656c5606728da
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/a7e701db.failed

A crypto card may be in checkstopped state. With this
patch this is handled as a new state in the ap card and
ap queue structs. There is also a new card sysfs attribute

  /sys/devices/ap/cardxx/chkstop

and a new queue sysfs attribute

  /sys/devices/ap/cardxx/xx.yyyy/chkstop

displaying the checkstop state of the card or queue. Please
note that the queue's checkstop state is only a copy of the
card's checkstop state but makes maintenance much easier.

The checkstop state expressed here is the result of an
RC 0x04 (CHECKSTOP) during an AP command, mostly the
PQAP(TAPQ) command which is 'testing' the queue.

	Signed-off-by: Harald Freudenberger <freude@linux.ibm.com>
	Reviewed-by: JÃ¼rgen Christ <jchrist@linux.ibm.com>
	Signed-off-by: Vasily Gorbik <gor@linux.ibm.com>
(cherry picked from commit a7e701dba1234adbfbacad5ce19656c5606728da)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/s390/crypto/ap_bus.c
diff --cc drivers/s390/crypto/ap_bus.c
index 8f97606e23f2,fdf16cb70881..000000000000
--- a/drivers/s390/crypto/ap_bus.c
+++ b/drivers/s390/crypto/ap_bus.c
@@@ -1664,11 -1740,11 +1665,12 @@@ static inline void ap_scan_domains(stru
  			continue;
  		}
  		/* domain is valid, get info from this APQN */
- 		if (!ap_queue_info(qid, &type, &func, &depth, &ml, &decfg)) {
+ 		if (!ap_queue_info(qid, &type, &func, &depth,
+ 				   &ml, &decfg, &chkstop)) {
  			if (aq) {
 -				AP_DBF_INFO("%s(%d,%d) queue_info() failed, rm queue dev\n",
 -					    __func__, ac->id, dom);
 +				AP_DBF_INFO(
 +					"%s(%d,%d) ap_queue_info() not successful, rm queue device\n",
 +					__func__, ac->id, dom);
  				device_unregister(dev);
  				put_device(dev);
  			}
@@@ -1698,10 -1775,13 +1701,13 @@@
  			/* get it and thus adjust reference counter */
  			get_device(dev);
  			if (decfg)
 -				AP_DBF_INFO("%s(%d,%d) new (decfg) queue dev created\n",
 +				AP_DBF_INFO("%s(%d,%d) new (decfg) queue device created\n",
  					    __func__, ac->id, dom);
+ 			else if (chkstop)
+ 				AP_DBF_INFO("%s(%d,%d) new (chkstop) queue dev created\n",
+ 					    __func__, ac->id, dom);
  			else
 -				AP_DBF_INFO("%s(%d,%d) new queue dev created\n",
 +				AP_DBF_INFO("%s(%d,%d) new queue device created\n",
  					    __func__, ac->id, dom);
  			goto put_dev_and_continue;
  		}
@@@ -1715,8 -1822,8 +1748,13 @@@
  				aq->last_err_rc = AP_RESPONSE_DECONFIGURED;
  			}
  			spin_unlock_bh(&aq->lock);
++<<<<<<< HEAD
 +			AP_DBF_INFO("%s(%d,%d) queue device config off\n",
 +				    __func__, ac->id, dom);
++=======
+ 			AP_DBF_DBG("%s(%d,%d) queue dev config off\n",
+ 				   __func__, ac->id, dom);
++>>>>>>> a7e701dba123 (s390/zcrypt: handle checkstopped cards with new state)
  			ap_send_config_uevent(&aq->ap_dev, aq->config);
  			/* 'receive' pending messages with -EAGAIN */
  			ap_flush_queue(aq);
@@@ -1730,8 -1836,8 +1767,13 @@@
  				aq->sm_state = AP_SM_STATE_RESET_START;
  			}
  			spin_unlock_bh(&aq->lock);
++<<<<<<< HEAD
 +			AP_DBF_INFO("%s(%d,%d) queue device config on\n",
 +				    __func__, ac->id, dom);
++=======
+ 			AP_DBF_DBG("%s(%d,%d) queue dev config on\n",
+ 				   __func__, ac->id, dom);
++>>>>>>> a7e701dba123 (s390/zcrypt: handle checkstopped cards with new state)
  			ap_send_config_uevent(&aq->ap_dev, aq->config);
  			goto put_dev_and_continue;
  		}
@@@ -1839,15 -1944,27 +1881,27 @@@ static inline void ap_scan_adapter(int 
  			put_device(dev);
  			ac = NULL;
  		} else {
+ 			/* handle checkstop state change */
+ 			if (chkstop && !ac->chkstop) {
+ 				/* checkstop on */
+ 				ac->chkstop = true;
+ 				AP_DBF_INFO("%s(%d) card dev checkstop on\n",
+ 					    __func__, ap);
+ 			} else if (!chkstop && ac->chkstop) {
+ 				/* checkstop off */
+ 				ac->chkstop = false;
+ 				AP_DBF_INFO("%s(%d) card dev checkstop off\n",
+ 					    __func__, ap);
+ 			}
+ 			/* handle config state change */
  			if (decfg && ac->config) {
  				ac->config = false;
 -				AP_DBF_INFO("%s(%d) card dev config off\n",
 +				AP_DBF_INFO("%s(%d) card device config off\n",
  					    __func__, ap);
  				ap_send_config_uevent(&ac->ap_dev, ac->config);
- 			}
- 			if (!decfg && !ac->config) {
+ 			} else if (!decfg && !ac->config) {
  				ac->config = true;
 -				AP_DBF_INFO("%s(%d) card dev config on\n",
 +				AP_DBF_INFO("%s(%d) card device config on\n",
  					    __func__, ap);
  				ap_send_config_uevent(&ac->ap_dev, ac->config);
  			}
@@@ -1890,10 -2009,13 +1945,13 @@@
  		/* get it and thus adjust reference counter */
  		get_device(dev);
  		if (decfg)
 -			AP_DBF_INFO("%s(%d) new (decfg) card dev type=%d func=0x%08x created\n",
 +			AP_DBF_INFO("%s(%d) new (decfg) card device type=%d func=0x%08x created\n",
  				    __func__, ap, type, func);
+ 		else if (chkstop)
+ 			AP_DBF_INFO("%s(%d) new (chkstop) card dev type=%d func=0x%08x created\n",
+ 				    __func__, ap, type, func);
  		else
 -			AP_DBF_INFO("%s(%d) new card dev type=%d func=0x%08x created\n",
 +			AP_DBF_INFO("%s(%d) new card device type=%d func=0x%08x created\n",
  				    __func__, ap, type, func);
  	}
  
* Unmerged path drivers/s390/crypto/ap_bus.c
diff --git a/drivers/s390/crypto/ap_bus.h b/drivers/s390/crypto/ap_bus.h
index 5ee06be1d3b0..22e300005196 100644
--- a/drivers/s390/crypto/ap_bus.h
+++ b/drivers/s390/crypto/ap_bus.h
@@ -175,6 +175,7 @@ struct ap_card {
 	int id;				/* AP card number. */
 	unsigned int maxmsgsize;	/* AP msg limit for this card */
 	bool config;			/* configured state */
+	bool chkstop;			/* checkstop state */
 	atomic64_t total_request_count;	/* # requests ever for this AP device.*/
 };
 
@@ -188,6 +189,7 @@ struct ap_queue {
 	void *private;			/* ap driver private pointer. */
 	enum ap_dev_state dev_state;	/* queue device state */
 	bool config;			/* configured state */
+	bool chkstop;			/* checkstop state */
 	ap_qid_t qid;			/* AP queue id. */
 	int interrupt;			/* indicate if interrupts are enabled */
 	int queue_count;		/* # messages currently on AP queue. */
diff --git a/drivers/s390/crypto/ap_card.c b/drivers/s390/crypto/ap_card.c
index 196325a66662..6b2170cf186e 100644
--- a/drivers/s390/crypto/ap_card.c
+++ b/drivers/s390/crypto/ap_card.c
@@ -174,6 +174,16 @@ static ssize_t config_store(struct device *dev,
 
 static DEVICE_ATTR_RW(config);
 
+static ssize_t chkstop_show(struct device *dev,
+			    struct device_attribute *attr, char *buf)
+{
+	struct ap_card *ac = to_ap_card(dev);
+
+	return scnprintf(buf, PAGE_SIZE, "%d\n", ac->chkstop ? 1 : 0);
+}
+
+static DEVICE_ATTR_RO(chkstop);
+
 static ssize_t max_msg_size_show(struct device *dev,
 				 struct device_attribute *attr, char *buf)
 {
@@ -194,6 +204,7 @@ static struct attribute *ap_card_dev_attrs[] = {
 	&dev_attr_pendingq_count.attr,
 	&dev_attr_modalias.attr,
 	&dev_attr_config.attr,
+	&dev_attr_chkstop.attr,
 	&dev_attr_max_msg_size.attr,
 	NULL
 };
diff --git a/drivers/s390/crypto/ap_queue.c b/drivers/s390/crypto/ap_queue.c
index a100abb4a2d6..26e892417711 100644
--- a/drivers/s390/crypto/ap_queue.c
+++ b/drivers/s390/crypto/ap_queue.c
@@ -459,7 +459,8 @@ static ap_func_t *ap_jumptable[NR_AP_SM_STATES][NR_AP_SM_EVENTS] = {
 
 enum ap_sm_wait ap_sm_event(struct ap_queue *aq, enum ap_sm_event event)
 {
-	if (aq->config && aq->dev_state > AP_DEV_STATE_UNINITIATED)
+	if (aq->config && !aq->chkstop &&
+	    aq->dev_state > AP_DEV_STATE_UNINITIATED)
 		return ap_jumptable[aq->sm_state][event](aq);
 	else
 		return AP_SM_WAIT_NONE;
@@ -641,6 +642,20 @@ static ssize_t config_show(struct device *dev,
 
 static DEVICE_ATTR_RO(config);
 
+static ssize_t chkstop_show(struct device *dev,
+			    struct device_attribute *attr, char *buf)
+{
+	struct ap_queue *aq = to_ap_queue(dev);
+	int rc;
+
+	spin_lock_bh(&aq->lock);
+	rc = scnprintf(buf, PAGE_SIZE, "%d\n", aq->chkstop ? 1 : 0);
+	spin_unlock_bh(&aq->lock);
+	return rc;
+}
+
+static DEVICE_ATTR_RO(chkstop);
+
 #ifdef CONFIG_ZCRYPT_DEBUG
 static ssize_t states_show(struct device *dev,
 			   struct device_attribute *attr, char *buf)
@@ -755,6 +770,7 @@ static struct attribute *ap_queue_dev_attrs[] = {
 	&dev_attr_reset.attr,
 	&dev_attr_interrupt.attr,
 	&dev_attr_config.attr,
+	&dev_attr_chkstop.attr,
 #ifdef CONFIG_ZCRYPT_DEBUG
 	&dev_attr_states.attr,
 	&dev_attr_last_err_rc.attr,
diff --git a/drivers/s390/crypto/zcrypt_api.c b/drivers/s390/crypto/zcrypt_api.c
index 41beb6a25160..a9ed440cb8f6 100644
--- a/drivers/s390/crypto/zcrypt_api.c
+++ b/drivers/s390/crypto/zcrypt_api.c
@@ -674,7 +674,7 @@ static long zcrypt_rsa_modexpo(struct ap_perms *perms,
 	spin_lock(&zcrypt_list_lock);
 	for_each_zcrypt_card(zc) {
 		/* Check for useable accelarator or CCA card */
-		if (!zc->online || !zc->card->config ||
+		if (!zc->online || !zc->card->config || zc->card->chkstop ||
 		    !(zc->card->functions & 0x18000000))
 			continue;
 		/* Check for size limits */
@@ -695,7 +695,7 @@ static long zcrypt_rsa_modexpo(struct ap_perms *perms,
 		for_each_zcrypt_queue(zq, zc) {
 			/* check if device is useable and eligible */
 			if (!zq->online || !zq->ops->rsa_modexpo ||
-			    !zq->queue->config)
+			    !zq->queue->config || zq->queue->chkstop)
 				continue;
 			/* check if device node has admission for this queue */
 			if (!zcrypt_check_queue(perms,
@@ -784,7 +784,7 @@ static long zcrypt_rsa_crt(struct ap_perms *perms,
 	spin_lock(&zcrypt_list_lock);
 	for_each_zcrypt_card(zc) {
 		/* Check for useable accelarator or CCA card */
-		if (!zc->online || !zc->card->config ||
+		if (!zc->online || !zc->card->config || zc->card->chkstop ||
 		    !(zc->card->functions & 0x18000000))
 			continue;
 		/* Check for size limits */
@@ -805,7 +805,7 @@ static long zcrypt_rsa_crt(struct ap_perms *perms,
 		for_each_zcrypt_queue(zq, zc) {
 			/* check if device is useable and eligible */
 			if (!zq->online || !zq->ops->rsa_modexpo_crt ||
-			    !zq->queue->config)
+			    !zq->queue->config || zq->queue->chkstop)
 				continue;
 			/* check if device node has admission for this queue */
 			if (!zcrypt_check_queue(perms,
@@ -899,7 +899,7 @@ static long _zcrypt_send_cprb(bool userspace, struct ap_perms *perms,
 	spin_lock(&zcrypt_list_lock);
 	for_each_zcrypt_card(zc) {
 		/* Check for useable CCA card */
-		if (!zc->online || !zc->card->config ||
+		if (!zc->online || !zc->card->config || zc->card->chkstop ||
 		    !(zc->card->functions & 0x10000000))
 			continue;
 		/* Check for user selected CCA card */
@@ -922,9 +922,8 @@ static long _zcrypt_send_cprb(bool userspace, struct ap_perms *perms,
 			continue;
 		for_each_zcrypt_queue(zq, zc) {
 			/* check for device useable and eligible */
-			if (!zq->online ||
-			    !zq->ops->send_cprb ||
-			    !zq->queue->config ||
+			if (!zq->online || !zq->ops->send_cprb ||
+			    !zq->queue->config || zq->queue->chkstop ||
 			    (tdom != AUTOSEL_DOM &&
 			     tdom != AP_QID_QUEUE(zq->queue->qid)))
 				continue;
@@ -1072,7 +1071,7 @@ static long _zcrypt_send_ep11_cprb(bool userspace, struct ap_perms *perms,
 	spin_lock(&zcrypt_list_lock);
 	for_each_zcrypt_card(zc) {
 		/* Check for useable EP11 card */
-		if (!zc->online || !zc->card->config ||
+		if (!zc->online || !zc->card->config || zc->card->chkstop ||
 		    !(zc->card->functions & 0x04000000))
 			continue;
 		/* Check for user selected EP11 card */
@@ -1095,9 +1094,8 @@ static long _zcrypt_send_ep11_cprb(bool userspace, struct ap_perms *perms,
 			continue;
 		for_each_zcrypt_queue(zq, zc) {
 			/* check if device is useable and eligible */
-			if (!zq->online ||
-			    !zq->ops->send_ep11_cprb ||
-			    !zq->queue->config ||
+			if (!zq->online || !zq->ops->send_ep11_cprb ||
+			    !zq->queue->config || zq->queue->chkstop ||
 			    (targets &&
 			     !is_desired_ep11_queue(zq->queue->qid,
 						    target_num, targets)))
@@ -1186,7 +1184,7 @@ static long zcrypt_rng(char *buffer)
 	spin_lock(&zcrypt_list_lock);
 	for_each_zcrypt_card(zc) {
 		/* Check for useable CCA card */
-		if (!zc->online || !zc->card->config ||
+		if (!zc->online || !zc->card->config || zc->card->chkstop ||
 		    !(zc->card->functions & 0x10000000))
 			continue;
 		/* get weight index of the card device	*/
@@ -1196,7 +1194,7 @@ static long zcrypt_rng(char *buffer)
 		for_each_zcrypt_queue(zq, zc) {
 			/* check if device is useable and eligible */
 			if (!zq->online || !zq->ops->rng ||
-			    !zq->queue->config)
+			    !zq->queue->config || zq->queue->chkstop)
 				continue;
 			if (!zcrypt_queue_compare(zq, pref_zq, wgt, pref_wgt))
 				continue;
