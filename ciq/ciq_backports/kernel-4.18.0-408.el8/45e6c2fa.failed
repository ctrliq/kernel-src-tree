KVM: x86: extract KVM_GET_CLOCK/KVM_SET_CLOCK to separate functions

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Paolo Bonzini <pbonzini@redhat.com>
commit 45e6c2fac097b4a3f72db339714a4dd6d789b81b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/45e6c2fa.failed

No functional change intended.

	Reviewed-by: Marcelo Tosatti <mtosatti@redhat.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 45e6c2fac097b4a3f72db339714a4dd6d789b81b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/x86.c
diff --cc arch/x86/kvm/x86.c
index 87d165bd834e,ed86e437d707..000000000000
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@@ -6256,60 -6108,12 +6304,52 @@@ set_pit2_out
  		break;
  	}
  #endif
++<<<<<<< HEAD
 +	case KVM_SET_CLOCK: {
 +		struct kvm_arch *ka = &kvm->arch;
 +		struct kvm_clock_data user_ns;
 +		u64 now_ns;
 +
 +		r = -EFAULT;
 +		if (copy_from_user(&user_ns, argp, sizeof(user_ns)))
 +			goto out;
 +
 +		r = -EINVAL;
 +		if (user_ns.flags)
 +			goto out;
 +
 +		r = 0;
 +		/*
 +		 * TODO: userspace has to take care of races with VCPU_RUN, so
 +		 * kvm_gen_update_masterclock() can be cut down to locked
 +		 * pvclock_update_vm_gtod_copy().
 +		 */
 +		kvm_gen_update_masterclock(kvm);
 +
 +		/*
 +		 * This pairs with kvm_guest_time_update(): when masterclock is
 +		 * in use, we use master_kernel_ns + kvmclock_offset to set
 +		 * unsigned 'system_time' so if we use get_kvmclock_ns() (which
 +		 * is slightly ahead) here we risk going negative on unsigned
 +		 * 'system_time' when 'user_ns.clock' is very small.
 +		 */
 +		raw_spin_lock_irq(&ka->pvclock_gtod_sync_lock);
 +		if (kvm->arch.use_master_clock)
 +			now_ns = ka->master_kernel_ns;
 +		else
 +			now_ns = get_kvmclock_base_ns();
 +		ka->kvmclock_offset = user_ns.clock - now_ns;
 +		raw_spin_unlock_irq(&ka->pvclock_gtod_sync_lock);
 +
 +		kvm_make_all_cpus_request(kvm, KVM_REQ_CLOCK_UPDATE);
++=======
+ 	case KVM_SET_CLOCK:
+ 		r = kvm_vm_ioctl_set_clock(kvm, argp);
++>>>>>>> 45e6c2fac097 (KVM: x86: extract KVM_GET_CLOCK/KVM_SET_CLOCK to separate functions)
  		break;
- 	}
- 	case KVM_GET_CLOCK: {
- 		struct kvm_clock_data user_ns;
- 		u64 now_ns;
- 
- 		now_ns = get_kvmclock_ns(kvm);
- 		user_ns.clock = now_ns;
- 		user_ns.flags = kvm->arch.use_master_clock ? KVM_CLOCK_TSC_STABLE : 0;
- 		memset(&user_ns.pad, 0, sizeof(user_ns.pad));
- 
- 		r = -EFAULT;
- 		if (copy_to_user(argp, &user_ns, sizeof(user_ns)))
- 			goto out;
- 		r = 0;
+ 	case KVM_GET_CLOCK:
+ 		r = kvm_vm_ioctl_get_clock(kvm, argp);
  		break;
- 	}
  	case KVM_MEMORY_ENCRYPT_OP: {
  		r = -ENOTTY;
  		if (kvm_x86_ops.mem_enc_op)
* Unmerged path arch/x86/kvm/x86.c
