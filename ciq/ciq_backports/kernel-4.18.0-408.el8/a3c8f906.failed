platform/x86/intel: Move intel_pmt from MFD to Auxiliary Bus

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author David E. Box <david.e.box@linux.intel.com>
commit a3c8f906ed5fc1d4895b5e1a5c6ad6e942d6c0ca
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/a3c8f906.failed

Intel Platform Monitoring Technology (PMT) support is indicated by presence
of an Intel defined PCIe Designated Vendor Specific Extended Capabilities
(DVSEC) structure with a PMT specific ID. The current MFD implementation
creates child devices for each PMT feature, currently telemetry, watcher,
and crashlog. However DVSEC structures may also be used by Intel to
indicate support for other features. The Out Of Band Management Services
Module (OOBMSM) uses DVSEC to enumerate several features, including PMT.
In order to support them it is necessary to modify the intel_pmt driver to
handle the creation of the child devices more generically. To that end,
modify the driver to create child devices for any VSEC/DVSEC features on
supported devices (indicated by PCI ID).  Additionally, move the
implementation from MFD to the Auxiliary bus.  VSEC/DVSEC features are
really multifunctional PCI devices, not platform devices as MFD was
designed for. Auxiliary bus gives more flexibility by allowing the
definition of custom structures that can be shared between associated
auxiliary devices and the parent device. Also, rename the driver from
intel_pmt to intel_vsec to better reflect the purpose.

This series also removes the current runtime pm support which was not
complete to begin with. None of the current devices require runtime pm.
However the support will be replaced when a device is added that requires
it.

	Reviewed-by: Mark Gross <markgross@kernel.org>
	Acked-by: Hans de Goede <hdegoede@redhat.com>
	Signed-off-by: David E. Box <david.e.box@linux.intel.com>
Link: https://lore.kernel.org/r/20211208015015.891275-4-david.e.box@linux.intel.com
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit a3c8f906ed5fc1d4895b5e1a5c6ad6e942d6c0ca)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	MAINTAINERS
#	drivers/mfd/Kconfig
#	drivers/mfd/Makefile
#	drivers/platform/x86/intel/Kconfig
#	drivers/platform/x86/intel/Makefile
#	drivers/platform/x86/intel/pmt/Kconfig
#	drivers/platform/x86/intel_pmt_class.c
#	drivers/platform/x86/intel_pmt_crashlog.c
#	drivers/platform/x86/intel_pmt_telemetry.c
diff --cc MAINTAINERS
index daede1a933b0,ea919889075f..000000000000
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@@ -7550,20 -9729,22 +7550,27 @@@ S:	Maintaine
  F:	Documentation/ABI/testing/sysfs-platform-intel-pmc
  F:	drivers/platform/x86/intel/pmc/
  
 -INTEL PMIC GPIO DRIVERS
 -M:	Andy Shevchenko <andy@kernel.org>
 +INTEL PMC/P-Unit IPC DRIVER
 +M:	Zha Qipeng<qipeng.zha@intel.com>
 +L:	platform-driver-x86@vger.kernel.org
  S:	Maintained
 -T:	git git://git.kernel.org/pub/scm/linux/kernel/git/andy/linux-gpio-intel.git
 -F:	drivers/gpio/gpio-*cove.c
 +F:	arch/x86/include/asm/intel_pmc_ipc.h
 +F:	arch/x86/include/asm/intel_punit_ipc.h
 +F:	drivers/platform/x86/intel_pmc_ipc.c
 +F:	drivers/platform/x86/intel_punit_ipc.c
  
 -INTEL PMIC MULTIFUNCTION DEVICE DRIVERS
 -M:	Andy Shevchenko <andy@kernel.org>
++<<<<<<< HEAD
 +INTEL PMT DRIVER
 +M:	"David E. Box" <david.e.box@linux.intel.com>
  S:	Maintained
 -F:	drivers/mfd/intel_soc_pmic*
 -F:	include/linux/mfd/intel_soc_pmic*
 -
 +F:	drivers/mfd/intel_pmt.c
 +F:	drivers/platform/x86/intel_pmt_*
++=======
+ INTEL PMT DRIVERS
+ M:	David E. Box <david.e.box@linux.intel.com>
+ S:	Supported
+ F:	drivers/platform/x86/intel/pmt/
++>>>>>>> a3c8f906ed5f (platform/x86/intel: Move intel_pmt from MFD to Auxiliary Bus)
  
  INTEL PRO/WIRELESS 2100, 2200BG, 2915ABG NETWORK CONNECTION SUPPORT
  M:	Stanislav Yakovlev <stas.yakovlev@gmail.com>
@@@ -7585,6 -9766,111 +7592,114 @@@ M:	Jarkko Nikula <jarkko.nikula@linux.i
  L:	linux-iio@vger.kernel.org
  F:	drivers/counter/intel-qep.c
  
++<<<<<<< HEAD
++=======
+ INTEL SCU DRIVERS
+ M:	Mika Westerberg <mika.westerberg@linux.intel.com>
+ S:	Maintained
+ F:	arch/x86/include/asm/intel_scu_ipc.h
+ F:	drivers/platform/x86/intel_scu_*
+ 
+ INTEL SKYLAKE INT3472 ACPI DEVICE DRIVER
+ M:	Daniel Scally <djrscally@gmail.com>
+ S:	Maintained
+ F:	drivers/platform/x86/intel/int3472/
+ 
+ INTEL SPEED SELECT TECHNOLOGY
+ M:	Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
+ L:	platform-driver-x86@vger.kernel.org
+ S:	Maintained
+ F:	drivers/platform/x86/intel/speed_select_if/
+ F:	include/uapi/linux/isst_if.h
+ F:	tools/power/x86/intel-speed-select/
+ 
+ INTEL STRATIX10 FIRMWARE DRIVERS
+ M:	Dinh Nguyen <dinguyen@kernel.org>
+ L:	linux-kernel@vger.kernel.org
+ S:	Maintained
+ F:	Documentation/ABI/testing/sysfs-devices-platform-stratix10-rsu
+ F:	Documentation/devicetree/bindings/firmware/intel,stratix10-svc.txt
+ F:	drivers/firmware/stratix10-rsu.c
+ F:	drivers/firmware/stratix10-svc.c
+ F:	include/linux/firmware/intel/stratix10-smc.h
+ F:	include/linux/firmware/intel/stratix10-svc-client.h
+ 
+ INTEL TELEMETRY DRIVER
+ M:	Rajneesh Bhardwaj <irenic.rajneesh@gmail.com>
+ M:	"David E. Box" <david.e.box@linux.intel.com>
+ L:	platform-driver-x86@vger.kernel.org
+ S:	Maintained
+ F:	arch/x86/include/asm/intel_telemetry.h
+ F:	drivers/platform/x86/intel/telemetry/
+ 
+ INTEL UNCORE FREQUENCY CONTROL
+ M:	Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
+ L:	platform-driver-x86@vger.kernel.org
+ S:	Maintained
+ F:	drivers/platform/x86/intel/uncore-frequency.c
+ 
+ INTEL VENDOR SPECIFIC EXTENDED CAPABILITIES DRIVER
+ M:	David E. Box <david.e.box@linux.intel.com>
+ S:	Supported
+ F:	drivers/platform/x86/intel/vsec.*
+ 
+ INTEL VIRTUAL BUTTON DRIVER
+ M:	AceLan Kao <acelan.kao@canonical.com>
+ L:	platform-driver-x86@vger.kernel.org
+ S:	Maintained
+ F:	drivers/platform/x86/intel/vbtn.c
+ 
+ INTEL WIRELESS 3945ABG/BG, 4965AGN (iwlegacy)
+ M:	Stanislaw Gruszka <stf_xl@wp.pl>
+ L:	linux-wireless@vger.kernel.org
+ S:	Supported
+ F:	drivers/net/wireless/intel/iwlegacy/
+ 
+ INTEL WIRELESS WIFI LINK (iwlwifi)
+ M:	Luca Coelho <luciano.coelho@intel.com>
+ L:	linux-wireless@vger.kernel.org
+ S:	Supported
+ W:	https://wireless.wiki.kernel.org/en/users/drivers/iwlwifi
+ T:	git git://git.kernel.org/pub/scm/linux/kernel/git/iwlwifi/iwlwifi.git
+ F:	drivers/net/wireless/intel/iwlwifi/
+ 
+ INTEL WMI SLIM BOOTLOADER (SBL) FIRMWARE UPDATE DRIVER
+ M:	Jithu Joseph <jithu.joseph@intel.com>
+ R:	Maurice Ma <maurice.ma@intel.com>
+ S:	Maintained
+ W:	https://slimbootloader.github.io/security/firmware-update.html
+ F:	drivers/platform/x86/intel/wmi/sbl-fw-update.c
+ 
+ INTEL WMI THUNDERBOLT FORCE POWER DRIVER
+ L:	Dell.Client.Kernel@dell.com
+ S:	Maintained
+ F:	drivers/platform/x86/intel/wmi/thunderbolt.c
+ 
+ INTEL WWAN IOSM DRIVER
+ M:	M Chetan Kumar <m.chetan.kumar@intel.com>
+ M:	Intel Corporation <linuxwwan@intel.com>
+ L:	netdev@vger.kernel.org
+ S:	Maintained
+ F:	drivers/net/wwan/iosm/
+ 
+ INTEL(R) TRACE HUB
+ M:	Alexander Shishkin <alexander.shishkin@linux.intel.com>
+ S:	Supported
+ F:	Documentation/trace/intel_th.rst
+ F:	drivers/hwtracing/intel_th/
+ F:	include/linux/intel_th.h
+ 
+ INTEL(R) TRUSTED EXECUTION TECHNOLOGY (TXT)
+ M:	Ning Sun <ning.sun@intel.com>
+ L:	tboot-devel@lists.sourceforge.net
+ S:	Supported
+ W:	http://tboot.sourceforge.net
+ T:	hg http://tboot.hg.sourceforge.net:8000/hgroot/tboot/tboot
+ F:	Documentation/x86/intel_txt.rst
+ F:	arch/x86/kernel/tboot.c
+ F:	include/linux/tboot.h
+ 
++>>>>>>> a3c8f906ed5f (platform/x86/intel: Move intel_pmt from MFD to Auxiliary Bus)
  INTEL SGX
  M:	Jarkko Sakkinen <jarkko@kernel.org>
  R:	Dave Hansen <dave.hansen@linux.intel.com>
diff --cc drivers/mfd/Kconfig
index 6b9916e54fa0,ac7b23eb62c2..000000000000
--- a/drivers/mfd/Kconfig
+++ b/drivers/mfd/Kconfig
@@@ -536,25 -678,20 +536,28 @@@ config MFD_INTEL_LPSS_PC
  	  I2C, SPI and HS-UART starting from Intel Sunrisepoint (Intel Skylake
  	  PCH) in PCI mode.
  
 -config MFD_INTEL_PMC_BXT
 -	tristate "Intel PMC Driver for Broxton"
 -	depends on X86
 -	depends on X86_PLATFORM_DEVICES
 -	depends on ACPI
 -	select INTEL_SCU_IPC
 +config MFD_INTEL_MSIC
 +	bool "Intel MSIC"
 +	depends on INTEL_SCU_IPC
 +	select MFD_CORE
 +	help
 +	  Select this option to enable access to Intel MSIC (Avatele
 +	  Passage) chip. This chip embeds audio, battery, GPIO, etc.
 +	  devices used in Intel Medfield platforms.
 +
++<<<<<<< HEAD
 +config MFD_INTEL_PMT
 +	tristate "Intel Platform Monitoring Technology (PMT) support"
 +	depends on PCI
  	select MFD_CORE
  	help
 -	  This driver provides support for the PMC (Power Management
 -	  Controller) on Intel Broxton and Apollo Lake. The PMC is a
 -	  multi-function device that exposes IPC, General Control
 -	  Register and P-unit access. In addition this creates devices
 -	  for iTCO watchdog and telemetry that are part of the PMC.
 +	  The Intel Platform Monitoring Technology (PMT) is an interface that
 +	  provides access to hardware monitor registers. This driver supports
 +	  Telemetry, Watcher, and Crashlog PMT capabilities/devices for
 +	  platforms starting from Tiger Lake.
  
++=======
++>>>>>>> a3c8f906ed5f (platform/x86/intel: Move intel_pmt from MFD to Auxiliary Bus)
  config MFD_IPAQ_MICRO
  	bool "Atmel Micro ASIC (iPAQ h3100/h3600/h3700) Support"
  	depends on SA1100_H3100 || SA1100_H3600
diff --cc drivers/mfd/Makefile
index ef7fec892904,31734d9318e2..000000000000
--- a/drivers/mfd/Makefile
+++ b/drivers/mfd/Makefile
@@@ -189,10 -210,10 +189,14 @@@ obj-$(CONFIG_MFD_ATMEL_SMC)	+= atmel-sm
  obj-$(CONFIG_MFD_INTEL_LPSS)	+= intel-lpss.o
  obj-$(CONFIG_MFD_INTEL_LPSS_PCI)	+= intel-lpss-pci.o
  obj-$(CONFIG_MFD_INTEL_LPSS_ACPI)	+= intel-lpss-acpi.o
++<<<<<<< HEAD
 +obj-$(CONFIG_MFD_INTEL_MSIC)	+= intel_msic.o
 +obj-$(CONFIG_MFD_INTEL_PMT)	+= intel_pmt.o
++=======
+ obj-$(CONFIG_MFD_INTEL_PMC_BXT)	+= intel_pmc_bxt.o
++>>>>>>> a3c8f906ed5f (platform/x86/intel: Move intel_pmt from MFD to Auxiliary Bus)
  obj-$(CONFIG_MFD_PALMAS)	+= palmas.o
  obj-$(CONFIG_MFD_VIPERBOARD)    += viperboard.o
 -obj-$(CONFIG_MFD_NTXEC)		+= ntxec.o
  obj-$(CONFIG_MFD_RC5T583)	+= rc5t583.o rc5t583-irq.o
  obj-$(CONFIG_MFD_RK808)		+= rk808.o
  obj-$(CONFIG_MFD_RN5T618)	+= rn5t618.o
diff --cc drivers/platform/x86/intel/Kconfig
index 1a3496800567,35a5d1a5eba8..000000000000
--- a/drivers/platform/x86/intel/Kconfig
+++ b/drivers/platform/x86/intel/Kconfig
@@@ -33,4 -118,81 +33,84 @@@ config INTEL_ISHTP_ECLIT
  	  To compile this driver as a module, choose M here: the module
  	  will be called intel_ishtp_eclite.
  
++<<<<<<< HEAD
++=======
+ config INTEL_MRFLD_PWRBTN
+ 	tristate "Intel Merrifield Basin Cove power button driver"
+ 	depends on INTEL_SOC_PMIC_MRFLD
+ 	depends on INPUT
+ 	help
+ 	  This option adds a power button driver for Basin Cove PMIC
+ 	  on Intel Merrifield devices.
+ 
+ 	  To compile this driver as a module, choose M here: the module
+ 	  will be called intel_mrfld_pwrbtn.
+ 
+ config INTEL_PUNIT_IPC
+ 	tristate "Intel P-Unit IPC Driver"
+ 	help
+ 	  This driver provides support for Intel P-Unit Mailbox IPC mechanism,
+ 	  which is used to bridge the communications between kernel and P-Unit.
+ 
+ config INTEL_RST
+ 	tristate "Intel Rapid Start Technology Driver"
+ 	depends on ACPI
+ 	help
+ 	  This driver provides support for modifying parameters on systems
+ 	  equipped with Intel's Rapid Start Technology. When put in an ACPI
+ 	  sleep state, these devices will wake after either a configured
+ 	  timeout or when the system battery reaches a critical state,
+ 	  automatically copying memory contents to disk. On resume, the
+ 	  firmware will copy the memory contents back to RAM and resume the OS
+ 	  as usual.
+ 
+ config INTEL_SMARTCONNECT
+ 	tristate "Intel Smart Connect disabling driver"
+ 	depends on ACPI
+ 	help
+ 	  Intel Smart Connect is a technology intended to permit devices to
+ 	  update state by resuming for a short period of time at regular
+ 	  intervals. If a user enables this functionality under Windows and
+ 	  then reboots into Linux, the system may remain configured to resume
+ 	  on suspend. In the absence of any userspace to support it, the system
+ 	  will then remain awake until something triggers another suspend.
+ 
+ 	  This driver checks to determine whether the device has Intel Smart
+ 	  Connect enabled, and if so disables it.
+ 
+ config INTEL_TURBO_MAX_3
+ 	bool "Intel Turbo Boost Max Technology 3.0 enumeration driver"
+ 	depends on X86_64 && SCHED_MC_PRIO
+ 	help
+ 	  This driver reads maximum performance ratio of each CPU and set up
+ 	  the scheduler priority metrics. In this way scheduler can prefer
+ 	  CPU with higher performance to schedule tasks.
+ 
+ 	  This driver is only required when the system is not using Hardware
+ 	  P-States (HWP). In HWP mode, priority can be read from ACPI tables.
+ 
+ config INTEL_UNCORE_FREQ_CONTROL
+ 	tristate "Intel Uncore frequency control driver"
+ 	depends on X86_64
+ 	help
+ 	  This driver allows control of Uncore frequency limits on
+ 	  supported server platforms.
+ 
+ 	  Uncore frequency controls RING/LLC (last-level cache) clocks.
+ 
+ 	  To compile this driver as a module, choose M here: the module
+ 	  will be called intel-uncore-frequency.
+ 
+ config INTEL_VSEC
+ 	tristate "Intel Vendor Specific Extended Capabilities Driver"
+ 	depends on PCI
+ 	select AUXILIARY_BUS
+ 	help
+ 	  Adds support for feature drivers exposed using Intel PCIe VSEC and
+ 	  DVSEC.
+ 
+ 	  To compile this driver as a module, choose M here: the module will
+ 	  be called intel_vsec.
+ 
++>>>>>>> a3c8f906ed5f (platform/x86/intel: Move intel_pmt from MFD to Auxiliary Bus)
  endif # X86_PLATFORM_DRIVERS_INTEL
diff --cc drivers/platform/x86/intel/Makefile
index 620d6c974a88,8ecdf709fb17..000000000000
--- a/drivers/platform/x86/intel/Makefile
+++ b/drivers/platform/x86/intel/Makefile
@@@ -7,3 -12,39 +7,32 @@@ obj-$(CONFIG_INTEL_PMC_CORE)		+= pmc
  
  # Intel miscellaneous drivers
  obj-$(CONFIG_INTEL_ISHTP_ECLITE)	+= ishtp_eclite.o
++<<<<<<< HEAD
++=======
+ intel_int0002_vgpio-y			:= int0002_vgpio.o
+ obj-$(CONFIG_INTEL_INT0002_VGPIO)	+= intel_int0002_vgpio.o
+ intel_oaktrail-y			:= oaktrail.o
+ obj-$(CONFIG_INTEL_OAKTRAIL)		+= intel_oaktrail.o
+ intel_vsec-y				:= vsec.o
+ obj-$(CONFIG_INTEL_VSEC)		+= intel_vsec.o
+ 
+ # Intel PMIC / PMC / P-Unit drivers
+ intel_bxtwc_tmu-y			:= bxtwc_tmu.o
+ obj-$(CONFIG_INTEL_BXTWC_PMIC_TMU)	+= intel_bxtwc_tmu.o
+ intel_chtdc_ti_pwrbtn-y			:= chtdc_ti_pwrbtn.o
+ obj-$(CONFIG_INTEL_CHTDC_TI_PWRBTN)	+= intel_chtdc_ti_pwrbtn.o
+ intel_mrfld_pwrbtn-y			:= mrfld_pwrbtn.o
+ obj-$(CONFIG_INTEL_MRFLD_PWRBTN)	+= intel_mrfld_pwrbtn.o
+ intel_punit_ipc-y			:= punit_ipc.o
+ obj-$(CONFIG_INTEL_PUNIT_IPC)		+= intel_punit_ipc.o
+ 
+ # Intel Uncore drivers
+ intel-rst-y				:= rst.o
+ obj-$(CONFIG_INTEL_RST)			+= intel-rst.o
+ intel-smartconnect-y			:= smartconnect.o
+ obj-$(CONFIG_INTEL_SMARTCONNECT)	+= intel-smartconnect.o
+ intel_turbo_max_3-y			:= turbo_max_3.o
+ obj-$(CONFIG_INTEL_TURBO_MAX_3)		+= intel_turbo_max_3.o
+ intel-uncore-frequency-y		:= uncore-frequency.o
+ obj-$(CONFIG_INTEL_UNCORE_FREQ_CONTROL)	+= intel-uncore-frequency.o
++>>>>>>> a3c8f906ed5f (platform/x86/intel: Move intel_pmt from MFD to Auxiliary Bus)
diff --cc drivers/platform/x86/intel_pmt_class.c
index c86ff15b1ed5,1c9e3f3ea41c..000000000000
--- a/drivers/platform/x86/intel_pmt_class.c
+++ b/drivers/platform/x86/intel_pmt_class.c
@@@ -13,7 -13,8 +13,12 @@@
  #include <linux/mm.h>
  #include <linux/pci.h>
  
++<<<<<<< HEAD:drivers/platform/x86/intel_pmt_class.c
 +#include "intel_pmt_class.h"
++=======
+ #include "../vsec.h"
+ #include "class.h"
++>>>>>>> a3c8f906ed5f (platform/x86/intel: Move intel_pmt from MFD to Auxiliary Bus):drivers/platform/x86/intel/pmt/class.c
  
  #define PMT_XA_START		0
  #define PMT_XA_MAX		INT_MAX
diff --cc drivers/platform/x86/intel_pmt_crashlog.c
index 92d315a16cfd,34daf9df168b..000000000000
--- a/drivers/platform/x86/intel_pmt_crashlog.c
+++ b/drivers/platform/x86/intel_pmt_crashlog.c
@@@ -15,9 -16,8 +16,12 @@@
  #include <linux/uaccess.h>
  #include <linux/overflow.h>
  
++<<<<<<< HEAD:drivers/platform/x86/intel_pmt_crashlog.c
 +#include "intel_pmt_class.h"
- 
- #define DRV_NAME		"pmt_crashlog"
++=======
+ #include "../vsec.h"
+ #include "class.h"
++>>>>>>> a3c8f906ed5f (platform/x86/intel: Move intel_pmt from MFD to Auxiliary Bus):drivers/platform/x86/intel/pmt/crashlog.c
  
  /* Crashlog discovery header types */
  #define CRASH_TYPE_OOBMSM	1
diff --cc drivers/platform/x86/intel_pmt_telemetry.c
index 9f845e70a1f8,6b6f3e2a617a..000000000000
--- a/drivers/platform/x86/intel_pmt_telemetry.c
+++ b/drivers/platform/x86/intel_pmt_telemetry.c
@@@ -15,9 -16,8 +16,12 @@@
  #include <linux/uaccess.h>
  #include <linux/overflow.h>
  
++<<<<<<< HEAD:drivers/platform/x86/intel_pmt_telemetry.c
 +#include "intel_pmt_class.h"
- 
- #define TELEM_DEV_NAME		"pmt_telemetry"
++=======
+ #include "../vsec.h"
+ #include "class.h"
++>>>>>>> a3c8f906ed5f (platform/x86/intel: Move intel_pmt from MFD to Auxiliary Bus):drivers/platform/x86/intel/pmt/telemetry.c
  
  #define TELEM_SIZE_OFFSET	0x0
  #define TELEM_GUID_OFFSET	0x4
* Unmerged path drivers/platform/x86/intel/pmt/Kconfig
* Unmerged path MAINTAINERS
* Unmerged path drivers/mfd/Kconfig
* Unmerged path drivers/mfd/Makefile
diff --git a/drivers/mfd/intel_pmt.c b/drivers/mfd/intel_pmt.c
deleted file mode 100644
index dd7eb614c28e..000000000000
--- a/drivers/mfd/intel_pmt.c
+++ /dev/null
@@ -1,261 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * Intel Platform Monitoring Technology PMT driver
- *
- * Copyright (c) 2020, Intel Corporation.
- * All Rights Reserved.
- *
- * Author: David E. Box <david.e.box@linux.intel.com>
- */
-
-#include <linux/bits.h>
-#include <linux/kernel.h>
-#include <linux/mfd/core.h>
-#include <linux/module.h>
-#include <linux/pci.h>
-#include <linux/platform_device.h>
-#include <linux/pm.h>
-#include <linux/pm_runtime.h>
-#include <linux/types.h>
-
-/* Intel DVSEC capability vendor space offsets */
-#define INTEL_DVSEC_ENTRIES		0xA
-#define INTEL_DVSEC_SIZE		0xB
-#define INTEL_DVSEC_TABLE		0xC
-#define INTEL_DVSEC_TABLE_BAR(x)	((x) & GENMASK(2, 0))
-#define INTEL_DVSEC_TABLE_OFFSET(x)	((x) & GENMASK(31, 3))
-#define INTEL_DVSEC_ENTRY_SIZE		4
-
-/* PMT capabilities */
-#define DVSEC_INTEL_ID_TELEMETRY	2
-#define DVSEC_INTEL_ID_WATCHER		3
-#define DVSEC_INTEL_ID_CRASHLOG		4
-
-struct intel_dvsec_header {
-	u16	length;
-	u16	id;
-	u8	num_entries;
-	u8	entry_size;
-	u8	tbir;
-	u32	offset;
-};
-
-enum pmt_quirks {
-	/* Watcher capability not supported */
-	PMT_QUIRK_NO_WATCHER	= BIT(0),
-
-	/* Crashlog capability not supported */
-	PMT_QUIRK_NO_CRASHLOG	= BIT(1),
-
-	/* Use shift instead of mask to read discovery table offset */
-	PMT_QUIRK_TABLE_SHIFT	= BIT(2),
-
-	/* DVSEC not present (provided in driver data) */
-	PMT_QUIRK_NO_DVSEC	= BIT(3),
-};
-
-struct pmt_platform_info {
-	unsigned long quirks;
-	struct intel_dvsec_header **capabilities;
-};
-
-static const struct pmt_platform_info tgl_info = {
-	.quirks = PMT_QUIRK_NO_WATCHER | PMT_QUIRK_NO_CRASHLOG |
-		  PMT_QUIRK_TABLE_SHIFT,
-};
-
-/* DG1 Platform with DVSEC quirk*/
-static struct intel_dvsec_header dg1_telemetry = {
-	.length = 0x10,
-	.id = 2,
-	.num_entries = 1,
-	.entry_size = 3,
-	.tbir = 0,
-	.offset = 0x466000,
-};
-
-static struct intel_dvsec_header *dg1_capabilities[] = {
-	&dg1_telemetry,
-	NULL
-};
-
-static const struct pmt_platform_info dg1_info = {
-	.quirks = PMT_QUIRK_NO_DVSEC,
-	.capabilities = dg1_capabilities,
-};
-
-static int pmt_add_dev(struct pci_dev *pdev, struct intel_dvsec_header *header,
-		       unsigned long quirks)
-{
-	struct device *dev = &pdev->dev;
-	struct resource *res, *tmp;
-	struct mfd_cell *cell;
-	const char *name;
-	int count = header->num_entries;
-	int size = header->entry_size;
-	int id = header->id;
-	int i;
-
-	switch (id) {
-	case DVSEC_INTEL_ID_TELEMETRY:
-		name = "pmt_telemetry";
-		break;
-	case DVSEC_INTEL_ID_WATCHER:
-		if (quirks & PMT_QUIRK_NO_WATCHER) {
-			dev_info(dev, "Watcher not supported\n");
-			return -EINVAL;
-		}
-		name = "pmt_watcher";
-		break;
-	case DVSEC_INTEL_ID_CRASHLOG:
-		if (quirks & PMT_QUIRK_NO_CRASHLOG) {
-			dev_info(dev, "Crashlog not supported\n");
-			return -EINVAL;
-		}
-		name = "pmt_crashlog";
-		break;
-	default:
-		return -EINVAL;
-	}
-
-	if (!header->num_entries || !header->entry_size) {
-		dev_err(dev, "Invalid count or size for %s header\n", name);
-		return -EINVAL;
-	}
-
-	cell = devm_kzalloc(dev, sizeof(*cell), GFP_KERNEL);
-	if (!cell)
-		return -ENOMEM;
-
-	res = devm_kcalloc(dev, count, sizeof(*res), GFP_KERNEL);
-	if (!res)
-		return -ENOMEM;
-
-	if (quirks & PMT_QUIRK_TABLE_SHIFT)
-		header->offset >>= 3;
-
-	/*
-	 * The PMT DVSEC contains the starting offset and count for a block of
-	 * discovery tables, each providing access to monitoring facilities for
-	 * a section of the device. Create a resource list of these tables to
-	 * provide to the driver.
-	 */
-	for (i = 0, tmp = res; i < count; i++, tmp++) {
-		tmp->start = pdev->resource[header->tbir].start +
-			     header->offset + i * (size << 2);
-		tmp->end = tmp->start + (size << 2) - 1;
-		tmp->flags = IORESOURCE_MEM;
-	}
-
-	cell->resources = res;
-	cell->num_resources = count;
-	cell->name = name;
-
-	return devm_mfd_add_devices(dev, PLATFORM_DEVID_AUTO, cell, 1, NULL, 0,
-				    NULL);
-}
-
-static int pmt_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)
-{
-	struct pmt_platform_info *info;
-	unsigned long quirks = 0;
-	bool found_devices = false;
-	int ret, pos = 0;
-
-	ret = pcim_enable_device(pdev);
-	if (ret)
-		return ret;
-
-	info = (struct pmt_platform_info *)id->driver_data;
-
-	if (info)
-		quirks = info->quirks;
-
-	if (info && (info->quirks & PMT_QUIRK_NO_DVSEC)) {
-		struct intel_dvsec_header **header;
-
-		header = info->capabilities;
-		while (*header) {
-			ret = pmt_add_dev(pdev, *header, quirks);
-			if (ret)
-				dev_warn(&pdev->dev,
-					 "Failed to add device for DVSEC id %d\n",
-					 (*header)->id);
-			else
-				found_devices = true;
-
-			++header;
-		}
-	} else {
-		do {
-			struct intel_dvsec_header header;
-			u32 table;
-			u16 vid;
-
-			pos = pci_find_next_ext_capability(pdev, pos, PCI_EXT_CAP_ID_DVSEC);
-			if (!pos)
-				break;
-
-			pci_read_config_word(pdev, pos + PCI_DVSEC_HEADER1, &vid);
-			if (vid != PCI_VENDOR_ID_INTEL)
-				continue;
-
-			pci_read_config_word(pdev, pos + PCI_DVSEC_HEADER2,
-					     &header.id);
-			pci_read_config_byte(pdev, pos + INTEL_DVSEC_ENTRIES,
-					     &header.num_entries);
-			pci_read_config_byte(pdev, pos + INTEL_DVSEC_SIZE,
-					     &header.entry_size);
-			pci_read_config_dword(pdev, pos + INTEL_DVSEC_TABLE,
-					      &table);
-
-			header.tbir = INTEL_DVSEC_TABLE_BAR(table);
-			header.offset = INTEL_DVSEC_TABLE_OFFSET(table);
-
-			ret = pmt_add_dev(pdev, &header, quirks);
-			if (ret)
-				continue;
-
-			found_devices = true;
-		} while (true);
-	}
-
-	if (!found_devices)
-		return -ENODEV;
-
-	pm_runtime_put(&pdev->dev);
-	pm_runtime_allow(&pdev->dev);
-
-	return 0;
-}
-
-static void pmt_pci_remove(struct pci_dev *pdev)
-{
-	pm_runtime_forbid(&pdev->dev);
-	pm_runtime_get_sync(&pdev->dev);
-}
-
-#define PCI_DEVICE_ID_INTEL_PMT_ADL	0x467d
-#define PCI_DEVICE_ID_INTEL_PMT_DG1	0x490e
-#define PCI_DEVICE_ID_INTEL_PMT_OOBMSM	0x09a7
-#define PCI_DEVICE_ID_INTEL_PMT_TGL	0x9a0d
-static const struct pci_device_id pmt_pci_ids[] = {
-	{ PCI_DEVICE_DATA(INTEL, PMT_ADL, &tgl_info) },
-	{ PCI_DEVICE_DATA(INTEL, PMT_DG1, &dg1_info) },
-	{ PCI_DEVICE_DATA(INTEL, PMT_OOBMSM, NULL) },
-	{ PCI_DEVICE_DATA(INTEL, PMT_TGL, &tgl_info) },
-	{ }
-};
-MODULE_DEVICE_TABLE(pci, pmt_pci_ids);
-
-static struct pci_driver pmt_pci_driver = {
-	.name = "intel-pmt",
-	.id_table = pmt_pci_ids,
-	.probe = pmt_pci_probe,
-	.remove = pmt_pci_remove,
-};
-module_pci_driver(pmt_pci_driver);
-
-MODULE_AUTHOR("David E. Box <david.e.box@linux.intel.com>");
-MODULE_DESCRIPTION("Intel Platform Monitoring Technology PMT driver");
-MODULE_LICENSE("GPL v2");
* Unmerged path drivers/platform/x86/intel/Kconfig
* Unmerged path drivers/platform/x86/intel/Makefile
* Unmerged path drivers/platform/x86/intel/pmt/Kconfig
diff --git a/drivers/platform/x86/intel/vsec.c b/drivers/platform/x86/intel/vsec.c
new file mode 100644
index 000000000000..c3bdd75ed690
--- /dev/null
+++ b/drivers/platform/x86/intel/vsec.c
@@ -0,0 +1,408 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Intel Vendor Specific Extended Capabilities auxiliary bus driver
+ *
+ * Copyright (c) 2021, Intel Corporation.
+ * All Rights Reserved.
+ *
+ * Author: David E. Box <david.e.box@linux.intel.com>
+ *
+ * This driver discovers and creates auxiliary devices for Intel defined PCIe
+ * "Vendor Specific" and "Designated Vendor Specific" Extended Capabilities,
+ * VSEC and DVSEC respectively. The driver supports features on specific PCIe
+ * endpoints that exist primarily to expose them.
+ */
+
+#include <linux/auxiliary_bus.h>
+#include <linux/bits.h>
+#include <linux/kernel.h>
+#include <linux/idr.h>
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/types.h>
+
+#include "vsec.h"
+
+/* Intel DVSEC offsets */
+#define INTEL_DVSEC_ENTRIES		0xA
+#define INTEL_DVSEC_SIZE		0xB
+#define INTEL_DVSEC_TABLE		0xC
+#define INTEL_DVSEC_TABLE_BAR(x)	((x) & GENMASK(2, 0))
+#define INTEL_DVSEC_TABLE_OFFSET(x)	((x) & GENMASK(31, 3))
+#define TABLE_OFFSET_SHIFT		3
+
+static DEFINE_IDA(intel_vsec_ida);
+
+/**
+ * struct intel_vsec_header - Common fields of Intel VSEC and DVSEC registers.
+ * @rev:         Revision ID of the VSEC/DVSEC register space
+ * @length:      Length of the VSEC/DVSEC register space
+ * @id:          ID of the feature
+ * @num_entries: Number of instances of the feature
+ * @entry_size:  Size of the discovery table for each feature
+ * @tbir:        BAR containing the discovery tables
+ * @offset:      BAR offset of start of the first discovery table
+ */
+struct intel_vsec_header {
+	u8	rev;
+	u16	length;
+	u16	id;
+	u8	num_entries;
+	u8	entry_size;
+	u8	tbir;
+	u32	offset;
+};
+
+/* Platform specific data */
+struct intel_vsec_platform_info {
+	struct intel_vsec_header **capabilities;
+	unsigned long quirks;
+};
+
+enum intel_vsec_id {
+	VSEC_ID_TELEMETRY	= 2,
+	VSEC_ID_WATCHER		= 3,
+	VSEC_ID_CRASHLOG	= 4,
+};
+
+static enum intel_vsec_id intel_vsec_allow_list[] = {
+	VSEC_ID_TELEMETRY,
+	VSEC_ID_WATCHER,
+	VSEC_ID_CRASHLOG,
+};
+
+static const char *intel_vsec_name(enum intel_vsec_id id)
+{
+	switch (id) {
+	case VSEC_ID_TELEMETRY:
+		return "telemetry";
+
+	case VSEC_ID_WATCHER:
+		return "watcher";
+
+	case VSEC_ID_CRASHLOG:
+		return "crashlog";
+
+	default:
+		return NULL;
+	}
+}
+
+static bool intel_vsec_allowed(u16 id)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(intel_vsec_allow_list); i++)
+		if (intel_vsec_allow_list[i] == id)
+			return true;
+
+	return false;
+}
+
+static bool intel_vsec_disabled(u16 id, unsigned long quirks)
+{
+	switch (id) {
+	case VSEC_ID_WATCHER:
+		return !!(quirks & VSEC_QUIRK_NO_WATCHER);
+
+	case VSEC_ID_CRASHLOG:
+		return !!(quirks & VSEC_QUIRK_NO_CRASHLOG);
+
+	default:
+		return false;
+	}
+}
+
+static void intel_vsec_remove_aux(void *data)
+{
+	auxiliary_device_delete(data);
+	auxiliary_device_uninit(data);
+}
+
+static void intel_vsec_dev_release(struct device *dev)
+{
+	struct intel_vsec_device *intel_vsec_dev = dev_to_ivdev(dev);
+
+	ida_free(intel_vsec_dev->ida, intel_vsec_dev->auxdev.id);
+	kfree(intel_vsec_dev->resource);
+	kfree(intel_vsec_dev);
+}
+
+static int intel_vsec_add_aux(struct pci_dev *pdev, struct intel_vsec_device *intel_vsec_dev,
+			      const char *name)
+{
+	struct auxiliary_device *auxdev = &intel_vsec_dev->auxdev;
+	int ret;
+
+	ret = ida_alloc(intel_vsec_dev->ida, GFP_KERNEL);
+	if (ret < 0) {
+		kfree(intel_vsec_dev);
+		return ret;
+	}
+
+	auxdev->id = ret;
+	auxdev->name = name;
+	auxdev->dev.parent = &pdev->dev;
+	auxdev->dev.release = intel_vsec_dev_release;
+
+	ret = auxiliary_device_init(auxdev);
+	if (ret < 0) {
+		ida_free(intel_vsec_dev->ida, auxdev->id);
+		kfree(intel_vsec_dev->resource);
+		kfree(intel_vsec_dev);
+		return ret;
+	}
+
+	ret = auxiliary_device_add(auxdev);
+	if (ret < 0) {
+		auxiliary_device_uninit(auxdev);
+		return ret;
+	}
+
+	return devm_add_action_or_reset(&pdev->dev, intel_vsec_remove_aux, auxdev);
+}
+
+static int intel_vsec_add_dev(struct pci_dev *pdev, struct intel_vsec_header *header,
+			   unsigned long quirks)
+{
+	struct intel_vsec_device *intel_vsec_dev;
+	struct resource *res, *tmp;
+	int i;
+
+	if (!intel_vsec_allowed(header->id) || intel_vsec_disabled(header->id, quirks))
+		return -EINVAL;
+
+	if (!header->num_entries) {
+		dev_dbg(&pdev->dev, "Invalid 0 entry count for header id %d\n", header->id);
+		return -EINVAL;
+	}
+
+	if (!header->entry_size) {
+		dev_dbg(&pdev->dev, "Invalid 0 entry size for header id %d\n", header->id);
+		return -EINVAL;
+	}
+
+	intel_vsec_dev = kzalloc(sizeof(*intel_vsec_dev), GFP_KERNEL);
+	if (!intel_vsec_dev)
+		return -ENOMEM;
+
+	res = kcalloc(header->num_entries, sizeof(*res), GFP_KERNEL);
+	if (!res) {
+		kfree(intel_vsec_dev);
+		return -ENOMEM;
+	}
+
+	if (quirks & VSEC_QUIRK_TABLE_SHIFT)
+		header->offset >>= TABLE_OFFSET_SHIFT;
+
+	/*
+	 * The DVSEC/VSEC contains the starting offset and count for a block of
+	 * discovery tables. Create a resource array of these tables to the
+	 * auxiliary device driver.
+	 */
+	for (i = 0, tmp = res; i < header->num_entries; i++, tmp++) {
+		tmp->start = pdev->resource[header->tbir].start +
+			     header->offset + i * (header->entry_size * sizeof(u32));
+		tmp->end = tmp->start + (header->entry_size * sizeof(u32)) - 1;
+		tmp->flags = IORESOURCE_MEM;
+	}
+
+	intel_vsec_dev->pcidev = pdev;
+	intel_vsec_dev->resource = res;
+	intel_vsec_dev->num_resources = header->num_entries;
+	intel_vsec_dev->quirks = quirks;
+	intel_vsec_dev->ida = &intel_vsec_ida;
+
+	return intel_vsec_add_aux(pdev, intel_vsec_dev, intel_vsec_name(header->id));
+}
+
+static bool intel_vsec_walk_header(struct pci_dev *pdev, unsigned long quirks,
+				struct intel_vsec_header **header)
+{
+	bool have_devices = false;
+	int ret;
+
+	for ( ; *header; header++) {
+		ret = intel_vsec_add_dev(pdev, *header, quirks);
+		if (ret)
+			dev_info(&pdev->dev, "Could not add device for DVSEC id %d\n",
+				 (*header)->id);
+		else
+			have_devices = true;
+	}
+
+	return have_devices;
+}
+
+static bool intel_vsec_walk_dvsec(struct pci_dev *pdev, unsigned long quirks)
+{
+	bool have_devices = false;
+	int pos = 0;
+
+	do {
+		struct intel_vsec_header header;
+		u32 table, hdr;
+		u16 vid;
+		int ret;
+
+		pos = pci_find_next_ext_capability(pdev, pos, PCI_EXT_CAP_ID_DVSEC);
+		if (!pos)
+			break;
+
+		pci_read_config_dword(pdev, pos + PCI_DVSEC_HEADER1, &hdr);
+		vid = PCI_DVSEC_HEADER1_VID(hdr);
+		if (vid != PCI_VENDOR_ID_INTEL)
+			continue;
+
+		/* Support only revision 1 */
+		header.rev = PCI_DVSEC_HEADER1_REV(hdr);
+		if (header.rev != 1) {
+			dev_info(&pdev->dev, "Unsupported DVSEC revision %d\n", header.rev);
+			continue;
+		}
+
+		header.length = PCI_DVSEC_HEADER1_LEN(hdr);
+
+		pci_read_config_byte(pdev, pos + INTEL_DVSEC_ENTRIES, &header.num_entries);
+		pci_read_config_byte(pdev, pos + INTEL_DVSEC_SIZE, &header.entry_size);
+		pci_read_config_dword(pdev, pos + INTEL_DVSEC_TABLE, &table);
+
+		header.tbir = INTEL_DVSEC_TABLE_BAR(table);
+		header.offset = INTEL_DVSEC_TABLE_OFFSET(table);
+
+		pci_read_config_dword(pdev, pos + PCI_DVSEC_HEADER2, &hdr);
+		header.id = PCI_DVSEC_HEADER2_ID(hdr);
+
+		ret = intel_vsec_add_dev(pdev, &header, quirks);
+		if (ret)
+			continue;
+
+		have_devices = true;
+	} while (true);
+
+	return have_devices;
+}
+
+static bool intel_vsec_walk_vsec(struct pci_dev *pdev, unsigned long quirks)
+{
+	bool have_devices = false;
+	int pos = 0;
+
+	do {
+		struct intel_vsec_header header;
+		u32 table, hdr;
+		int ret;
+
+		pos = pci_find_next_ext_capability(pdev, pos, PCI_EXT_CAP_ID_VNDR);
+		if (!pos)
+			break;
+
+		pci_read_config_dword(pdev, pos + PCI_VNDR_HEADER, &hdr);
+
+		/* Support only revision 1 */
+		header.rev = PCI_VNDR_HEADER_REV(hdr);
+		if (header.rev != 1) {
+			dev_info(&pdev->dev, "Unsupported VSEC revision %d\n", header.rev);
+			continue;
+		}
+
+		header.id = PCI_VNDR_HEADER_ID(hdr);
+		header.length = PCI_VNDR_HEADER_LEN(hdr);
+
+		/* entry, size, and table offset are the same as DVSEC */
+		pci_read_config_byte(pdev, pos + INTEL_DVSEC_ENTRIES, &header.num_entries);
+		pci_read_config_byte(pdev, pos + INTEL_DVSEC_SIZE, &header.entry_size);
+		pci_read_config_dword(pdev, pos + INTEL_DVSEC_TABLE, &table);
+
+		header.tbir = INTEL_DVSEC_TABLE_BAR(table);
+		header.offset = INTEL_DVSEC_TABLE_OFFSET(table);
+
+		ret = intel_vsec_add_dev(pdev, &header, quirks);
+		if (ret)
+			continue;
+
+		have_devices = true;
+	} while (true);
+
+	return have_devices;
+}
+
+static int intel_vsec_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)
+{
+	struct intel_vsec_platform_info *info;
+	bool have_devices = false;
+	unsigned long quirks = 0;
+	int ret;
+
+	ret = pcim_enable_device(pdev);
+	if (ret)
+		return ret;
+
+	info = (struct intel_vsec_platform_info *)id->driver_data;
+	if (info)
+		quirks = info->quirks;
+
+	if (intel_vsec_walk_dvsec(pdev, quirks))
+		have_devices = true;
+
+	if (intel_vsec_walk_vsec(pdev, quirks))
+		have_devices = true;
+
+	if (info && (info->quirks & VSEC_QUIRK_NO_DVSEC) &&
+	    intel_vsec_walk_header(pdev, quirks, info->capabilities))
+		have_devices = true;
+
+	if (!have_devices)
+		return -ENODEV;
+
+	return 0;
+}
+
+/* TGL info */
+static const struct intel_vsec_platform_info tgl_info = {
+	.quirks = VSEC_QUIRK_NO_WATCHER | VSEC_QUIRK_NO_CRASHLOG | VSEC_QUIRK_TABLE_SHIFT,
+};
+
+/* DG1 info */
+static struct intel_vsec_header dg1_telemetry = {
+	.length = 0x10,
+	.id = 2,
+	.num_entries = 1,
+	.entry_size = 3,
+	.tbir = 0,
+	.offset = 0x466000,
+};
+
+static struct intel_vsec_header *dg1_capabilities[] = {
+	&dg1_telemetry,
+	NULL
+};
+
+static const struct intel_vsec_platform_info dg1_info = {
+	.capabilities = dg1_capabilities,
+	.quirks = VSEC_QUIRK_NO_DVSEC,
+};
+
+#define PCI_DEVICE_ID_INTEL_VSEC_ADL		0x467d
+#define PCI_DEVICE_ID_INTEL_VSEC_DG1		0x490e
+#define PCI_DEVICE_ID_INTEL_VSEC_OOBMSM		0x09a7
+#define PCI_DEVICE_ID_INTEL_VSEC_TGL		0x9a0d
+static const struct pci_device_id intel_vsec_pci_ids[] = {
+	{ PCI_DEVICE_DATA(INTEL, VSEC_ADL, &tgl_info) },
+	{ PCI_DEVICE_DATA(INTEL, VSEC_DG1, &dg1_info) },
+	{ PCI_DEVICE_DATA(INTEL, VSEC_OOBMSM, NULL) },
+	{ PCI_DEVICE_DATA(INTEL, VSEC_TGL, &tgl_info) },
+	{ }
+};
+MODULE_DEVICE_TABLE(pci, intel_vsec_pci_ids);
+
+static struct pci_driver intel_vsec_pci_driver = {
+	.name = "intel_vsec",
+	.id_table = intel_vsec_pci_ids,
+	.probe = intel_vsec_pci_probe,
+};
+module_pci_driver(intel_vsec_pci_driver);
+
+MODULE_AUTHOR("David E. Box <david.e.box@linux.intel.com>");
+MODULE_DESCRIPTION("Intel Extended Capabilities auxiliary bus driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/platform/x86/intel/vsec.h b/drivers/platform/x86/intel/vsec.h
new file mode 100644
index 000000000000..4cc36678e8c5
--- /dev/null
+++ b/drivers/platform/x86/intel/vsec.h
@@ -0,0 +1,43 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef _VSEC_H
+#define _VSEC_H
+
+#include <linux/auxiliary_bus.h>
+#include <linux/bits.h>
+
+struct pci_dev;
+struct resource;
+
+enum intel_vsec_quirks {
+	/* Watcher feature not supported */
+	VSEC_QUIRK_NO_WATCHER	= BIT(0),
+
+	/* Crashlog feature not supported */
+	VSEC_QUIRK_NO_CRASHLOG	= BIT(1),
+
+	/* Use shift instead of mask to read discovery table offset */
+	VSEC_QUIRK_TABLE_SHIFT	= BIT(2),
+
+	/* DVSEC not present (provided in driver data) */
+	VSEC_QUIRK_NO_DVSEC	= BIT(3),
+};
+
+struct intel_vsec_device {
+	struct auxiliary_device auxdev;
+	struct pci_dev *pcidev;
+	struct resource *resource;
+	struct ida *ida;
+	unsigned long quirks;
+	int num_resources;
+};
+
+static inline struct intel_vsec_device *dev_to_ivdev(struct device *dev)
+{
+	return container_of(dev, struct intel_vsec_device, auxdev.dev);
+}
+
+static inline struct intel_vsec_device *auxdev_to_ivdev(struct auxiliary_device *auxdev)
+{
+	return container_of(auxdev, struct intel_vsec_device, auxdev);
+}
+#endif
* Unmerged path drivers/platform/x86/intel_pmt_class.c
diff --git a/drivers/platform/x86/intel_pmt_class.h b/drivers/platform/x86/intel_pmt_class.h
index 1337019c2873..db11d58867ce 100644
--- a/drivers/platform/x86/intel_pmt_class.h
+++ b/drivers/platform/x86/intel_pmt_class.h
@@ -2,13 +2,14 @@
 #ifndef _INTEL_PMT_CLASS_H
 #define _INTEL_PMT_CLASS_H
 
-#include <linux/platform_device.h>
 #include <linux/xarray.h>
 #include <linux/types.h>
 #include <linux/bits.h>
 #include <linux/err.h>
 #include <linux/io.h>
 
+#include "../vsec.h"
+
 /* PMT access types */
 #define ACCESS_BARID		2
 #define ACCESS_LOCAL		3
@@ -47,7 +48,7 @@ struct intel_pmt_namespace {
 bool intel_pmt_is_early_client_hw(struct device *dev);
 int intel_pmt_dev_create(struct intel_pmt_entry *entry,
 			 struct intel_pmt_namespace *ns,
-			 struct platform_device *pdev, int idx);
+			 struct intel_vsec_device *dev, int idx);
 void intel_pmt_dev_destroy(struct intel_pmt_entry *entry,
 			   struct intel_pmt_namespace *ns);
 #endif
* Unmerged path drivers/platform/x86/intel_pmt_crashlog.c
* Unmerged path drivers/platform/x86/intel_pmt_telemetry.c
