dmaengine: idxd: remove fault processing code

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Dave Jiang <dave.jiang@intel.com>
commit 0e96454ca26cc5c594ec792f7e5168cce726f7cf
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/0e96454c.failed

Kernel memory are pinned and will not cause faults. Since the driver
does not support interrupts for user descriptors, no fault errors are
expected to come through the misc interrupt. Remove dead code.

	Signed-off-by: Dave Jiang <dave.jiang@intel.com>
Link: https://lore.kernel.org/r/162630502789.631986.10591230961790023856.stgit@djiang5-desk3.ch.intel.com
	Signed-off-by: Vinod Koul <vkoul@kernel.org>
(cherry picked from commit 0e96454ca26cc5c594ec792f7e5168cce726f7cf)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/dma/idxd/irq.c
diff --cc drivers/dma/idxd/irq.c
index 7a2cf0512501,e018459b534f..000000000000
--- a/drivers/dma/idxd/irq.c
+++ b/drivers/dma/idxd/irq.c
@@@ -228,31 -177,7 +177,33 @@@ irqreturn_t idxd_misc_thread(int vec, v
  	return IRQ_HANDLED;
  }
  
++<<<<<<< HEAD
 +static inline bool match_fault(struct idxd_desc *desc, u64 fault_addr)
 +{
 +	/*
 +	 * Completion address can be bad as well. Check fault address match for descriptor
 +	 * and completion address.
 +	 */
 +	if ((u64)desc->hw == fault_addr || (u64)desc->completion == fault_addr) {
 +		struct idxd_device *idxd = desc->wq->idxd;
 +		struct device *dev = &idxd->pdev->dev;
 +
 +		dev_warn(dev, "desc with fault address: %#llx\n", fault_addr);
 +		return true;
 +	}
 +
 +	return false;
 +}
 +
 +static inline void complete_desc(struct idxd_desc *desc, enum idxd_complete_type reason)
 +{
 +	idxd_dma_complete_txd(desc, reason);
 +	idxd_free_desc(desc->wq, desc);
 +}
 +
++=======
++>>>>>>> 0e96454ca26c (dmaengine: idxd: remove fault processing code)
  static int irq_process_pending_llist(struct idxd_irq_entry *irq_entry,
- 				     enum irq_work_type wtype,
  				     int *processed, u64 data)
  {
  	struct idxd_desc *desc, *t;
@@@ -266,16 -190,17 +216,24 @@@
  	if (!head)
  		goto out;
  
- 	if (wtype == IRQ_WORK_NORMAL)
- 		reason = IDXD_COMPLETE_NORMAL;
- 	else
- 		reason = IDXD_COMPLETE_DEV_FAIL;
- 
  	llist_for_each_entry_safe(desc, t, head, llnode) {
++<<<<<<< HEAD
 +		if (desc->completion->status) {
 +			if ((desc->completion->status & DSA_COMP_STATUS_MASK) != DSA_COMP_SUCCESS)
 +				match_fault(desc, data);
 +			complete_desc(desc, reason);
++=======
+ 		u8 status = desc->completion->status & DSA_COMP_STATUS_MASK;
+ 
+ 		if (status) {
+ 			if (unlikely(status == IDXD_COMP_DESC_ABORT)) {
+ 				complete_desc(desc, IDXD_COMPLETE_ABORT);
+ 				(*processed)++;
+ 				continue;
+ 			}
+ 
+ 			complete_desc(desc, IDXD_COMPLETE_NORMAL);
++>>>>>>> 0e96454ca26c (dmaengine: idxd: remove fault processing code)
  			(*processed)++;
  		} else {
  			spin_lock_irqsave(&irq_entry->list_lock, flags);
@@@ -329,9 -248,14 +281,20 @@@ static int irq_process_work_list(struc
  	spin_unlock_irqrestore(&irq_entry->list_lock, flags);
  
  	list_for_each_entry(desc, &flist, list) {
++<<<<<<< HEAD
 +		if ((desc->completion->status & DSA_COMP_STATUS_MASK) != DSA_COMP_SUCCESS)
 +			match_fault(desc, data);
 +		complete_desc(desc, reason);
++=======
+ 		u8 status = desc->completion->status & DSA_COMP_STATUS_MASK;
+ 
+ 		if (unlikely(status == IDXD_COMP_DESC_ABORT)) {
+ 			complete_desc(desc, IDXD_COMPLETE_ABORT);
+ 			continue;
+ 		}
+ 
+ 		complete_desc(desc, IDXD_COMPLETE_NORMAL);
++>>>>>>> 0e96454ca26c (dmaengine: idxd: remove fault processing code)
  	}
  
  	return queued;
* Unmerged path drivers/dma/idxd/irq.c
