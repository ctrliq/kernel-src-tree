KVM: x86: Retry page fault if MMU reload is pending and root has no sp

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Sean Christopherson <seanjc@google.com>
commit 18c841e1f4112d3fb742aca3429e84117fcb1e1c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/18c841e1.failed

Play nice with a NULL shadow page when checking for an obsolete root in
the page fault handler by flagging the page fault as stale if there's no
shadow page associated with the root and KVM_REQ_MMU_RELOAD is pending.
Invalidating memslots, which is the only case where _all_ roots need to
be reloaded, requests all vCPUs to reload their MMUs while holding
mmu_lock for lock.

The "special" roots, e.g. pae_root when KVM uses PAE paging, are not
backed by a shadow page.  Running with TDP disabled or with nested NPT
explodes spectaculary due to dereferencing a NULL shadow page pointer.

Skip the KVM_REQ_MMU_RELOAD check if there is a valid shadow page for the
root.  Zapping shadow pages in response to guest activity, e.g. when the
guest frees a PGD, can trigger KVM_REQ_MMU_RELOAD even if the current
vCPU isn't using the affected root.  I.e. KVM_REQ_MMU_RELOAD can be seen
with a completely valid root shadow page.  This is a bit of a moot point
as KVM currently unloads all roots on KVM_REQ_MMU_RELOAD, but that will
be cleaned up in the future.

Fixes: a955cad84cda ("KVM: x86/mmu: Retry page fault if root is invalidated by memslot update")
	Cc: stable@vger.kernel.org
	Cc: Maxim Levitsky <mlevitsk@redhat.com>
	Signed-off-by: Sean Christopherson <seanjc@google.com>
Message-Id: <20211209060552.2956723-2-seanjc@google.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 18c841e1f4112d3fb742aca3429e84117fcb1e1c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/mmu/mmu.c
diff --cc arch/x86/kvm/mmu/mmu.c
index c9cd8efee6c0,fcdf3f8bb59a..000000000000
--- a/arch/x86/kvm/mmu/mmu.c
+++ b/arch/x86/kvm/mmu/mmu.c
@@@ -3935,6 -3980,34 +3935,37 @@@ out_retry
  	return true;
  }
  
++<<<<<<< HEAD
++=======
+ /*
+  * Returns true if the page fault is stale and needs to be retried, i.e. if the
+  * root was invalidated by a memslot update or a relevant mmu_notifier fired.
+  */
+ static bool is_page_fault_stale(struct kvm_vcpu *vcpu,
+ 				struct kvm_page_fault *fault, int mmu_seq)
+ {
+ 	struct kvm_mmu_page *sp = to_shadow_page(vcpu->arch.mmu->root_hpa);
+ 
+ 	/* Special roots, e.g. pae_root, are not backed by shadow pages. */
+ 	if (sp && is_obsolete_sp(vcpu->kvm, sp))
+ 		return true;
+ 
+ 	/*
+ 	 * Roots without an associated shadow page are considered invalid if
+ 	 * there is a pending request to free obsolete roots.  The request is
+ 	 * only a hint that the current root _may_ be obsolete and needs to be
+ 	 * reloaded, e.g. if the guest frees a PGD that KVM is tracking as a
+ 	 * previous root, then __kvm_mmu_prepare_zap_page() signals all vCPUs
+ 	 * to reload even if no vCPU is actively using the root.
+ 	 */
+ 	if (!sp && kvm_test_request(KVM_REQ_MMU_RELOAD, vcpu))
+ 		return true;
+ 
+ 	return fault->slot &&
+ 	       mmu_notifier_retry_hva(vcpu->kvm, mmu_seq, fault->hva);
+ }
+ 
++>>>>>>> 18c841e1f411 (KVM: x86: Retry page fault if MMU reload is pending and root has no sp)
  static int direct_page_fault(struct kvm_vcpu *vcpu, struct kvm_page_fault *fault)
  {
  	bool is_tdp_mmu_fault = is_tdp_mmu(vcpu->arch.mmu);
* Unmerged path arch/x86/kvm/mmu/mmu.c
