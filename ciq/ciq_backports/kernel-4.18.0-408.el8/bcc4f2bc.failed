KVM: MMU: mark page dirty in make_spte

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Paolo Bonzini <pbonzini@redhat.com>
commit bcc4f2bc5026633198c0f8b7dd8b0e5e15de5c9d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/bcc4f2bc.failed

This simplifies set_spte, which we want to remove, and unifies code
between the shadow MMU and the TDP MMU.  The warning will be added
back later to make_spte as well.

There is a small disadvantage in the TDP MMU; it may unnecessarily mark
a page as dirty twice if two vCPUs end up mapping the same page twice.
However, this is a very small cost for a case that is already rare.

	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit bcc4f2bc5026633198c0f8b7dd8b0e5e15de5c9d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/mmu/tdp_mmu.c
diff --cc arch/x86/kvm/mmu/tdp_mmu.c
index bc5924587138,b41b6f5ea82b..000000000000
--- a/arch/x86/kvm/mmu/tdp_mmu.c
+++ b/arch/x86/kvm/mmu/tdp_mmu.c
@@@ -526,10 -520,29 +526,36 @@@ static inline bool tdp_mmu_set_spte_ato
  		      new_spte) != iter->old_spte)
  		return false;
  
++<<<<<<< HEAD
 +	handle_changed_spte(kvm, iter->as_id, iter->gfn, iter->old_spte,
 +			    new_spte, iter->level, true);
 +
 +	return true;
++=======
+ 	__handle_changed_spte(kvm, iter->as_id, iter->gfn, iter->old_spte,
+ 			      new_spte, iter->level, true);
+ 	handle_changed_spte_acc_track(iter->old_spte, new_spte, iter->level);
+ 
+ 	return true;
+ }
+ 
+ /*
+  * tdp_mmu_map_set_spte_atomic - Set a leaf TDP MMU SPTE atomically to resolve a
+  * TDP page fault.
+  *
+  * @vcpu: The vcpu instance that took the TDP page fault.
+  * @iter: a tdp_iter instance currently on the SPTE that should be set
+  * @new_spte: The value the SPTE should be set to
+  *
+  * Returns: true if the SPTE was set, false if it was not. If false is returned,
+  *	    this function will have no side-effects.
+  */
+ static inline bool tdp_mmu_map_set_spte_atomic(struct kvm_vcpu *vcpu,
+ 					       struct tdp_iter *iter,
+ 					       u64 new_spte)
+ {
+ 	return tdp_mmu_set_spte_atomic_no_dirty_log(vcpu->kvm, iter, new_spte);
++>>>>>>> bcc4f2bc5026 (KVM: MMU: mark page dirty in make_spte)
  }
  
  static inline bool tdp_mmu_zap_spte_atomic(struct kvm *kvm,
diff --git a/arch/x86/kvm/mmu/mmu.c b/arch/x86/kvm/mmu/mmu.c
index 4d7446c022d2..6d7fbcfde7ee 100644
--- a/arch/x86/kvm/mmu/mmu.c
+++ b/arch/x86/kvm/mmu/mmu.c
@@ -2666,9 +2666,6 @@ static int set_spte(struct kvm_vcpu *vcpu, u64 *sptep,
 	ret = make_spte(vcpu, pte_access, level, gfn, pfn, *sptep, speculative,
 			can_unsync, host_writable, sp_ad_disabled(sp), &spte);
 
-	if (spte & PT_WRITABLE_MASK)
-		kvm_vcpu_mark_page_dirty(vcpu, gfn);
-
 	if (*sptep == spte)
 		ret |= SET_SPTE_SPURIOUS;
 	else if (mmu_spte_update(sptep, spte))
diff --git a/arch/x86/kvm/mmu/spte.c b/arch/x86/kvm/mmu/spte.c
index 86a21eb85d25..0fa643221ba1 100644
--- a/arch/x86/kvm/mmu/spte.c
+++ b/arch/x86/kvm/mmu/spte.c
@@ -179,6 +179,9 @@ int make_spte(struct kvm_vcpu *vcpu, unsigned int pte_access, int level,
 		  "spte = 0x%llx, level = %d, rsvd bits = 0x%llx", spte, level,
 		  get_rsvd_bits(&vcpu->arch.mmu->shadow_zero_check, spte, level));
 
+	if (spte & PT_WRITABLE_MASK)
+		kvm_vcpu_mark_page_dirty(vcpu, gfn);
+
 	*new_spte = spte;
 	return ret;
 }
* Unmerged path arch/x86/kvm/mmu/tdp_mmu.c
