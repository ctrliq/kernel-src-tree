selftests: sdsi: test sysfs setup

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author David E. Box <david.e.box@linux.intel.com>
commit a3d38af35d61a1e2045b73b4e43fa5ffb9d71008
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/a3d38af3.failed

Tests file configuration and error handling of the Intel Software
Defined Silicon sysfs ABI.

	Signed-off-by: David E. Box <david.e.box@linux.intel.com>
Link: https://lore.kernel.org/r/20220225012457.1661574-2-david.e.box@linux.intel.com
	Reviewed-by: Hans de Goede <hdegoede@redhat.com>
	Signed-off-by: Hans de Goede <hdegoede@redhat.com>
(cherry picked from commit a3d38af35d61a1e2045b73b4e43fa5ffb9d71008)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	MAINTAINERS
diff --cc MAINTAINERS
index daede1a933b0,a09e383d9d11..000000000000
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@@ -7585,6 -9871,118 +7585,121 @@@ M:	Jarkko Nikula <jarkko.nikula@linux.i
  L:	linux-iio@vger.kernel.org
  F:	drivers/counter/intel-qep.c
  
++<<<<<<< HEAD
++=======
+ INTEL SCU DRIVERS
+ M:	Mika Westerberg <mika.westerberg@linux.intel.com>
+ S:	Maintained
+ F:	arch/x86/include/asm/intel_scu_ipc.h
+ F:	drivers/platform/x86/intel_scu_*
+ 
+ INTEL SDSI DRIVER
+ M:	David E. Box <david.e.box@linux.intel.com>
+ S:	Supported
+ F:	drivers/platform/x86/intel/sdsi.c
+ F:	tools/arch/x86/intel_sdsi/
+ F:	tools/testing/selftests/drivers/sdsi/
+ 
+ INTEL SKYLAKE INT3472 ACPI DEVICE DRIVER
+ M:	Daniel Scally <djrscally@gmail.com>
+ S:	Maintained
+ F:	drivers/platform/x86/intel/int3472/
+ 
+ INTEL SPEED SELECT TECHNOLOGY
+ M:	Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
+ L:	platform-driver-x86@vger.kernel.org
+ S:	Maintained
+ F:	drivers/platform/x86/intel/speed_select_if/
+ F:	include/uapi/linux/isst_if.h
+ F:	tools/power/x86/intel-speed-select/
+ 
+ INTEL STRATIX10 FIRMWARE DRIVERS
+ M:	Dinh Nguyen <dinguyen@kernel.org>
+ L:	linux-kernel@vger.kernel.org
+ S:	Maintained
+ F:	Documentation/ABI/testing/sysfs-devices-platform-stratix10-rsu
+ F:	Documentation/devicetree/bindings/firmware/intel,stratix10-svc.txt
+ F:	drivers/firmware/stratix10-rsu.c
+ F:	drivers/firmware/stratix10-svc.c
+ F:	include/linux/firmware/intel/stratix10-smc.h
+ F:	include/linux/firmware/intel/stratix10-svc-client.h
+ 
+ INTEL TELEMETRY DRIVER
+ M:	Rajneesh Bhardwaj <irenic.rajneesh@gmail.com>
+ M:	"David E. Box" <david.e.box@linux.intel.com>
+ L:	platform-driver-x86@vger.kernel.org
+ S:	Maintained
+ F:	arch/x86/include/asm/intel_telemetry.h
+ F:	drivers/platform/x86/intel/telemetry/
+ 
+ INTEL UNCORE FREQUENCY CONTROL
+ M:	Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
+ L:	platform-driver-x86@vger.kernel.org
+ S:	Maintained
+ F:	drivers/platform/x86/intel/uncore-frequency/
+ 
+ INTEL VENDOR SPECIFIC EXTENDED CAPABILITIES DRIVER
+ M:	David E. Box <david.e.box@linux.intel.com>
+ S:	Supported
+ F:	drivers/platform/x86/intel/vsec.*
+ 
+ INTEL VIRTUAL BUTTON DRIVER
+ M:	AceLan Kao <acelan.kao@canonical.com>
+ L:	platform-driver-x86@vger.kernel.org
+ S:	Maintained
+ F:	drivers/platform/x86/intel/vbtn.c
+ 
+ INTEL WIRELESS 3945ABG/BG, 4965AGN (iwlegacy)
+ M:	Stanislaw Gruszka <stf_xl@wp.pl>
+ L:	linux-wireless@vger.kernel.org
+ S:	Supported
+ F:	drivers/net/wireless/intel/iwlegacy/
+ 
+ INTEL WIRELESS WIFI LINK (iwlwifi)
+ M:	Luca Coelho <luciano.coelho@intel.com>
+ L:	linux-wireless@vger.kernel.org
+ S:	Supported
+ W:	https://wireless.wiki.kernel.org/en/users/drivers/iwlwifi
+ T:	git git://git.kernel.org/pub/scm/linux/kernel/git/iwlwifi/iwlwifi.git
+ F:	drivers/net/wireless/intel/iwlwifi/
+ 
+ INTEL WMI SLIM BOOTLOADER (SBL) FIRMWARE UPDATE DRIVER
+ M:	Jithu Joseph <jithu.joseph@intel.com>
+ R:	Maurice Ma <maurice.ma@intel.com>
+ S:	Maintained
+ W:	https://slimbootloader.github.io/security/firmware-update.html
+ F:	drivers/platform/x86/intel/wmi/sbl-fw-update.c
+ 
+ INTEL WMI THUNDERBOLT FORCE POWER DRIVER
+ L:	Dell.Client.Kernel@dell.com
+ S:	Maintained
+ F:	drivers/platform/x86/intel/wmi/thunderbolt.c
+ 
+ INTEL WWAN IOSM DRIVER
+ M:	M Chetan Kumar <m.chetan.kumar@intel.com>
+ M:	Intel Corporation <linuxwwan@intel.com>
+ L:	netdev@vger.kernel.org
+ S:	Maintained
+ F:	drivers/net/wwan/iosm/
+ 
+ INTEL(R) TRACE HUB
+ M:	Alexander Shishkin <alexander.shishkin@linux.intel.com>
+ S:	Supported
+ F:	Documentation/trace/intel_th.rst
+ F:	drivers/hwtracing/intel_th/
+ F:	include/linux/intel_th.h
+ 
+ INTEL(R) TRUSTED EXECUTION TECHNOLOGY (TXT)
+ M:	Ning Sun <ning.sun@intel.com>
+ L:	tboot-devel@lists.sourceforge.net
+ S:	Supported
+ W:	http://tboot.sourceforge.net
+ T:	hg http://tboot.hg.sourceforge.net:8000/hgroot/tboot/tboot
+ F:	Documentation/x86/intel_txt.rst
+ F:	arch/x86/kernel/tboot.c
+ F:	include/linux/tboot.h
+ 
++>>>>>>> a3d38af35d61 (selftests: sdsi: test sysfs setup)
  INTEL SGX
  M:	Jarkko Sakkinen <jarkko@kernel.org>
  R:	Dave Hansen <dave.hansen@linux.intel.com>
* Unmerged path MAINTAINERS
diff --git a/tools/testing/selftests/drivers/sdsi/sdsi.sh b/tools/testing/selftests/drivers/sdsi/sdsi.sh
new file mode 100755
index 000000000000..9b84b9b82b49
--- /dev/null
+++ b/tools/testing/selftests/drivers/sdsi/sdsi.sh
@@ -0,0 +1,25 @@
+#!/bin/sh
+# SPDX-License-Identifier: GPL-2.0
+# Runs tests for the intel_sdsi driver
+
+if ! command -v python3 > /dev/null 2>&1; then
+	echo "drivers/sdsi: [SKIP] python3 not installed"
+	exit 77
+fi
+
+if ! python3 -c "import pytest" > /dev/null 2>&1; then
+	echo "drivers/sdsi: [SKIP] pytest module not installed"
+	exit 77
+fi
+
+if ! /sbin/modprobe -q -r intel_sdsi; then
+	echo "drivers/sdsi: [SKIP]"
+	exit 77
+fi
+
+if /sbin/modprobe -q intel_sdsi && python3 -m pytest sdsi_test.py; then
+	echo "drivers/sdsi: [OK]"
+else
+	echo "drivers/sdsi: [FAIL]"
+	exit 1
+fi
diff --git a/tools/testing/selftests/drivers/sdsi/sdsi_test.py b/tools/testing/selftests/drivers/sdsi/sdsi_test.py
new file mode 100644
index 000000000000..5efb29feee70
--- /dev/null
+++ b/tools/testing/selftests/drivers/sdsi/sdsi_test.py
@@ -0,0 +1,226 @@
+#!/usr/bin/env python3
+# SPDX-License-Identifier: GPL-2.0
+
+from struct import pack
+from time import sleep
+
+import errno
+import glob
+import os
+import subprocess
+
+try:
+    import pytest
+except ImportError:
+    print("Unable to import pytest python module.")
+    print("\nIf not already installed, you may do so with:")
+    print("\t\tpip3 install pytest")
+    exit(1)
+
+SOCKETS = glob.glob('/sys/bus/auxiliary/devices/intel_vsec.sdsi.*')
+NUM_SOCKETS = len(SOCKETS)
+
+MODULE_NAME = 'intel_sdsi'
+DEV_PREFIX = 'intel_vsec.sdsi'
+CLASS_DIR = '/sys/bus/auxiliary/devices'
+GUID = "0x6dd191"
+
+def read_bin_file(file):
+    with open(file, mode='rb') as f:
+        content = f.read()
+    return content
+
+def get_dev_file_path(socket, file):
+    return CLASS_DIR + '/' + DEV_PREFIX + '.' + str(socket) + '/' + file
+
+def kmemleak_enabled():
+    kmemleak = "/sys/kernel/debug/kmemleak"
+    return os.path.isfile(kmemleak)
+
+class TestSDSiDriver:
+    def test_driver_loaded(self):
+        lsmod_p = subprocess.Popen(('lsmod'), stdout=subprocess.PIPE)
+        result = subprocess.check_output(('grep', '-q', MODULE_NAME), stdin=lsmod_p.stdout)
+
+@pytest.mark.parametrize('socket', range(0, NUM_SOCKETS))
+class TestSDSiFilesClass:
+
+    def read_value(self, file):
+        f = open(file, "r")
+        value = f.read().strip("\n")
+        return value
+
+    def get_dev_folder(self, socket):
+        return CLASS_DIR + '/' + DEV_PREFIX + '.' + str(socket) + '/'
+
+    def test_sysfs_files_exist(self, socket):
+        folder = self.get_dev_folder(socket)
+        print (folder)
+        assert os.path.isfile(folder + "guid") == True
+        assert os.path.isfile(folder + "provision_akc") == True
+        assert os.path.isfile(folder + "provision_cap") == True
+        assert os.path.isfile(folder + "state_certificate") == True
+        assert os.path.isfile(folder + "registers") == True
+
+    def test_sysfs_file_permissions(self, socket):
+        folder = self.get_dev_folder(socket)
+        mode = os.stat(folder + "guid").st_mode & 0o777
+        assert mode == 0o444    # Read all
+        mode = os.stat(folder + "registers").st_mode & 0o777
+        assert mode == 0o400    # Read owner
+        mode = os.stat(folder + "provision_akc").st_mode & 0o777
+        assert mode == 0o200    # Read owner
+        mode = os.stat(folder + "provision_cap").st_mode & 0o777
+        assert mode == 0o200    # Read owner
+        mode = os.stat(folder + "state_certificate").st_mode & 0o777
+        assert mode == 0o400    # Read owner
+
+    def test_sysfs_file_ownership(self, socket):
+        folder = self.get_dev_folder(socket)
+
+        st = os.stat(folder + "guid")
+        assert st.st_uid == 0
+        assert st.st_gid == 0
+
+        st = os.stat(folder + "registers")
+        assert st.st_uid == 0
+        assert st.st_gid == 0
+
+        st = os.stat(folder + "provision_akc")
+        assert st.st_uid == 0
+        assert st.st_gid == 0
+
+        st = os.stat(folder + "provision_cap")
+        assert st.st_uid == 0
+        assert st.st_gid == 0
+
+        st = os.stat(folder + "state_certificate")
+        assert st.st_uid == 0
+        assert st.st_gid == 0
+
+    def test_sysfs_file_sizes(self, socket):
+        folder = self.get_dev_folder(socket)
+
+        if self.read_value(folder + "guid") == GUID:
+            st = os.stat(folder + "registers")
+            assert st.st_size == 72
+
+        st = os.stat(folder + "provision_akc")
+        assert st.st_size == 1024
+
+        st = os.stat(folder + "provision_cap")
+        assert st.st_size == 1024
+
+        st = os.stat(folder + "state_certificate")
+        assert st.st_size == 4096
+
+    def test_no_seek_allowed(self, socket):
+        folder = self.get_dev_folder(socket)
+        rand_file = bytes(os.urandom(8))
+
+        f = open(folder + "provision_cap", "wb", 0)
+        f.seek(1)
+        with pytest.raises(OSError) as error:
+            f.write(rand_file)
+        assert error.value.errno == errno.ESPIPE
+        f.close()
+
+        f = open(folder + "provision_akc", "wb", 0)
+        f.seek(1)
+        with pytest.raises(OSError) as error:
+            f.write(rand_file)
+        assert error.value.errno == errno.ESPIPE
+        f.close()
+
+    def test_registers_seek(self, socket):
+        folder = self.get_dev_folder(socket)
+
+        # Check that the value read from an offset of the entire
+        # file is none-zero and the same as the value read
+        # from seeking to the same location
+        f = open(folder + "registers", "rb")
+        data = f.read()
+        f.seek(64)
+        id = f.read()
+        assert id != bytes(0)
+        assert data[64:] == id
+        f.close()
+
+@pytest.mark.parametrize('socket', range(0, NUM_SOCKETS))
+class TestSDSiMailboxCmdsClass:
+    def test_provision_akc_eoverflow_1017_bytes(self, socket):
+
+        # The buffer for writes is 1k, of with 8 bytes must be
+        # reserved for the command, leaving 1016 bytes max.
+        # Check that we get an overflow error for 1017 bytes.
+        node = get_dev_file_path(socket, "provision_akc")
+        rand_file = bytes(os.urandom(1017))
+
+        f = open(node, 'wb', 0)
+        with pytest.raises(OSError) as error:
+            f.write(rand_file)
+        assert error.value.errno == errno.EOVERFLOW
+        f.close()
+
+@pytest.mark.parametrize('socket', range(0, NUM_SOCKETS))
+class TestSdsiDriverLocksClass:
+    def test_enodev_when_pci_device_removed(self, socket):
+        node = get_dev_file_path(socket, "provision_akc")
+        dev_name = DEV_PREFIX + '.' + str(socket)
+        driver_dir = CLASS_DIR + '/' + dev_name + "/driver/"
+        rand_file = bytes(os.urandom(8))
+
+        f = open(node, 'wb', 0)
+        g = open(node, 'wb', 0)
+
+        with open(driver_dir + 'unbind', 'w') as k:
+            print(dev_name, file = k)
+
+        with pytest.raises(OSError) as error:
+            f.write(rand_file)
+        assert error.value.errno == errno.ENODEV
+
+        with pytest.raises(OSError) as error:
+            g.write(rand_file)
+        assert error.value.errno == errno.ENODEV
+
+        f.close()
+        g.close()
+
+        # Short wait needed to allow file to close before pulling driver
+        sleep(1)
+
+        p = subprocess.Popen(('modprobe', '-r', 'intel_sdsi'))
+        p.wait()
+        p = subprocess.Popen(('modprobe', '-r', 'intel_vsec'))
+        p.wait()
+        p = subprocess.Popen(('modprobe', 'intel_vsec'))
+        p.wait()
+
+        # Short wait needed to allow driver time to get inserted
+        # before continuing tests
+        sleep(1)
+
+    def test_memory_leak(self, socket):
+        if not kmemleak_enabled():
+            pytest.skip("kmemleak not enabled in kernel")
+
+        dev_name = DEV_PREFIX + '.' + str(socket)
+        driver_dir = CLASS_DIR + '/' + dev_name + "/driver/"
+
+        with open(driver_dir + 'unbind', 'w') as k:
+            print(dev_name, file = k)
+
+        sleep(1)
+
+        subprocess.check_output(('modprobe', '-r', 'intel_sdsi'))
+        subprocess.check_output(('modprobe', '-r', 'intel_vsec'))
+
+        with open('/sys/kernel/debug/kmemleak', 'w') as f:
+            print('scan', file = f)
+        sleep(5)
+
+        assert os.stat('/sys/kernel/debug/kmemleak').st_size == 0
+
+        subprocess.check_output(('modprobe', 'intel_vsec'))
+        sleep(1)
