tools/objtool: Check for use of the ENQCMD instruction in the kernel

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Fenghua Yu <fenghua.yu@intel.com>
commit 6e3133d901e89a4ba83ce7ebd8c27bbeaa9ed1f2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/6e3133d9.failed

The ENQCMD instruction implicitly accesses the PASID_MSR to fill in the
pasid field of the descriptor being submitted to an accelerator. But
there is no precise (and stable across kernel changes) point at which
the PASID_MSR is updated from the value for one task to the next.

Kernel code that uses accelerators must always use the ENQCMDS instruction
which does not access the PASID_MSR.

Check for use of the ENQCMD instruction in the kernel and warn on its
usage.

	Signed-off-by: Fenghua Yu <fenghua.yu@intel.com>
	Signed-off-by: Borislav Petkov <bp@suse.de>
	Reviewed-by: Tony Luck <tony.luck@intel.com>
	Acked-by: Josh Poimboeuf <jpoimboe@redhat.com>
Link: https://lore.kernel.org/r/20220207230254.3342514-11-fenghua.yu@intel.com
(cherry picked from commit 6e3133d901e89a4ba83ce7ebd8c27bbeaa9ed1f2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/objtool/arch/x86/decode.c
diff --cc tools/objtool/arch/x86/decode.c
index 7a3ae00d5704,479e769ca324..000000000000
--- a/tools/objtool/arch/x86/decode.c
+++ b/tools/objtool/arch/x86/decode.c
@@@ -78,16 -63,62 +78,27 @@@ bool arch_callee_saved_reg(unsigned cha
  	}
  }
  
 -unsigned long arch_dest_reloc_offset(int addend)
 -{
 -	return addend + 4;
 -}
 -
 -unsigned long arch_jump_destination(struct instruction *insn)
 -{
 -	return insn->offset + insn->len + insn->immediate;
 -}
 -
 -#define ADD_OP(op) \
 -	if (!(op = calloc(1, sizeof(*op)))) \
 -		return -1; \
 -	else for (list_add_tail(&op->list, ops_list); op; op = NULL)
 -
 -/*
 - * Helpers to decode ModRM/SIB:
 - *
 - * r/m| AX  CX  DX  BX |  SP |  BP |  SI  DI |
 - *    | R8  R9 R10 R11 | R12 | R13 | R14 R15 |
 - * Mod+----------------+-----+-----+---------+
 - * 00 |    [r/m]       |[SIB]|[IP+]|  [r/m]  |
 - * 01 |  [r/m + d8]    |[S+d]|   [r/m + d8]  |
 - * 10 |  [r/m + d32]   |[S+D]|   [r/m + d32] |
 - * 11 |                   r/ m               |
 - */
 -
 -#define mod_is_mem()	(modrm_mod != 3)
 -#define mod_is_reg()	(modrm_mod == 3)
 -
 -#define is_RIP()   ((modrm_rm & 7) == CFI_BP && modrm_mod == 0)
 -#define have_SIB() ((modrm_rm & 7) == CFI_SP && mod_is_mem())
 -
 -#define rm_is(reg) (have_SIB() ? \
 -		    sib_base == (reg) && sib_index == CFI_SP : \
 -		    modrm_rm == (reg))
 -
 -#define rm_is_mem(reg)	(mod_is_mem() && !is_RIP() && rm_is(reg))
 -#define rm_is_reg(reg)	(mod_is_reg() && modrm_rm == (reg))
 -
 -int arch_decode_instruction(struct objtool_file *file, const struct section *sec,
 +int arch_decode_instruction(struct elf *elf, struct section *sec,
  			    unsigned long offset, unsigned int maxlen,
 -			    unsigned int *len, enum insn_type *type,
 -			    unsigned long *immediate,
 -			    struct list_head *ops_list)
 +			    unsigned int *len, unsigned char *type,
 +			    unsigned long *immediate, struct stack_op *op)
  {
 -	const struct elf *elf = file->elf;
  	struct insn insn;
++<<<<<<< HEAD
 +	int x86_64, sign;
 +	unsigned char op1, op2, rex = 0, rex_b = 0, rex_r = 0, rex_w = 0,
 +		      rex_x = 0, modrm = 0, modrm_mod = 0, modrm_rm = 0,
 +		      modrm_reg = 0, sib = 0;
++=======
+ 	int x86_64, ret;
+ 	unsigned char op1, op2, op3,
+ 		      rex = 0, rex_b = 0, rex_r = 0, rex_w = 0, rex_x = 0,
+ 		      modrm = 0, modrm_mod = 0, modrm_rm = 0, modrm_reg = 0,
+ 		      sib = 0, /* sib_scale = 0, */ sib_index = 0, sib_base = 0;
+ 	struct stack_op *op = NULL;
+ 	struct symbol *sym;
+ 	u64 imm;
++>>>>>>> 6e3133d901e8 (tools/objtool: Check for use of the ENQCMD instruction in the kernel)
  
  	x86_64 = is_x86_64(elf);
  	if (x86_64 == -1)
* Unmerged path tools/objtool/arch/x86/decode.c
