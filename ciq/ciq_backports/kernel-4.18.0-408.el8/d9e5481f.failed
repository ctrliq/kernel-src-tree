dmaengine: dsa: move dsa_bus_type out of idxd driver to standalone

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Dave Jiang <dave.jiang@intel.com>
commit d9e5481fca74f870cf2fc2f90a0e77e85c0b5b86
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/d9e5481f.failed

In preparation for dsa_drv compat support to be built-in, move the bus
code to its own compilation unit. A follow-on patch adds the compat
implementation. Recall that the compat implementation allows for the
deprecated / omnibus dsa_drv binding scheme rather than the idiomatic
organization of a full fledged bus driver per driver type.

	Reviewed-by: Dan Williams <dan.j.williams@intel.com>
	Signed-off-by: Dave Jiang <dave.jiang@intel.com>
Link: https://lore.kernel.org/r/162637468142.744545.2811632736881720857.stgit@djiang5-desk3.ch.intel.com
	Signed-off-by: Vinod Koul <vkoul@kernel.org>
(cherry picked from commit d9e5481fca74f870cf2fc2f90a0e77e85c0b5b86)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/dma/idxd/init.c
#	drivers/dma/idxd/sysfs.c
diff --cc drivers/dma/idxd/init.c
index 20eae71edab4,9b797fcdfd7b..000000000000
--- a/drivers/dma/idxd/init.c
+++ b/drivers/dma/idxd/init.c
@@@ -816,13 -837,21 +817,17 @@@ static int __init idxd_init_module(void
  
  	perfmon_init();
  
 -	err = idxd_driver_register(&idxd_drv);
 -	if (err < 0)
 -		goto err_idxd_driver_register;
 -
 -	err = idxd_driver_register(&idxd_dmaengine_drv);
++<<<<<<< HEAD
 +	err = idxd_register_bus_type();
  	if (err < 0)
 -		goto err_idxd_dmaengine_driver_register;
 +		return err;
  
 -	err = idxd_driver_register(&idxd_user_drv);
 -	if (err < 0)
 -		goto err_idxd_user_driver_register;
 -
 -	err = idxd_driver_register(&dsa_drv);
 +	err = idxd_register_driver();
++=======
++	err = idxd_driver_register(&idxd_drv);
++>>>>>>> d9e5481fca74 (dmaengine: dsa: move dsa_bus_type out of idxd driver to standalone)
  	if (err < 0)
 -		goto err_dsa_driver_register;
 +		goto err_idxd_driver_register;
  
  	err = idxd_cdev_register();
  	if (err)
@@@ -837,37 -866,26 +842,38 @@@
  err_pci_register:
  	idxd_cdev_remove();
  err_cdev_register:
 -	idxd_driver_unregister(&dsa_drv);
 -err_dsa_driver_register:
 -	idxd_driver_unregister(&idxd_user_drv);
 -err_idxd_user_driver_register:
 -	idxd_driver_unregister(&idxd_dmaengine_drv);
 -err_idxd_dmaengine_driver_register:
 -	idxd_driver_unregister(&idxd_drv);
 +	idxd_unregister_driver();
  err_idxd_driver_register:
- 	idxd_unregister_bus_type();
  	return err;
  }
  module_init(idxd_init_module);
  
  static void __exit idxd_exit_module(void)
  {
 -	idxd_driver_unregister(&idxd_user_drv);
 -	idxd_driver_unregister(&idxd_dmaengine_drv);
 -	idxd_driver_unregister(&idxd_drv);
 -	idxd_driver_unregister(&dsa_drv);
 +	idxd_unregister_driver();
  	pci_unregister_driver(&idxd_pci_driver);
  	idxd_cdev_remove();
- 	idxd_unregister_bus_type();
  	perfmon_exit();
  }
  module_exit(idxd_exit_module);
++<<<<<<< HEAD
 +
 +int __idxd_driver_register(struct idxd_device_driver *idxd_drv, struct module *owner,
 +			   const char *mod_name)
 +{
 +	struct device_driver *drv = &idxd_drv->drv;
 +
 +	drv->name = idxd_drv->name;
 +	drv->bus = &dsa_bus_type;
 +	drv->owner = owner;
 +	drv->mod_name = mod_name;
 +
 +	return driver_register(drv);
 +}
 +
 +void idxd_driver_unregister(struct idxd_device_driver *idxd_drv)
 +{
 +	driver_unregister(&idxd_drv->drv);
 +}
++=======
++>>>>>>> d9e5481fca74 (dmaengine: dsa: move dsa_bus_type out of idxd driver to standalone)
diff --cc drivers/dma/idxd/sysfs.c
index e25f04f3917e,633f4947ed32..000000000000
--- a/drivers/dma/idxd/sysfs.c
+++ b/drivers/dma/idxd/sysfs.c
@@@ -16,296 -16,46 +16,331 @@@ static char *idxd_wq_type_names[] = 
  	[IDXD_WQT_USER]		= "user",
  };
  
++<<<<<<< HEAD
 +static int idxd_config_bus_match(struct device *dev,
 +				 struct device_driver *drv)
 +{
 +	int matched = 0;
 +
 +	if (is_idxd_dev(dev)) {
 +		matched = 1;
 +	} else if (is_idxd_wq_dev(dev)) {
 +		struct idxd_wq *wq = confdev_to_wq(dev);
 +
 +		if (wq->state != IDXD_WQ_DISABLED) {
 +			dev_dbg(dev, "%s not disabled\n", dev_name(dev));
 +			return 0;
 +		}
 +		matched = 1;
 +	}
 +
 +	if (matched)
 +		dev_dbg(dev, "%s matched\n", dev_name(dev));
 +
 +	return matched;
 +}
 +
 +static int enable_wq(struct idxd_wq *wq)
 +{
 +	struct idxd_device *idxd = wq->idxd;
 +	struct device *dev = &idxd->pdev->dev;
 +	unsigned long flags;
 +	int rc;
 +
 +	mutex_lock(&wq->wq_lock);
 +
 +	if (idxd->state != IDXD_DEV_ENABLED) {
 +		mutex_unlock(&wq->wq_lock);
 +		dev_warn(dev, "Enabling while device not enabled.\n");
 +		return -EPERM;
 +	}
 +
 +	if (wq->state != IDXD_WQ_DISABLED) {
 +		mutex_unlock(&wq->wq_lock);
 +		dev_warn(dev, "WQ %d already enabled.\n", wq->id);
 +		return -EBUSY;
 +	}
 +
 +	if (!wq->group) {
 +		mutex_unlock(&wq->wq_lock);
 +		dev_warn(dev, "WQ not attached to group.\n");
 +		return -EINVAL;
 +	}
 +
 +	if (strlen(wq->name) == 0) {
 +		mutex_unlock(&wq->wq_lock);
 +		dev_warn(dev, "WQ name not set.\n");
 +		return -EINVAL;
 +	}
 +
 +	/* Shared WQ checks */
 +	if (wq_shared(wq)) {
 +		if (!device_swq_supported(idxd)) {
 +			dev_warn(dev, "PASID not enabled and shared WQ.\n");
 +			mutex_unlock(&wq->wq_lock);
 +			return -ENXIO;
 +		}
 +		/*
 +		 * Shared wq with the threshold set to 0 means the user
 +		 * did not set the threshold or transitioned from a
 +		 * dedicated wq but did not set threshold. A value
 +		 * of 0 would effectively disable the shared wq. The
 +		 * driver does not allow a value of 0 to be set for
 +		 * threshold via sysfs.
 +		 */
 +		if (wq->threshold == 0) {
 +			dev_warn(dev, "Shared WQ and threshold 0.\n");
 +			mutex_unlock(&wq->wq_lock);
 +			return -EINVAL;
 +		}
 +	}
 +
 +	rc = idxd_wq_alloc_resources(wq);
 +	if (rc < 0) {
 +		mutex_unlock(&wq->wq_lock);
 +		dev_warn(dev, "WQ resource alloc failed\n");
 +		return rc;
 +	}
 +
 +	spin_lock_irqsave(&idxd->dev_lock, flags);
 +	if (test_bit(IDXD_FLAG_CONFIGURABLE, &idxd->flags))
 +		rc = idxd_device_config(idxd);
 +	spin_unlock_irqrestore(&idxd->dev_lock, flags);
 +	if (rc < 0) {
 +		mutex_unlock(&wq->wq_lock);
 +		dev_warn(dev, "Writing WQ %d config failed: %d\n", wq->id, rc);
 +		return rc;
 +	}
 +
 +	rc = idxd_wq_enable(wq);
 +	if (rc < 0) {
 +		mutex_unlock(&wq->wq_lock);
 +		dev_warn(dev, "WQ %d enabling failed: %d\n", wq->id, rc);
 +		return rc;
 +	}
 +
 +	rc = idxd_wq_map_portal(wq);
 +	if (rc < 0) {
 +		dev_warn(dev, "wq portal mapping failed: %d\n", rc);
 +		rc = idxd_wq_disable(wq, false);
 +		if (rc < 0)
 +			dev_warn(dev, "IDXD wq disable failed\n");
 +		mutex_unlock(&wq->wq_lock);
 +		return rc;
 +	}
 +
 +	wq->client_count = 0;
 +
 +	if (wq->type == IDXD_WQT_KERNEL) {
 +		rc = idxd_wq_init_percpu_ref(wq);
 +		if (rc < 0) {
 +			dev_dbg(dev, "percpu_ref setup failed\n");
 +			mutex_unlock(&wq->wq_lock);
 +			return rc;
 +		}
 +	}
 +
 +	if (is_idxd_wq_dmaengine(wq)) {
 +		rc = idxd_register_dma_channel(wq);
 +		if (rc < 0) {
 +			dev_dbg(dev, "DMA channel register failed\n");
 +			mutex_unlock(&wq->wq_lock);
 +			return rc;
 +		}
 +	} else if (is_idxd_wq_cdev(wq)) {
 +		rc = idxd_wq_add_cdev(wq);
 +		if (rc < 0) {
 +			dev_dbg(dev, "Cdev creation failed\n");
 +			mutex_unlock(&wq->wq_lock);
 +			return rc;
 +		}
 +	}
 +
 +	mutex_unlock(&wq->wq_lock);
 +	dev_info(dev, "wq %s enabled\n", dev_name(&wq->conf_dev));
 +
 +	return 0;
 +}
 +
 +static int idxd_config_bus_probe(struct device *dev)
 +{
 +	int rc = 0;
 +	unsigned long flags;
 +
 +	dev_dbg(dev, "%s called\n", __func__);
 +
 +	if (is_idxd_dev(dev)) {
 +		struct idxd_device *idxd = confdev_to_idxd(dev);
 +
 +		if (!try_module_get(THIS_MODULE))
 +			return -ENXIO;
 +
 +		/* Perform IDXD configuration and enabling */
 +		spin_lock_irqsave(&idxd->dev_lock, flags);
 +		if (test_bit(IDXD_FLAG_CONFIGURABLE, &idxd->flags))
 +			rc = idxd_device_config(idxd);
 +		spin_unlock_irqrestore(&idxd->dev_lock, flags);
 +		if (rc < 0) {
 +			module_put(THIS_MODULE);
 +			dev_warn(dev, "Device config failed: %d\n", rc);
 +			return rc;
 +		}
 +
 +		/* start device */
 +		rc = idxd_device_enable(idxd);
 +		if (rc < 0) {
 +			module_put(THIS_MODULE);
 +			dev_warn(dev, "Device enable failed: %d\n", rc);
 +			return rc;
 +		}
 +
 +		dev_info(dev, "Device %s enabled\n", dev_name(dev));
 +
 +		rc = idxd_register_dma_device(idxd);
 +		if (rc < 0) {
 +			module_put(THIS_MODULE);
 +			dev_dbg(dev, "Failed to register dmaengine device\n");
 +			return rc;
 +		}
 +		return 0;
 +	} else if (is_idxd_wq_dev(dev)) {
 +		struct idxd_wq *wq = confdev_to_wq(dev);
 +
 +		return enable_wq(wq);
++=======
+ static int idxd_dsa_drv_probe(struct idxd_dev *idxd_dev)
+ {
+ 	if (is_idxd_dev(idxd_dev))
+ 		return idxd_device_drv_probe(idxd_dev);
+ 
+ 	if (is_idxd_wq_dev(idxd_dev)) {
+ 		struct idxd_wq *wq = idxd_dev_to_wq(idxd_dev);
+ 
+ 		return drv_enable_wq(wq);
++>>>>>>> d9e5481fca74 (dmaengine: dsa: move dsa_bus_type out of idxd driver to standalone)
  	}
  
  	return -ENODEV;
  }
  
++<<<<<<< HEAD
 +static void disable_wq(struct idxd_wq *wq)
 +{
 +	struct idxd_device *idxd = wq->idxd;
 +	struct device *dev = &idxd->pdev->dev;
 +
 +	mutex_lock(&wq->wq_lock);
 +	dev_dbg(dev, "%s removing WQ %s\n", __func__, dev_name(&wq->conf_dev));
 +	if (wq->state == IDXD_WQ_DISABLED) {
 +		mutex_unlock(&wq->wq_lock);
 +		return;
 +	}
 +
 +	if (wq->type == IDXD_WQT_KERNEL)
 +		idxd_wq_quiesce(wq);
 +
 +	if (is_idxd_wq_dmaengine(wq))
 +		idxd_unregister_dma_channel(wq);
 +	else if (is_idxd_wq_cdev(wq))
 +		idxd_wq_del_cdev(wq);
 +
 +	if (idxd_wq_refcount(wq))
 +		dev_warn(dev, "Clients has claim on wq %d: %d\n",
 +			 wq->id, idxd_wq_refcount(wq));
 +
 +	idxd_wq_unmap_portal(wq);
 +
 +	idxd_wq_drain(wq);
 +	idxd_wq_reset(wq);
 +
 +	idxd_wq_free_resources(wq);
 +	wq->client_count = 0;
 +	mutex_unlock(&wq->wq_lock);
 +
 +	dev_info(dev, "wq %s disabled\n", dev_name(&wq->conf_dev));
 +}
 +
 +static int idxd_config_bus_remove(struct device *dev)
 +{
 +	dev_dbg(dev, "%s called for %s\n", __func__, dev_name(dev));
 +
 +	/* disable workqueue here */
 +	if (is_idxd_wq_dev(dev)) {
 +		struct idxd_wq *wq = confdev_to_wq(dev);
 +
 +		disable_wq(wq);
 +	} else if (is_idxd_dev(dev)) {
 +		struct idxd_device *idxd = confdev_to_idxd(dev);
 +		int i;
 +
 +		dev_dbg(dev, "%s removing dev %s\n", __func__,
 +			dev_name(&idxd->conf_dev));
 +		for (i = 0; i < idxd->max_wqs; i++) {
 +			struct idxd_wq *wq = idxd->wqs[i];
 +
 +			if (wq->state == IDXD_WQ_DISABLED)
 +				continue;
 +			dev_warn(dev, "Active wq %d on disable %s.\n", i,
 +				 dev_name(&idxd->conf_dev));
 +			device_release_driver(&wq->conf_dev);
 +		}
 +
 +		idxd_unregister_dma_device(idxd);
 +		idxd_device_disable(idxd);
 +		if (test_bit(IDXD_FLAG_CONFIGURABLE, &idxd->flags))
 +			idxd_device_reset(idxd);
 +		module_put(THIS_MODULE);
 +
 +		dev_info(dev, "Device %s disabled\n", dev_name(dev));
 +	}
 +
 +	return 0;
 +}
 +
 +struct bus_type dsa_bus_type = {
 +	.name = "dsa",
 +	.match = idxd_config_bus_match,
 +	.probe = idxd_config_bus_probe,
 +	.remove = idxd_config_bus_remove,
 +};
 +
 +static struct idxd_device_driver dsa_drv = {
++=======
+ static void idxd_dsa_drv_remove(struct idxd_dev *idxd_dev)
+ {
+ 	if (is_idxd_dev(idxd_dev)) {
+ 		idxd_device_drv_remove(idxd_dev);
+ 		return;
+ 	}
+ 
+ 	if (is_idxd_wq_dev(idxd_dev)) {
+ 		struct idxd_wq *wq = idxd_dev_to_wq(idxd_dev);
+ 
+ 		drv_disable_wq(wq);
+ 		return;
+ 	}
+ }
+ 
+ static enum idxd_dev_type dev_types[] = {
+ 	IDXD_DEV_NONE,
+ };
+ 
+ struct idxd_device_driver dsa_drv = {
++>>>>>>> d9e5481fca74 (dmaengine: dsa: move dsa_bus_type out of idxd driver to standalone)
  	.name = "dsa",
 -	.probe = idxd_dsa_drv_probe,
 -	.remove = idxd_dsa_drv_remove,
 -	.type = dev_types,
  };
  
 +/* IDXD generic driver setup */
 +int idxd_register_driver(void)
 +{
 +	return idxd_driver_register(&dsa_drv);
 +}
 +
 +void idxd_unregister_driver(void)
 +{
 +	idxd_driver_unregister(&dsa_drv);
 +}
 +
  /* IDXD engine attributes */
  static ssize_t engine_group_id_show(struct device *dev,
  				    struct device_attribute *attr, char *buf)
diff --git a/drivers/dma/Kconfig b/drivers/dma/Kconfig
index f70e6a229c06..9a14e919a5e2 100644
--- a/drivers/dma/Kconfig
+++ b/drivers/dma/Kconfig
@@ -263,6 +263,10 @@ config INTEL_IDMA64
 	  Enable DMA support for Intel Low Power Subsystem such as found on
 	  Intel Skylake PCH.
 
+config INTEL_IDXD_BUS
+	tristate
+	default INTEL_IDXD
+
 config INTEL_IDXD
 	tristate "Intel Data Accelerators support"
 	depends on PCI && X86_64 && !UML
diff --git a/drivers/dma/Makefile b/drivers/dma/Makefile
index 549d30e1388a..b1672a1bcc7d 100644
--- a/drivers/dma/Makefile
+++ b/drivers/dma/Makefile
@@ -40,7 +40,7 @@ obj-$(CONFIG_IMX_DMA) += imx-dma.o
 obj-$(CONFIG_IMX_SDMA) += imx-sdma.o
 obj-$(CONFIG_INTEL_IDMA64) += idma64.o
 obj-$(CONFIG_INTEL_IOATDMA) += ioat/
-obj-$(CONFIG_INTEL_IDXD) += idxd/
+obj-y += idxd/
 obj-$(CONFIG_INTEL_IOP_ADMA) += iop-adma.o
 obj-$(CONFIG_INTEL_MIC_X100_DMA) += mic_x100_dma.o
 obj-$(CONFIG_K3_DMA) += k3dma.o
diff --git a/drivers/dma/idxd/Makefile b/drivers/dma/idxd/Makefile
index 6d11558756f8..8c29ed4d48c3 100644
--- a/drivers/dma/idxd/Makefile
+++ b/drivers/dma/idxd/Makefile
@@ -1,4 +1,9 @@
+ccflags-y += -DDEFAULT_SYMBOL_NAMESPACE=IDXD
+
 obj-$(CONFIG_INTEL_IDXD) += idxd.o
 idxd-y := init.o irq.o device.o sysfs.o submit.o dma.o cdev.o
 
 idxd-$(CONFIG_INTEL_IDXD_PERFMON) += perfmon.o
+
+obj-$(CONFIG_INTEL_IDXD_BUS) += idxd_bus.o
+idxd_bus-y := bus.o
diff --git a/drivers/dma/idxd/bus.c b/drivers/dma/idxd/bus.c
new file mode 100644
index 000000000000..02837f0fb3e4
--- /dev/null
+++ b/drivers/dma/idxd/bus.c
@@ -0,0 +1,92 @@
+// SPDX-License-Identifier: GPL-2.0
+/* Copyright(c) 2021 Intel Corporation. All rights rsvd. */
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include "idxd.h"
+
+
+int __idxd_driver_register(struct idxd_device_driver *idxd_drv, struct module *owner,
+			   const char *mod_name)
+{
+	struct device_driver *drv = &idxd_drv->drv;
+
+	if (!idxd_drv->type) {
+		pr_debug("driver type not set (%ps)\n", __builtin_return_address(0));
+		return -EINVAL;
+	}
+
+	drv->name = idxd_drv->name;
+	drv->bus = &dsa_bus_type;
+	drv->owner = owner;
+	drv->mod_name = mod_name;
+
+	return driver_register(drv);
+}
+EXPORT_SYMBOL_GPL(__idxd_driver_register);
+
+void idxd_driver_unregister(struct idxd_device_driver *idxd_drv)
+{
+	driver_unregister(&idxd_drv->drv);
+}
+EXPORT_SYMBOL_GPL(idxd_driver_unregister);
+
+static int idxd_config_bus_match(struct device *dev,
+				 struct device_driver *drv)
+{
+	struct idxd_device_driver *idxd_drv =
+		container_of(drv, struct idxd_device_driver, drv);
+	struct idxd_dev *idxd_dev = confdev_to_idxd_dev(dev);
+	int i = 0;
+
+	while (idxd_drv->type[i] != IDXD_DEV_NONE) {
+		if (idxd_dev->type == idxd_drv->type[i])
+			return 1;
+		i++;
+	}
+
+	return 0;
+}
+
+static int idxd_config_bus_probe(struct device *dev)
+{
+	struct idxd_device_driver *idxd_drv =
+		container_of(dev->driver, struct idxd_device_driver, drv);
+	struct idxd_dev *idxd_dev = confdev_to_idxd_dev(dev);
+
+	return idxd_drv->probe(idxd_dev);
+}
+
+static int idxd_config_bus_remove(struct device *dev)
+{
+	struct idxd_device_driver *idxd_drv =
+		container_of(dev->driver, struct idxd_device_driver, drv);
+	struct idxd_dev *idxd_dev = confdev_to_idxd_dev(dev);
+
+	idxd_drv->remove(idxd_dev);
+	return 0;
+}
+
+struct bus_type dsa_bus_type = {
+	.name = "dsa",
+	.match = idxd_config_bus_match,
+	.probe = idxd_config_bus_probe,
+	.remove = idxd_config_bus_remove,
+};
+EXPORT_SYMBOL_GPL(dsa_bus_type);
+
+static int __init dsa_bus_init(void)
+{
+	return bus_register(&dsa_bus_type);
+}
+module_init(dsa_bus_init);
+
+static void __exit dsa_bus_exit(void)
+{
+	bus_unregister(&dsa_bus_type);
+}
+module_exit(dsa_bus_exit);
+
+MODULE_DESCRIPTION("IDXD driver dsa_bus_type driver");
+MODULE_LICENSE("GPL v2");
* Unmerged path drivers/dma/idxd/init.c
* Unmerged path drivers/dma/idxd/sysfs.c
