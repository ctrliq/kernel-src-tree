KVM: SVM: Don't apply SEV+SMAP workaround on code fetch or PT access

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Sean Christopherson <seanjc@google.com>
commit 3280cc22aea74d78ebbea277ff8bc8d593582de3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/3280cc22.failed

Resume the guest instead of synthesizing a triple fault shutdown if the
instruction bytes buffer is empty due to the #NPF being on the code fetch
itself or on a page table access.  The SMAP errata applies if and only if
the code fetch was successful and ucode's subsequent data read from the
code page encountered a SMAP violation.  In practice, the guest is likely
hosed either way, but crashing the guest on a code fetch to emulated MMIO
is technically wrong according to the behavior described in the APM.

	Signed-off-by: Sean Christopherson <seanjc@google.com>
	Reviewed-by: Liam Merwick <liam.merwick@oracle.com>
Message-Id: <20220120010719.711476-9-seanjc@google.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 3280cc22aea74d78ebbea277ff8bc8d593582de3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/svm/svm.c
diff --cc arch/x86/kvm/svm/svm.c
index de9327a192dc,be25831830b0..000000000000
--- a/arch/x86/kvm/svm/svm.c
+++ b/arch/x86/kvm/svm/svm.c
@@@ -4289,44 -4322,37 +4290,68 @@@ static bool svm_can_emulate_instruction
  	 * Detect and workaround Errata 1096 Fam_17h_00_0Fh.
  	 *
  	 * Errata:
 -	 * When CPU raises #NPF on guest data access and vCPU CR4.SMAP=1, it is
 -	 * possible that CPU microcode implementing DecodeAssist will fail to
 -	 * read guest memory at CS:RIP and vmcb.GuestIntrBytes will incorrectly
 -	 * be '0'.  This happens because microcode reads CS:RIP using a _data_
 -	 * loap uop with CPL=0 privileges.  If the load hits a SMAP #PF, ucode
 -	 * gives up and does not fill the instruction bytes buffer.
 +	 * When CPU raise #NPF on guest data access and vCPU CR4.SMAP=1, it is
 +	 * possible that CPU microcode implementing DecodeAssist will fail
 +	 * to read bytes of instruction which caused #NPF. In this case,
 +	 * GuestIntrBytes field of the VMCB on a VMEXIT will incorrectly
 +	 * return 0 instead of the correct guest instruction bytes.
  	 *
 +	 * This happens because CPU microcode reading instruction bytes
 +	 * uses a special opcode which attempts to read data using CPL=0
 +	 * priviledges. The microcode reads CS:RIP and if it hits a SMAP
 +	 * fault, it gives up and returns no instruction bytes.
 +	 *
++<<<<<<< HEAD
 +	 * Detection:
 +	 * We reach here in case CPU supports DecodeAssist, raised #NPF and
 +	 * returned 0 in GuestIntrBytes field of the VMCB.
 +	 * First, errata can only be triggered in case vCPU CR4.SMAP=1.
 +	 * Second, if vCPU CR4.SMEP=1, errata could only be triggered
 +	 * in case vCPU CPL==3 (Because otherwise guest would have triggered
 +	 * a SMEP fault instead of #NPF).
 +	 * Otherwise, vCPU CR4.SMEP=0, errata could be triggered by any vCPU CPL.
 +	 * As most guests enable SMAP if they have also enabled SMEP, use above
 +	 * logic in order to attempt minimize false-positive of detecting errata
 +	 * while still preserving all cases semantic correctness.
++=======
+ 	 * As above, KVM reaches this point iff the VM is an SEV guest, the CPU
+ 	 * supports DecodeAssist, a #NPF was raised, KVM's page fault handler
+ 	 * triggered emulation (e.g. for MMIO), and the CPU returned 0 in the
+ 	 * GuestIntrBytes field of the VMCB.
++>>>>>>> 3280cc22aea7 (KVM: SVM: Don't apply SEV+SMAP workaround on code fetch or PT access)
 +	 *
 +	 * Workaround:
 +	 * To determine what instruction the guest was executing, the hypervisor
 +	 * will have to decode the instruction at the instruction pointer.
  	 *
 -	 * This does _not_ mean that the erratum has been encountered, as the
 -	 * DecodeAssist will also fail if the load for CS:RIP hits a legitimate
 -	 * #PF, e.g. if the guest attempt to execute from emulated MMIO and
 -	 * encountered a reserved/not-present #PF.
++<<<<<<< HEAD
 +	 * In non SEV guest, hypervisor will be able to read the guest
 +	 * memory to decode the instruction pointer when insn_len is zero
 +	 * so we return true to indicate that decoding is possible.
  	 *
 +	 * But in the SEV guest, the guest memory is encrypted with the
 +	 * guest specific key and hypervisor will not be able to decode the
 +	 * instruction pointer so we will not able to workaround it. Lets
 +	 * print the error and request to kill the guest.
 +	 */
 +	if (likely(!insn || insn_len))
 +		return true;
++=======
+ 	 * To hit the erratum, the following conditions must be true:
+ 	 *    1. CR4.SMAP=1 (obviously).
+ 	 *    2. CR4.SMEP=0 || CPL=3.  If SMEP=1 and CPL<3, the erratum cannot
+ 	 *       have been hit as the guest would have encountered a SMEP
+ 	 *       violation #PF, not a #NPF.
+ 	 *    3. The #NPF is not due to a code fetch, in which case failure to
+ 	 *       retrieve the instruction bytes is legitimate (see abvoe).
+ 	 *
+ 	 * In addition, don't apply the erratum workaround if the #NPF occurred
+ 	 * while translating guest page tables (see below).
+ 	 */
+ 	error_code = to_svm(vcpu)->vmcb->control.exit_info_1;
+ 	if (error_code & (PFERR_GUEST_PAGE_MASK | PFERR_FETCH_MASK))
+ 		goto resume_guest;
++>>>>>>> 3280cc22aea7 (KVM: SVM: Don't apply SEV+SMAP workaround on code fetch or PT access)
  
  	cr4 = kvm_read_cr4(vcpu);
  	smep = cr4 & X86_CR4_SMEP;
* Unmerged path arch/x86/kvm/svm/svm.c
