KVM: VMX: Remove vCPU from PI wakeup list before updating PID.NV

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Sean Christopherson <seanjc@google.com>
commit baed82c8e4893a3258267dad198e04691d2f7c09
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/baed82c8.failed

Remove the vCPU from the wakeup list before updating the notification
vector in the posted interrupt post-block helper.  There is no need to
wake the current vCPU as it is by definition not blocking.  Practically
speaking this is a nop as it only shaves a few meager cycles in the
unlikely case that the vCPU was migrated and the previous pCPU gets a
wakeup IRQ right before PID.NV is updated.  The real motivation is to
allow for more readable code in the future, when post-block is merged
with vmx_vcpu_pi_load(), at which point removal from the list will be
conditional on the old notification vector.

Opportunistically add comments to document why KVM has a per-CPU spinlock
that, at first glance, appears to be taken only on the owning CPU.
Explicitly call out that the spinlock must be taken with IRQs disabled, a
detail that was "lost" when KVM switched from spin_lock_irqsave() to
spin_lock(), with IRQs disabled for the entirety of the relevant path.

	Signed-off-by: Sean Christopherson <seanjc@google.com>
Message-Id: <20211009021236.4122790-29-seanjc@google.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit baed82c8e4893a3258267dad198e04691d2f7c09)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/vmx/posted_intr.c
diff --cc arch/x86/kvm/vmx/posted_intr.c
index 359222f558f9,4db2b14ee7c6..000000000000
--- a/arch/x86/kvm/vmx/posted_intr.c
+++ b/arch/x86/kvm/vmx/posted_intr.c
@@@ -11,11 -11,23 +11,31 @@@
  #include "vmx.h"
  
  /*
++<<<<<<< HEAD
 + * We maintian a per-CPU linked-list of vCPU, so in wakeup_handler() we
 + * can find which vCPU should be waken up.
 + */
 +static DEFINE_PER_CPU(struct list_head, blocked_vcpu_on_cpu);
 +static DEFINE_PER_CPU(raw_spinlock_t, blocked_vcpu_on_cpu_lock);
++=======
+  * Maintain a per-CPU list of vCPUs that need to be awakened by wakeup_handler()
+  * when a WAKEUP_VECTOR interrupted is posted.  vCPUs are added to the list when
+  * the vCPU is scheduled out and is blocking (e.g. in HLT) with IRQs enabled.
+  * The vCPUs posted interrupt descriptor is updated at the same time to set its
+  * notification vector to WAKEUP_VECTOR, so that posted interrupt from devices
+  * wake the target vCPUs.  vCPUs are removed from the list and the notification
+  * vector is reset when the vCPU is scheduled in.
+  */
+ static DEFINE_PER_CPU(struct list_head, blocked_vcpu_on_cpu);
+ /*
+  * Protect the per-CPU list with a per-CPU spinlock to handle task migration.
+  * When a blocking vCPU is awakened _and_ migrated to a different pCPU, the
+  * ->sched_in() path will need to take the vCPU off the list of the _previous_
+  * CPU.  IRQs must be disabled when taking this lock, otherwise deadlock will
+  * occur if a wakeup IRQ arrives and attempts to acquire the lock.
+  */
+ static DEFINE_PER_CPU(spinlock_t, blocked_vcpu_on_cpu_lock);
++>>>>>>> baed82c8e489 (KVM: VMX: Remove vCPU from PI wakeup list before updating PID.NV)
  
  static inline struct pi_desc *vcpu_to_pi_desc(struct kvm_vcpu *vcpu)
  {
@@@ -120,12 -140,7 +148,16 @@@ static void __pi_post_block(struct kvm_
  	} while (cmpxchg64(&pi_desc->control, old.control,
  			   new.control) != old.control);
  
++<<<<<<< HEAD
 +	if (!WARN_ON_ONCE(vcpu->pre_pcpu == -1)) {
 +		raw_spin_lock(&per_cpu(blocked_vcpu_on_cpu_lock, vcpu->pre_pcpu));
 +		list_del(&vcpu->blocked_vcpu_list);
 +		raw_spin_unlock(&per_cpu(blocked_vcpu_on_cpu_lock, vcpu->pre_pcpu));
 +		vcpu->pre_pcpu = -1;
 +	}
++=======
+ 	vcpu->pre_pcpu = -1;
++>>>>>>> baed82c8e489 (KVM: VMX: Remove vCPU from PI wakeup list before updating PID.NV)
  }
  
  /*
* Unmerged path arch/x86/kvm/vmx/posted_intr.c
