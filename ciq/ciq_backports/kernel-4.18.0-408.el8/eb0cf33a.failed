dmaengine: idxd: move interrupt handle assignment

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Dave Jiang <dave.jiang@intel.com>
commit eb0cf33a91b46cd50b590d032471f7f977d5a92a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/eb0cf33a.failed

In preparation of supporting interrupt handle revoke event, move the
interrupt handle assignment to right before the descriptor to be submitted.
This allows the interrupt handle revoke logic to assign the latest
interrupt handle on submission.

	Reviewed-by: Kevin Tian <kevin.tian@intel.com>
	Signed-off-by: Dave Jiang <dave.jiang@intel.com>
Link: https://lore.kernel.org/r/163528417767.3925689.7730411152122952808.stgit@djiang5-desk3.ch.intel.com
	Signed-off-by: Vinod Koul <vkoul@kernel.org>
(cherry picked from commit eb0cf33a91b46cd50b590d032471f7f977d5a92a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/dma/idxd/submit.c
diff --cc drivers/dma/idxd/submit.c
index 0afcd1322339,df02c5c814e7..000000000000
--- a/drivers/dma/idxd/submit.c
+++ b/drivers/dma/idxd/submit.c
@@@ -22,23 -21,6 +22,26 @@@ static struct idxd_desc *__get_desc(str
  	if (device_pasid_enabled(idxd))
  		desc->hw->pasid = idxd->pasid;
  
++<<<<<<< HEAD
 +	/*
 +	 * Descriptor completion vectors are 1...N for MSIX. We will round
 +	 * robin through the N vectors.
 +	 */
 +	wq->vec_ptr = desc->vector = (wq->vec_ptr % idxd->num_wq_irqs) + 1;
 +	if (!idxd->int_handles) {
 +		desc->hw->int_handle = wq->vec_ptr;
 +	} else {
 +		/*
 +		 * int_handles are only for descriptor completion. However for device
 +		 * MSIX enumeration, vec 0 is used for misc interrupts. Therefore even
 +		 * though we are rotating through 1...N for descriptor interrupts, we
 +		 * need to acqurie the int_handles from 0..N-1.
 +		 */
 +		desc->hw->int_handle = idxd->int_handles[desc->vector - 1];
 +	}
 +
++=======
++>>>>>>> eb0cf33a91b4 (dmaengine: idxd: move interrupt handle assignment)
  	return desc;
  }
  
@@@ -108,6 -144,21 +111,24 @@@ int idxd_submit_desc(struct idxd_wq *wq
  	 * even on UP because the recipient is a device.
  	 */
  	wmb();
++<<<<<<< HEAD
++=======
+ 
+ 	/*
+ 	 * Pending the descriptor to the lockless list for the irq_entry
+ 	 * that we designated the descriptor to.
+ 	 */
+ 	if (desc->hw->flags & IDXD_OP_FLAG_RCI) {
+ 		ie = wq->ie;
+ 		if (ie->int_handle == INVALID_INT_HANDLE)
+ 			desc->hw->int_handle = ie->id;
+ 		else
+ 			desc->hw->int_handle = ie->int_handle;
+ 
+ 		llist_add(&desc->llnode, &ie->pending_llist);
+ 	}
+ 
++>>>>>>> eb0cf33a91b4 (dmaengine: idxd: move interrupt handle assignment)
  	if (wq_dedicated(wq)) {
  		iosubmit_cmds512(portal, desc->hw, 1);
  	} else {
* Unmerged path drivers/dma/idxd/submit.c
