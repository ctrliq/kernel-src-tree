net/smc: Add global configure for handshake limitation by netlink

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author D. Wythe <alibuda@linux.alibaba.com>
commit f9496b7c1b48ce02cd17a3ee88b1e049c689a222
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/f9496b7c.failed

Although we can control SMC handshake limitation through socket options,
which means that applications who need it must modify their code. It's
quite troublesome for many existing applications. This patch modifies
the global default value of SMC handshake limitation through netlink,
providing a way to put constraint on handshake without modifies any code
for applications.

	Suggested-by: Tony Lu <tonylu@linux.alibaba.com>
	Signed-off-by: D. Wythe <alibuda@linux.alibaba.com>
	Reviewed-by: Tony Lu <tonylu@linux.alibaba.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit f9496b7c1b48ce02cd17a3ee88b1e049c689a222)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/netns/smc.h
#	include/uapi/linux/smc.h
diff --cc include/net/netns/smc.h
index 89fd36f07742,47b166684fd8..000000000000
--- a/include/net/netns/smc.h
+++ b/include/net/netns/smc.h
@@@ -12,9 -12,7 +12,14 @@@ struct netns_smc 
  	/* protect fback_rsn */
  	struct mutex			mutex_fback_rsn;
  	struct smc_stats_rsn		*fback_rsn;
++<<<<<<< HEAD
 +	RH_KABI_RESERVE(1)
 +	RH_KABI_RESERVE(2)
 +	RH_KABI_RESERVE(3)
 +	RH_KABI_RESERVE(4)
++=======
+ 
+ 	bool				limit_smc_hs;	/* constraint on handshake */
++>>>>>>> f9496b7c1b48 (net/smc: Add global configure for handshake limitation by netlink)
  };
  #endif
diff --cc include/uapi/linux/smc.h
index 6c2874fd2c00,693f549f6966..000000000000
--- a/include/uapi/linux/smc.h
+++ b/include/uapi/linux/smc.h
@@@ -284,4 -287,16 +287,19 @@@ enum 
  	__SMC_NLA_SEID_TABLE_MAX,
  	SMC_NLA_SEID_TABLE_MAX = __SMC_NLA_SEID_TABLE_MAX - 1
  };
++<<<<<<< HEAD
++=======
+ 
+ /* SMC_NETLINK_HS_LIMITATION attributes */
+ enum {
+ 	SMC_NLA_HS_LIMITATION_UNSPEC,
+ 	SMC_NLA_HS_LIMITATION_ENABLED,	/* u8 */
+ 	__SMC_NLA_HS_LIMITATION_MAX,
+ 	SMC_NLA_HS_LIMITATION_MAX = __SMC_NLA_HS_LIMITATION_MAX - 1
+ };
+ 
+ /* SMC socket options */
+ #define SMC_LIMIT_HS 1	/* constraint on smc handshake */
+ 
++>>>>>>> f9496b7c1b48 (net/smc: Add global configure for handshake limitation by netlink)
  #endif /* _UAPI_LINUX_SMC_H */
* Unmerged path include/net/netns/smc.h
* Unmerged path include/uapi/linux/smc.h
diff --git a/net/smc/af_smc.c b/net/smc/af_smc.c
index b7264bf208bb..9ab5b2b73d03 100644
--- a/net/smc/af_smc.c
+++ b/net/smc/af_smc.c
@@ -64,6 +64,45 @@ struct workqueue_struct	*smc_close_wq;	/* wq for close work */
 static void smc_tcp_listen_work(struct work_struct *);
 static void smc_connect_work(struct work_struct *);
 
+int smc_nl_dump_hs_limitation(struct sk_buff *skb, struct netlink_callback *cb)
+{
+	struct smc_nl_dmp_ctx *cb_ctx = smc_nl_dmp_ctx(cb);
+	void *hdr;
+
+	if (cb_ctx->pos[0])
+		goto out;
+
+	hdr = genlmsg_put(skb, NETLINK_CB(cb->skb).portid, cb->nlh->nlmsg_seq,
+			  &smc_gen_nl_family, NLM_F_MULTI,
+			  SMC_NETLINK_DUMP_HS_LIMITATION);
+	if (!hdr)
+		return -ENOMEM;
+
+	if (nla_put_u8(skb, SMC_NLA_HS_LIMITATION_ENABLED,
+		       sock_net(skb->sk)->smc.limit_smc_hs))
+		goto err;
+
+	genlmsg_end(skb, hdr);
+	cb_ctx->pos[0] = 1;
+out:
+	return skb->len;
+err:
+	genlmsg_cancel(skb, hdr);
+	return -EMSGSIZE;
+}
+
+int smc_nl_enable_hs_limitation(struct sk_buff *skb, struct genl_info *info)
+{
+	sock_net(skb->sk)->smc.limit_smc_hs = true;
+	return 0;
+}
+
+int smc_nl_disable_hs_limitation(struct sk_buff *skb, struct genl_info *info)
+{
+	sock_net(skb->sk)->smc.limit_smc_hs = false;
+	return 0;
+}
+
 static void smc_set_keepalive(struct sock *sk, int val)
 {
 	struct smc_sock *smc = smc_sk(sk);
@@ -2710,6 +2749,9 @@ static int __smc_create(struct net *net, struct socket *sock, int protocol,
 	smc->use_fallback = false; /* assume rdma capability first */
 	smc->fallback_rsn = 0;
 
+	/* default behavior from limit_smc_hs in every net namespace */
+	smc->limit_smc_hs = net->smc.limit_smc_hs;
+
 	rc = 0;
 	if (!clcsock) {
 		rc = sock_create_kern(net, family, SOCK_STREAM, IPPROTO_TCP,
diff --git a/net/smc/smc.h b/net/smc/smc.h
index 3d0b8e300deb..1b04a14fe469 100644
--- a/net/smc/smc.h
+++ b/net/smc/smc.h
@@ -14,6 +14,7 @@
 #include <linux/socket.h>
 #include <linux/types.h>
 #include <linux/compiler.h> /* __aligned */
+#include <net/genetlink.h>
 #include <net/sock.h>
 
 #include "smc_ib.h"
@@ -313,4 +314,9 @@ void smc_fill_gid_list(struct smc_link_group *lgr,
 		       struct smc_gidlist *gidlist,
 		       struct smc_ib_device *known_dev, u8 *known_gid);
 
+/* smc handshake limitation interface for netlink  */
+int smc_nl_dump_hs_limitation(struct sk_buff *skb, struct netlink_callback *cb);
+int smc_nl_enable_hs_limitation(struct sk_buff *skb, struct genl_info *info);
+int smc_nl_disable_hs_limitation(struct sk_buff *skb, struct genl_info *info);
+
 #endif	/* __SMC_H */
diff --git a/net/smc/smc_netlink.c b/net/smc/smc_netlink.c
index f13ab0661ed5..c5a62f6f52ba 100644
--- a/net/smc/smc_netlink.c
+++ b/net/smc/smc_netlink.c
@@ -111,6 +111,21 @@ static const struct genl_ops smc_gen_nl_ops[] = {
 		.flags = GENL_ADMIN_PERM,
 		.doit = smc_nl_disable_seid,
 	},
+	{
+		.cmd = SMC_NETLINK_DUMP_HS_LIMITATION,
+		/* can be retrieved by unprivileged users */
+		.dumpit = smc_nl_dump_hs_limitation,
+	},
+	{
+		.cmd = SMC_NETLINK_ENABLE_HS_LIMITATION,
+		.flags = GENL_ADMIN_PERM,
+		.doit = smc_nl_enable_hs_limitation,
+	},
+	{
+		.cmd = SMC_NETLINK_DISABLE_HS_LIMITATION,
+		.flags = GENL_ADMIN_PERM,
+		.doit = smc_nl_disable_hs_limitation,
+	},
 };
 
 static const struct nla_policy smc_gen_nl_policy[2] = {
diff --git a/net/smc/smc_pnet.c b/net/smc/smc_pnet.c
index 756190e0a780..dcf94ad37b6a 100644
--- a/net/smc/smc_pnet.c
+++ b/net/smc/smc_pnet.c
@@ -866,6 +866,9 @@ int smc_pnet_net_init(struct net *net)
 
 	smc_pnet_create_pnetids_list(net);
 
+	/* disable handshake limitation by default */
+	net->smc.limit_smc_hs = 0;
+
 	return 0;
 }
 
