gfs2: re-factor function do_promote

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Bob Peterson <rpeterso@redhat.com>
commit 17a6eceeb1c54a0a4af5b03ccc1de7ab824408bc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/17a6ecee.failed

This patch simply re-factors function do_promote to reduce the indents.
The logic should be unchanged. This makes future patches more readable.

	Signed-off-by: Bob Peterson <rpeterso@redhat.com>
	Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
(cherry picked from commit 17a6eceeb1c54a0a4af5b03ccc1de7ab824408bc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/gfs2/glock.c
diff --cc fs/gfs2/glock.c
index ea487d5365d7,f9aebeba7454..000000000000
--- a/fs/gfs2/glock.c
+++ b/fs/gfs2/glock.c
@@@ -498,33 -494,38 +498,63 @@@ restart
  	list_for_each_entry_safe(gh, tmp, &gl->gl_holders, gh_list) {
  		if (!test_bit(HIF_WAIT, &gh->gh_iflags))
  			continue;
++<<<<<<< HEAD
 +		if (may_grant(gl, first_gh, gh)) {
 +			if (!incompat_holders_demoted) {
 +				demote_incompat_holders(gl, first_gh);
 +				incompat_holders_demoted = true;
 +				first_gh = gh;
 +			}
 +			if (gh->gh_list.prev == &gl->gl_holders &&
 +			    glops->go_lock) {
 +				if (!(gh->gh_flags & GL_SKIP)) {
 +					spin_unlock(&gl->gl_lockref.lock);
 +					/* FIXME: eliminate this eventually */
 +					ret = glops->go_lock(gh);
 +					spin_lock(&gl->gl_lockref.lock);
 +					if (ret) {
 +						if (ret == 1)
 +							return 2;
 +						gh->gh_error = ret;
 +						list_del_init(&gh->gh_list);
 +						trace_gfs2_glock_queue(gh, 0);
 +						gfs2_holder_wake(gh);
 +						goto restart;
 +					}
++=======
+ 		if (!may_grant(gl, first_gh, gh)) {
+ 			/*
+ 			 * If we get here, it means we may not grant this holder for
+ 			 * some reason. If this holder is the head of the list, it
+ 			 * means we have a blocked holder at the head, so return 1.
+ 			 */
+ 			if (gh->gh_list.prev == &gl->gl_holders)
+ 				return 1;
+ 			do_error(gl, 0);
+ 			break;
+ 		}
+ 		if (!incompat_holders_demoted) {
+ 			demote_incompat_holders(gl, first_gh);
+ 			incompat_holders_demoted = true;
+ 			first_gh = gh;
+ 		}
+ 		if (gh->gh_list.prev == &gl->gl_holders &&
+ 		    glops->go_instantiate) {
+ 			if (!(gh->gh_flags & GL_SKIP)) {
+ 				spin_unlock(&gl->gl_lockref.lock);
+ 				/* FIXME: eliminate this eventually */
+ 				ret = glops->go_instantiate(gh);
+ 				spin_lock(&gl->gl_lockref.lock);
+ 				if (ret) {
+ 					if (ret == 1)
+ 						return 2;
+ 					gh->gh_error = ret;
+ 					list_del_init(&gh->gh_list);
+ 					trace_gfs2_glock_queue(gh, 0);
+ 					gfs2_holder_wake(gh);
+ 					goto restart;
++>>>>>>> 17a6eceeb1c5 (gfs2: re-factor function do_promote)
  				}
- 				set_bit(HIF_HOLDER, &gh->gh_iflags);
- 				trace_gfs2_promote(gh);
- 				gfs2_holder_wake(gh);
- 				goto restart;
  			}
  			set_bit(HIF_HOLDER, &gh->gh_iflags);
  			trace_gfs2_promote(gh);
* Unmerged path fs/gfs2/glock.c
