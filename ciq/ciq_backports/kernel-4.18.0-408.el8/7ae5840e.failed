KVM: x86/mmu: Document that zapping invalidated roots doesn't need to flush

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Sean Christopherson <seanjc@google.com>
commit 7ae5840e6f3325b52ee46437d46ba0465016584d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/7ae5840e.failed

Remove the misleading flush "handling" when zapping invalidated TDP MMU
roots, and document that flushing is unnecessary for all flavors of MMUs
when zapping invalid/obsolete roots/pages.  The "handling" in the TDP MMU
is dead code, as zap_gfn_range() is called with shared=true, in which
case it will never return true due to the flushing being handled by
tdp_mmu_zap_spte_atomic().

No functional change intended.

	Signed-off-by: Sean Christopherson <seanjc@google.com>
	Reviewed-by: Ben Gardon <bgardon@google.com>
Message-Id: <20220226001546.360188-6-seanjc@google.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 7ae5840e6f3325b52ee46437d46ba0465016584d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/mmu/tdp_mmu.c
diff --cc arch/x86/kvm/mmu/tdp_mmu.c
index abdf98ed849c,2ce6915b70fe..000000000000
--- a/arch/x86/kvm/mmu/tdp_mmu.c
+++ b/arch/x86/kvm/mmu/tdp_mmu.c
@@@ -795,10 -849,8 +795,9 @@@ static struct kvm_mmu_page *next_invali
   */
  void kvm_tdp_mmu_zap_invalidated_roots(struct kvm *kvm)
  {
 +	gfn_t max_gfn = 1ULL << (shadow_phys_bits - PAGE_SHIFT);
  	struct kvm_mmu_page *next_root;
  	struct kvm_mmu_page *root;
- 	bool flush = false;
  
  	lockdep_assert_held_read(&kvm->mmu_lock);
  
@@@ -811,8 -863,16 +810,21 @@@
  
  		rcu_read_unlock();
  
++<<<<<<< HEAD
 +		flush = zap_gfn_range(kvm, root, 0, max_gfn, true, flush,
 +				      true);
++=======
+ 		/*
+ 		 * A TLB flush is unnecessary, invalidated roots are guaranteed
+ 		 * to be unreachable by the guest (see kvm_tdp_mmu_put_root()
+ 		 * for more details), and unlike the legacy MMU, no vCPU kick
+ 		 * is needed to play nice with lockless shadow walks as the TDP
+ 		 * MMU protects its paging structures via RCU.  Note, zapping
+ 		 * will still flush on yield, but that's a minor performance
+ 		 * blip and not a functional issue.
+ 		 */
+ 		(void)zap_gfn_range(kvm, root, 0, -1ull, true, false, true);
++>>>>>>> 7ae5840e6f33 (KVM: x86/mmu: Document that zapping invalidated roots doesn't need to flush)
  
  		/*
  		 * Put the reference acquired in
diff --git a/arch/x86/kvm/mmu/mmu.c b/arch/x86/kvm/mmu/mmu.c
index ad983809b045..846d3d813d0f 100644
--- a/arch/x86/kvm/mmu/mmu.c
+++ b/arch/x86/kvm/mmu/mmu.c
@@ -5585,9 +5585,13 @@ static void kvm_zap_obsolete_pages(struct kvm *kvm)
 	}
 
 	/*
-	 * Trigger a remote TLB flush before freeing the page tables to ensure
-	 * KVM is not in the middle of a lockless shadow page table walk, which
-	 * may reference the pages.
+	 * Kick all vCPUs (via remote TLB flush) before freeing the page tables
+	 * to ensure KVM is not in the middle of a lockless shadow page table
+	 * walk, which may reference the pages.  The remote TLB flush itself is
+	 * not required and is simply a convenient way to kick vCPUs as needed.
+	 * KVM performs a local TLB flush when allocating a new root (see
+	 * kvm_mmu_load()), and the reload in the caller ensure no vCPUs are
+	 * running with an obsolete MMU.
 	 */
 	kvm_mmu_commit_zap_page(kvm, &kvm->arch.zapped_obsolete_pages);
 }
* Unmerged path arch/x86/kvm/mmu/tdp_mmu.c
