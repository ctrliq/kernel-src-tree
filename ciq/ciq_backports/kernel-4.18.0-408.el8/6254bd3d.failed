selinux: fix bad cleanup on error in hashtab_duplicate()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Ondrej Mosnacek <omosnace@redhat.com>
commit 6254bd3db316c9ccb3b05caa8b438be63245466f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/6254bd3d.failed

The code attempts to free the 'new' pointer using kmem_cache_free(),
which is wrong because this function isn't responsible of freeing it.
Instead, the function should free new->htable and clear the contents of
*new (to prevent double-free).

	Cc: stable@vger.kernel.org
Fixes: c7c556f1e81b ("selinux: refactor changing booleans")
	Reported-by: Wander Lairson Costa <wander@redhat.com>
	Signed-off-by: Ondrej Mosnacek <omosnace@redhat.com>
	Signed-off-by: Paul Moore <paul@paul-moore.com>
(cherry picked from commit 6254bd3db316c9ccb3b05caa8b438be63245466f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	security/selinux/ss/hashtab.c
diff --cc security/selinux/ss/hashtab.c
index 251e51104976,3fb8f9026e9b..000000000000
--- a/security/selinux/ss/hashtab.c
+++ b/security/selinux/ss/hashtab.c
@@@ -129,6 -130,60 +129,63 @@@ void hashtab_stat(struct hashtab *h, st
  	info->max_chain_len = max_chain_len;
  }
  
++<<<<<<< HEAD
++=======
+ int hashtab_duplicate(struct hashtab *new, struct hashtab *orig,
+ 		int (*copy)(struct hashtab_node *new,
+ 			struct hashtab_node *orig, void *args),
+ 		int (*destroy)(void *k, void *d, void *args),
+ 		void *args)
+ {
+ 	struct hashtab_node *cur, *tmp, *tail;
+ 	int i, rc;
+ 
+ 	memset(new, 0, sizeof(*new));
+ 
+ 	new->htable = kcalloc(orig->size, sizeof(*new->htable), GFP_KERNEL);
+ 	if (!new->htable)
+ 		return -ENOMEM;
+ 
+ 	new->size = orig->size;
+ 
+ 	for (i = 0; i < orig->size; i++) {
+ 		tail = NULL;
+ 		for (cur = orig->htable[i]; cur; cur = cur->next) {
+ 			tmp = kmem_cache_zalloc(hashtab_node_cachep,
+ 						GFP_KERNEL);
+ 			if (!tmp)
+ 				goto error;
+ 			rc = copy(tmp, cur, args);
+ 			if (rc) {
+ 				kmem_cache_free(hashtab_node_cachep, tmp);
+ 				goto error;
+ 			}
+ 			tmp->next = NULL;
+ 			if (!tail)
+ 				new->htable[i] = tmp;
+ 			else
+ 				tail->next = tmp;
+ 			tail = tmp;
+ 			new->nel++;
+ 		}
+ 	}
+ 
+ 	return 0;
+ 
+  error:
+ 	for (i = 0; i < new->size; i++) {
+ 		for (cur = new->htable[i]; cur; cur = tmp) {
+ 			tmp = cur->next;
+ 			destroy(cur->key, cur->datum, args);
+ 			kmem_cache_free(hashtab_node_cachep, cur);
+ 		}
+ 	}
+ 	kfree(new->htable);
+ 	memset(new, 0, sizeof(*new));
+ 	return -ENOMEM;
+ }
+ 
++>>>>>>> 6254bd3db316 (selinux: fix bad cleanup on error in hashtab_duplicate())
  void __init hashtab_cache_init(void)
  {
  		hashtab_node_cachep = kmem_cache_create("hashtab_node",
* Unmerged path security/selinux/ss/hashtab.c
