KVM: x86: mmu: trace kvm_mmu_set_spte after the new SPTE was set

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Maxim Levitsky <mlevitsk@redhat.com>
commit 5959ff4ae96eece2f0c3dfde5d27bff70ab1ce56
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/5959ff4a.failed

It makes more sense to print new SPTE value than the
old value.

	Signed-off-by: Maxim Levitsky <mlevitsk@redhat.com>
	Reviewed-by: Sean Christopherson <seanjc@google.com>
Message-Id: <20220302102457.588450-1-mlevitsk@redhat.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 5959ff4ae96eece2f0c3dfde5d27bff70ab1ce56)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/mmu/mmu.c
diff --cc arch/x86/kvm/mmu/mmu.c
index 978c125f417f,8f19ea752704..000000000000
--- a/arch/x86/kvm/mmu/mmu.c
+++ b/arch/x86/kvm/mmu/mmu.c
@@@ -2701,9 -2690,17 +2701,23 @@@ static int mmu_set_spte(struct kvm_vcp
  			was_rmapped = 1;
  	}
  
++<<<<<<< HEAD
 +	set_spte_ret = set_spte(vcpu, sptep, pte_access, level, gfn, pfn,
 +				speculative, true, host_writable);
 +	if (set_spte_ret & SET_SPTE_WRITE_PROTECTED_PT) {
++=======
+ 	wrprot = make_spte(vcpu, sp, slot, pte_access, gfn, pfn, *sptep, prefetch,
+ 			   true, host_writable, &spte);
+ 
+ 	if (*sptep == spte) {
+ 		ret = RET_PF_SPURIOUS;
+ 	} else {
+ 		flush |= mmu_spte_update(sptep, spte);
+ 		trace_kvm_mmu_set_spte(level, gfn, sptep);
+ 	}
+ 
+ 	if (wrprot) {
++>>>>>>> 5959ff4ae96e (KVM: x86: mmu: trace kvm_mmu_set_spte after the new SPTE was set)
  		if (write_fault)
  			ret = RET_PF_EMULATE;
  	}
* Unmerged path arch/x86/kvm/mmu/mmu.c
