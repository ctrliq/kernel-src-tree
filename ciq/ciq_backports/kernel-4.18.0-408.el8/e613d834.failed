KVM: s390: Honor storage keys when accessing guest memory

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Janis Schoetterl-Glausch <scgl@linux.ibm.com>
commit e613d83454d7da1c37d78edb278db9c20afb21a2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/e613d834.failed

Storage key checking had not been implemented for instructions emulated
by KVM. Implement it by enhancing the functions used for guest access,
in particular those making use of access_guest which has been renamed
to access_guest_with_key.
Accesses via access_guest_real should not be key checked.

For actual accesses, key checking is done by
copy_from/to_user_key (which internally uses MVCOS/MVCP/MVCS).
In cases where accessibility is checked without an actual access,
this is performed by getting the storage key and checking if the access
key matches. In both cases, if applicable, storage and fetch protection
override are honored.

	Signed-off-by: Janis Schoetterl-Glausch <scgl@linux.ibm.com>
	Reviewed-by: Janosch Frank <frankja@linux.ibm.com>
	Reviewed-by: Christian Borntraeger <borntraeger@linux.ibm.com>
Link: https://lore.kernel.org/r/20220211182215.2730017-3-scgl@linux.ibm.com
	Signed-off-by: Christian Borntraeger <borntraeger@linux.ibm.com>
(cherry picked from commit e613d83454d7da1c37d78edb278db9c20afb21a2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/s390/include/asm/ctl_reg.h
#	arch/s390/kvm/gaccess.c
diff --cc arch/s390/include/asm/ctl_reg.h
index 4600453536c2,c800199a376b..000000000000
--- a/arch/s390/include/asm/ctl_reg.h
+++ b/arch/s390/include/asm/ctl_reg.h
@@@ -8,27 -8,28 +8,42 @@@
  #ifndef __ASM_CTL_REG_H
  #define __ASM_CTL_REG_H
  
 -#include <linux/bits.h>
 -
 +#include <linux/const.h>
 +
++<<<<<<< HEAD
 +#define CR0_CLOCK_COMPARATOR_SIGN	_BITUL(63 - 10)
 +#define CR0_EMERGENCY_SIGNAL_SUBMASK	_BITUL(63 - 49)
 +#define CR0_EXTERNAL_CALL_SUBMASK	_BITUL(63 - 50)
 +#define CR0_CLOCK_COMPARATOR_SUBMASK	_BITUL(63 - 52)
 +#define CR0_CPU_TIMER_SUBMASK		_BITUL(63 - 53)
 +#define CR0_SERVICE_SIGNAL_SUBMASK	_BITUL(63 - 54)
 +#define CR0_UNUSED_56			_BITUL(63 - 56)
 +#define CR0_INTERRUPT_KEY_SUBMASK	_BITUL(63 - 57)
 +#define CR0_MEASUREMENT_ALERT_SUBMASK	_BITUL(63 - 58)
++=======
+ #define CR0_CLOCK_COMPARATOR_SIGN	BIT(63 - 10)
+ #define CR0_LOW_ADDRESS_PROTECTION	BIT(63 - 35)
+ #define CR0_FETCH_PROTECTION_OVERRIDE	BIT(63 - 38)
+ #define CR0_STORAGE_PROTECTION_OVERRIDE	BIT(63 - 39)
+ #define CR0_EMERGENCY_SIGNAL_SUBMASK	BIT(63 - 49)
+ #define CR0_EXTERNAL_CALL_SUBMASK	BIT(63 - 50)
+ #define CR0_CLOCK_COMPARATOR_SUBMASK	BIT(63 - 52)
+ #define CR0_CPU_TIMER_SUBMASK		BIT(63 - 53)
+ #define CR0_SERVICE_SIGNAL_SUBMASK	BIT(63 - 54)
+ #define CR0_UNUSED_56			BIT(63 - 56)
+ #define CR0_INTERRUPT_KEY_SUBMASK	BIT(63 - 57)
+ #define CR0_MEASUREMENT_ALERT_SUBMASK	BIT(63 - 58)
++>>>>>>> e613d83454d7 (KVM: s390: Honor storage keys when accessing guest memory)
 +
 +#define CR2_GUARDED_STORAGE		_BITUL(63 - 59)
  
 -#define CR14_UNUSED_32			BIT(63 - 32)
 -#define CR14_UNUSED_33			BIT(63 - 33)
 -#define CR14_CHANNEL_REPORT_SUBMASK	BIT(63 - 35)
 -#define CR14_RECOVERY_SUBMASK		BIT(63 - 36)
 -#define CR14_DEGRADATION_SUBMASK	BIT(63 - 37)
 -#define CR14_EXTERNAL_DAMAGE_SUBMASK	BIT(63 - 38)
 -#define CR14_WARNING_SUBMASK		BIT(63 - 39)
 +#define CR14_UNUSED_32			_BITUL(63 - 32)
 +#define CR14_UNUSED_33			_BITUL(63 - 33)
 +#define CR14_CHANNEL_REPORT_SUBMASK	_BITUL(63 - 35)
 +#define CR14_RECOVERY_SUBMASK		_BITUL(63 - 36)
 +#define CR14_DEGRADATION_SUBMASK	_BITUL(63 - 37)
 +#define CR14_EXTERNAL_DAMAGE_SUBMASK	_BITUL(63 - 38)
 +#define CR14_WARNING_SUBMASK		_BITUL(63 - 39)
  
  #ifndef __ASSEMBLY__
  
diff --cc arch/s390/kvm/gaccess.c
index 3d68154dd4eb,7fca0cff4c12..000000000000
--- a/arch/s390/kvm/gaccess.c
+++ b/arch/s390/kvm/gaccess.c
@@@ -9,8 -9,9 +9,13 @@@
  #include <linux/vmalloc.h>
  #include <linux/mm_types.h>
  #include <linux/err.h>
++<<<<<<< HEAD
++=======
+ #include <linux/pgtable.h>
+ #include <linux/bitfield.h>
++>>>>>>> e613d83454d7 (KVM: s390: Honor storage keys when accessing guest memory)
  
 +#include <asm/pgtable.h>
  #include <asm/gmap.h>
  #include "kvm-s390.h"
  #include "gaccess.h"
* Unmerged path arch/s390/include/asm/ctl_reg.h
diff --git a/arch/s390/include/asm/page.h b/arch/s390/include/asm/page.h
index 62440a82731a..d9c5ab877a06 100644
--- a/arch/s390/include/asm/page.h
+++ b/arch/s390/include/asm/page.h
@@ -20,6 +20,8 @@
 #define PAGE_SIZE	_PAGE_SIZE
 #define PAGE_MASK	_PAGE_MASK
 #define PAGE_DEFAULT_ACC	0
+/* storage-protection override */
+#define PAGE_SPO_ACC		9
 #define PAGE_DEFAULT_KEY	(PAGE_DEFAULT_ACC << 4)
 
 #define HPAGE_SHIFT	20
* Unmerged path arch/s390/kvm/gaccess.c
diff --git a/arch/s390/kvm/gaccess.h b/arch/s390/kvm/gaccess.h
index 7c72a5e3449f..e5b2f56e7962 100644
--- a/arch/s390/kvm/gaccess.h
+++ b/arch/s390/kvm/gaccess.h
@@ -186,24 +186,31 @@ enum gacc_mode {
 	GACC_IFETCH,
 };
 
+int guest_translate_address_with_key(struct kvm_vcpu *vcpu, unsigned long gva, u8 ar,
+				     unsigned long *gpa, enum gacc_mode mode,
+				     u8 access_key);
+
 int guest_translate_address(struct kvm_vcpu *vcpu, unsigned long gva,
 			    u8 ar, unsigned long *gpa, enum gacc_mode mode);
+
 int check_gva_range(struct kvm_vcpu *vcpu, unsigned long gva, u8 ar,
-		    unsigned long length, enum gacc_mode mode);
+		    unsigned long length, enum gacc_mode mode, u8 access_key);
 
-int access_guest(struct kvm_vcpu *vcpu, unsigned long ga, u8 ar, void *data,
-		 unsigned long len, enum gacc_mode mode);
+int access_guest_with_key(struct kvm_vcpu *vcpu, unsigned long ga, u8 ar,
+			  void *data, unsigned long len, enum gacc_mode mode,
+			  u8 access_key);
 
 int access_guest_real(struct kvm_vcpu *vcpu, unsigned long gra,
 		      void *data, unsigned long len, enum gacc_mode mode);
 
 /**
- * write_guest - copy data from kernel space to guest space
+ * write_guest_with_key - copy data from kernel space to guest space
  * @vcpu: virtual cpu
  * @ga: guest address
  * @ar: access register
  * @data: source address in kernel space
  * @len: number of bytes to copy
+ * @access_key: access key the storage key needs to match
  *
  * Copy @len bytes from @data (kernel space) to @ga (guest address).
  * In order to copy data to guest space the PSW of the vcpu is inspected:
@@ -214,8 +221,8 @@ int access_guest_real(struct kvm_vcpu *vcpu, unsigned long gra,
  * The addressing mode of the PSW is also inspected, so that address wrap
  * around is taken into account for 24-, 31- and 64-bit addressing mode,
  * if the to be copied data crosses page boundaries in guest address space.
- * In addition also low address and DAT protection are inspected before
- * copying any data (key protection is currently not implemented).
+ * In addition low address, DAT and key protection checks are performed before
+ * copying any data.
  *
  * This function modifies the 'struct kvm_s390_pgm_info pgm' member of @vcpu.
  * In case of an access exception (e.g. protection exception) pgm will contain
@@ -243,10 +250,53 @@ int access_guest_real(struct kvm_vcpu *vcpu, unsigned long gra,
  *	 if data has been changed in guest space in case of an exception.
  */
 static inline __must_check
+int write_guest_with_key(struct kvm_vcpu *vcpu, unsigned long ga, u8 ar,
+			 void *data, unsigned long len, u8 access_key)
+{
+	return access_guest_with_key(vcpu, ga, ar, data, len, GACC_STORE,
+				     access_key);
+}
+
+/**
+ * write_guest - copy data from kernel space to guest space
+ * @vcpu: virtual cpu
+ * @ga: guest address
+ * @ar: access register
+ * @data: source address in kernel space
+ * @len: number of bytes to copy
+ *
+ * The behaviour of write_guest is identical to write_guest_with_key, except
+ * that the PSW access key is used instead of an explicit argument.
+ */
+static inline __must_check
 int write_guest(struct kvm_vcpu *vcpu, unsigned long ga, u8 ar, void *data,
 		unsigned long len)
 {
-	return access_guest(vcpu, ga, ar, data, len, GACC_STORE);
+	u8 access_key = psw_bits(vcpu->arch.sie_block->gpsw).key;
+
+	return write_guest_with_key(vcpu, ga, ar, data, len, access_key);
+}
+
+/**
+ * read_guest_with_key - copy data from guest space to kernel space
+ * @vcpu: virtual cpu
+ * @ga: guest address
+ * @ar: access register
+ * @data: destination address in kernel space
+ * @len: number of bytes to copy
+ * @access_key: access key the storage key needs to match
+ *
+ * Copy @len bytes from @ga (guest address) to @data (kernel space).
+ *
+ * The behaviour of read_guest_with_key is identical to write_guest_with_key,
+ * except that data will be copied from guest space to kernel space.
+ */
+static inline __must_check
+int read_guest_with_key(struct kvm_vcpu *vcpu, unsigned long ga, u8 ar,
+			void *data, unsigned long len, u8 access_key)
+{
+	return access_guest_with_key(vcpu, ga, ar, data, len, GACC_FETCH,
+				     access_key);
 }
 
 /**
@@ -259,14 +309,16 @@ int write_guest(struct kvm_vcpu *vcpu, unsigned long ga, u8 ar, void *data,
  *
  * Copy @len bytes from @ga (guest address) to @data (kernel space).
  *
- * The behaviour of read_guest is identical to write_guest, except that
- * data will be copied from guest space to kernel space.
+ * The behaviour of read_guest is identical to read_guest_with_key, except
+ * that the PSW access key is used instead of an explicit argument.
  */
 static inline __must_check
 int read_guest(struct kvm_vcpu *vcpu, unsigned long ga, u8 ar, void *data,
 	       unsigned long len)
 {
-	return access_guest(vcpu, ga, ar, data, len, GACC_FETCH);
+	u8 access_key = psw_bits(vcpu->arch.sie_block->gpsw).key;
+
+	return read_guest_with_key(vcpu, ga, ar, data, len, access_key);
 }
 
 /**
@@ -287,7 +339,10 @@ static inline __must_check
 int read_guest_instr(struct kvm_vcpu *vcpu, unsigned long ga, void *data,
 		     unsigned long len)
 {
-	return access_guest(vcpu, ga, 0, data, len, GACC_IFETCH);
+	u8 access_key = psw_bits(vcpu->arch.sie_block->gpsw).key;
+
+	return access_guest_with_key(vcpu, ga, 0, data, len, GACC_IFETCH,
+				     access_key);
 }
 
 /**
diff --git a/arch/s390/kvm/intercept.c b/arch/s390/kvm/intercept.c
index d07ff646d844..8bd42a20d924 100644
--- a/arch/s390/kvm/intercept.c
+++ b/arch/s390/kvm/intercept.c
@@ -331,18 +331,18 @@ static int handle_mvpg_pei(struct kvm_vcpu *vcpu)
 
 	kvm_s390_get_regs_rre(vcpu, &reg1, &reg2);
 
-	/* Make sure that the source is paged-in */
-	rc = guest_translate_address(vcpu, vcpu->run->s.regs.gprs[reg2],
-				     reg2, &srcaddr, GACC_FETCH);
+	/* Ensure that the source is paged-in, no actual access -> no key checking */
+	rc = guest_translate_address_with_key(vcpu, vcpu->run->s.regs.gprs[reg2],
+					      reg2, &srcaddr, GACC_FETCH, 0);
 	if (rc)
 		return kvm_s390_inject_prog_cond(vcpu, rc);
 	rc = kvm_arch_fault_in_page(vcpu, srcaddr, 0);
 	if (rc != 0)
 		return rc;
 
-	/* Make sure that the destination is paged-in */
-	rc = guest_translate_address(vcpu, vcpu->run->s.regs.gprs[reg1],
-				     reg1, &dstaddr, GACC_STORE);
+	/* Ensure that the source is paged-in, no actual access -> no key checking */
+	rc = guest_translate_address_with_key(vcpu, vcpu->run->s.regs.gprs[reg1],
+					      reg1, &dstaddr, GACC_STORE, 0);
 	if (rc)
 		return kvm_s390_inject_prog_cond(vcpu, rc);
 	rc = kvm_arch_fault_in_page(vcpu, dstaddr, 1);
diff --git a/arch/s390/kvm/kvm-s390.c b/arch/s390/kvm/kvm-s390.c
index 3586a7dbed80..5b74c71d2b28 100644
--- a/arch/s390/kvm/kvm-s390.c
+++ b/arch/s390/kvm/kvm-s390.c
@@ -4717,7 +4717,7 @@ static long kvm_s390_guest_mem_op(struct kvm_vcpu *vcpu,
 	case KVM_S390_MEMOP_LOGICAL_READ:
 		if (mop->flags & KVM_S390_MEMOP_F_CHECK_ONLY) {
 			r = check_gva_range(vcpu, mop->gaddr, mop->ar,
-					    mop->size, GACC_FETCH);
+					    mop->size, GACC_FETCH, 0);
 			break;
 		}
 		r = read_guest(vcpu, mop->gaddr, mop->ar, tmpbuf, mop->size);
@@ -4729,7 +4729,7 @@ static long kvm_s390_guest_mem_op(struct kvm_vcpu *vcpu,
 	case KVM_S390_MEMOP_LOGICAL_WRITE:
 		if (mop->flags & KVM_S390_MEMOP_F_CHECK_ONLY) {
 			r = check_gva_range(vcpu, mop->gaddr, mop->ar,
-					    mop->size, GACC_STORE);
+					    mop->size, GACC_STORE, 0);
 			break;
 		}
 		if (copy_from_user(tmpbuf, uaddr, mop->size)) {
