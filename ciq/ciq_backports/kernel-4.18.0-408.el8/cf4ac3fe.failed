dmaengine: idxd: fix lockdep warning on device driver removal

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Dave Jiang <dave.jiang@intel.com>
commit cf4ac3fef33883a14131d8925d7edfbdb7d69b68
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/cf4ac3fe.failed

Jacob reported that with lockdep debug turned on, idxd_device_driver
removal causes kernel splat from lock assert warning for
idxd_device_wqs_clear_state(). Make sure
idxd_device_wqs_clear_state() holds the wq lock for each wq when
cleaning the wq state. Move the call outside of the device spinlock.

	Reported-by: Jacob Pan <jacob.jun.pan@intel.com>
	Signed-off-by: Dave Jiang <dave.jiang@intel.com>
Link: https://lore.kernel.org/r/165231364426.986304.9294302800482492780.stgit@djiang5-desk3.ch.intel.com
	Signed-off-by: Vinod Koul <vkoul@kernel.org>
(cherry picked from commit cf4ac3fef33883a14131d8925d7edfbdb7d69b68)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/dma/idxd/device.c
diff --cc drivers/dma/idxd/device.c
index cac50f25271e,001a82040e98..000000000000
--- a/drivers/dma/idxd/device.c
+++ b/drivers/dma/idxd/device.c
@@@ -569,22 -578,17 +569,33 @@@ int idxd_device_disable(struct idxd_dev
  		return -ENXIO;
  	}
  
++<<<<<<< HEAD
 +	spin_lock_irqsave(&idxd->dev_lock, flags);
 +	idxd_device_clear_state(idxd);
 +	idxd->state = IDXD_DEV_DISABLED;
 +	spin_unlock_irqrestore(&idxd->dev_lock, flags);
++=======
+ 	idxd_device_clear_state(idxd);
++>>>>>>> cf4ac3fef338 (dmaengine: idxd: fix lockdep warning on device driver removal)
  	return 0;
  }
  
  void idxd_device_reset(struct idxd_device *idxd)
  {
 +	unsigned long flags;
 +
  	idxd_cmd_exec(idxd, IDXD_CMD_RESET_DEVICE, 0, NULL);
++<<<<<<< HEAD
 +	spin_lock_irqsave(&idxd->dev_lock, flags);
 +	idxd_device_clear_state(idxd);
 +	idxd->state = IDXD_DEV_DISABLED;
 +	spin_unlock_irqrestore(&idxd->dev_lock, flags);
++=======
+ 	idxd_device_clear_state(idxd);
+ 	spin_lock(&idxd->dev_lock);
+ 	idxd_unmask_error_interrupts(idxd);
+ 	spin_unlock(&idxd->dev_lock);
++>>>>>>> cf4ac3fef338 (dmaengine: idxd: fix lockdep warning on device driver removal)
  }
  
  void idxd_device_drain_pasid(struct idxd_device *idxd, int pasid)
@@@ -723,41 -728,14 +735,44 @@@ static void idxd_device_wqs_clear_state
  
  void idxd_device_clear_state(struct idxd_device *idxd)
  {
+ 	idxd_device_wqs_clear_state(idxd);
+ 	spin_lock(&idxd->dev_lock);
  	idxd_groups_clear_state(idxd);
  	idxd_engines_clear_state(idxd);
- 	idxd_device_wqs_clear_state(idxd);
+ 	idxd->state = IDXD_DEV_DISABLED;
+ 	spin_unlock(&idxd->dev_lock);
  }
  
 +void idxd_msix_perm_setup(struct idxd_device *idxd)
 +{
 +	union msix_perm mperm;
 +	int i, msixcnt;
 +
 +	msixcnt = pci_msix_vec_count(idxd->pdev);
 +	if (msixcnt < 0)
 +		return;
 +
 +	mperm.bits = 0;
 +	mperm.pasid = idxd->pasid;
 +	mperm.pasid_en = device_pasid_enabled(idxd);
 +	for (i = 1; i < msixcnt; i++)
 +		iowrite32(mperm.bits, idxd->reg_base + idxd->msix_perm_offset + i * 8);
 +}
 +
 +void idxd_msix_perm_clear(struct idxd_device *idxd)
 +{
 +	union msix_perm mperm;
 +	int i, msixcnt;
 +
 +	msixcnt = pci_msix_vec_count(idxd->pdev);
 +	if (msixcnt < 0)
 +		return;
 +
 +	mperm.bits = 0;
 +	for (i = 1; i < msixcnt; i++)
 +		iowrite32(mperm.bits, idxd->reg_base + idxd->msix_perm_offset + i * 8);
 +}
 +
  static void idxd_group_config_write(struct idxd_group *group)
  {
  	struct idxd_device *idxd = group->idxd;
* Unmerged path drivers/dma/idxd/device.c
