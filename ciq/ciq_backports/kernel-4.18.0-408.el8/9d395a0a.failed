KVM: x86/mmu: Remove need for a vcpu from kvm_slot_page_track_is_active

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Ben Gardon <bgardon@google.com>
commit 9d395a0a7aca75caa72a8ab11a6efc9909c5a918
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/9d395a0a.failed

kvm_slot_page_track_is_active only uses its vCPU argument to get a
pointer to the assoicated struct kvm, so just pass in the struct KVM to
remove the need for a vCPU pointer.

No functional change intended.

	Signed-off-by: Ben Gardon <bgardon@google.com>
Message-Id: <20211115234603.2908381-6-bgardon@google.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 9d395a0a7aca75caa72a8ab11a6efc9909c5a918)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/kvm_page_track.h
#	arch/x86/kvm/mmu/mmu.c
#	arch/x86/kvm/mmu/page_track.c
diff --cc arch/x86/include/asm/kvm_page_track.h
index 9cd9230e5cc8,e99a30a4d38b..000000000000
--- a/arch/x86/include/asm/kvm_page_track.h
+++ b/arch/x86/include/asm/kvm_page_track.h
@@@ -59,9 -63,8 +59,14 @@@ void kvm_slot_page_track_add_page(struc
  void kvm_slot_page_track_remove_page(struct kvm *kvm,
  				     struct kvm_memory_slot *slot, gfn_t gfn,
  				     enum kvm_page_track_mode mode);
++<<<<<<< HEAD
 +bool kvm_page_track_is_active(struct kvm_vcpu *vcpu, gfn_t gfn,
 +			      enum kvm_page_track_mode mode);
 +bool kvm_slot_page_track_is_active(struct kvm_memory_slot *slot, gfn_t gfn,
++=======
+ bool kvm_slot_page_track_is_active(struct kvm *kvm,
+ 				   struct kvm_memory_slot *slot, gfn_t gfn,
++>>>>>>> 9d395a0a7aca (KVM: x86/mmu: Remove need for a vcpu from kvm_slot_page_track_is_active)
  				   enum kvm_page_track_mode mode);
  
  void
diff --cc arch/x86/kvm/mmu/mmu.c
index 970fc4a0eb93,2ea6e5e1fde9..000000000000
--- a/arch/x86/kvm/mmu/mmu.c
+++ b/arch/x86/kvm/mmu/mmu.c
@@@ -2594,7 -2591,7 +2594,11 @@@ int mmu_try_to_unsync_pages(struct kvm_
  	 * track machinery is used to write-protect upper-level shadow pages,
  	 * i.e. this guards the role.level == 4K assertion below!
  	 */
++<<<<<<< HEAD
 +	if (kvm_page_track_is_active(vcpu, gfn, KVM_PAGE_TRACK_WRITE))
++=======
+ 	if (kvm_slot_page_track_is_active(vcpu->kvm, slot, gfn, KVM_PAGE_TRACK_WRITE))
++>>>>>>> 9d395a0a7aca (KVM: x86/mmu: Remove need for a vcpu from kvm_slot_page_track_is_active)
  		return -EPERM;
  
  	/*
@@@ -3854,7 -3888,7 +3858,11 @@@ static bool page_fault_handle_page_trac
  	 * guest is writing the page which is write tracked which can
  	 * not be fixed by page fault handler.
  	 */
++<<<<<<< HEAD
 +	if (kvm_slot_page_track_is_active(fault->slot, fault->gfn, KVM_PAGE_TRACK_WRITE))
++=======
+ 	if (kvm_slot_page_track_is_active(vcpu->kvm, fault->slot, fault->gfn, KVM_PAGE_TRACK_WRITE))
++>>>>>>> 9d395a0a7aca (KVM: x86/mmu: Remove need for a vcpu from kvm_slot_page_track_is_active)
  		return true;
  
  	return false;
diff --cc arch/x86/kvm/mmu/page_track.c
index 58985087b096,35c221d5f6ce..000000000000
--- a/arch/x86/kvm/mmu/page_track.c
+++ b/arch/x86/kvm/mmu/page_track.c
@@@ -135,7 -170,11 +135,15 @@@ void kvm_slot_page_track_remove_page(st
  }
  EXPORT_SYMBOL_GPL(kvm_slot_page_track_remove_page);
  
++<<<<<<< HEAD
 +bool kvm_slot_page_track_is_active(struct kvm_memory_slot *slot, gfn_t gfn,
++=======
+ /*
+  * check if the corresponding access on the specified guest page is tracked.
+  */
+ bool kvm_slot_page_track_is_active(struct kvm *kvm,
+ 				   struct kvm_memory_slot *slot, gfn_t gfn,
++>>>>>>> 9d395a0a7aca (KVM: x86/mmu: Remove need for a vcpu from kvm_slot_page_track_is_active)
  				   enum kvm_page_track_mode mode)
  {
  	int index;
@@@ -146,6 -185,10 +154,13 @@@
  	if (!slot)
  		return false;
  
++<<<<<<< HEAD
++=======
+ 	if (mode == KVM_PAGE_TRACK_WRITE &&
+ 	    !kvm_page_track_write_tracking_enabled(kvm))
+ 		return false;
+ 
++>>>>>>> 9d395a0a7aca (KVM: x86/mmu: Remove need for a vcpu from kvm_slot_page_track_is_active)
  	index = gfn_to_index(gfn, slot->base_gfn, PG_LEVEL_4K);
  	return !!READ_ONCE(slot->arch.gfn_track[mode][index]);
  }
* Unmerged path arch/x86/include/asm/kvm_page_track.h
* Unmerged path arch/x86/kvm/mmu/mmu.c
* Unmerged path arch/x86/kvm/mmu/page_track.c
