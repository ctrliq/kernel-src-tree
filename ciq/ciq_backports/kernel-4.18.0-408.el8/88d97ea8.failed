dmaengine: idxd: add halt interrupt support

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Dave Jiang <dave.jiang@intel.com>
commit 88d97ea82cbe352851a8654ee952d3a694c8c2c6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/88d97ea8.failed

Add halt interrupt support. Given that the misc interrupt handler already
check halt state, the driver just need to run the halt handling code when
receiving the halt interrupt.

	Signed-off-by: Dave Jiang <dave.jiang@intel.com>
Link: https://lore.kernel.org/r/163114224352.846654.14334468363464318828.stgit@djiang5-desk3.ch.intel.com
	Signed-off-by: Vinod Koul <vkoul@kernel.org>
(cherry picked from commit 88d97ea82cbe352851a8654ee952d3a694c8c2c6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/dma/idxd/irq.c
diff --cc drivers/dma/idxd/irq.c
index 7a2cf0512501,17f2f8a31b63..000000000000
--- a/drivers/dma/idxd/irq.c
+++ b/drivers/dma/idxd/irq.c
@@@ -110,8 -63,11 +110,11 @@@ static int process_misc_interrupts(stru
  	int i;
  	bool err = false;
  
+ 	if (cause & IDXD_INTC_HALT_STATE)
+ 		goto halt;
+ 
  	if (cause & IDXD_INTC_ERR) {
 -		spin_lock(&idxd->dev_lock);
 +		spin_lock_bh(&idxd->dev_lock);
  		for (i = 0; i < 4; i++)
  			idxd->sw_err.bits[i] = ioread64(idxd->reg_base +
  					IDXD_SWERR_OFFSET + i * sizeof(u64));
@@@ -168,15 -124,7 +171,19 @@@
  	if (!err)
  		return 0;
  
++<<<<<<< HEAD
 +	/*
 +	 * This case should rarely happen and typically is due to software
 +	 * programming error by the driver.
 +	 */
 +	if (idxd->sw_err.valid &&
 +	    idxd->sw_err.desc_valid &&
 +	    idxd->sw_err.fault_addr)
 +		idxd_device_schedule_fault_process(idxd, idxd->sw_err.fault_addr);
 +
++=======
+ halt:
++>>>>>>> 88d97ea82cbe (dmaengine: idxd: add halt interrupt support)
  	gensts.bits = ioread32(idxd->reg_base + IDXD_GENSTATS_OFFSET);
  	if (gensts.state == IDXD_DEVICE_STATE_HALT) {
  		idxd->state = IDXD_DEV_HALTED;
@@@ -189,7 -137,8 +196,12 @@@
  			INIT_WORK(&idxd->work, idxd_device_reinit);
  			queue_work(idxd->wq, &idxd->work);
  		} else {
++<<<<<<< HEAD
 +			spin_lock_bh(&idxd->dev_lock);
++=======
+ 			spin_lock(&idxd->dev_lock);
+ 			idxd->state = IDXD_DEV_HALTED;
++>>>>>>> 88d97ea82cbe (dmaengine: idxd: add halt interrupt support)
  			idxd_wqs_quiesce(idxd);
  			idxd_wqs_unmap_portal(idxd);
  			idxd_device_clear_state(idxd);
* Unmerged path drivers/dma/idxd/irq.c
diff --git a/drivers/dma/idxd/registers.h b/drivers/dma/idxd/registers.h
index eeb11e6eb25b..262c8220adbd 100644
--- a/drivers/dma/idxd/registers.h
+++ b/drivers/dma/idxd/registers.h
@@ -157,6 +157,7 @@ enum idxd_device_reset_type {
 #define IDXD_INTC_CMD			0x02
 #define IDXD_INTC_OCCUPY			0x04
 #define IDXD_INTC_PERFMON_OVFL		0x08
+#define IDXD_INTC_HALT_STATE		0x10
 
 #define IDXD_CMD_OFFSET			0xa0
 union idxd_command_reg {
