dmaengine: idxd: fix abort status check

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Dave Jiang <dave.jiang@intel.com>
commit b60bb6e2bfc192091b8f792781b83b5e0f9324f6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/b60bb6e2.failed

Coverity static analysis of linux-next found issue.

The check (status == IDXD_COMP_DESC_ABORT) is always false since status
was previously masked with 0x7f and IDXD_COMP_DESC_ABORT is 0xff.

Fixes: 6b4b87f2c31a ("dmaengine: idxd: fix submission race window")
	Reported-by: Colin Ian King <colin.king@canonical.com>
	Signed-off-by: Dave Jiang <dave.jiang@intel.com>
Link: https://lore.kernel.org/r/162698465160.3560828.18173186265683415384.stgit@djiang5-desk3.ch.intel.com
	Signed-off-by: Vinod Koul <vkoul@kernel.org>
(cherry picked from commit b60bb6e2bfc192091b8f792781b83b5e0f9324f6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/dma/idxd/irq.c
diff --cc drivers/dma/idxd/irq.c
index 7a2cf0512501,65dc7bbb0a13..000000000000
--- a/drivers/dma/idxd/irq.c
+++ b/drivers/dma/idxd/irq.c
@@@ -266,16 -190,21 +266,33 @@@ static int irq_process_pending_llist(st
  	if (!head)
  		goto out;
  
 +	if (wtype == IRQ_WORK_NORMAL)
 +		reason = IDXD_COMPLETE_NORMAL;
 +	else
 +		reason = IDXD_COMPLETE_DEV_FAIL;
 +
  	llist_for_each_entry_safe(desc, t, head, llnode) {
++<<<<<<< HEAD
 +		if (desc->completion->status) {
 +			if ((desc->completion->status & DSA_COMP_STATUS_MASK) != DSA_COMP_SUCCESS)
 +				match_fault(desc, data);
 +			complete_desc(desc, reason);
++=======
+ 		u8 status = desc->completion->status & DSA_COMP_STATUS_MASK;
+ 
+ 		if (status) {
+ 			/*
+ 			 * Check against the original status as ABORT is software defined
+ 			 * and 0xff, which DSA_COMP_STATUS_MASK can mask out.
+ 			 */
+ 			if (unlikely(desc->completion->status == IDXD_COMP_DESC_ABORT)) {
+ 				complete_desc(desc, IDXD_COMPLETE_ABORT);
+ 				(*processed)++;
+ 				continue;
+ 			}
+ 
+ 			complete_desc(desc, IDXD_COMPLETE_NORMAL);
++>>>>>>> b60bb6e2bfc1 (dmaengine: idxd: fix abort status check)
  			(*processed)++;
  		} else {
  			spin_lock_irqsave(&irq_entry->list_lock, flags);
@@@ -329,9 -252,18 +346,24 @@@ static int irq_process_work_list(struc
  	spin_unlock_irqrestore(&irq_entry->list_lock, flags);
  
  	list_for_each_entry(desc, &flist, list) {
++<<<<<<< HEAD
 +		if ((desc->completion->status & DSA_COMP_STATUS_MASK) != DSA_COMP_SUCCESS)
 +			match_fault(desc, data);
 +		complete_desc(desc, reason);
++=======
+ 		u8 status = desc->completion->status & DSA_COMP_STATUS_MASK;
+ 
+ 		/*
+ 		 * Check against the original status as ABORT is software defined
+ 		 * and 0xff, which DSA_COMP_STATUS_MASK can mask out.
+ 		 */
+ 		if (unlikely(desc->completion->status == IDXD_COMP_DESC_ABORT)) {
+ 			complete_desc(desc, IDXD_COMPLETE_ABORT);
+ 			continue;
+ 		}
+ 
+ 		complete_desc(desc, IDXD_COMPLETE_NORMAL);
++>>>>>>> b60bb6e2bfc1 (dmaengine: idxd: fix abort status check)
  	}
  
  	return queued;
* Unmerged path drivers/dma/idxd/irq.c
