net/smc: Introduce tracepoints for tx and rx msg

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Tony Lu <tonylu@linux.alibaba.com>
commit aff3083f10bff7a37eaa2b4e6bc5fb627ddd5f84
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/aff3083f.failed

This introduce two tracepoints for smc tx and rx msg to help us
diagnosis issues of data path. These two tracepoitns don't cover the
path of CORK or MSG_MORE in tx, just the top half of data path.

	Signed-off-by: Tony Lu <tonylu@linux.alibaba.com>
	Reviewed-by: Wen Gu <guwen@linux.alibaba.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit aff3083f10bff7a37eaa2b4e6bc5fb627ddd5f84)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/smc/smc_tracepoint.c
#	net/smc/smc_tracepoint.h
* Unmerged path net/smc/smc_tracepoint.c
* Unmerged path net/smc/smc_tracepoint.h
diff --git a/net/smc/smc_rx.c b/net/smc/smc_rx.c
index b8eb9e5c63fe..1fd769e62cb0 100644
--- a/net/smc/smc_rx.c
+++ b/net/smc/smc_rx.c
@@ -22,6 +22,7 @@
 #include "smc_tx.h" /* smc_tx_consumer_update() */
 #include "smc_rx.h"
 #include "smc_stats.h"
+#include "smc_tracepoint.h"
 
 /* callback implementation to wakeup consumers blocked with smc_rx_wait().
  * indirectly called by smc_cdc_msg_recv_action().
@@ -447,6 +448,8 @@ int smc_rx_recvmsg(struct smc_sock *smc, struct msghdr *msg,
 			if (msg && smc_rx_update_consumer(smc, cons, copylen))
 				goto out;
 		}
+
+		trace_smc_rx_recvmsg(smc, copylen);
 	} while (read_remaining);
 out:
 	return read_done;
* Unmerged path net/smc/smc_tracepoint.c
* Unmerged path net/smc/smc_tracepoint.h
diff --git a/net/smc/smc_tx.c b/net/smc/smc_tx.c
index 738a4a99c827..be241d53020f 100644
--- a/net/smc/smc_tx.c
+++ b/net/smc/smc_tx.c
@@ -28,6 +28,7 @@
 #include "smc_ism.h"
 #include "smc_tx.h"
 #include "smc_stats.h"
+#include "smc_tracepoint.h"
 
 #define SMC_TX_WORK_DELAY	0
 #define SMC_TX_CORK_DELAY	(HZ >> 2)	/* 250 ms */
@@ -245,6 +246,8 @@ int smc_tx_sendmsg(struct smc_sock *smc, struct msghdr *msg, size_t len)
 					   SMC_TX_CORK_DELAY);
 		else
 			smc_tx_sndbuf_nonempty(conn);
+
+		trace_smc_tx_sendmsg(smc, copylen);
 	} /* while (msg_data_left(msg)) */
 
 	return send_done;
