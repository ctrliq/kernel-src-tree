KVM: x86/mmu: do not consult levels when freeing roots

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Paolo Bonzini <pbonzini@redhat.com>
commit 594bef7931089cbdeaf7d8954d54535c8ddd4b30
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/594bef79.failed

Right now, PGD caching requires a complicated dance of first computing
the MMU role and passing it to __kvm_mmu_new_pgd(), and then separately calling
kvm_init_mmu().

Part of this is due to kvm_mmu_free_roots using mmu->root_level and
mmu->shadow_root_level to distinguish whether the page table uses a single
root or 4 PAE roots.  Because kvm_init_mmu() can overwrite mmu->root_level,
kvm_mmu_free_roots() must be called before kvm_init_mmu().

However, even after kvm_init_mmu() there is a way to detect whether the
page table may hold PAE roots, as root.hpa isn't backed by a shadow when
it points at PAE roots.  Using this method results in simpler code, and
is one less obstacle in moving all calls to __kvm_mmu_new_pgd() after the
MMU has been initialized.

	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 594bef7931089cbdeaf7d8954d54535c8ddd4b30)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/mmu/mmu.c
diff --cc arch/x86/kvm/mmu/mmu.c
index bdbeb3101d0e,b97ff7601d0a..000000000000
--- a/arch/x86/kvm/mmu/mmu.c
+++ b/arch/x86/kvm/mmu/mmu.c
@@@ -3282,7 -3229,10 +3282,14 @@@ void kvm_mmu_free_roots(struct kvm_vcp
  	BUILD_BUG_ON(KVM_MMU_NUM_PREV_ROOTS >= BITS_PER_LONG);
  
  	/* Before acquiring the MMU lock, see if we need to do any real work. */
++<<<<<<< HEAD
 +	if (!(free_active_root && VALID_PAGE(mmu->root_hpa))) {
++=======
+ 	free_active_root = (roots_to_free & KVM_MMU_ROOT_CURRENT)
+ 		&& VALID_PAGE(mmu->root.hpa);
+ 
+ 	if (!free_active_root) {
++>>>>>>> 594bef793108 (KVM: x86/mmu: do not consult levels when freeing roots)
  		for (i = 0; i < KVM_MMU_NUM_PREV_ROOTS; i++)
  			if ((roots_to_free & KVM_MMU_ROOT_PREVIOUS(i)) &&
  			    VALID_PAGE(mmu->prev_roots[i].hpa))
@@@ -3300,9 -3250,8 +3307,14 @@@
  					   &invalid_list);
  
  	if (free_active_root) {
++<<<<<<< HEAD
 +		if (mmu->shadow_root_level >= PT64_ROOT_4LEVEL &&
 +		    (mmu->root_level >= PT64_ROOT_4LEVEL || mmu->direct_map)) {
 +			mmu_free_root_page(kvm, &mmu->root_hpa, &invalid_list);
++=======
+ 		if (to_shadow_page(mmu->root.hpa)) {
+ 			mmu_free_root_page(kvm, &mmu->root.hpa, &invalid_list);
++>>>>>>> 594bef793108 (KVM: x86/mmu: do not consult levels when freeing roots)
  		} else if (mmu->pae_root) {
  			for (i = 0; i < 4; ++i) {
  				if (!IS_VALID_PAE_ROOT(mmu->pae_root[i]))
* Unmerged path arch/x86/kvm/mmu/mmu.c
