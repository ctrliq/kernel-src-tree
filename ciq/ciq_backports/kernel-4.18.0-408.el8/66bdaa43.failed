dm: fold __clone_and_map_data_bio into __split_and_process_bio

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Mike Snitzer <snitzer@redhat.com>
commit 66bdaa4302d3b58d1f8f2afcdd424addc9a80e3c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/66bdaa43.failed

Fold __clone_and_map_data_bio into its only caller.

	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Mikulas Patocka <mpatocka@redhat.com>
	Signed-off-by: Mike Snitzer <snitzer@redhat.com>
(cherry picked from commit 66bdaa4302d3b58d1f8f2afcdd424addc9a80e3c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/md/dm.c
diff --cc drivers/md/dm.c
index 495368816d3f,bed236d604f8..000000000000
--- a/drivers/md/dm.c
+++ b/drivers/md/dm.c
@@@ -1335,59 -1207,15 +1335,62 @@@ static void bio_setup_sector(struct bi
  	bio->bi_iter.bi_size = to_bytes(len);
  }
  
++<<<<<<< HEAD
 +/*
 + * Creates a bio that consists of range of complete bvecs.
 + */
 +static int clone_bio(struct dm_target_io *tio, struct bio *bio,
 +		     sector_t sector, unsigned len)
 +{
 +	struct bio *clone = &tio->clone;
 +
 +	__bio_clone_fast(clone, bio);
 +
 +	if (bio_integrity(bio)) {
 +		int r;
 +
 +		if (unlikely(!dm_target_has_integrity(tio->ti->type) &&
 +			     !dm_target_passes_integrity(tio->ti->type))) {
 +			DMWARN("%s: the target %s doesn't support integrity data.",
 +				dm_device_name(tio->io->md),
 +				tio->ti->type->name);
 +			return -EIO;
 +		}
 +
 +		r = bio_integrity_clone(clone, bio, GFP_NOIO);
 +		if (r < 0)
 +			return r;
 +	}
 +
 +	bio_advance(clone, to_bytes(sector - clone->bi_iter.bi_sector));
 +	clone->bi_iter.bi_size = to_bytes(len);
 +
 +	if (bio_integrity(bio))
 +		bio_integrity_trim(clone);
 +
 +	return 0;
 +}
 +
++=======
++>>>>>>> 66bdaa4302d3 (dm: fold __clone_and_map_data_bio into __split_and_process_bio)
  static void alloc_multiple_bios(struct bio_list *blist, struct clone_info *ci,
 -				struct dm_target *ti, unsigned num_bios,
 -				unsigned *len)
 +				struct dm_target *ti, unsigned num_bios)
  {
 -	struct bio *bio;
 +	struct dm_target_io *tio;
  	int try;
  
 +	if (!num_bios)
 +		return;
 +
 +	if (num_bios == 1) {
 +		tio = alloc_tio(ci, ti, 0, GFP_NOIO);
 +		bio_list_add(blist, &tio->clone);
 +		return;
 +	}
 +
  	for (try = 0; try < 2; try++) {
  		int bio_nr;
 +		struct bio *bio;
  
  		if (try)
  			mutex_lock(&ci->io->md->table_devices_lock);
@@@ -1573,8 -1359,9 +1576,9 @@@ static bool __process_abnormal_io(struc
  /*
   * Select the correct strategy for processing a non-flush bio.
   */
 -static int __split_and_process_bio(struct clone_info *ci)
 +static int __split_and_process_non_flush(struct clone_info *ci)
  {
+ 	struct bio *clone;
  	struct dm_target *ti;
  	unsigned len;
  	int r;
* Unmerged path drivers/md/dm.c
