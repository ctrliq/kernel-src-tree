KVM: arm64: Convert to the gfn-based MMU notifier callbacks

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Sean Christopherson <seanjc@google.com>
commit cd4c7183522817087278b3e000b8a888f9f91b5c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/cd4c7183.failed

Move arm64 to the gfn-base MMU notifier APIs, which do the hva->gfn
lookup in common code.

No meaningful functional change intended, though the exact order of
operations is slightly different since the memslot lookups occur before
calling into arch code.

	Reviewed-by: Marc Zyngier <maz@kernel.org>
	Tested-by: Marc Zyngier <maz@kernel.org>
	Signed-off-by: Sean Christopherson <seanjc@google.com>
Message-Id: <20210402005658.3024832-4-seanjc@google.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit cd4c7183522817087278b3e000b8a888f9f91b5c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/arm64/kvm/mmu.c
diff --cc arch/arm64/kvm/mmu.c
index 60713ffdcad4,35728231e9a0..000000000000
--- a/arch/arm64/kvm/mmu.c
+++ b/arch/arm64/kvm/mmu.c
@@@ -2019,150 -1064,70 +2019,200 @@@ out_unlock
  	return ret;
  }
  
++<<<<<<< HEAD
 +static int handle_hva_to_gpa(struct kvm *kvm,
 +			     unsigned long start,
 +			     unsigned long end,
 +			     int (*handler)(struct kvm *kvm,
 +					    gpa_t gpa, u64 size,
 +					    void *data),
 +			     void *data)
 +{
 +	struct kvm_memslots *slots;
 +	struct kvm_memory_slot *memslot;
 +	int ret = 0;
 +
 +	slots = kvm_memslots(kvm);
 +
 +	/* we only care about the pages that the guest sees */
 +	kvm_for_each_memslot(memslot, slots) {
 +		unsigned long hva_start, hva_end;
 +		gfn_t gpa;
 +
 +		hva_start = max(start, memslot->userspace_addr);
 +		hva_end = min(end, memslot->userspace_addr +
 +					(memslot->npages << PAGE_SHIFT));
 +		if (hva_start >= hva_end)
 +			continue;
 +
 +		gpa = hva_to_gfn_memslot(hva_start, memslot) << PAGE_SHIFT;
 +		ret |= handler(kvm, gpa, (u64)(hva_end - hva_start), data);
 +	}
 +
 +	return ret;
 +}
 +
 +static int kvm_unmap_hva_handler(struct kvm *kvm, gpa_t gpa, u64 size, void *data)
 +{
 +	unsigned flags = *(unsigned *)data;
 +	bool may_block = flags & MMU_NOTIFIER_RANGE_BLOCKABLE;
 +
 +	__unmap_stage2_range(kvm, gpa, size, may_block);
 +	return 0;
 +}
 +
 +int kvm_unmap_hva_range(struct kvm *kvm,
 +			unsigned long start, unsigned long end, unsigned flags)
++=======
+ bool kvm_unmap_gfn_range(struct kvm *kvm, struct kvm_gfn_range *range)
++>>>>>>> cd4c71835228 (KVM: arm64: Convert to the gfn-based MMU notifier callbacks)
  {
 -	if (!kvm->arch.mmu.pgt)
 +	if (!kvm->arch.pgd)
  		return 0;
  
- 	handle_hva_to_gpa(kvm, start, end, &kvm_unmap_hva_handler, &flags);
+ 	__unmap_stage2_range(&kvm->arch.mmu, range->start << PAGE_SHIFT,
+ 			     (range->end - range->start) << PAGE_SHIFT,
+ 			     range->may_block);
+ 
  	return 0;
  }
  
- static int kvm_set_spte_handler(struct kvm *kvm, gpa_t gpa, u64 size, void *data)
+ bool kvm_set_spte_gfn(struct kvm *kvm, struct kvm_gfn_range *range)
  {
++<<<<<<< HEAD
 +	pte_t *pte = (pte_t *)data;
 +
 +	WARN_ON(size != PAGE_SIZE);
 +	/*
 +	 * We can always call stage2_set_pte with KVM_S2PTE_FLAG_LOGGING_ACTIVE
 +	 * flag clear because MMU notifiers will have unmapped a huge PMD before
 +	 * calling ->change_pte() (which in turn calls kvm_set_spte_hva()) and
 +	 * therefore stage2_set_pte() never needs to clear out a huge PMD
 +	 * through this calling path.
 +	 */
 +	stage2_set_pte(kvm, NULL, gpa, pte, 0);
 +	return 0;
 +}
 +
 +
 +int kvm_set_spte_hva(struct kvm *kvm, unsigned long hva, pte_t pte)
 +{
 +	unsigned long end = hva + PAGE_SIZE;
 +	kvm_pfn_t pfn = pte_pfn(pte);
 +	pte_t stage2_pte;
++=======
+ 	kvm_pfn_t pfn = pte_pfn(range->pte);
++>>>>>>> cd4c71835228 (KVM: arm64: Convert to the gfn-based MMU notifier callbacks)
  
 -	if (!kvm->arch.mmu.pgt)
 +	if (!kvm->arch.pgd)
  		return 0;
  
+ 	WARN_ON(range->end - range->start != 1);
+ 
  	/*
  	 * We've moved a page around, probably through CoW, so let's treat it
  	 * just like a translation fault and clean the cache to the PoC.
  	 */
  	clean_dcache_guest_page(pfn, PAGE_SIZE);
++<<<<<<< HEAD
 +	stage2_pte = kvm_pfn_pte(pfn, PAGE_S2);
 +	handle_hva_to_gpa(kvm, hva, end, &kvm_set_spte_handler, &stage2_pte);
++=======
+ 
+ 	/*
+ 	 * The MMU notifiers will have unmapped a huge PMD before calling
+ 	 * ->change_pte() (which in turn calls kvm_set_spte_gfn()) and
+ 	 * therefore we never need to clear out a huge PMD through this
+ 	 * calling path and a memcache is not required.
+ 	 */
+ 	kvm_pgtable_stage2_map(kvm->arch.mmu.pgt, range->start << PAGE_SHIFT,
+ 			       PAGE_SIZE, __pfn_to_phys(pfn),
+ 			       KVM_PGTABLE_PROT_R, NULL);
++>>>>>>> cd4c71835228 (KVM: arm64: Convert to the gfn-based MMU notifier callbacks)
  
  	return 0;
  }
  
- static int kvm_age_hva_handler(struct kvm *kvm, gpa_t gpa, u64 size, void *data)
+ bool kvm_age_gfn(struct kvm *kvm, struct kvm_gfn_range *range)
  {
++<<<<<<< HEAD
 +	pud_t *pud;
 +	pmd_t *pmd;
 +	pte_t *pte;
 +
 +	WARN_ON(size != PAGE_SIZE && size != PMD_SIZE && size != PUD_SIZE);
 +	if (!stage2_get_leaf_entry(kvm, gpa, &pud, &pmd, &pte))
 +		return 0;
 +
 +	if (pud)
 +		return stage2_pudp_test_and_clear_young(pud);
 +	else if (pmd)
 +		return stage2_pmdp_test_and_clear_young(pmd);
 +	else
 +		return stage2_ptep_test_and_clear_young(pte);
 +}
 +
 +static int kvm_test_age_hva_handler(struct kvm *kvm, gpa_t gpa, u64 size, void *data)
 +{
 +	pud_t *pud;
 +	pmd_t *pmd;
 +	pte_t *pte;
 +
 +	WARN_ON(size != PAGE_SIZE && size != PMD_SIZE && size != PUD_SIZE);
 +	if (!stage2_get_leaf_entry(kvm, gpa, &pud, &pmd, &pte))
 +		return 0;
 +
 +	if (pud)
 +		return kvm_s2pud_young(*pud);
 +	else if (pmd)
 +		return pmd_young(*pmd);
 +	else
 +		return pte_young(*pte);
 +}
 +
 +int kvm_age_hva(struct kvm *kvm, unsigned long start, unsigned long end)
++=======
+ 	u64 size = (range->end - range->start) << PAGE_SHIFT;
+ 	kvm_pte_t kpte;
+ 	pte_t pte;
+ 
+ 	if (!kvm->arch.mmu.pgt)
+ 		return 0;
+ 
+ 	WARN_ON(size != PAGE_SIZE && size != PMD_SIZE && size != PUD_SIZE);
+ 
+ 	kpte = kvm_pgtable_stage2_mkold(kvm->arch.mmu.pgt,
+ 					range->start << PAGE_SHIFT);
+ 	pte = __pte(kpte);
+ 	return pte_valid(pte) && pte_young(pte);
+ }
+ 
+ bool kvm_test_age_gfn(struct kvm *kvm, struct kvm_gfn_range *range)
++>>>>>>> cd4c71835228 (KVM: arm64: Convert to the gfn-based MMU notifier callbacks)
  {
 -	if (!kvm->arch.mmu.pgt)
 +	if (!kvm->arch.pgd)
 +		return 0;
 +
++<<<<<<< HEAD
 +	return handle_hva_to_gpa(kvm, start, end, kvm_age_hva_handler, NULL);
 +}
 +
 +int kvm_test_age_hva(struct kvm *kvm, unsigned long hva)
 +{
 +	if (!kvm->arch.pgd)
  		return 0;
  
 +	return handle_hva_to_gpa(kvm, hva, hva + PAGE_SIZE,
 +				 kvm_test_age_hva_handler, NULL);
++=======
+ 	return kvm_pgtable_stage2_is_young(kvm->arch.mmu.pgt,
+ 					   range->start << PAGE_SHIFT);
++>>>>>>> cd4c71835228 (KVM: arm64: Convert to the gfn-based MMU notifier callbacks)
 +}
 +
 +void kvm_mmu_free_memory_caches(struct kvm_vcpu *vcpu)
 +{
 +	kvm_mmu_free_memory_cache(&vcpu->arch.mmu_page_cache);
  }
  
  phys_addr_t kvm_mmu_get_httbr(void)
diff --git a/arch/arm64/include/asm/kvm_host.h b/arch/arm64/include/asm/kvm_host.h
index 9ba6b9601d36..758b9d1bcc9c 100644
--- a/arch/arm64/include/asm/kvm_host.h
+++ b/arch/arm64/include/asm/kvm_host.h
@@ -461,6 +461,7 @@ int __kvm_arm_vcpu_set_events(struct kvm_vcpu *vcpu,
 			      struct kvm_vcpu_events *events);
 
 #define KVM_ARCH_WANT_MMU_NOTIFIER
+#define KVM_ARCH_WANT_NEW_MMU_NOTIFIER_APIS
 
 void kvm_arm_halt_guest(struct kvm *kvm);
 void kvm_arm_resume_guest(struct kvm *kvm);
* Unmerged path arch/arm64/kvm/mmu.c
