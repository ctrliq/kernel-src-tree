dm: allow dm_accept_partial_bio() for dm_io without duplicate bios

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Mike Snitzer <snitzer@kernel.org>
commit 7dd06a2548b2bf516ef2e79873a9cdd00b354b99
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/7dd06a25.failed

The intent behind commit e6fc9f62ce6e ("dm: flag clones created by
__send_duplicate_bios") was to formally disallow the use of
dm_accept_partial_bio() where it simply isn't possible -- due to
constraint that multiple bios cannot meaningfully update a shared
tio->len_ptr.

But that commit went too far and disallowed the case where "abormal"
IO (e.g. WRITE_ZEROES) is only using a single bio.  Fix this by
not marking a dm_io with a single dm_target_io (and bio), that happens
to be created by __send_duplicate_bios, as DM_TIO_IS_DUPLICATE_BIO.
Also remove 'unsigned *len' parameter from alloc_multiple_bios().

This commit fixes a dm_accept_partial_bio() BUG_ON() with dm-zoned
when a WRITE_ZEROES bio is issued.

Fixes: 655f3aad7aa4 ("dm: switch dm_target_io booleans over to proper flags")
	Reported-by: Shinichiro Kawasaki <shinichiro.kawasaki@wdc.com>
	Reviewed-by: Damien Le Moal <damien.lemoal@opensource.wdc.com>
	Signed-off-by: Mike Snitzer <snitzer@kernel.org>
(cherry picked from commit 7dd06a2548b2bf516ef2e79873a9cdd00b354b99)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/md/dm.c
diff --cc drivers/md/dm.c
index e7cb1b8972bd,fc1f9583a271..000000000000
--- a/drivers/md/dm.c
+++ b/drivers/md/dm.c
@@@ -1392,11 -1334,12 +1392,17 @@@ static void alloc_multiple_bios(struct 
  		if (try)
  			mutex_lock(&ci->io->md->table_devices_lock);
  		for (bio_nr = 0; bio_nr < num_bios; bio_nr++) {
++<<<<<<< HEAD
 +			tio = alloc_tio(ci, ti, bio_nr, try ? GFP_NOIO : GFP_NOWAIT);
 +			if (!tio)
++=======
+ 			bio = alloc_tio(ci, ti, bio_nr, NULL,
+ 					try ? GFP_NOIO : GFP_NOWAIT);
+ 			if (!bio)
++>>>>>>> 7dd06a2548b2 (dm: allow dm_accept_partial_bio() for dm_io without duplicate bios)
  				break;
  
 -			bio_list_add(blist, bio);
 +			bio_list_add(blist, &tio->clone);
  		}
  		if (try)
  			mutex_unlock(&ci->io->md->table_devices_lock);
@@@ -1428,14 -1355,23 +1434,32 @@@ static void __send_duplicate_bios(struc
  				  unsigned num_bios, unsigned *len)
  {
  	struct bio_list blist = BIO_EMPTY_LIST;
 -	struct bio *clone;
 +	struct bio *bio;
 +	struct dm_target_io *tio;
 +
++<<<<<<< HEAD
 +	alloc_multiple_bios(&blist, ci, ti, num_bios);
  
 +	while ((bio = bio_list_pop(&blist))) {
 +		tio = container_of(bio, struct dm_target_io, clone);
 +		(void) __clone_and_map_simple_bio(ci, tio, len);
++=======
+ 	switch (num_bios) {
+ 	case 0:
+ 		break;
+ 	case 1:
+ 		clone = alloc_tio(ci, ti, 0, len, GFP_NOIO);
+ 		__map_bio(clone);
+ 		break;
+ 	default:
+ 		/* dm_accept_partial_bio() is not supported with shared tio->len_ptr */
+ 		alloc_multiple_bios(&blist, ci, ti, num_bios);
+ 		while ((clone = bio_list_pop(&blist))) {
+ 			dm_tio_set_flag(clone_to_tio(clone), DM_TIO_IS_DUPLICATE_BIO);
+ 			__map_bio(clone);
+ 		}
+ 		break;
++>>>>>>> 7dd06a2548b2 (dm: allow dm_accept_partial_bio() for dm_io without duplicate bios)
  	}
  }
  
@@@ -1501,27 -1403,13 +1525,35 @@@ static int __send_changing_extent_only(
  {
  	unsigned len;
  
++<<<<<<< HEAD
 +	/*
 +	 * Even though the device advertised support for this type of
 +	 * request, that does not mean every target supports it, and
 +	 * reconfiguration might also have changed that since the
 +	 * check was performed.
 +	 */
 +	if (!num_bios)
 +		return -EOPNOTSUPP;
 +
 +	if (!is_split_required)
 +		len = min_t(sector_t, ci->sector_count,
 +			    max_io_len_target_boundary(ti, dm_target_offset(ti, ci->sector)));
 +	else
 +		len = min_t(sector_t, ci->sector_count, max_io_len(ti, ci->sector));
++=======
+ 	len = min_t(sector_t, ci->sector_count,
+ 		    max_io_len_target_boundary(ti, dm_target_offset(ti, ci->sector)));
++>>>>>>> 7dd06a2548b2 (dm: allow dm_accept_partial_bio() for dm_io without duplicate bios)
  
  	__send_duplicate_bios(ci, ti, num_bios, &len);
  
  	ci->sector += len;
  	ci->sector_count -= len;
++<<<<<<< HEAD
 +
 +	return 0;
++=======
++>>>>>>> 7dd06a2548b2 (dm: allow dm_accept_partial_bio() for dm_io without duplicate bios)
  }
  
  static bool is_abnormal_io(struct bio *bio)
* Unmerged path drivers/md/dm.c
