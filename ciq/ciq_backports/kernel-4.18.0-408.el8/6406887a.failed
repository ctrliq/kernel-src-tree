selinux: fix variable scope issue in live sidtab conversion

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Ondrej Mosnacek <omosnace@redhat.com>
commit 6406887a12ee5dcdaffff1a8508d91113d545559
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/6406887a.failed

Commit 02a52c5c8c3b ("selinux: move policy commit after updating
selinuxfs") moved the selinux_policy_commit() call out of
security_load_policy() into sel_write_load(), which caused a subtle yet
rather serious bug.

The problem is that security_load_policy() passes a reference to the
convert_params local variable to sidtab_convert(), which stores it in
the sidtab, where it may be accessed until the policy is swapped over
and RCU synchronized. Before 02a52c5c8c3b, selinux_policy_commit() was
called directly from security_load_policy(), so the convert_params
pointer remained valid all the way until the old sidtab was destroyed,
but now that's no longer the case and calls to sidtab_context_to_sid()
on the old sidtab after security_load_policy() returns may cause invalid
memory accesses.

This can be easily triggered using the stress test from commit
ee1a84fdfeed ("selinux: overhaul sidtab to fix bug and improve
performance"):
```
function rand_cat() {
	echo $(( $RANDOM % 1024 ))
}

function do_work() {
	while true; do
		echo -n "system_u:system_r:kernel_t:s0:c$(rand_cat),c$(rand_cat)" \
			>/sys/fs/selinux/context 2>/dev/null || true
	done
}

do_work >/dev/null &
do_work >/dev/null &
do_work >/dev/null &

while load_policy; do echo -n .; sleep 0.1; done

kill %1
kill %2
kill %3
```

Fix this by allocating the temporary sidtab convert structures
dynamically and passing them among the
selinux_policy_{load,cancel,commit} functions.

Fixes: 02a52c5c8c3b ("selinux: move policy commit after updating selinuxfs")
	Cc: stable@vger.kernel.org
	Tested-by: Tyler Hicks <tyhicks@linux.microsoft.com>
	Reviewed-by: Tyler Hicks <tyhicks@linux.microsoft.com>
	Signed-off-by: Ondrej Mosnacek <omosnace@redhat.com>
[PM: merge fuzz in security.h and services.c]
	Signed-off-by: Paul Moore <paul@paul-moore.com>
(cherry picked from commit 6406887a12ee5dcdaffff1a8508d91113d545559)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	security/selinux/include/security.h
#	security/selinux/ss/services.c
diff --cc security/selinux/include/security.h
index aedc0702f5dd,25db66e0ac51..000000000000
--- a/security/selinux/include/security.h
+++ b/security/selinux/include/security.h
@@@ -218,17 -212,30 +218,34 @@@ static inline bool selinux_policycap_nn
  	return READ_ONCE(state->policycap[POLICYDB_CAPABILITY_NNP_NOSUID_TRANSITION]);
  }
  
++<<<<<<< HEAD
++=======
+ static inline bool selinux_policycap_genfs_seclabel_symlinks(void)
+ {
+ 	struct selinux_state *state = &selinux_state;
+ 
+ 	return READ_ONCE(state->policycap[POLICYDB_CAPABILITY_GENFS_SECLABEL_SYMLINKS]);
+ }
+ 
+ struct selinux_policy_convert_data;
+ 
+ struct selinux_load_state {
+ 	struct selinux_policy *policy;
+ 	struct selinux_policy_convert_data *convert_data;
+ };
+ 
++>>>>>>> 6406887a12ee (selinux: fix variable scope issue in live sidtab conversion)
  int security_mls_enabled(struct selinux_state *state);
  int security_load_policy(struct selinux_state *state,
- 			void *data, size_t len,
- 			struct selinux_policy **newpolicyp);
+ 			 void *data, size_t len,
+ 			 struct selinux_load_state *load_state);
  void selinux_policy_commit(struct selinux_state *state,
- 			struct selinux_policy *newpolicy);
+ 			   struct selinux_load_state *load_state);
  void selinux_policy_cancel(struct selinux_state *state,
- 			struct selinux_policy *policy);
+ 			   struct selinux_load_state *load_state);
  int security_read_policy(struct selinux_state *state,
  			 void **data, size_t *len);
 +size_t security_policydb_len(struct selinux_state *state);
  
  int security_policycap_supported(struct selinux_state *state,
  				 unsigned int req_cap);
diff --cc security/selinux/ss/services.c
index 45cded883bbc,4a907e008a98..000000000000
--- a/security/selinux/ss/services.c
+++ b/security/selinux/ss/services.c
@@@ -67,25 -64,19 +67,36 @@@
  #include "xfrm.h"
  #include "ebitmap.h"
  #include "audit.h"
 -#include "policycap_names.h"
 +
 +/* Policy capability names */
 +const char *selinux_policycap_names[__POLICYDB_CAPABILITY_MAX] = {
 +	"network_peer_controls",
 +	"open_perms",
 +	"extended_socket_class",
 +	"always_check_network",
 +	"cgroup_seclabel",
 +	"nnp_nosuid_transition"
 +};
 +
 +static struct selinux_ss selinux_ss;
 +
 +void selinux_ss_init(struct selinux_ss **ss)
 +{
 +	rwlock_init(&selinux_ss.policy_rwlock);
 +	*ss = &selinux_ss;
 +}
  
+ struct convert_context_args {
+ 	struct selinux_state *state;
+ 	struct policydb *oldp;
+ 	struct policydb *newp;
+ };
+ 
+ struct selinux_policy_convert_data {
+ 	struct convert_context_args args;
+ 	struct sidtab_convert_params sidtab_params;
+ };
+ 
  /* Forward declaration. */
  static int context_struct_to_string(struct policydb *policydb,
  				    struct context *context,
@@@ -2145,28 -2163,39 +2150,37 @@@ static void selinux_policy_free(struct 
  }
  
  void selinux_policy_cancel(struct selinux_state *state,
- 			struct selinux_policy *policy)
+ 			   struct selinux_load_state *load_state)
  {
 -	struct selinux_policy *oldpolicy;
  
++<<<<<<< HEAD
 +	sidtab_cancel_convert(&state->ss->policy->sidtab);
 +	selinux_policy_free(policy);
++=======
+ 	oldpolicy = rcu_dereference_protected(state->policy,
+ 					lockdep_is_held(&state->policy_mutex));
+ 
+ 	sidtab_cancel_convert(oldpolicy->sidtab);
+ 	selinux_policy_free(load_state->policy);
+ 	kfree(load_state->convert_data);
 -}
 -
 -static void selinux_notify_policy_change(struct selinux_state *state,
 -					u32 seqno)
 -{
 -	/* Flush external caches and notify userspace of policy load */
 -	avc_ss_reset(state->avc, seqno);
 -	selnl_notify_policyload(seqno);
 -	selinux_status_update_policyload(state, seqno);
 -	selinux_netlbl_cache_invalidate();
 -	selinux_xfrm_notify_policyload();
++>>>>>>> 6406887a12ee (selinux: fix variable scope issue in live sidtab conversion)
  }
  
  void selinux_policy_commit(struct selinux_state *state,
- 			struct selinux_policy *newpolicy)
+ 			   struct selinux_load_state *load_state)
  {
- 	struct selinux_policy *oldpolicy;
+ 	struct selinux_policy *oldpolicy, *newpolicy = load_state->policy;
  	u32 seqno;
  
 -	oldpolicy = rcu_dereference_protected(state->policy,
 -					lockdep_is_held(&state->policy_mutex));
 +	/*
 +	 * NOTE: We do not need to take the policy read-lock
 +	 * around the code below because other policy-modifying
 +	 * operations are already excluded by selinuxfs via
 +	 * fsi->mutex.
 +	 */
  
  	/* If switching between different policy types, log MLS status */
 +	oldpolicy = state->ss->policy;
  	if (oldpolicy) {
  		if (oldpolicy->policydb.mls_enabled && !newpolicy->policydb.mls_enabled)
  			pr_info("SELinux: Disabling MLS support...\n");
@@@ -2194,14 -2227,12 +2208,15 @@@
  	}
  
  	/* Free the old policy */
 -	synchronize_rcu();
  	selinux_policy_free(oldpolicy);
+ 	kfree(load_state->convert_data);
  
 -	/* Notify others of the policy change */
 -	selinux_notify_policy_change(state, seqno);
 +	/* Flush external caches and notify userspace of policy load */
 +	avc_ss_reset(state->avc, seqno);
 +	selnl_notify_policyload(seqno);
 +	selinux_status_update_policyload(state, seqno);
 +	selinux_netlbl_cache_invalidate();
 +	selinux_xfrm_notify_policyload();
  }
  
  /**
@@@ -2215,11 -2246,10 +2230,16 @@@
   * loading the new policy.
   */
  int security_load_policy(struct selinux_state *state, void *data, size_t len,
- 			struct selinux_policy **newpolicyp)
+ 			 struct selinux_load_state *load_state)
  {
++<<<<<<< HEAD
 +	struct selinux_policy *newpolicy;
 +	struct sidtab_convert_params convert_params;
 +	struct convert_context_args args;
++=======
+ 	struct selinux_policy *newpolicy, *oldpolicy;
+ 	struct selinux_policy_convert_data *convert_data;
++>>>>>>> 6406887a12ee (selinux: fix variable scope issue in live sidtab conversion)
  	int rc = 0;
  	struct policy_file file = { data, len }, *fp = &file;
  
@@@ -2235,57 -2271,74 +2255,97 @@@
  	rc = selinux_set_mapping(&newpolicy->policydb, secclass_map,
  				&newpolicy->map);
  	if (rc)
 -		goto err_policydb;
 +		goto err;
  
 -	rc = policydb_load_isids(&newpolicy->policydb, newpolicy->sidtab);
 +	rc = policydb_load_isids(&newpolicy->policydb, &newpolicy->sidtab);
  	if (rc) {
  		pr_err("SELinux:  unable to load the initial SIDs\n");
 -		goto err_mapping;
 +		goto err;
  	}
  
- 
  	if (!selinux_initialized(state)) {
  		/* First policy load, so no need to preserve state from old policy */
- 		*newpolicyp = newpolicy;
+ 		load_state->policy = newpolicy;
+ 		load_state->convert_data = NULL;
  		return 0;
  	}
  
 -	oldpolicy = rcu_dereference_protected(state->policy,
 -					lockdep_is_held(&state->policy_mutex));
 -
  	/* Preserve active boolean values from the old policy */
 -	rc = security_preserve_bools(oldpolicy, newpolicy);
 +	rc = security_preserve_bools(state, &newpolicy->policydb);
  	if (rc) {
  		pr_err("SELinux:  unable to preserve booleans\n");
 -		goto err_free_isids;
 +		goto err;
  	}
  
+ 	convert_data = kmalloc(sizeof(*convert_data), GFP_KERNEL);
+ 	if (!convert_data) {
+ 		rc = -ENOMEM;
+ 		goto err_free_isids;
+ 	}
+ 
  	/*
  	 * Convert the internal representations of contexts
  	 * in the new SID table.
 +	 *
 +	 * NOTE: We do not need to take the policy read-lock
 +	 * around the code below because other policy-modifying
 +	 * operations are already excluded by selinuxfs via
 +	 * fsi->mutex.
  	 */
++<<<<<<< HEAD
 +	args.state = state;
 +	args.oldp = &state->ss->policy->policydb;
 +	args.newp = &newpolicy->policydb;
 +
 +	convert_params.func = convert_context;
 +	convert_params.args = &args;
 +	convert_params.target = &newpolicy->sidtab;
 +
 +	rc = sidtab_convert(&state->ss->policy->sidtab, &convert_params);
++=======
+ 	convert_data->args.state = state;
+ 	convert_data->args.oldp = &oldpolicy->policydb;
+ 	convert_data->args.newp = &newpolicy->policydb;
+ 
+ 	convert_data->sidtab_params.func = convert_context;
+ 	convert_data->sidtab_params.args = &convert_data->args;
+ 	convert_data->sidtab_params.target = newpolicy->sidtab;
+ 
+ 	rc = sidtab_convert(oldpolicy->sidtab, &convert_data->sidtab_params);
++>>>>>>> 6406887a12ee (selinux: fix variable scope issue in live sidtab conversion)
  	if (rc) {
  		pr_err("SELinux:  unable to convert the internal"
  			" representation of contexts in the new SID"
  			" table\n");
++<<<<<<< HEAD
 +		goto err;
++=======
+ 		goto err_free_convert_data;
++>>>>>>> 6406887a12ee (selinux: fix variable scope issue in live sidtab conversion)
  	}
  
- 	*newpolicyp = newpolicy;
+ 	load_state->policy = newpolicy;
+ 	load_state->convert_data = convert_data;
  	return 0;
++<<<<<<< HEAD
 +err:
 +	selinux_policy_free(newpolicy);
++=======
+ 
+ err_free_convert_data:
+ 	kfree(convert_data);
+ err_free_isids:
+ 	sidtab_destroy(newpolicy->sidtab);
+ err_mapping:
+ 	kfree(newpolicy->map.mapping);
+ err_policydb:
+ 	policydb_destroy(&newpolicy->policydb);
+ err_sidtab:
+ 	kfree(newpolicy->sidtab);
+ err_policy:
+ 	kfree(newpolicy);
+ 
++>>>>>>> 6406887a12ee (selinux: fix variable scope issue in live sidtab conversion)
  	return rc;
  }
  
* Unmerged path security/selinux/include/security.h
diff --git a/security/selinux/selinuxfs.c b/security/selinux/selinuxfs.c
index 04269129ce20..5e4de1cc3927 100644
--- a/security/selinux/selinuxfs.c
+++ b/security/selinux/selinuxfs.c
@@ -613,7 +613,7 @@ static ssize_t sel_write_load(struct file *file, const char __user *buf,
 
 {
 	struct selinux_fs_info *fsi = file_inode(file)->i_sb->s_fs_info;
-	struct selinux_policy *newpolicy;
+	struct selinux_load_state load_state;
 	ssize_t length;
 	void *data = NULL;
 
@@ -639,19 +639,19 @@ static ssize_t sel_write_load(struct file *file, const char __user *buf,
 	if (copy_from_user(data, buf, count) != 0)
 		goto out;
 
-	length = security_load_policy(fsi->state, data, count, &newpolicy);
+	length = security_load_policy(fsi->state, data, count, &load_state);
 	if (length) {
 		pr_warn_ratelimited("SELinux: failed to load policy\n");
 		goto out;
 	}
 
-	length = sel_make_policy_nodes(fsi, newpolicy);
+	length = sel_make_policy_nodes(fsi, load_state.policy);
 	if (length) {
-		selinux_policy_cancel(fsi->state, newpolicy);
+		selinux_policy_cancel(fsi->state, &load_state);
 		goto out;
 	}
 
-	selinux_policy_commit(fsi->state, newpolicy);
+	selinux_policy_commit(fsi->state, &load_state);
 
 	length = count;
 
* Unmerged path security/selinux/ss/services.c
