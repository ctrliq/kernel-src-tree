KVM: x86/mmu: Allow yielding when zapping GFNs for defunct TDP MMU root

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Paolo Bonzini <pbonzini@redhat.com>
commit 8351779ce65f0d54b7845a732c6141a9fe10dcaa
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/8351779c.failed

Allow yielding when zapping SPTEs after the last reference to a valid
root is put.  Because KVM must drop all SPTEs in response to relevant
mmu_notifier events, mark defunct roots invalid and reset their refcount
prior to zapping the root.  Keeping the refcount elevated while the zap
is in-progress ensures the root is reachable via mmu_notifier until the
zap completes and the last reference to the invalid, defunct root is put.

Allowing kvm_tdp_mmu_put_root() to yield fixes soft lockup issues if the
root in being put has a massive paging structure, e.g. zapping a root
that is backed entirely by 4kb pages for a guest with 32tb of memory can
take hundreds of seconds to complete.

  watchdog: BUG: soft lockup - CPU#49 stuck for 485s! [max_guest_memor:52368]
  RIP: 0010:kvm_set_pfn_dirty+0x30/0x50 [kvm]
   __handle_changed_spte+0x1b2/0x2f0 [kvm]
   handle_removed_tdp_mmu_page+0x1a7/0x2b8 [kvm]
   __handle_changed_spte+0x1f4/0x2f0 [kvm]
   handle_removed_tdp_mmu_page+0x1a7/0x2b8 [kvm]
   __handle_changed_spte+0x1f4/0x2f0 [kvm]
   tdp_mmu_zap_root+0x307/0x4d0 [kvm]
   kvm_tdp_mmu_put_root+0x7c/0xc0 [kvm]
   kvm_mmu_free_roots+0x22d/0x350 [kvm]
   kvm_mmu_reset_context+0x20/0x60 [kvm]
   kvm_arch_vcpu_ioctl_set_sregs+0x5a/0xc0 [kvm]
   kvm_vcpu_ioctl+0x5bd/0x710 [kvm]
   __se_sys_ioctl+0x77/0xc0
   __x64_sys_ioctl+0x1d/0x20
   do_syscall_64+0x44/0xa0
   entry_SYSCALL_64_after_hwframe+0x44/0xae

KVM currently doesn't put a root from a non-preemptible context, so other
than the mmu_notifier wrinkle, yielding when putting a root is safe.

Yield-unfriendly iteration uses for_each_tdp_mmu_root(), which doesn't
take a reference to each root (it requires mmu_lock be held for the
entire duration of the walk).

tdp_mmu_next_root() is used only by the yield-friendly iterator.

tdp_mmu_zap_root_work() is explicitly yield friendly.

kvm_mmu_free_roots() => mmu_free_root_page() is a much bigger fan-out,
but is still yield-friendly in all call sites, as all callers can be
traced back to some combination of vcpu_run(), kvm_destroy_vm(), and/or
kvm_create_vm().

	Signed-off-by: Sean Christopherson <seanjc@google.com>
Message-Id: <20220226001546.360188-21-seanjc@google.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 8351779ce65f0d54b7845a732c6141a9fe10dcaa)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/mmu/tdp_mmu.c
diff --cc arch/x86/kvm/mmu/tdp_mmu.c
index 97bb57fe39ca,decf1fb3ce08..000000000000
--- a/arch/x86/kvm/mmu/tdp_mmu.c
+++ b/arch/x86/kvm/mmu/tdp_mmu.c
@@@ -66,11 -84,60 +66,59 @@@ static void tdp_mmu_free_sp_rcu_callbac
  	tdp_mmu_free_sp(sp);
  }
  
 -static void tdp_mmu_zap_root(struct kvm *kvm, struct kvm_mmu_page *root,
 -			     bool shared);
 -
 -static void tdp_mmu_zap_root_work(struct work_struct *work)
 +void kvm_tdp_mmu_put_root(struct kvm *kvm, struct kvm_mmu_page *root)
  {
 -	struct kvm_mmu_page *root = container_of(work, struct kvm_mmu_page,
 -						 tdp_mmu_async_work);
 -	struct kvm *kvm = root->tdp_mmu_async_data;
 +	gfn_t max_gfn = 1ULL << (shadow_phys_bits - PAGE_SHIFT);
  
++<<<<<<< HEAD
 +	lockdep_assert_held_write(&kvm->mmu_lock);
++=======
+ 	read_lock(&kvm->mmu_lock);
+ 
+ 	/*
+ 	 * A TLB flush is not necessary as KVM performs a local TLB flush when
+ 	 * allocating a new root (see kvm_mmu_load()), and when migrating vCPU
+ 	 * to a different pCPU.  Note, the local TLB flush on reuse also
+ 	 * invalidates any paging-structure-cache entries, i.e. TLB entries for
+ 	 * intermediate paging structures, that may be zapped, as such entries
+ 	 * are associated with the ASID on both VMX and SVM.
+ 	 */
+ 	tdp_mmu_zap_root(kvm, root, true);
+ 
+ 	/*
+ 	 * Drop the refcount using kvm_tdp_mmu_put_root() to test its logic for
+ 	 * avoiding an infinite loop.  By design, the root is reachable while
+ 	 * it's being asynchronously zapped, thus a different task can put its
+ 	 * last reference, i.e. flowing through kvm_tdp_mmu_put_root() for an
+ 	 * asynchronously zapped root is unavoidable.
+ 	 */
+ 	kvm_tdp_mmu_put_root(kvm, root, true);
+ 
+ 	read_unlock(&kvm->mmu_lock);
+ }
+ 
+ static void tdp_mmu_schedule_zap_root(struct kvm *kvm, struct kvm_mmu_page *root)
+ {
+ 	root->tdp_mmu_async_data = kvm;
+ 	INIT_WORK(&root->tdp_mmu_async_work, tdp_mmu_zap_root_work);
+ 	queue_work(kvm->arch.tdp_mmu_zap_wq, &root->tdp_mmu_async_work);
+ }
+ 
+ static inline bool kvm_tdp_root_mark_invalid(struct kvm_mmu_page *page)
+ {
+ 	union kvm_mmu_page_role role = page->role;
+ 	role.invalid = true;
+ 
+ 	/* No need to use cmpxchg, only the invalid bit can change.  */
+ 	role.word = xchg(&page->role.word, role.word);
+ 	return role.invalid;
+ }
+ 
+ void kvm_tdp_mmu_put_root(struct kvm *kvm, struct kvm_mmu_page *root,
+ 			  bool shared)
+ {
+ 	kvm_lockdep_assert_mmu_lock_held(kvm, shared);
++>>>>>>> 8351779ce65f (KVM: x86/mmu: Allow yielding when zapping GFNs for defunct TDP MMU root)
  
  	if (!refcount_dec_and_test(&root->tdp_mmu_root_count))
  		return;
@@@ -80,9 -184,6 +165,12 @@@
  	spin_lock(&kvm->arch.tdp_mmu_pages_lock);
  	list_del_rcu(&root->link);
  	spin_unlock(&kvm->arch.tdp_mmu_pages_lock);
++<<<<<<< HEAD
 +
 +	zap_gfn_range(kvm, root, 0, max_gfn, false, false);
 +
++=======
++>>>>>>> 8351779ce65f (KVM: x86/mmu: Allow yielding when zapping GFNs for defunct TDP MMU root)
  	call_rcu(&root->rcu_head, tdp_mmu_free_sp_rcu_callback);
  }
  
@@@ -700,11 -812,86 +788,90 @@@ static inline bool __must_check tdp_mmu
  	return iter->yielded;
  }
  
++<<<<<<< HEAD
++=======
+ static inline gfn_t tdp_mmu_max_gfn_host(void)
+ {
+ 	/*
+ 	 * Bound TDP MMU walks at host.MAXPHYADDR, guest accesses beyond that
+ 	 * will hit a #PF(RSVD) and never hit an EPT Violation/Misconfig / #NPF,
+ 	 * and so KVM will never install a SPTE for such addresses.
+ 	 */
+ 	return 1ULL << (shadow_phys_bits - PAGE_SHIFT);
+ }
+ 
+ static void tdp_mmu_zap_root(struct kvm *kvm, struct kvm_mmu_page *root,
+ 			     bool shared)
+ {
+ 	struct tdp_iter iter;
+ 
+ 	gfn_t end = tdp_mmu_max_gfn_host();
+ 	gfn_t start = 0;
+ 
+ 	/*
+ 	 * The root must have an elevated refcount so that it's reachable via
+ 	 * mmu_notifier callbacks, which allows this path to yield and drop
+ 	 * mmu_lock.  When handling an unmap/release mmu_notifier command, KVM
+ 	 * must drop all references to relevant pages prior to completing the
+ 	 * callback.  Dropping mmu_lock with an unreachable root would result
+ 	 * in zapping SPTEs after a relevant mmu_notifier callback completes
+ 	 * and lead to use-after-free as zapping a SPTE triggers "writeback" of
+ 	 * dirty accessed bits to the SPTE's associated struct page.
+ 	 */
+ 	WARN_ON_ONCE(!refcount_read(&root->tdp_mmu_root_count));
+ 
+ 	kvm_lockdep_assert_mmu_lock_held(kvm, shared);
+ 
+ 	rcu_read_lock();
+ 
+ 	/*
+ 	 * No need to try to step down in the iterator when zapping an entire
+ 	 * root, zapping an upper-level SPTE will recurse on its children.
+ 	 */
+ 	for_each_tdp_pte_min_level(iter, root, root->role.level, start, end) {
+ retry:
+ 		if (tdp_mmu_iter_cond_resched(kvm, &iter, false, shared))
+ 			continue;
+ 
+ 		if (!is_shadow_present_pte(iter.old_spte))
+ 			continue;
+ 
+ 		if (!shared)
+ 			tdp_mmu_set_spte(kvm, &iter, 0);
+ 		else if (tdp_mmu_set_spte_atomic(kvm, &iter, 0))
+ 			goto retry;
+ 	}
+ 
+ 	rcu_read_unlock();
+ }
+ 
+ bool kvm_tdp_mmu_zap_sp(struct kvm *kvm, struct kvm_mmu_page *sp)
+ {
+ 	u64 old_spte;
+ 
+ 	/*
+ 	 * This helper intentionally doesn't allow zapping a root shadow page,
+ 	 * which doesn't have a parent page table and thus no associated entry.
+ 	 */
+ 	if (WARN_ON_ONCE(!sp->ptep))
+ 		return false;
+ 
+ 	old_spte = kvm_tdp_mmu_read_spte(sp->ptep);
+ 	if (WARN_ON_ONCE(!is_shadow_present_pte(old_spte)))
+ 		return false;
+ 
+ 	__tdp_mmu_set_spte(kvm, kvm_mmu_page_as_id(sp), sp->ptep, old_spte, 0,
+ 			   sp->gfn, sp->role.level + 1, true, true);
+ 
+ 	return true;
+ }
+ 
++>>>>>>> 8351779ce65f (KVM: x86/mmu: Allow yielding when zapping GFNs for defunct TDP MMU root)
  /*
 - * Zap leafs SPTEs for the range of gfns, [start, end). Returns true if SPTEs
 - * have been cleared and a TLB flush is needed before releasing the MMU lock.
 - *
 + * Tears down the mappings for the range of gfns, [start, end), and frees the
 + * non-root pages mapping GFNs strictly within that range. Returns true if
 + * SPTEs have been cleared and a TLB flush is needed before releasing the
 + * MMU lock.
   * If can_yield is true, will release the MMU lock and reschedule if the
   * scheduler needs the CPU or there is contention on the MMU lock. If this
   * function cannot yield, it will not release the MMU lock or reschedule and
* Unmerged path arch/x86/kvm/mmu/tdp_mmu.c
