block: initialize the target bio in __bio_clone_fast

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Christoph Hellwig <hch@lst.de>
commit a0e8de798dd6710a69d69ec57b246a0e34c4a695
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/a0e8de79.failed

All callers of __bio_clone_fast initialize the bio first.  Move that
initialization into __bio_clone_fast instead.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Mike Snitzer <snitzer@redhat.com>
Link: https://lore.kernel.org/r/20220202160109.108149-13-hch@lst.de
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit a0e8de798dd6710a69d69ec57b246a0e34c4a695)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	block/bio.c
#	drivers/md/bcache/request.c
#	drivers/md/md-multipath.c
diff --cc block/bio.c
index df04c1ad5361,74f66e22ef63..000000000000
--- a/block/bio.c
+++ b/block/bio.c
@@@ -633,86 -728,83 +633,131 @@@ void bio_put(struct bio *bio
  }
  EXPORT_SYMBOL(bio_put);
  
++<<<<<<< HEAD
 +inline int bio_phys_segments(struct request_queue *q, struct bio *bio)
 +{
 +	if (unlikely(!bio_flagged(bio, BIO_SEG_VALID)))
 +		blk_recount_segments(q, bio);
 +
 +	return bio->bi_phys_segments;
 +}
 +EXPORT_SYMBOL(bio_phys_segments);
 +
 +/**
 + * 	__bio_clone_fast - clone a bio that shares the original bio's biovec
 + * 	@bio: destination bio
 + * 	@bio_src: bio to clone
 + *
 + *	Clone a &bio. Caller will own the returned bio, but not
 + *	the actual data it points to. Reference count of returned
 + * 	bio will be one.
 + *
 + * 	Caller must ensure that @bio_src is not freed before @bio.
 + */
 +void __bio_clone_fast(struct bio *bio, struct bio *bio_src)
 +{
 +	WARN_ON_ONCE(bio->bi_pool && bio->bi_max_vecs);
 +
 +	/*
 +	 * most users will be overriding ->bi_disk with a new target,
 +	 * so we don't set nor calculate new physical/hw segment counts here
 +	 */
 +	bio->bi_disk = bio_src->bi_disk;
 +	bio->bi_partno = bio_src->bi_partno;
 +	bio_set_flag(bio, BIO_CLONED);
 +	if (bio_flagged(bio_src, BIO_THROTTLED))
 +		bio_set_flag(bio, BIO_THROTTLED);
 +	bio->bi_opf = bio_src->bi_opf;
++=======
+ static int __bio_clone(struct bio *bio, struct bio *bio_src, gfp_t gfp)
+ {
+ 	bio_set_flag(bio, BIO_CLONED);
+ 	if (bio_flagged(bio_src, BIO_THROTTLED))
+ 		bio_set_flag(bio, BIO_THROTTLED);
+ 	if (bio_flagged(bio_src, BIO_REMAPPED))
+ 		bio_set_flag(bio, BIO_REMAPPED);
++>>>>>>> a0e8de798dd6 (block: initialize the target bio in __bio_clone_fast)
  	bio->bi_ioprio = bio_src->bi_ioprio;
  	bio->bi_write_hint = bio_src->bi_write_hint;
  	bio->bi_iter = bio_src->bi_iter;
  
  	bio_clone_blkg_association(bio, bio_src);
  	blkcg_bio_issue_init(bio);
 -
 -	if (bio_crypt_clone(bio, bio_src, gfp) < 0)
 -		return -ENOMEM;
 -	if (bio_integrity(bio_src) &&
 -	    bio_integrity_clone(bio, bio_src, gfp) < 0)
 -		return -ENOMEM;
 -	return 0;
  }
- EXPORT_SYMBOL(__bio_clone_fast);
  
  /**
-  *	bio_clone_fast - clone a bio that shares the original bio's biovec
-  *	@bio: bio to clone
-  *	@gfp_mask: allocation priority
-  *	@bs: bio_set to allocate from
+  * bio_clone_fast - clone a bio that shares the original bio's biovec
+  * @bio_src: bio to clone from
+  * @gfp: allocation priority
+  * @bs: bio_set to allocate from
   *
-  * 	Like __bio_clone_fast, only also allocates the returned bio
+  * Allocate a new bio that is a clone of @bio_src. The caller owns the returned
+  * bio, but not the actual data it points to.
+  *
+  * The caller must ensure that the return bio is not freed before @bio_src.
   */
- struct bio *bio_clone_fast(struct bio *bio, gfp_t gfp_mask, struct bio_set *bs)
+ struct bio *bio_clone_fast(struct bio *bio_src, gfp_t gfp, struct bio_set *bs)
  {
- 	struct bio *b;
+ 	struct bio *bio;
  
++<<<<<<< HEAD
 +	b = bio_alloc_bioset(gfp_mask, 0, bs);
 +	if (!b)
 +		return NULL;
 +
 +	__bio_clone_fast(b, bio);
 +
 +	if (bio_integrity(bio)) {
 +		int ret;
 +
 +		ret = bio_integrity_clone(b, bio, gfp_mask);
 +
 +		if (ret < 0) {
 +			bio_put(b);
 +			return NULL;
 +		}
++=======
+ 	bio = bio_alloc_bioset(bio_src->bi_bdev, 0, bio_src->bi_opf, gfp, bs);
+ 	if (!bio)
+ 		return NULL;
+ 
+ 	if (__bio_clone(bio, bio_src, gfp) < 0) {
+ 		bio_put(bio);
+ 		return NULL;
++>>>>>>> a0e8de798dd6 (block: initialize the target bio in __bio_clone_fast)
  	}
+ 	bio->bi_io_vec = bio_src->bi_io_vec;
  
- 	return b;
+ 	return bio;
  }
  EXPORT_SYMBOL(bio_clone_fast);
  
+ /**
+  * __bio_clone_fast - clone a bio that shares the original bio's biovec
+  * @bio: bio to clone into
+  * @bio_src: bio to clone from
+  * @gfp: allocation priority
+  *
+  * Initialize a new bio in caller provided memory that is a clone of @bio_src.
+  * The caller owns the returned bio, but not the actual data it points to.
+  *
+  * The caller must ensure that @bio_src is not freed before @bio.
+  */
+ int __bio_clone_fast(struct bio *bio, struct bio *bio_src, gfp_t gfp)
+ {
+ 	int ret;
+ 
+ 	bio_init(bio, bio_src->bi_bdev, bio_src->bi_io_vec, 0, bio_src->bi_opf);
+ 	ret = __bio_clone(bio, bio_src, gfp);
+ 	if (ret)
+ 		bio_uninit(bio);
+ 	return ret;
+ }
+ EXPORT_SYMBOL(__bio_clone_fast);
+ 
  const char *bio_devname(struct bio *bio, char *buf)
  {
 -	return bdevname(bio->bi_bdev, buf);
 +	return disk_name(bio->bi_disk, bio->bi_partno, buf);
  }
  EXPORT_SYMBOL(bio_devname);
  
diff --cc drivers/md/bcache/request.c
index 97707b0c54ce,d2cb853bf917..000000000000
--- a/drivers/md/bcache/request.c
+++ b/drivers/md/bcache/request.c
@@@ -683,8 -685,7 +683,12 @@@ static void do_bio_hook(struct search *
  {
  	struct bio *bio = &s->bio.bio;
  
++<<<<<<< HEAD
 +	bio_init(bio, NULL, 0);
 +	__bio_clone_fast(bio, orig_bio);
++=======
+ 	__bio_clone_fast(bio, orig_bio, GFP_NOIO);
++>>>>>>> a0e8de798dd6 (block: initialize the target bio in __bio_clone_fast)
  	/*
  	 * bi_end_io can be set separately somewhere else, e.g. the
  	 * variants in,
diff --cc drivers/md/md-multipath.c
index a681d2def114,483a5500f83c..000000000000
--- a/drivers/md/md-multipath.c
+++ b/drivers/md/md-multipath.c
@@@ -129,8 -121,7 +129,12 @@@ static bool multipath_make_request(stru
  	}
  	multipath = conf->multipaths + mp_bh->path;
  
++<<<<<<< HEAD
 +	bio_init(&mp_bh->bio, NULL, 0);
 +	__bio_clone_fast(&mp_bh->bio, bio);
++=======
+ 	__bio_clone_fast(&mp_bh->bio, bio, GFP_NOIO);
++>>>>>>> a0e8de798dd6 (block: initialize the target bio in __bio_clone_fast)
  
  	mp_bh->bio.bi_iter.bi_sector += multipath->rdev->data_offset;
  	bio_set_dev(&mp_bh->bio, multipath->rdev->bdev);
* Unmerged path block/bio.c
* Unmerged path drivers/md/bcache/request.c
* Unmerged path drivers/md/md-multipath.c
