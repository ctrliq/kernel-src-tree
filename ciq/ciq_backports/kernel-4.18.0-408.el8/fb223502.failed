tcp: add SNMP counter for zero-window drops

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Yafang Shao <laoar.shao@gmail.com>
commit fb223502ec0889444965f602f57b1f45f9e9845e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/fb223502.failed

It will be helpful if we could display the drops due to zero window or no
enough window space.
So a new SNMP MIB entry is added to track this behavior.
This entry is named LINUX_MIB_TCPZEROWINDOWDROP and published in
/proc/net/netstat in TcpExt line as TCPZeroWindowDrop.

	Signed-off-by: Yafang Shao <laoar.shao@gmail.com>
	Signed-off-by: Eric Dumazet <edumazet@google.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit fb223502ec0889444965f602f57b1f45f9e9845e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/uapi/linux/snmp.h
#	net/ipv4/proc.c
diff --cc include/uapi/linux/snmp.h
index b3db0c8fba73,97517f36a5f9..000000000000
--- a/include/uapi/linux/snmp.h
+++ b/include/uapi/linux/snmp.h
@@@ -284,9 -279,7 +284,13 @@@ enu
  	LINUX_MIB_TCPDELIVERED,			/* TCPDelivered */
  	LINUX_MIB_TCPDELIVEREDCE,		/* TCPDeliveredCE */
  	LINUX_MIB_TCPACKCOMPRESSED,		/* TCPAckCompressed */
++<<<<<<< HEAD
 +#ifndef __GENKSYMS__
 +	LINUX_MIB_TCPWQUEUETOOBIG,		/* TCPWqueueTooBig */
 +#endif
++=======
+ 	LINUX_MIB_TCPZEROWINDOWDROP,		/* TCPZeroWindowDrop */
++>>>>>>> fb223502ec08 (tcp: add SNMP counter for zero-window drops)
  	__LINUX_MIB_MAX
  };
  
diff --cc net/ipv4/proc.c
index 980c3770381b,225ef3433fe5..000000000000
--- a/net/ipv4/proc.c
+++ b/net/ipv4/proc.c
@@@ -291,7 -287,7 +291,11 @@@ static const struct snmp_mib snmp4_net_
  	SNMP_MIB_ITEM("TCPDelivered", LINUX_MIB_TCPDELIVERED),
  	SNMP_MIB_ITEM("TCPDeliveredCE", LINUX_MIB_TCPDELIVEREDCE),
  	SNMP_MIB_ITEM("TCPAckCompressed", LINUX_MIB_TCPACKCOMPRESSED),
++<<<<<<< HEAD
 +	SNMP_MIB_ITEM("TCPWqueueTooBig", LINUX_MIB_TCPWQUEUETOOBIG),
++=======
+ 	SNMP_MIB_ITEM("TCPZeroWindowDrop", LINUX_MIB_TCPZEROWINDOWDROP),
++>>>>>>> fb223502ec08 (tcp: add SNMP counter for zero-window drops)
  	SNMP_MIB_SENTINEL
  };
  
* Unmerged path include/uapi/linux/snmp.h
* Unmerged path net/ipv4/proc.c
diff --git a/net/ipv4/tcp_input.c b/net/ipv4/tcp_input.c
index 040dc4f9858b..6750178e1b7f 100644
--- a/net/ipv4/tcp_input.c
+++ b/net/ipv4/tcp_input.c
@@ -4882,8 +4882,10 @@ static void tcp_data_queue(struct sock *sk, struct sk_buff *skb)
 	 *  Out of sequence packets to the out_of_order_queue.
 	 */
 	if (TCP_SKB_CB(skb)->seq == tp->rcv_nxt) {
-		if (tcp_receive_window(tp) == 0)
+		if (tcp_receive_window(tp) == 0) {
+			NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPZEROWINDOWDROP);
 			goto out_of_window;
+		}
 
 		/* Ok. In sequence. In window. */
 queue_and_out:
@@ -4951,8 +4953,10 @@ static void tcp_data_queue(struct sock *sk, struct sk_buff *skb)
 		/* If window is closed, drop tail of packet. But after
 		 * remembering D-SACK for its head made in previous line.
 		 */
-		if (!tcp_receive_window(tp))
+		if (!tcp_receive_window(tp)) {
+			NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPZEROWINDOWDROP);
 			goto out_of_window;
+		}
 		goto queue_and_out;
 	}
 
