cpufreq: intel_pstate: Update cpuinfo.max_freq on HWP_CAP changes

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Rafael J. Wysocki <rafael.j.wysocki@intel.com>
commit dfeeedc1bf5772226bddf51ed3f853e5a6707bf1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/dfeeedc1.failed

With HWP enabled, when the turbo range of performance levels is
disabled by the platform firmware, the CPU capacity is given by
the "guaranteed performance" field in MSR_HWP_CAPABILITIES which
is generally dynamic.  When it changes, the kernel receives an HWP
notification interrupt handled by notify_hwp_interrupt().

When the "guaranteed performance" value changes in the above
configuration, the CPU performance scaling needs to be adjusted so
as to use the new CPU capacity in computations, which means that
the cpuinfo.max_freq value needs to be updated for that CPU.

Accordingly, modify intel_pstate_notify_work() to read
MSR_HWP_CAPABILITIES and update cpuinfo.max_freq to reflect the
new configuration (this update can be carried out even if the
configuration doesn't actually change, because it simply doesn't
matter then and it takes less time to update it than to do extra
checks to decide whether or not a change has really occurred).

	Reported-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
	Tested-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit dfeeedc1bf5772226bddf51ed3f853e5a6707bf1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/cpufreq/intel_pstate.c
diff --cc drivers/cpufreq/intel_pstate.c
index 6bf9016dc6f4,bc7f7e6759bd..000000000000
--- a/drivers/cpufreq/intel_pstate.c
+++ b/drivers/cpufreq/intel_pstate.c
@@@ -1585,12 -1595,23 +1588,27 @@@ static void intel_pstate_sysfs_hide_hwp
  
  static void intel_pstate_notify_work(struct work_struct *work)
  {
++<<<<<<< HEAD
 +	mutex_lock(&intel_pstate_driver_lock);
 +	cpufreq_update_policy(smp_processor_id());
 +	wrmsrl(MSR_HWP_STATUS, 0);
 +	mutex_unlock(&intel_pstate_driver_lock);
++=======
+ 	struct cpudata *cpudata =
+ 		container_of(to_delayed_work(work), struct cpudata, hwp_notify_work);
+ 	struct cpufreq_policy *policy = cpufreq_cpu_acquire(cpudata->cpu);
+ 
+ 	if (policy) {
+ 		intel_pstate_get_hwp_cap(cpudata);
+ 		__intel_pstate_update_max_freq(cpudata, policy);
+ 
+ 		cpufreq_cpu_release(policy);
+ 	}
+ 
+ 	wrmsrl_on_cpu(cpudata->cpu, MSR_HWP_STATUS, 0);
++>>>>>>> dfeeedc1bf57 (cpufreq: intel_pstate: Update cpuinfo.max_freq on HWP_CAP changes)
  }
  
 -static DEFINE_SPINLOCK(hwp_notify_lock);
 -static cpumask_t hwp_intr_enable_mask;
 -
  void notify_hwp_interrupt(void)
  {
  	unsigned int this_cpu = smp_processor_id();
* Unmerged path drivers/cpufreq/intel_pstate.c
