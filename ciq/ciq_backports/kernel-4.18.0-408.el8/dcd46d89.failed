exec: Force single empty string when argv is empty

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Kees Cook <keescook@chromium.org>
commit dcd46d897adb70d63e025f175a00a89797d31a43
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/dcd46d89.failed

Quoting[1] Ariadne Conill:

"In several other operating systems, it is a hard requirement that the
second argument to execve(2) be the name of a program, thus prohibiting
a scenario where argc < 1. POSIX 2017 also recommends this behaviour,
but it is not an explicit requirement[2]:

    The argument arg0 should point to a filename string that is
    associated with the process being started by one of the exec
    functions.
...
Interestingly, Michael Kerrisk opened an issue about this in 2008[3],
but there was no consensus to support fixing this issue then.
Hopefully now that CVE-2021-4034 shows practical exploitative use[4]
of this bug in a shellcode, we can reconsider.

This issue is being tracked in the KSPP issue tracker[5]."

While the initial code searches[6][7] turned up what appeared to be
mostly corner case tests, trying to that just reject argv == NULL
(or an immediately terminated pointer list) quickly started tripping[8]
existing userspace programs.

The next best approach is forcing a single empty string into argv and
adjusting argc to match. The number of programs depending on argc == 0
seems a smaller set than those calling execve with a NULL argv.

Account for the additional stack space in bprm_stack_limits(). Inject an
empty string when argc == 0 (and set argc = 1). Warn about the case so
userspace has some notice about the change:

    process './argc0' launched './argc0' with NULL argv: empty string added

Additionally WARN() and reject NULL argv usage for kernel threads.

[1] https://lore.kernel.org/lkml/20220127000724.15106-1-ariadne@dereferenced.org/
[2] https://pubs.opengroup.org/onlinepubs/9699919799/functions/exec.html
[3] https://bugzilla.kernel.org/show_bug.cgi?id=8408
[4] https://www.qualys.com/2022/01/25/cve-2021-4034/pwnkit.txt
[5] https://github.com/KSPP/linux/issues/176
[6] https://codesearch.debian.net/search?q=execve%5C+*%5C%28%5B%5E%2C%5D%2B%2C+*NULL&literal=0
[7] https://codesearch.debian.net/search?q=execlp%3F%5Cs*%5C%28%5B%5E%2C%5D%2B%2C%5Cs*NULL&literal=0
[8] https://lore.kernel.org/lkml/20220131144352.GE16385@xsang-OptiPlex-9020/

	Reported-by: Ariadne Conill <ariadne@dereferenced.org>
	Reported-by: Michael Kerrisk <mtk.manpages@gmail.com>
	Cc: Matthew Wilcox <willy@infradead.org>
	Cc: Christian Brauner <brauner@kernel.org>
	Cc: Rich Felker <dalias@libc.org>
	Cc: Eric Biederman <ebiederm@xmission.com>
	Cc: Alexander Viro <viro@zeniv.linux.org.uk>
	Cc: linux-fsdevel@vger.kernel.org
	Cc: stable@vger.kernel.org
	Signed-off-by: Kees Cook <keescook@chromium.org>
	Acked-by: Christian Brauner <brauner@kernel.org>
	Acked-by: Ariadne Conill <ariadne@dereferenced.org>
	Acked-by: Andy Lutomirski <luto@kernel.org>
Link: https://lore.kernel.org/r/20220201000947.2453721-1-keescook@chromium.org
(cherry picked from commit dcd46d897adb70d63e025f175a00a89797d31a43)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/exec.c
diff --cc fs/exec.c
index ac7e4cd1de49,40b1008fb0f7..000000000000
--- a/fs/exec.c
+++ b/fs/exec.c
@@@ -492,6 -453,64 +492,67 @@@ static int count(struct user_arg_ptr ar
  	return i;
  }
  
++<<<<<<< HEAD
++=======
+ static int count_strings_kernel(const char *const *argv)
+ {
+ 	int i;
+ 
+ 	if (!argv)
+ 		return 0;
+ 
+ 	for (i = 0; argv[i]; ++i) {
+ 		if (i >= MAX_ARG_STRINGS)
+ 			return -E2BIG;
+ 		if (fatal_signal_pending(current))
+ 			return -ERESTARTNOHAND;
+ 		cond_resched();
+ 	}
+ 	return i;
+ }
+ 
+ static int bprm_stack_limits(struct linux_binprm *bprm)
+ {
+ 	unsigned long limit, ptr_size;
+ 
+ 	/*
+ 	 * Limit to 1/4 of the max stack size or 3/4 of _STK_LIM
+ 	 * (whichever is smaller) for the argv+env strings.
+ 	 * This ensures that:
+ 	 *  - the remaining binfmt code will not run out of stack space,
+ 	 *  - the program will have a reasonable amount of stack left
+ 	 *    to work from.
+ 	 */
+ 	limit = _STK_LIM / 4 * 3;
+ 	limit = min(limit, bprm->rlim_stack.rlim_cur / 4);
+ 	/*
+ 	 * We've historically supported up to 32 pages (ARG_MAX)
+ 	 * of argument strings even with small stacks
+ 	 */
+ 	limit = max_t(unsigned long, limit, ARG_MAX);
+ 	/*
+ 	 * We must account for the size of all the argv and envp pointers to
+ 	 * the argv and envp strings, since they will also take up space in
+ 	 * the stack. They aren't stored until much later when we can't
+ 	 * signal to the parent that the child has run out of stack space.
+ 	 * Instead, calculate it here so it's possible to fail gracefully.
+ 	 *
+ 	 * In the case of argc = 0, make sure there is space for adding a
+ 	 * empty string (which will bump argc to 1), to ensure confused
+ 	 * userspace programs don't start processing from argv[1], thinking
+ 	 * argc can never be 0, to keep them from walking envp by accident.
+ 	 * See do_execveat_common().
+ 	 */
+ 	ptr_size = (max(bprm->argc, 1) + bprm->envc) * sizeof(void *);
+ 	if (limit <= ptr_size)
+ 		return -E2BIG;
+ 	limit -= ptr_size;
+ 
+ 	bprm->argmin = bprm->p - limit;
+ 	return 0;
+ }
+ 
++>>>>>>> dcd46d897adb (exec: Force single empty string when argv is empty)
  /*
   * 'copy_strings()' copies argument/environment strings from the old
   * processes's memory to the new process's stack.  The call to get_user_pages()
@@@ -1792,117 -1896,114 +1853,154 @@@ static int do_execveat_common(int fd, s
  	 * further execve() calls fail. */
  	current->flags &= ~PF_NPROC_EXCEEDED;
  
 -	bprm = alloc_bprm(fd, filename);
 -	if (IS_ERR(bprm)) {
 -		retval = PTR_ERR(bprm);
 +	retval = unshare_files(&displaced);
 +	if (retval)
  		goto out_ret;
 +
 +	retval = -ENOMEM;
 +	bprm = kzalloc(sizeof(*bprm), GFP_KERNEL);
 +	if (!bprm)
 +		goto out_files;
 +
 +	retval = prepare_bprm_creds(bprm);
 +	if (retval)
 +		goto out_free;
 +
 +	check_unsafe_exec(bprm);
 +	current->in_execve = 1;
 +
 +	file = do_open_execat(fd, filename, flags);
 +	retval = PTR_ERR(file);
 +	if (IS_ERR(file))
 +		goto out_unmark;
 +
 +	sched_exec();
 +
 +	bprm->file = file;
 +	if (fd == AT_FDCWD || filename->name[0] == '/') {
 +		bprm->filename = filename->name;
 +	} else {
 +		if (filename->name[0] == '\0')
 +			pathbuf = kasprintf(GFP_KERNEL, "/dev/fd/%d", fd);
 +		else
 +			pathbuf = kasprintf(GFP_KERNEL, "/dev/fd/%d/%s",
 +					    fd, filename->name);
 +		if (!pathbuf) {
 +			retval = -ENOMEM;
 +			goto out_unmark;
 +		}
 +		/*
 +		 * Record that a name derived from an O_CLOEXEC fd will be
 +		 * inaccessible after exec. Relies on having exclusive access to
 +		 * current->files (due to unshare_files above).
 +		 */
 +		if (close_on_exec(fd, rcu_dereference_raw(current->files->fdt)))
 +			bprm->interp_flags |= BINPRM_FLAGS_PATH_INACCESSIBLE;
 +		bprm->filename = pathbuf;
  	}
 +	bprm->interp = bprm->filename;
  
++<<<<<<< HEAD
 +	retval = bprm_mm_init(bprm);
 +	if (retval)
 +		goto out_unmark;
++=======
+ 	retval = count(argv, MAX_ARG_STRINGS);
+ 	if (retval == 0)
+ 		pr_warn_once("process '%s' launched '%s' with NULL argv: empty string added\n",
+ 			     current->comm, bprm->filename);
+ 	if (retval < 0)
+ 		goto out_free;
+ 	bprm->argc = retval;
++>>>>>>> dcd46d897adb (exec: Force single empty string when argv is empty)
  
 -	retval = count(envp, MAX_ARG_STRINGS);
 -	if (retval < 0)
 -		goto out_free;
 -	bprm->envc = retval;
 +	bprm->argc = count(argv, MAX_ARG_STRINGS);
 +	if ((retval = bprm->argc) < 0)
 +		goto out;
  
 -	retval = bprm_stack_limits(bprm);
 -	if (retval < 0)
 -		goto out_free;
 +	bprm->envc = count(envp, MAX_ARG_STRINGS);
 +	if ((retval = bprm->envc) < 0)
 +		goto out;
  
 -	retval = copy_string_kernel(bprm->filename, bprm);
 +	/* Set the unchanging part of bprm->cred */
 +	retval = security_bprm_creds_for_exec(bprm);
 +	if (retval)
 +		goto out;
 +
 +	retval = copy_strings_kernel(1, &bprm->filename, bprm);
  	if (retval < 0)
 -		goto out_free;
 -	bprm->exec = bprm->p;
 +		goto out;
  
 +	bprm->exec = bprm->p;
  	retval = copy_strings(bprm->envc, envp, bprm);
  	if (retval < 0)
 -		goto out_free;
 +		goto out;
  
  	retval = copy_strings(bprm->argc, argv, bprm);
  	if (retval < 0)
 -		goto out_free;
 +		goto out;
  
++<<<<<<< HEAD
 +	retval = exec_binprm(bprm);
 +	if (retval < 0)
 +		goto out;
 +
 +	/* execve succeeded */
 +	current->fs->in_exec = 0;
 +	current->in_execve = 0;
 +	rseq_execve(current);
 +	acct_update_integrals(current);
 +	task_numa_free(current, false);
++=======
+ 	/*
+ 	 * When argv is empty, add an empty string ("") as argv[0] to
+ 	 * ensure confused userspace programs that start processing
+ 	 * from argv[1] won't end up walking envp. See also
+ 	 * bprm_stack_limits().
+ 	 */
+ 	if (bprm->argc == 0) {
+ 		retval = copy_string_kernel("", bprm);
+ 		if (retval < 0)
+ 			goto out_free;
+ 		bprm->argc = 1;
+ 	}
+ 
+ 	retval = bprm_execve(bprm, fd, filename, flags);
+ out_free:
++>>>>>>> dcd46d897adb (exec: Force single empty string when argv is empty)
  	free_bprm(bprm);
 -
 -out_ret:
 +	kfree(pathbuf);
  	putname(filename);
 +	if (displaced)
 +		put_files_struct(displaced);
  	return retval;
 -}
 -
 -int kernel_execve(const char *kernel_filename,
 -		  const char *const *argv, const char *const *envp)
 -{
 -	struct filename *filename;
 -	struct linux_binprm *bprm;
 -	int fd = AT_FDCWD;
 -	int retval;
 -
 -	filename = getname_kernel(kernel_filename);
 -	if (IS_ERR(filename))
 -		return PTR_ERR(filename);
  
 -	bprm = alloc_bprm(fd, filename);
 -	if (IS_ERR(bprm)) {
 -		retval = PTR_ERR(bprm);
 -		goto out_ret;
 +out:
 +	if (bprm->mm) {
 +		acct_arg_size(bprm, 0);
 +		mmput(bprm->mm);
  	}
  
++<<<<<<< HEAD
 +out_unmark:
 +	current->fs->in_exec = 0;
 +	current->in_execve = 0;
++=======
+ 	retval = count_strings_kernel(argv);
+ 	if (WARN_ON_ONCE(retval == 0))
+ 		retval = -EINVAL;
+ 	if (retval < 0)
+ 		goto out_free;
+ 	bprm->argc = retval;
++>>>>>>> dcd46d897adb (exec: Force single empty string when argv is empty)
  
 -	retval = count_strings_kernel(envp);
 -	if (retval < 0)
 -		goto out_free;
 -	bprm->envc = retval;
 -
 -	retval = bprm_stack_limits(bprm);
 -	if (retval < 0)
 -		goto out_free;
 -
 -	retval = copy_string_kernel(bprm->filename, bprm);
 -	if (retval < 0)
 -		goto out_free;
 -	bprm->exec = bprm->p;
 -
 -	retval = copy_strings_kernel(bprm->envc, envp, bprm);
 -	if (retval < 0)
 -		goto out_free;
 -
 -	retval = copy_strings_kernel(bprm->argc, argv, bprm);
 -	if (retval < 0)
 -		goto out_free;
 -
 -	retval = bprm_execve(bprm, fd, filename, 0);
  out_free:
  	free_bprm(bprm);
 +	kfree(pathbuf);
 +
 +out_files:
 +	if (displaced)
 +		reset_files_struct(displaced);
  out_ret:
  	putname(filename);
  	return retval;
* Unmerged path fs/exec.c
