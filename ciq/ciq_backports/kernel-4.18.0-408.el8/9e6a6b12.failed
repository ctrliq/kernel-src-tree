nvme: paring quiesce/unquiesce

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Ming Lei <ming.lei@redhat.com>
commit 9e6a6b1212100148c109675e003369e3e219dbd9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/9e6a6b12.failed

The current blk_mq_quiesce_queue() and blk_mq_unquiesce_queue() always
stops and starts the queue unconditionally. And there can be concurrent
quiesce/unquiesce coming from different unrelated code paths, so
unquiesce may come unexpectedly and start queue too early.

Prepare for supporting concurrent quiesce/unquiesce from multiple
contexts, so that we can address the above issue.

NVMe has very complicated quiesce/unquiesce use pattern, add one atomic
bit for makeiing sure that blk-mq quiece/unquiesce is always called in
pair.

	Signed-off-by: Ming Lei <ming.lei@redhat.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
Link: https://lore.kernel.org/r/20211014081710.1871747-5-ming.lei@redhat.com
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit 9e6a6b1212100148c109675e003369e3e219dbd9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/nvme/host/core.c
#	drivers/nvme/host/nvme.h
diff --cc drivers/nvme/host/core.c
index ca7b302b6fd8,eb284f45fc44..000000000000
--- a/drivers/nvme/host/core.c
+++ b/drivers/nvme/host/core.c
@@@ -4546,6 -4466,37 +4546,40 @@@ out
  }
  EXPORT_SYMBOL_GPL(nvme_init_ctrl);
  
++<<<<<<< HEAD
++=======
+ static void nvme_start_ns_queue(struct nvme_ns *ns)
+ {
+ 	if (test_and_clear_bit(NVME_NS_STOPPED, &ns->flags))
+ 		blk_mq_unquiesce_queue(ns->queue);
+ }
+ 
+ static void nvme_stop_ns_queue(struct nvme_ns *ns)
+ {
+ 	if (!test_and_set_bit(NVME_NS_STOPPED, &ns->flags))
+ 		blk_mq_quiesce_queue(ns->queue);
+ }
+ 
+ /*
+  * Prepare a queue for teardown.
+  *
+  * This must forcibly unquiesce queues to avoid blocking dispatch, and only set
+  * the capacity to 0 after that to avoid blocking dispatchers that may be
+  * holding bd_butex.  This will end buffered writers dirtying pages that can't
+  * be synced.
+  */
+ static void nvme_set_queue_dying(struct nvme_ns *ns)
+ {
+ 	if (test_and_set_bit(NVME_NS_DEAD, &ns->flags))
+ 		return;
+ 
+ 	blk_set_queue_dying(ns->queue);
+ 	nvme_start_ns_queue(ns);
+ 
+ 	set_capacity_and_notify(ns->disk, 0);
+ }
+ 
++>>>>>>> 9e6a6b121210 (nvme: paring quiesce/unquiesce)
  /**
   * nvme_kill_queues(): Ends all namespace queues
   * @ctrl: the dead controller that needs to end
diff --cc drivers/nvme/host/nvme.h
index e7d83bc971f2,3652439a7458..000000000000
--- a/drivers/nvme/host/nvme.h
+++ b/drivers/nvme/host/nvme.h
@@@ -472,6 -463,8 +473,11 @@@ struct nvme_ns 
  #define NVME_NS_DEAD     	1
  #define NVME_NS_ANA_PENDING	2
  #define NVME_NS_FORCE_RO	3
++<<<<<<< HEAD
++=======
+ #define NVME_NS_READY		4
+ #define NVME_NS_STOPPED		5
++>>>>>>> 9e6a6b121210 (nvme: paring quiesce/unquiesce)
  
  	struct cdev		cdev;
  	struct device		cdev_device;
* Unmerged path drivers/nvme/host/core.c
* Unmerged path drivers/nvme/host/nvme.h
