KVM: stats: Add stat to detect if vcpu is currently blocking

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Jing Zhang <jingzhangos@google.com>
commit c3858335c711569b82a234a560dc19247e8f3fcc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/c3858335.failed

Add a "blocking" stat that userspace can use to detect the case where a
vCPU is not being run because of an vCPU/guest action, e.g. HLT or WFS on
x86, WFI on arm64, etc...  Current guest/host/halt stats don't show this
well, e.g. if a guest halts for a long period of time then the vCPU could
could appear pathologically blocked due to a host condition, when in
reality the vCPU has been put into a not-runnable state by the guest.

Originally-by: Cannon Matthews <cannonmatthews@google.com>
	Suggested-by: Sean Christopherson <seanjc@google.com>
	Reviewed-by: David Matlack <dmatlack@google.com>
	Signed-off-by: Jing Zhang <jingzhangos@google.com>
[sean: renamed stat to "blocking", massaged changelog]
	Signed-off-by: Sean Christopherson <seanjc@google.com>
Message-Id: <20211009021236.4122790-16-seanjc@google.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit c3858335c711569b82a234a560dc19247e8f3fcc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	virt/kvm/kvm_main.c
diff --cc virt/kvm/kvm_main.c
index 8d37c7cdca84,2630db6e8cb5..000000000000
--- a/virt/kvm/kvm_main.c
+++ b/virt/kvm/kvm_main.c
@@@ -3001,6 -3272,39 +3001,42 @@@ out
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ /*
+  * Block the vCPU until the vCPU is runnable, an event arrives, or a signal is
+  * pending.  This is mostly used when halting a vCPU, but may also be used
+  * directly for other vCPU non-runnable states, e.g. x86's Wait-For-SIPI.
+  */
+ bool kvm_vcpu_block(struct kvm_vcpu *vcpu)
+ {
+ 	struct rcuwait *wait = kvm_arch_vcpu_get_wait(vcpu);
+ 	bool waited = false;
+ 
+ 	vcpu->stat.generic.blocking = 1;
+ 
+ 	kvm_arch_vcpu_blocking(vcpu);
+ 
+ 	prepare_to_rcuwait(wait);
+ 	for (;;) {
+ 		set_current_state(TASK_INTERRUPTIBLE);
+ 
+ 		if (kvm_vcpu_check_block(vcpu) < 0)
+ 			break;
+ 
+ 		waited = true;
+ 		schedule();
+ 	}
+ 	finish_rcuwait(wait);
+ 
+ 	kvm_arch_vcpu_unblocking(vcpu);
+ 
+ 	vcpu->stat.generic.blocking = 0;
+ 
+ 	return waited;
+ }
+ 
++>>>>>>> c3858335c711 (KVM: stats: Add stat to detect if vcpu is currently blocking)
  static inline void update_halt_poll_stats(struct kvm_vcpu *vcpu, ktime_t start,
  					  ktime_t end, bool success)
  {
diff --git a/include/linux/kvm_host.h b/include/linux/kvm_host.h
index 6f79c17e60ed..048b790f7c18 100644
--- a/include/linux/kvm_host.h
+++ b/include/linux/kvm_host.h
@@ -1426,7 +1426,8 @@ struct _kvm_stats_desc {
 	STATS_DESC_LOGHIST_TIME_NSEC(VCPU_GENERIC, halt_poll_fail_hist,	       \
 			HALT_POLL_HIST_COUNT),				       \
 	STATS_DESC_LOGHIST_TIME_NSEC(VCPU_GENERIC, halt_wait_hist,	       \
-			HALT_POLL_HIST_COUNT)
+			HALT_POLL_HIST_COUNT),				       \
+	STATS_DESC_ICOUNTER(VCPU_GENERIC, blocking)
 
 extern struct dentry *kvm_debugfs_dir;
 
diff --git a/include/linux/kvm_types.h b/include/linux/kvm_types.h
index e65323751d08..0f502d8f521c 100644
--- a/include/linux/kvm_types.h
+++ b/include/linux/kvm_types.h
@@ -101,6 +101,7 @@ struct kvm_vcpu_stat_generic {
 	u64 halt_poll_success_hist[HALT_POLL_HIST_COUNT];
 	u64 halt_poll_fail_hist[HALT_POLL_HIST_COUNT];
 	u64 halt_wait_hist[HALT_POLL_HIST_COUNT];
+	u64 blocking;
 };
 
 #define KVM_STATS_NAME_SIZE	48
* Unmerged path virt/kvm/kvm_main.c
