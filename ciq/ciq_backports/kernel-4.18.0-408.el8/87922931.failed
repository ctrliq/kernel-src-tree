selinux: fix memdup.cocci warnings

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author kernel test robot <lkp@intel.com>
commit 879229311bc8a887f00d827525ea59f23861c1ad
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/87922931.failed

Use kmemdup rather than duplicating its implementation

Generated by: scripts/coccinelle/api/memdup.cocci

Fixes: c7c556f1e81b ("selinux: refactor changing booleans")
CC: Stephen Smalley <stephen.smalley.work@gmail.com>
	Signed-off-by: kernel test robot <lkp@intel.com>
	Signed-off-by: Julia Lawall <julia.lawall@inria.fr>
	Acked-by: Stephen Smalley <stephen.smalley.work@gmail.com>
	Signed-off-by: Paul Moore <paul@paul-moore.com>
(cherry picked from commit 879229311bc8a887f00d827525ea59f23861c1ad)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	security/selinux/ss/conditional.c
diff --cc security/selinux/ss/conditional.c
index 82171fda95f1,0b32f3ab025e..000000000000
--- a/security/selinux/ss/conditional.c
+++ b/security/selinux/ss/conditional.c
@@@ -603,3 -600,158 +603,161 @@@ void cond_compute_av(struct avtab *ctab
  			services_compute_xperms_drivers(xperms, node);
  	}
  }
++<<<<<<< HEAD
++=======
+ 
+ static int cond_dup_av_list(struct cond_av_list *new,
+ 			struct cond_av_list *orig,
+ 			struct avtab *avtab)
+ {
+ 	struct avtab_node *avnode;
+ 	u32 i;
+ 
+ 	memset(new, 0, sizeof(*new));
+ 
+ 	new->nodes = kcalloc(orig->len, sizeof(*new->nodes), GFP_KERNEL);
+ 	if (!new->nodes)
+ 		return -ENOMEM;
+ 
+ 	for (i = 0; i < orig->len; i++) {
+ 		avnode = avtab_search_node(avtab, &orig->nodes[i]->key);
+ 		if (WARN_ON(!avnode))
+ 			return -EINVAL;
+ 		new->nodes[i] = avnode;
+ 		new->len++;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int duplicate_policydb_cond_list(struct policydb *newp,
+ 					struct policydb *origp)
+ {
+ 	int rc, i, j;
+ 
+ 	rc = avtab_duplicate(&newp->te_cond_avtab, &origp->te_cond_avtab);
+ 	if (rc)
+ 		return rc;
+ 
+ 	newp->cond_list_len = 0;
+ 	newp->cond_list = kcalloc(origp->cond_list_len,
+ 				sizeof(*newp->cond_list),
+ 				GFP_KERNEL);
+ 	if (!newp->cond_list)
+ 		goto error;
+ 
+ 	for (i = 0; i < origp->cond_list_len; i++) {
+ 		struct cond_node *newn = &newp->cond_list[i];
+ 		struct cond_node *orign = &origp->cond_list[i];
+ 
+ 		newp->cond_list_len++;
+ 
+ 		newn->cur_state = orign->cur_state;
+ 		newn->expr.nodes = kcalloc(orign->expr.len,
+ 					sizeof(*newn->expr.nodes), GFP_KERNEL);
+ 		if (!newn->expr.nodes)
+ 			goto error;
+ 		for (j = 0; j < orign->expr.len; j++)
+ 			newn->expr.nodes[j] = orign->expr.nodes[j];
+ 		newn->expr.len = orign->expr.len;
+ 
+ 		rc = cond_dup_av_list(&newn->true_list, &orign->true_list,
+ 				&newp->te_cond_avtab);
+ 		if (rc)
+ 			goto error;
+ 
+ 		rc = cond_dup_av_list(&newn->false_list, &orign->false_list,
+ 				&newp->te_cond_avtab);
+ 		if (rc)
+ 			goto error;
+ 	}
+ 
+ 	return 0;
+ 
+ error:
+ 	avtab_destroy(&newp->te_cond_avtab);
+ 	cond_list_destroy(newp);
+ 	return -ENOMEM;
+ }
+ 
+ static int cond_bools_destroy(void *key, void *datum, void *args)
+ {
+ 	/* key was not copied so no need to free here */
+ 	kfree(datum);
+ 	return 0;
+ }
+ 
+ static int cond_bools_copy(struct hashtab_node *new, struct hashtab_node *orig, void *args)
+ {
+ 	struct cond_bool_datum *datum;
+ 
+ 	datum = kmemdup(orig->datum, sizeof(struct cond_bool_datum),
+ 			GFP_KERNEL);
+ 	if (!datum)
+ 		return -ENOMEM;
+ 
+ 	new->key = orig->key; /* No need to copy, never modified */
+ 	new->datum = datum;
+ 	return 0;
+ }
+ 
+ static int cond_bools_index(void *key, void *datum, void *args)
+ {
+ 	struct cond_bool_datum *booldatum, **cond_bool_array;
+ 
+ 	booldatum = datum;
+ 	cond_bool_array = args;
+ 	cond_bool_array[booldatum->value - 1] = booldatum;
+ 
+ 	return 0;
+ }
+ 
+ static int duplicate_policydb_bools(struct policydb *newdb,
+ 				struct policydb *orig)
+ {
+ 	struct cond_bool_datum **cond_bool_array;
+ 	int rc;
+ 
+ 	cond_bool_array = kmalloc_array(orig->p_bools.nprim,
+ 					sizeof(*orig->bool_val_to_struct),
+ 					GFP_KERNEL);
+ 	if (!cond_bool_array)
+ 		return -ENOMEM;
+ 
+ 	rc = hashtab_duplicate(&newdb->p_bools.table, &orig->p_bools.table,
+ 			cond_bools_copy, cond_bools_destroy, NULL);
+ 	if (rc) {
+ 		kfree(cond_bool_array);
+ 		return -ENOMEM;
+ 	}
+ 
+ 	hashtab_map(&newdb->p_bools.table, cond_bools_index, cond_bool_array);
+ 	newdb->bool_val_to_struct = cond_bool_array;
+ 
+ 	newdb->p_bools.nprim = orig->p_bools.nprim;
+ 
+ 	return 0;
+ }
+ 
+ void cond_policydb_destroy_dup(struct policydb *p)
+ {
+ 	hashtab_map(&p->p_bools.table, cond_bools_destroy, NULL);
+ 	hashtab_destroy(&p->p_bools.table);
+ 	cond_policydb_destroy(p);
+ }
+ 
+ int cond_policydb_dup(struct policydb *new, struct policydb *orig)
+ {
+ 	cond_policydb_init(new);
+ 
+ 	if (duplicate_policydb_bools(new, orig))
+ 		return -ENOMEM;
+ 
+ 	if (duplicate_policydb_cond_list(new, orig)) {
+ 		cond_policydb_destroy_dup(new);
+ 		return -ENOMEM;
+ 	}
+ 
+ 	return 0;
+ }
++>>>>>>> 879229311bc8 (selinux: fix memdup.cocci warnings)
* Unmerged path security/selinux/ss/conditional.c
