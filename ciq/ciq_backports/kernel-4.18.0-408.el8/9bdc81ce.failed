PCI: Change the type of probe argument in reset functions

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-408.el8
commit-author Amey Narkhede <ameynarkhede03@gmail.com>
commit 9bdc81ce440ec6ea899b236879aee470ec388020
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-408.el8/9bdc81ce.failed

Change the type of probe argument in functions which implement reset
methods from int to bool to make the context and intent clear.

	Suggested-by: Alex Williamson <alex.williamson@redhat.com>
Link: https://lore.kernel.org/r/20210817180500.1253-10-ameynarkhede03@gmail.com
	Signed-off-by: Amey Narkhede <ameynarkhede03@gmail.com>
	Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
(cherry picked from commit 9bdc81ce440ec6ea899b236879aee470ec388020)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/crypto/cavium/nitrox/nitrox_main.c
#	drivers/net/ethernet/cavium/liquidio/lio_vf_main.c
#	drivers/pci/pci-acpi.c
#	drivers/pci/pci.c
#	drivers/pci/pci.h
#	drivers/pci/pcie/aer.c
#	drivers/pci/quirks.c
#	include/linux/pci.h
#	include/linux/pci_hotplug.h
diff --cc drivers/crypto/cavium/nitrox/nitrox_main.c
index b3f6f56f0bc6,6c61817996a3..000000000000
--- a/drivers/crypto/cavium/nitrox/nitrox_main.c
+++ b/drivers/crypto/cavium/nitrox/nitrox_main.c
@@@ -220,9 -306,7 +220,13 @@@ static int nitrox_device_flr(struct pci
  		return -ENOMEM;
  	}
  
++<<<<<<< HEAD
 +	/* check flr support */
 +	if (pcie_has_flr(pdev))
 +		pcie_flr(pdev);
++=======
+ 	pcie_reset_flr(pdev, PCI_RESET_DO_RESET);
++>>>>>>> 9bdc81ce440e (PCI: Change the type of probe argument in reset functions)
  
  	pci_restore_state(pdev);
  
diff --cc drivers/net/ethernet/cavium/liquidio/lio_vf_main.c
index 5b00e0c6e1eb,ac821c5532a4..000000000000
--- a/drivers/net/ethernet/cavium/liquidio/lio_vf_main.c
+++ b/drivers/net/ethernet/cavium/liquidio/lio_vf_main.c
@@@ -510,7 -526,7 +510,11 @@@ static void octeon_destroy_resources(st
  			oct->irq_name_storage = NULL;
  		}
  		/* Soft reset the octeon device before exiting */
++<<<<<<< HEAD
 +		if (oct->pci_dev->reset_fn)
++=======
+ 		if (!pcie_reset_flr(oct->pci_dev, PCI_RESET_PROBE))
++>>>>>>> 9bdc81ce440e (PCI: Change the type of probe argument in reset functions)
  			octeon_pci_flr(oct);
  		else
  			cn23xx_vf_ask_pf_to_do_flr(oct);
diff --cc drivers/pci/pci-acpi.c
index c33c87c0729f,fe286c861187..000000000000
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@@ -941,6 -941,29 +941,32 @@@ void pci_set_acpi_fwnode(struct pci_de
  				   acpi_pci_find_companion(&dev->dev));
  }
  
++<<<<<<< HEAD
++=======
+ /**
+  * pci_dev_acpi_reset - do a function level reset using _RST method
+  * @dev: device to reset
+  * @probe: if true, return 0 if device supports _RST
+  */
+ int pci_dev_acpi_reset(struct pci_dev *dev, bool probe)
+ {
+ 	acpi_handle handle = ACPI_HANDLE(&dev->dev);
+ 
+ 	if (!handle || !acpi_has_method(handle, "_RST"))
+ 		return -ENOTTY;
+ 
+ 	if (probe)
+ 		return 0;
+ 
+ 	if (ACPI_FAILURE(acpi_evaluate_object(handle, "_RST", NULL, NULL))) {
+ 		pci_warn(dev, "ACPI _RST failed\n");
+ 		return -ENOTTY;
+ 	}
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> 9bdc81ce440e (PCI: Change the type of probe argument in reset functions)
  static bool acpi_pci_power_manageable(struct pci_dev *dev)
  {
  	struct acpi_device *adev = ACPI_COMPANION(&dev->dev);
diff --cc drivers/pci/pci.c
index c3df2812af1a,b87bac5e4572..000000000000
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@@ -4645,7 -4655,29 +4645,33 @@@ int pcie_flr(struct pci_dev *dev
  }
  EXPORT_SYMBOL_GPL(pcie_flr);
  
++<<<<<<< HEAD
 +static int pci_af_flr(struct pci_dev *dev, int probe)
++=======
+ /**
+  * pcie_reset_flr - initiate a PCIe function level reset
+  * @dev: device to reset
+  * @probe: if true, return 0 if device can be reset this way
+  *
+  * Initiate a function level reset on @dev.
+  */
+ int pcie_reset_flr(struct pci_dev *dev, bool probe)
+ {
+ 	if (dev->dev_flags & PCI_DEV_FLAGS_NO_FLR_RESET)
+ 		return -ENOTTY;
+ 
+ 	if (!(dev->devcap & PCI_EXP_DEVCAP_FLR))
+ 		return -ENOTTY;
+ 
+ 	if (probe)
+ 		return 0;
+ 
+ 	return pcie_flr(dev);
+ }
+ EXPORT_SYMBOL_GPL(pcie_reset_flr);
+ 
+ static int pci_af_flr(struct pci_dev *dev, bool probe)
++>>>>>>> 9bdc81ce440e (PCI: Change the type of probe argument in reset functions)
  {
  	int pos;
  	u8 cap;
@@@ -4701,10 -4733,10 +4727,10 @@@
   *
   * NOTE: This causes the caller to sleep for twice the device power transition
   * cooldown period, which for the D0->D3hot and D3hot->D0 transitions is 10 ms
 - * by default (i.e. unless the @dev's d3hot_delay field has a different value).
 + * by default (i.e. unless the @dev's d3_delay field has a different value).
   * Moreover, only devices in D0 can be reset by this function.
   */
- static int pci_pm_reset(struct pci_dev *dev, int probe)
+ static int pci_pm_reset(struct pci_dev *dev, bool probe)
  {
  	u16 csr;
  
@@@ -5088,6 -5122,139 +5114,142 @@@ static void pci_dev_restore(struct pci_
  		err_handler->reset_done(dev);
  }
  
++<<<<<<< HEAD
++=======
+ /* dev->reset_methods[] is a 0-terminated list of indices into this array */
+ static const struct pci_reset_fn_method pci_reset_fn_methods[] = {
+ 	{ },
+ 	{ pci_dev_specific_reset, .name = "device_specific" },
+ 	{ pci_dev_acpi_reset, .name = "acpi" },
+ 	{ pcie_reset_flr, .name = "flr" },
+ 	{ pci_af_flr, .name = "af_flr" },
+ 	{ pci_pm_reset, .name = "pm" },
+ 	{ pci_reset_bus_function, .name = "bus" },
+ };
+ 
+ static ssize_t reset_method_show(struct device *dev,
+ 				 struct device_attribute *attr, char *buf)
+ {
+ 	struct pci_dev *pdev = to_pci_dev(dev);
+ 	ssize_t len = 0;
+ 	int i, m;
+ 
+ 	for (i = 0; i < PCI_NUM_RESET_METHODS; i++) {
+ 		m = pdev->reset_methods[i];
+ 		if (!m)
+ 			break;
+ 
+ 		len += sysfs_emit_at(buf, len, "%s%s", len ? " " : "",
+ 				     pci_reset_fn_methods[m].name);
+ 	}
+ 
+ 	if (len)
+ 		len += sysfs_emit_at(buf, len, "\n");
+ 
+ 	return len;
+ }
+ 
+ static int reset_method_lookup(const char *name)
+ {
+ 	int m;
+ 
+ 	for (m = 1; m < PCI_NUM_RESET_METHODS; m++) {
+ 		if (sysfs_streq(name, pci_reset_fn_methods[m].name))
+ 			return m;
+ 	}
+ 
+ 	return 0;	/* not found */
+ }
+ 
+ static ssize_t reset_method_store(struct device *dev,
+ 				  struct device_attribute *attr,
+ 				  const char *buf, size_t count)
+ {
+ 	struct pci_dev *pdev = to_pci_dev(dev);
+ 	char *options, *name;
+ 	int m, n;
+ 	u8 reset_methods[PCI_NUM_RESET_METHODS] = { 0 };
+ 
+ 	if (sysfs_streq(buf, "")) {
+ 		pdev->reset_methods[0] = 0;
+ 		pci_warn(pdev, "All device reset methods disabled by user");
+ 		return count;
+ 	}
+ 
+ 	if (sysfs_streq(buf, "default")) {
+ 		pci_init_reset_methods(pdev);
+ 		return count;
+ 	}
+ 
+ 	options = kstrndup(buf, count, GFP_KERNEL);
+ 	if (!options)
+ 		return -ENOMEM;
+ 
+ 	n = 0;
+ 	while ((name = strsep(&options, " ")) != NULL) {
+ 		if (sysfs_streq(name, ""))
+ 			continue;
+ 
+ 		name = strim(name);
+ 
+ 		m = reset_method_lookup(name);
+ 		if (!m) {
+ 			pci_err(pdev, "Invalid reset method '%s'", name);
+ 			goto error;
+ 		}
+ 
+ 		if (pci_reset_fn_methods[m].reset_fn(pdev, PCI_RESET_PROBE)) {
+ 			pci_err(pdev, "Unsupported reset method '%s'", name);
+ 			goto error;
+ 		}
+ 
+ 		if (n == PCI_NUM_RESET_METHODS - 1) {
+ 			pci_err(pdev, "Too many reset methods\n");
+ 			goto error;
+ 		}
+ 
+ 		reset_methods[n++] = m;
+ 	}
+ 
+ 	reset_methods[n] = 0;
+ 
+ 	/* Warn if dev-specific supported but not highest priority */
+ 	if (pci_reset_fn_methods[1].reset_fn(pdev, PCI_RESET_PROBE) == 0 &&
+ 	    reset_methods[0] != 1)
+ 		pci_warn(pdev, "Device-specific reset disabled/de-prioritized by user");
+ 	memcpy(pdev->reset_methods, reset_methods, sizeof(pdev->reset_methods));
+ 	kfree(options);
+ 	return count;
+ 
+ error:
+ 	/* Leave previous methods unchanged */
+ 	kfree(options);
+ 	return -EINVAL;
+ }
+ static DEVICE_ATTR_RW(reset_method);
+ 
+ static struct attribute *pci_dev_reset_method_attrs[] = {
+ 	&dev_attr_reset_method.attr,
+ 	NULL,
+ };
+ 
+ static umode_t pci_dev_reset_method_attr_is_visible(struct kobject *kobj,
+ 						    struct attribute *a, int n)
+ {
+ 	struct pci_dev *pdev = to_pci_dev(kobj_to_dev(kobj));
+ 
+ 	if (!pci_reset_supported(pdev))
+ 		return 0;
+ 
+ 	return a->mode;
+ }
+ 
+ const struct attribute_group pci_dev_reset_method_attr_group = {
+ 	.attrs = pci_dev_reset_method_attrs,
+ 	.is_visible = pci_dev_reset_method_attr_is_visible,
+ };
+ 
++>>>>>>> 9bdc81ce440e (PCI: Change the type of probe argument in reset functions)
  /**
   * __pci_reset_function_locked - reset a PCI device function while holding
   * the @dev mutex lock.
@@@ -5115,18 -5282,21 +5277,29 @@@ int __pci_reset_function_locked(struct 
  	might_sleep();
  
  	/*
 -	 * A reset method returns -ENOTTY if it doesn't support this device and
 -	 * we should try the next method.
 +	 * A reset method returns -ENOTTY if it doesn't support this device
 +	 * and we should try the next method.
  	 *
 -	 * If it returns 0 (success), we're finished.  If it returns any other
 -	 * error, we're also finished: this indicates that further reset
 -	 * mechanisms might be broken on the device.
 +	 * If it returns 0 (success), we're finished.  If it returns any
 +	 * other error, we're also finished: this indicates that further
 +	 * reset mechanisms might be broken on the device.
  	 */
++<<<<<<< HEAD
 +	rc = pci_dev_specific_reset(dev, 0);
 +	if (rc != -ENOTTY)
 +		return rc;
 +	if (pcie_has_flr(dev)) {
 +		rc = pcie_flr(dev);
++=======
+ 	for (i = 0; i < PCI_NUM_RESET_METHODS; i++) {
+ 		m = dev->reset_methods[i];
+ 		if (!m)
+ 			return -ENOTTY;
+ 
+ 		rc = pci_reset_fn_methods[m].reset_fn(dev, PCI_RESET_DO_RESET);
+ 		if (!rc)
+ 			return 0;
++>>>>>>> 9bdc81ce440e (PCI: Change the type of probe argument in reset functions)
  		if (rc != -ENOTTY)
  			return rc;
  	}
@@@ -5157,19 -5325,16 +5330,30 @@@ int pci_probe_reset_function(struct pci
  
  	might_sleep();
  
++<<<<<<< HEAD
 +	rc = pci_dev_specific_reset(dev, 1);
 +	if (rc != -ENOTTY)
 +		return rc;
 +	if (pcie_has_flr(dev))
 +		return 0;
 +	rc = pci_af_flr(dev, 1);
 +	if (rc != -ENOTTY)
 +		return rc;
 +	rc = pci_pm_reset(dev, 1);
 +	if (rc != -ENOTTY)
 +		return rc;
++=======
+ 	i = 0;
+ 	for (m = 1; m < PCI_NUM_RESET_METHODS; m++) {
+ 		rc = pci_reset_fn_methods[m].reset_fn(dev, PCI_RESET_PROBE);
+ 		if (!rc)
+ 			dev->reset_methods[i++] = m;
+ 		else if (rc != -ENOTTY)
+ 			break;
+ 	}
++>>>>>>> 9bdc81ce440e (PCI: Change the type of probe argument in reset functions)
  
 -	dev->reset_methods[i] = 0;
 +	return pci_reset_bus_function(dev, 1);
  }
  
  /**
diff --cc drivers/pci/pci.h
index ff387d8e7bf8,05b7e7e04246..000000000000
--- a/drivers/pci/pci.h
+++ b/drivers/pci/pci.h
@@@ -613,13 -608,18 +613,21 @@@ static inline void pci_ptm_init(struct 
  struct pci_dev_reset_methods {
  	u16 vendor;
  	u16 device;
- 	int (*reset)(struct pci_dev *dev, int probe);
+ 	int (*reset)(struct pci_dev *dev, bool probe);
  };
  
++<<<<<<< HEAD
++=======
+ struct pci_reset_fn_method {
+ 	int (*reset_fn)(struct pci_dev *pdev, bool probe);
+ 	char *name;
+ };
+ 
++>>>>>>> 9bdc81ce440e (PCI: Change the type of probe argument in reset functions)
  #ifdef CONFIG_PCI_QUIRKS
- int pci_dev_specific_reset(struct pci_dev *dev, int probe);
+ int pci_dev_specific_reset(struct pci_dev *dev, bool probe);
  #else
- static inline int pci_dev_specific_reset(struct pci_dev *dev, int probe)
+ static inline int pci_dev_specific_reset(struct pci_dev *dev, bool probe)
  {
  	return -ENOTTY;
  }
@@@ -707,7 -708,13 +715,17 @@@ static inline int pci_aer_raw_clear_sta
  int pci_acpi_program_hp_params(struct pci_dev *dev);
  extern const struct attribute_group pci_dev_acpi_attr_group;
  void pci_set_acpi_fwnode(struct pci_dev *dev);
++<<<<<<< HEAD
 +#else
++=======
+ int pci_dev_acpi_reset(struct pci_dev *dev, bool probe);
+ #else
+ static inline int pci_dev_acpi_reset(struct pci_dev *dev, bool probe)
+ {
+ 	return -ENOTTY;
+ }
+ 
++>>>>>>> 9bdc81ce440e (PCI: Change the type of probe argument in reset functions)
  static inline void pci_set_acpi_fwnode(struct pci_dev *dev) {}
  static inline int pci_acpi_program_hp_params(struct pci_dev *dev)
  {
diff --cc drivers/pci/pcie/aer.c
index 050d92bbf51c,9784fdcf3006..000000000000
--- a/drivers/pci/pcie/aer.c
+++ b/drivers/pci/pcie/aer.c
@@@ -1405,13 -1407,11 +1405,21 @@@ static pci_ers_result_t aer_root_reset(
  	}
  
  	if (type == PCI_EXP_TYPE_RC_EC || type == PCI_EXP_TYPE_RC_END) {
++<<<<<<< HEAD
 +		if (pcie_has_flr(dev)) {
 +			rc = pcie_flr(dev);
 +			pci_info(dev, "has been reset (%d)\n", rc);
 +		} else {
 +			pci_info(dev, "not reset (no FLR support)\n");
 +			rc = -ENOTTY;
 +		}
++=======
+ 		rc = pcie_reset_flr(dev, PCI_RESET_DO_RESET);
+ 		if (!rc)
+ 			pci_info(dev, "has been reset\n");
+ 		else
+ 			pci_info(dev, "not reset (no FLR support: %d)\n", rc);
++>>>>>>> 9bdc81ce440e (PCI: Change the type of probe argument in reset functions)
  	} else {
  		rc = pci_bus_error_reset(dev);
  		pci_info(dev, "%s Port link has been reset (%d)\n",
diff --cc drivers/pci/quirks.c
index 62f27075a735,e7657b8c8a33..000000000000
--- a/drivers/pci/quirks.c
+++ b/drivers/pci/quirks.c
@@@ -3848,7 -3852,7 +3848,11 @@@ static int nvme_disable_and_flr(struct 
  	u32 cfg;
  
  	if (dev->class != PCI_CLASS_STORAGE_EXPRESS ||
++<<<<<<< HEAD
 +	    !pcie_has_flr(dev) || !pci_resource_start(dev, 0))
++=======
+ 	    pcie_reset_flr(dev, PCI_RESET_PROBE) || !pci_resource_start(dev, 0))
++>>>>>>> 9bdc81ce440e (PCI: Change the type of probe argument in reset functions)
  		return -ENOTTY;
  
  	if (probe)
@@@ -3915,10 -3919,31 +3919,36 @@@
   * device too soon after FLR.  A 250ms delay after FLR has heuristically
   * proven to produce reliably working results for device assignment cases.
   */
- static int delay_250ms_after_flr(struct pci_dev *dev, int probe)
+ static int delay_250ms_after_flr(struct pci_dev *dev, bool probe)
  {
++<<<<<<< HEAD
 +	if (!pcie_has_flr(dev))
 +		return -ENOTTY;
++=======
+ 	if (probe)
+ 		return pcie_reset_flr(dev, PCI_RESET_PROBE);
+ 
+ 	pcie_reset_flr(dev, PCI_RESET_DO_RESET);
+ 
+ 	msleep(250);
+ 
+ 	return 0;
+ }
+ 
+ #define PCI_DEVICE_ID_HINIC_VF      0x375E
+ #define HINIC_VF_FLR_TYPE           0x1000
+ #define HINIC_VF_FLR_CAP_BIT        (1UL << 30)
+ #define HINIC_VF_OP                 0xE80
+ #define HINIC_VF_FLR_PROC_BIT       (1UL << 18)
+ #define HINIC_OPERATION_TIMEOUT     15000	/* 15 seconds */
+ 
+ /* Device-specific reset method for Huawei Intelligent NIC virtual functions */
+ static int reset_hinic_vf_dev(struct pci_dev *pdev, bool probe)
+ {
+ 	unsigned long timeout;
+ 	void __iomem *bar;
+ 	u32 val;
++>>>>>>> 9bdc81ce440e (PCI: Change the type of probe argument in reset functions)
  
  	if (probe)
  		return 0;
diff --cc include/linux/pci.h
index 0b97f3c12e39,a46363f29b68..000000000000
--- a/include/linux/pci.h
+++ b/include/linux/pci.h
@@@ -51,6 -49,12 +51,15 @@@
  			       PCI_STATUS_SIG_TARGET_ABORT | \
  			       PCI_STATUS_PARITY)
  
++<<<<<<< HEAD
++=======
+ /* Number of reset methods used in pci_reset_fn_methods array in pci.c */
+ #define PCI_NUM_RESET_METHODS 7
+ 
+ #define PCI_RESET_PROBE		true
+ #define PCI_RESET_DO_RESET	false
+ 
++>>>>>>> 9bdc81ce440e (PCI: Change the type of probe argument in reset functions)
  /*
   * The PCI interface treats multi-function devices as independent
   * devices.  The slot/function address of each device is encoded
@@@ -1293,7 -1237,7 +1302,11 @@@ u32 pcie_bandwidth_available(struct pci
  			     enum pci_bus_speed *speed,
  			     enum pcie_link_width *width);
  void pcie_print_link_status(struct pci_dev *dev);
++<<<<<<< HEAD
 +bool pcie_has_flr(struct pci_dev *dev);
++=======
+ int pcie_reset_flr(struct pci_dev *dev, bool probe);
++>>>>>>> 9bdc81ce440e (PCI: Change the type of probe argument in reset functions)
  int pcie_flr(struct pci_dev *dev);
  int __pci_reset_function_locked(struct pci_dev *dev);
  int pci_reset_function(struct pci_dev *dev);
diff --cc include/linux/pci_hotplug.h
index 23c34e84c086,3a10d6ec3ee7..000000000000
--- a/include/linux/pci_hotplug.h
+++ b/include/linux/pci_hotplug.h
@@@ -44,16 -44,7 +44,20 @@@ struct hotplug_slot_ops 
  	int (*get_attention_status)	(struct hotplug_slot *slot, u8 *value);
  	int (*get_latch_status)		(struct hotplug_slot *slot, u8 *value);
  	int (*get_adapter_status)	(struct hotplug_slot *slot, u8 *value);
++<<<<<<< HEAD
 +	int (*reset_slot)		(struct hotplug_slot *slot, int probe);
 +
 +	RH_KABI_RESERVE(1)
 +	RH_KABI_RESERVE(2)
 +	RH_KABI_RESERVE(3)
 +	RH_KABI_RESERVE(4)
 +	RH_KABI_RESERVE(5)
 +	RH_KABI_RESERVE(6)
 +	RH_KABI_RESERVE(7)
 +	RH_KABI_RESERVE(8)
++=======
+ 	int (*reset_slot)		(struct hotplug_slot *slot, bool probe);
++>>>>>>> 9bdc81ce440e (PCI: Change the type of probe argument in reset functions)
  };
  
  /**
* Unmerged path drivers/crypto/cavium/nitrox/nitrox_main.c
* Unmerged path drivers/net/ethernet/cavium/liquidio/lio_vf_main.c
diff --git a/drivers/pci/hotplug/pciehp.h b/drivers/pci/hotplug/pciehp.h
index 104188112c2e..b2d3abc4b78c 100644
--- a/drivers/pci/hotplug/pciehp.h
+++ b/drivers/pci/hotplug/pciehp.h
@@ -181,7 +181,7 @@ void pciehp_release_ctrl(struct controller *ctrl);
 
 int pciehp_sysfs_enable_slot(struct hotplug_slot *hotplug_slot);
 int pciehp_sysfs_disable_slot(struct hotplug_slot *hotplug_slot);
-int pciehp_reset_slot(struct hotplug_slot *hotplug_slot, int probe);
+int pciehp_reset_slot(struct hotplug_slot *hotplug_slot, bool probe);
 int pciehp_get_attention_status(struct hotplug_slot *hotplug_slot, u8 *status);
 int pciehp_set_raw_indicator_status(struct hotplug_slot *h_slot, u8 status);
 int pciehp_get_raw_indicator_status(struct hotplug_slot *h_slot, u8 *status);
diff --git a/drivers/pci/hotplug/pciehp_hpc.c b/drivers/pci/hotplug/pciehp_hpc.c
index 5c5fb9f096a0..83a0fa119cae 100644
--- a/drivers/pci/hotplug/pciehp_hpc.c
+++ b/drivers/pci/hotplug/pciehp_hpc.c
@@ -896,7 +896,7 @@ int pciehp_slot_reset(struct pcie_device *dev)
  * momentarily, if we see that they could interfere. Also, clear any spurious
  * events after.
  */
-int pciehp_reset_slot(struct hotplug_slot *hotplug_slot, int probe)
+int pciehp_reset_slot(struct hotplug_slot *hotplug_slot, bool probe)
 {
 	struct controller *ctrl = to_ctrl(hotplug_slot);
 	struct pci_dev *pdev = ctrl_dev(ctrl);
diff --git a/drivers/pci/hotplug/pnv_php.c b/drivers/pci/hotplug/pnv_php.c
index 04565162a449..f4c2e6e01be0 100644
--- a/drivers/pci/hotplug/pnv_php.c
+++ b/drivers/pci/hotplug/pnv_php.c
@@ -526,7 +526,7 @@ static int pnv_php_enable(struct pnv_php_slot *php_slot, bool rescan)
 	return 0;
 }
 
-static int pnv_php_reset_slot(struct hotplug_slot *slot, int probe)
+static int pnv_php_reset_slot(struct hotplug_slot *slot, bool probe)
 {
 	struct pnv_php_slot *php_slot = to_pnv_php_slot(slot);
 	struct pci_dev *bridge = php_slot->pdev;
* Unmerged path drivers/pci/pci-acpi.c
* Unmerged path drivers/pci/pci.c
* Unmerged path drivers/pci/pci.h
* Unmerged path drivers/pci/pcie/aer.c
* Unmerged path drivers/pci/quirks.c
* Unmerged path include/linux/pci.h
* Unmerged path include/linux/pci_hotplug.h
