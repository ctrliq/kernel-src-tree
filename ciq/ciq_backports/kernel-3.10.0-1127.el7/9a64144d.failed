net/mlx5: E-Switch, Fix default encap mode

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1127.el7
commit-author Maor Gottlieb <maorg@mellanox.com>
commit 9a64144d683a4395f57562d90247c61a0bf5105f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1127.el7/9a64144d.failed

Encap mode is related to switchdev mode only. Move the init of
the encap mode to eswitch_offloads. Before this change, we reported
that eswitch supports encap, even tough the device was in non
SRIOV mode.

Fixes: 7768d1971de67 ('net/mlx5: E-Switch, Add control for encapsulation')
	Signed-off-by: Maor Gottlieb <maorg@mellanox.com>
	Reviewed-by: Roi Dayan <roid@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit 9a64144d683a4395f57562d90247c61a0bf5105f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
index c04fe56f0335,c2beadc41c40..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
@@@ -1604,9 -1840,13 +1604,19 @@@ int esw_offloads_init(struct mlx5_eswit
  {
  	int err;
  
++<<<<<<< HEAD
 +	mutex_init(&esw->fdb_table.offloads.fdb_prio_lock);
 +
 +	err = esw_offloads_steering_init(esw, nvports);
++=======
+ 	if (MLX5_CAP_ESW_FLOWTABLE_FDB(esw->dev, reformat) &&
+ 	    MLX5_CAP_ESW_FLOWTABLE_FDB(esw->dev, decap))
+ 		esw->offloads.encap = DEVLINK_ESWITCH_ENCAP_MODE_BASIC;
+ 	else
+ 		esw->offloads.encap = DEVLINK_ESWITCH_ENCAP_MODE_NONE;
+ 
+ 	err = esw_offloads_steering_init(esw, vf_nvports, total_nvports);
++>>>>>>> 9a64144d683a (net/mlx5: E-Switch, Fix default encap mode)
  	if (err)
  		return err;
  
@@@ -1643,11 -1891,23 +1653,12 @@@ static int esw_offloads_stop(struct mlx
  	return err;
  }
  
 -void esw_offloads_cleanup(struct mlx5_eswitch *esw)
 +void esw_offloads_cleanup(struct mlx5_eswitch *esw, int nvports)
  {
 -	u16 num_vfs;
 -
 -	if (mlx5_core_is_ecpf_esw_manager(esw->dev)) {
 -		mlx5_eq_notifier_unregister(esw->dev, &esw->host_info.nb);
 -		flush_workqueue(esw->work_queue);
 -		num_vfs = esw->host_info.num_vfs;
 -	} else {
 -		num_vfs = esw->dev->priv.sriov.num_vfs;
 -	}
 -
 -	mlx5_rdma_disable_roce(esw->dev);
  	esw_offloads_devcom_cleanup(esw);
 -	esw_offloads_unload_all_reps(esw, num_vfs);
 +	esw_offloads_unload_reps(esw, nvports);
  	esw_offloads_steering_cleanup(esw);
+ 	esw->offloads.encap = DEVLINK_ESWITCH_ENCAP_MODE_NONE;
  }
  
  static int esw_mode_from_devlink(u16 mode, u16 *mlx5_mode)
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
index 7a65b2da3f8b..0ccdd0e758d3 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
@@ -1742,11 +1742,6 @@ int mlx5_eswitch_init(struct mlx5_core_dev *dev)
 	esw->enabled_vports = 0;
 	esw->mode = SRIOV_NONE;
 	esw->offloads.inline_mode = MLX5_INLINE_MODE_NONE;
-	if (MLX5_CAP_ESW_FLOWTABLE_FDB(dev, reformat) &&
-	    MLX5_CAP_ESW_FLOWTABLE_FDB(dev, decap))
-		esw->offloads.encap = DEVLINK_ESWITCH_ENCAP_MODE_BASIC;
-	else
-		esw->offloads.encap = DEVLINK_ESWITCH_ENCAP_MODE_NONE;
 
 	dev->priv.eswitch = esw;
 	return 0;
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
