RDMA/uverbs: Simplify UVERBS_OBJECT and _TREE family of macros

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Jason Gunthorpe <jgg@mellanox.com>
commit 6c61d2a55c4e5980e231fac9bb54e6ff1a5e811b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/6c61d2a5.failed

Instead of the large set of indirecting macros, define the few needed
macros to directly instantiate the struct uverbs_oject_tree_def and
associated objects list.

This is small amount of code duplication but the readability is far
better.

	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
	Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
(cherry picked from commit 6c61d2a55c4e5980e231fac9bb54e6ff1a5e811b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/core/uverbs_std_types.c
#	drivers/infiniband/hw/mlx5/devx.c
#	include/rdma/uverbs_ioctl.h
#	include/rdma/uverbs_named_ioctl.h
diff --cc drivers/infiniband/core/uverbs_std_types.c
index f83837ce24d4,8d037f722c4d..000000000000
--- a/drivers/infiniband/core/uverbs_std_types.c
+++ b/drivers/infiniband/core/uverbs_std_types.c
@@@ -203,17 -209,12 +203,26 @@@ static int uverbs_hot_unplug_completion
  	return 0;
  };
  
++<<<<<<< HEAD
 +/*
 + * This spec is used in order to pass information to the hardware driver in a
 + * legacy way. Every verb that could get driver specific data should get this
 + * spec.
 + */
 +const struct uverbs_attr_def uverbs_uhw_compat_in =
 +	UVERBS_ATTR_PTR_IN_SZ(UVERBS_ATTR_UHW_IN, UVERBS_ATTR_MIN_SIZE(0),
 +			      UA_FLAGS(UVERBS_ATTR_SPEC_F_MIN_SZ_OR_ZERO));
 +const struct uverbs_attr_def uverbs_uhw_compat_out =
 +	UVERBS_ATTR_PTR_OUT_SZ(UVERBS_ATTR_UHW_OUT, UVERBS_ATTR_MIN_SIZE(0),
 +			       UA_FLAGS(UVERBS_ATTR_SPEC_F_MIN_SZ_OR_ZERO));
++=======
+ int uverbs_destroy_def_handler(struct ib_device *ib_dev,
+ 			       struct ib_uverbs_file *file,
+ 			       struct uverbs_attr_bundle *attrs)
+ {
+ 	return 0;
+ }
++>>>>>>> 6c61d2a55c4e (RDMA/uverbs: Simplify UVERBS_OBJECT and _TREE family of macros)
  
  void create_udata(struct uverbs_attr_bundle *ctx, struct ib_udata *udata)
  {
@@@ -293,20 -288,23 +302,40 @@@ DECLARE_UVERBS_NAMED_OBJECT(UVERBS_OBJE
  
  DECLARE_UVERBS_NAMED_OBJECT(UVERBS_OBJECT_DEVICE, NULL);
  
++<<<<<<< HEAD
 +static DECLARE_UVERBS_OBJECT_TREE(uverbs_default_objects,
 +				  &UVERBS_OBJECT(UVERBS_OBJECT_DEVICE),
 +				  &UVERBS_OBJECT(UVERBS_OBJECT_PD),
 +				  &UVERBS_OBJECT(UVERBS_OBJECT_MR),
 +				  &UVERBS_OBJECT(UVERBS_OBJECT_COMP_CHANNEL),
 +				  &UVERBS_OBJECT(UVERBS_OBJECT_CQ),
 +				  &UVERBS_OBJECT(UVERBS_OBJECT_QP),
 +				  &UVERBS_OBJECT(UVERBS_OBJECT_AH),
 +				  &UVERBS_OBJECT(UVERBS_OBJECT_MW),
 +				  &UVERBS_OBJECT(UVERBS_OBJECT_SRQ),
 +				  &UVERBS_OBJECT(UVERBS_OBJECT_FLOW),
 +				  &UVERBS_OBJECT(UVERBS_OBJECT_WQ),
 +				  &UVERBS_OBJECT(UVERBS_OBJECT_RWQ_IND_TBL),
 +				  &UVERBS_OBJECT(UVERBS_OBJECT_XRCD));
++=======
+ DECLARE_UVERBS_OBJECT_TREE(uverbs_default_objects,
+ 			   &UVERBS_OBJECT(UVERBS_OBJECT_DEVICE),
+ 			   &UVERBS_OBJECT(UVERBS_OBJECT_PD),
+ 			   &UVERBS_OBJECT(UVERBS_OBJECT_MR),
+ 			   &UVERBS_OBJECT(UVERBS_OBJECT_COMP_CHANNEL),
+ 			   &UVERBS_OBJECT(UVERBS_OBJECT_CQ),
+ 			   &UVERBS_OBJECT(UVERBS_OBJECT_QP),
+ 			   &UVERBS_OBJECT(UVERBS_OBJECT_AH),
+ 			   &UVERBS_OBJECT(UVERBS_OBJECT_MW),
+ 			   &UVERBS_OBJECT(UVERBS_OBJECT_SRQ),
+ 			   &UVERBS_OBJECT(UVERBS_OBJECT_FLOW),
+ 			   &UVERBS_OBJECT(UVERBS_OBJECT_WQ),
+ 			   &UVERBS_OBJECT(UVERBS_OBJECT_RWQ_IND_TBL),
+ 			   &UVERBS_OBJECT(UVERBS_OBJECT_XRCD),
+ 			   &UVERBS_OBJECT(UVERBS_OBJECT_FLOW_ACTION),
+ 			   &UVERBS_OBJECT(UVERBS_OBJECT_DM),
+ 			   &UVERBS_OBJECT(UVERBS_OBJECT_COUNTERS));
++>>>>>>> 6c61d2a55c4e (RDMA/uverbs: Simplify UVERBS_OBJECT and _TREE family of macros)
  
  const struct uverbs_object_tree_def *uverbs_default_get_objects(void)
  {
diff --cc include/rdma/uverbs_ioctl.h
index 2cc45699a237,392936ad25ba..000000000000
--- a/include/rdma/uverbs_ioctl.h
+++ b/include/rdma/uverbs_ioctl.h
@@@ -214,110 -208,78 +214,139 @@@ struct uverbs_object_tree_def 
  #define UVERBS_ATTR_MIN_SIZE(_min_len)				\
  	UVERBS_ATTR_SIZE(_min_len, USHRT_MAX)
  
 -/* Must be used in the '...' of any UVERBS_ATTR */
 -#define UA_FLAGS(_flags) .flags = _flags
 -
 -#define UVERBS_ATTR_IDR(_attr_id, _idr_type, _access, ...)                     \
 -	((const struct uverbs_attr_def){                                       \
 -		.id = _attr_id,                                                \
 -		.attr = { .type = UVERBS_ATTR_TYPE_IDR,                        \
 -			  .u.obj.obj_type = _idr_type,                         \
 -			  .u.obj.access = _access,                             \
 -			  __VA_ARGS__ } })
 -
 -#define UVERBS_ATTR_FD(_attr_id, _fd_type, _access, ...)                       \
 -	((const struct uverbs_attr_def){                                       \
 -		.id = (_attr_id) +                                             \
 -		      BUILD_BUG_ON_ZERO((_access) != UVERBS_ACCESS_NEW &&      \
 -					(_access) != UVERBS_ACCESS_READ),      \
 -		.attr = { .type = UVERBS_ATTR_TYPE_FD,                         \
 -			  .u.obj.obj_type = _fd_type,                          \
 -			  .u.obj.access = _access,                             \
 -			  __VA_ARGS__ } })
 -
 -#define UVERBS_ATTR_PTR_IN(_attr_id, _type, ...)                               \
 -	((const struct uverbs_attr_def){                                       \
 -		.id = _attr_id,                                                \
 -		.attr = { .type = UVERBS_ATTR_TYPE_PTR_IN,                     \
 -			  _type,                                               \
 -			  __VA_ARGS__ } })
 -
 -#define UVERBS_ATTR_PTR_OUT(_attr_id, _type, ...)                              \
 -	((const struct uverbs_attr_def){                                       \
 -		.id = _attr_id,                                                \
 -		.attr = { .type = UVERBS_ATTR_TYPE_PTR_OUT,                    \
 -			  _type,                                               \
 -			  __VA_ARGS__ } })
 -
 -/* _enum_arry should be a 'static const union uverbs_attr_spec[]' */
 -#define UVERBS_ATTR_ENUM_IN(_attr_id, _enum_arr, ...)                          \
 -	((const struct uverbs_attr_def){                                       \
 -		.id = _attr_id,                                                \
 -		.attr = { .type = UVERBS_ATTR_TYPE_ENUM_IN,                    \
 -			  .u2.enum_def.ids = _enum_arr,                        \
 -			  .u.enum_def.num_elems = ARRAY_SIZE(_enum_arr),       \
 -			  __VA_ARGS__ },                                       \
 -	})
 +/*
 + * In new compiler, UVERBS_ATTR could be simplified by declaring it as
 + * [_id] = {.type = _type, .len = _len, ##__VA_ARGS__}
 + * But since we support older compilers too, we need the more complex code.
 + */
 +#define UVERBS_ATTR(_id, _type, _fld, _attr, ...)			\
 +	__UVERBS_ATTR(_id, _type, _fld, _attr, ##__VA_ARGS__, 2, 1, 0)
 +#define UVERBS_ATTR_PTR_IN_SZ(_id, _len, ...)				\
 +	UVERBS_ATTR(_id, UVERBS_ATTR_TYPE_PTR_IN, ptr, _len, ##__VA_ARGS__)
 +/* If sizeof(_type) <= sizeof(u64), this will be inlined rather than a pointer */
 +#define UVERBS_ATTR_PTR_IN(_id, _type, ...)				\
 +	UVERBS_ATTR_PTR_IN_SZ(_id, _type, ##__VA_ARGS__)
 +#define UVERBS_ATTR_PTR_OUT_SZ(_id, _len, ...)				\
 +	UVERBS_ATTR(_id, UVERBS_ATTR_TYPE_PTR_OUT, ptr, _len, ##__VA_ARGS__)
 +#define UVERBS_ATTR_PTR_OUT(_id, _type, ...)				\
 +	UVERBS_ATTR_PTR_OUT_SZ(_id, _type, ##__VA_ARGS__)
 +#define UVERBS_ATTR_ENUM_IN(_id, _enum_arr, ...)			\
 +	UVERBS_ATTR(_id, UVERBS_ATTR_TYPE_ENUM_IN, enum_def,		\
 +		    .ids = (_enum_arr),					\
 +		    .num_elems = ARRAY_SIZE(_enum_arr), ##__VA_ARGS__)
  
  /*
++<<<<<<< HEAD
 + * In new compiler, UVERBS_ATTR_IDR (and FD) could be simplified by declaring
 + * it as
 + * {.id = _id,								\
 + *  .attr {.type = __obj_class,						\
 + *         .obj = {.obj_type = _idr_type,				\
 + *                       .access = _access                              \
 + *                }, ##__VA_ARGS__ } }
 + * But since we support older compilers too, we need the more complex code.
 + */
 +#define ___UVERBS_ATTR_OBJ0(_id, _obj_class, _obj_type, _access, ...)\
 +	((const struct uverbs_attr_def)					\
 +	{.id = _id,							\
 +	 .attr = { {.obj = {.type = _obj_class, .obj_type = _obj_type,	\
 +			    .access = _access, .flags = 0 } }, } })
 +#define ___UVERBS_ATTR_OBJ1(_id, _obj_class, _obj_type, _access, _flags)\
 +	((const struct uverbs_attr_def)					\
 +	{.id = _id,							\
 +	.attr = { {.obj = {.type = _obj_class, .obj_type = _obj_type,	\
 +			   .access = _access, _flags} }, } })
 +#define ___UVERBS_ATTR_OBJ(_id, _obj_class, _obj_type, _access, _flags, \
 +			   _n, ...)					\
 +	___UVERBS_ATTR_OBJ##_n(_id, _obj_class, _obj_type, _access, _flags)
 +#define __UVERBS_ATTR_OBJ(_id, _obj_class, _obj_type, _access, ...)	\
 +	___UVERBS_ATTR_OBJ(_id, _obj_class, _obj_type, _access,		\
 +			   ##__VA_ARGS__, 1, 0)
 +#define UVERBS_ATTR_IDR(_id, _idr_type, _access, ...)			 \
 +	__UVERBS_ATTR_OBJ(_id, UVERBS_ATTR_TYPE_IDR, _idr_type, _access,\
 +			  ##__VA_ARGS__)
 +#define UVERBS_ATTR_FD(_id, _fd_type, _access, ...)			\
 +	__UVERBS_ATTR_OBJ(_id, UVERBS_ATTR_TYPE_FD, _fd_type,		\
 +			  (_access) + BUILD_BUG_ON_ZERO(		\
 +				(_access) != UVERBS_ACCESS_NEW &&	\
 +				(_access) != UVERBS_ACCESS_READ),	\
 +			  ##__VA_ARGS__)
 +#define DECLARE_UVERBS_ATTR_SPEC(_name, ...)				\
 +	const struct uverbs_attr_def _name = __VA_ARGS__
 +
 +#define DECLARE_UVERBS_ENUM(_name, ...)					\
 +	const struct uverbs_enum_spec _name = {				\
 +		.len = ARRAY_SIZE(((struct uverbs_attr_spec[]){__VA_ARGS__})),\
 +		.ids = {__VA_ARGS__},					\
 +	}
 +#define _UVERBS_METHOD_ATTRS_SZ(...)					\
 +	(sizeof((const struct uverbs_attr_def * const []){__VA_ARGS__}) /\
 +	 sizeof(const struct uverbs_attr_def *))
 +#define _UVERBS_METHOD(_id, _handler, _flags, ...)			\
 +	((const struct uverbs_method_def) {				\
 +	 .id = _id,							\
 +	 .flags = _flags,						\
 +	 .handler = _handler,						\
 +	 .num_attrs = _UVERBS_METHOD_ATTRS_SZ(__VA_ARGS__),		\
 +	 .attrs = &(const struct uverbs_attr_def * const []){__VA_ARGS__} })
 +#define DECLARE_UVERBS_METHOD(_name, _id, _handler, ...)		\
 +	const struct uverbs_method_def _name =				\
 +		_UVERBS_METHOD(_id, _handler, 0, ##__VA_ARGS__)
 +#define DECLARE_UVERBS_CTX_METHOD(_name, _id, _handler, _flags, ...)	\
 +	const struct uverbs_method_def _name =				\
 +		_UVERBS_METHOD(_id, _handler,				\
 +			       UVERBS_ACTION_FLAG_CREATE_ROOT,		\
 +			       ##__VA_ARGS__)
 +#define _UVERBS_OBJECT_METHODS_SZ(...)					\
 +	(sizeof((const struct uverbs_method_def * const []){__VA_ARGS__}) / \
 +	 sizeof(const struct uverbs_method_def *))
 +#define _UVERBS_OBJECT(_id, _type_attrs, ...)				\
 +	((const struct uverbs_object_def) {				\
 +	 .id = _id,							\
 +	 .type_attrs = _type_attrs,					\
 +	 .num_methods = _UVERBS_OBJECT_METHODS_SZ(__VA_ARGS__),		\
 +	 .methods = &(const struct uverbs_method_def * const []){__VA_ARGS__} })
 +#define DECLARE_UVERBS_OBJECT(_name, _id, _type_attrs, ...)		\
 +	const struct uverbs_object_def _name =				\
 +		_UVERBS_OBJECT(_id, _type_attrs, ##__VA_ARGS__)
 +#define _UVERBS_TREE_OBJECTS_SZ(...)					\
 +	(sizeof((const struct uverbs_object_def * const []){__VA_ARGS__}) / \
 +	 sizeof(const struct uverbs_object_def *))
 +#define _UVERBS_OBJECT_TREE(...)					\
 +	((const struct uverbs_object_tree_def) {			\
 +	 .num_objects = _UVERBS_TREE_OBJECTS_SZ(__VA_ARGS__),		\
 +	 .objects = &(const struct uverbs_object_def * const []){__VA_ARGS__} })
 +#define DECLARE_UVERBS_OBJECT_TREE(_name, ...)				\
 +	const struct uverbs_object_tree_def _name =			\
 +		_UVERBS_OBJECT_TREE(__VA_ARGS__)
++=======
+  * This spec is used in order to pass information to the hardware driver in a
+  * legacy way. Every verb that could get driver specific data should get this
+  * spec.
+  */
+ #define UVERBS_ATTR_UHW()                                                      \
+ 	&UVERBS_ATTR_PTR_IN(UVERBS_ATTR_UHW_IN,                                \
+ 			    UVERBS_ATTR_SIZE(0, USHRT_MAX),		       \
+ 			    UA_FLAGS(UVERBS_ATTR_SPEC_F_MIN_SZ_OR_ZERO)),      \
+ 	&UVERBS_ATTR_PTR_OUT(UVERBS_ATTR_UHW_OUT,                              \
+ 			     UVERBS_ATTR_SIZE(0, USHRT_MAX),		       \
+ 			     UA_FLAGS(UVERBS_ATTR_SPEC_F_MIN_SZ_OR_ZERO))
+ 
+ /*
+  * =======================================
+  *	Declaration helpers
+  * =======================================
+  */
+ 
+ #define DECLARE_UVERBS_OBJECT_TREE(_name, ...)                                 \
+ 	static const struct uverbs_object_def *const _name##_ptr[] = {         \
+ 		__VA_ARGS__,                                                   \
+ 	};                                                                     \
+ 	static const struct uverbs_object_tree_def _name = {                   \
+ 		.num_objects = ARRAY_SIZE(_name##_ptr),                        \
+ 		.objects = &_name##_ptr,                                       \
+ 	}
++>>>>>>> 6c61d2a55c4e (RDMA/uverbs: Simplify UVERBS_OBJECT and _TREE family of macros)
  
  /* =================================================
   *              Parsing infrastructure
diff --cc include/rdma/uverbs_named_ioctl.h
index 228421f2a427,3ee045d7da4c..000000000000
--- a/include/rdma/uverbs_named_ioctl.h
+++ b/include/rdma/uverbs_named_ioctl.h
@@@ -45,50 -45,71 +45,91 @@@
  #define UVERBS_HANDLER(id)	_UVERBS_NAME(UVERBS_MODULE_NAME, _handler_##id)
  #define UVERBS_OBJECT(id)	_UVERBS_NAME(UVERBS_MOUDLE_NAME, _object_##id)
  
++<<<<<<< HEAD
 +#define DECLARE_UVERBS_NAMED_METHOD(id, ...)	\
 +	DECLARE_UVERBS_METHOD(UVERBS_METHOD(id), id, UVERBS_HANDLER(id), ##__VA_ARGS__)
++=======
+ /* These are static so they do not need to be qualified */
+ #define UVERBS_METHOD_ATTRS(method_id) _method_attrs_##method_id
+ #define UVERBS_OBJECT_METHODS(object_id) _object_methods_##object_id
++>>>>>>> 6c61d2a55c4e (RDMA/uverbs: Simplify UVERBS_OBJECT and _TREE family of macros)
  
 -#define DECLARE_UVERBS_NAMED_METHOD(_method_id, ...)                           \
 -	static const struct uverbs_attr_def *const UVERBS_METHOD_ATTRS(        \
 -		_method_id)[] = { __VA_ARGS__ };                               \
 -	static const struct uverbs_method_def UVERBS_METHOD(_method_id) = {    \
 -		.id = _method_id,                                              \
 -		.handler = UVERBS_HANDLER(_method_id),                         \
 -		.num_attrs = ARRAY_SIZE(UVERBS_METHOD_ATTRS(_method_id)),      \
 -		.attrs = &UVERBS_METHOD_ATTRS(_method_id),                     \
 -	}
 +#define DECLARE_UVERBS_NAMED_METHOD_WITH_HANDLER(id, handler, ...)	\
 +	DECLARE_UVERBS_METHOD(UVERBS_METHOD(id), id, handler, ##__VA_ARGS__)
  
 -/* Create a standard destroy method using the default handler. The handle_attr
 - * argument must be the attribute specifying the handle to destroy, the
 - * default handler does not support any other attributes.
 - */
 -#define DECLARE_UVERBS_NAMED_METHOD_DESTROY(_method_id, _handle_attr)          \
 -	static const struct uverbs_attr_def *const UVERBS_METHOD_ATTRS(        \
 -		_method_id)[] = { _handle_attr };                              \
 -	static const struct uverbs_method_def UVERBS_METHOD(_method_id) = {    \
 -		.id = _method_id,                                              \
 -		.handler = uverbs_destroy_def_handler,                         \
 -		.num_attrs = ARRAY_SIZE(UVERBS_METHOD_ATTRS(_method_id)),      \
 -		.attrs = &UVERBS_METHOD_ATTRS(_method_id),                     \
 -	}
 +#define DECLARE_UVERBS_NAMED_METHOD_NO_OVERRIDE(id, handler, ...)	\
 +	DECLARE_UVERBS_METHOD(UVERBS_METHOD(id), id, NULL, ##__VA_ARGS__)
  
- #define DECLARE_UVERBS_NAMED_OBJECT(id, ...)	\
- 	DECLARE_UVERBS_OBJECT(UVERBS_OBJECT(id), id, ##__VA_ARGS__)
+ #define DECLARE_UVERBS_NAMED_OBJECT(_object_id, _type_attrs, ...)              \
+ 	static const struct uverbs_method_def *const UVERBS_OBJECT_METHODS(    \
+ 		_object_id)[] = { __VA_ARGS__ };                               \
+ 	const struct uverbs_object_def UVERBS_OBJECT(_object_id) = {           \
+ 		.id = _object_id,                                              \
+ 		.type_attrs = _type_attrs,                                     \
+ 		.num_methods = ARRAY_SIZE(UVERBS_OBJECT_METHODS(_object_id)),  \
+ 		.methods = &UVERBS_OBJECT_METHODS(_object_id)                  \
+ 	}
  
  #define DECLARE_UVERBS_GLOBAL_METHODS(_name, ...)	\
  	DECLARE_UVERBS_NAMED_OBJECT(_name, NULL, ##__VA_ARGS__)
  
++<<<<<<< HEAD
 +#define _UVERBS_COMP_NAME(x, y, z) _UVERBS_NAME(_UVERBS_NAME(x, y), z)
 +
 +#define UVERBS_NO_OVERRIDE	NULL
 +
 +/* This declares a parsing tree with one object and one method. This is usually
 + * used for merging driver attributes to the common attributes. The driver has
 + * a chance to override the handler and type attrs of the original object.
 + * The __VA_ARGS__ just contains a list of attributes.
 + */
 +#define ADD_UVERBS_ATTRIBUTES(_name, _object, _method, _type_attrs, _handler, ...) \
 +static DECLARE_UVERBS_METHOD(_UVERBS_COMP_NAME(UVERBS_MODULE_NAME,	     \
 +					       _method_, _name),	     \
 +			     _method, _handler, ##__VA_ARGS__);		     \
 +									     \
 +static DECLARE_UVERBS_OBJECT(_UVERBS_COMP_NAME(UVERBS_MODULE_NAME,	     \
 +					       _object_, _name),	     \
 +			     _object, _type_attrs,			     \
 +			     &_UVERBS_COMP_NAME(UVERBS_MODULE_NAME,	     \
 +					       _method_, _name));	     \
 +									     \
 +static DECLARE_UVERBS_OBJECT_TREE(_name,				     \
 +				  &_UVERBS_COMP_NAME(UVERBS_MODULE_NAME,     \
 +						     _object_, _name))
 +
 +/* A very common use case is that the driver doesn't override the handler and
 + * type_attrs. Therefore, we provide a simplified macro for this common case.
 + */
 +#define ADD_UVERBS_ATTRIBUTES_SIMPLE(_name, _object, _method, ...)	     \
 +	ADD_UVERBS_ATTRIBUTES(_name, _object, _method, UVERBS_NO_OVERRIDE,   \
 +			      UVERBS_NO_OVERRIDE, ##__VA_ARGS__)
++=======
+ /* Used by drivers to declare a complete parsing tree for a single method that
+  * differs only in having additional driver specific attributes.
+  */
+ #define ADD_UVERBS_ATTRIBUTES_SIMPLE(_name, _object_id, _method_id, ...)       \
+ 	static const struct uverbs_attr_def *const UVERBS_METHOD_ATTRS(        \
+ 		_method_id)[] = { __VA_ARGS__ };                               \
+ 	static const struct uverbs_method_def UVERBS_METHOD(_method_id) = {    \
+ 		.id = _method_id,                                              \
+ 		.num_attrs = ARRAY_SIZE(UVERBS_METHOD_ATTRS(_method_id)),      \
+ 		.attrs = &UVERBS_METHOD_ATTRS(_method_id),                     \
+ 	};                                                                     \
+ 	static const struct uverbs_method_def *const UVERBS_OBJECT_METHODS(    \
+ 		_object_id)[] = { &UVERBS_METHOD(_method_id) };                \
+ 	static const struct uverbs_object_def _name##_struct = {               \
+ 		.id = _object_id,                                              \
+ 		.num_methods = 1,                                              \
+ 		.methods = &UVERBS_OBJECT_METHODS(_object_id)                  \
+ 	};                                                                     \
+ 	static const struct uverbs_object_def *const _name##_ptrs[] = {        \
+ 		&_name##_struct,                                               \
+ 	};                                                                     \
+ 	static const struct uverbs_object_tree_def _name = {                   \
+ 		.num_objects = 1,                                              \
+ 		.objects = &_name##_ptrs,                                      \
+ 	}
++>>>>>>> 6c61d2a55c4e (RDMA/uverbs: Simplify UVERBS_OBJECT and _TREE family of macros)
  
  #endif
* Unmerged path drivers/infiniband/hw/mlx5/devx.c
diff --git a/drivers/infiniband/core/uverbs.h b/drivers/infiniband/core/uverbs.h
index cbf36c75d546..00480b83229b 100644
--- a/drivers/infiniband/core/uverbs.h
+++ b/drivers/infiniband/core/uverbs.h
@@ -238,8 +238,6 @@ void ib_uverbs_detach_umcast(struct ib_qp *qp,
 			     struct ib_uqp_object *uobj);
 
 void create_udata(struct uverbs_attr_bundle *ctx, struct ib_udata *udata);
-extern const struct uverbs_attr_def uverbs_uhw_compat_in;
-extern const struct uverbs_attr_def uverbs_uhw_compat_out;
 long ib_uverbs_ioctl(struct file *filp, unsigned int cmd, unsigned long arg);
 
 struct ib_uverbs_flow_spec {
* Unmerged path drivers/infiniband/core/uverbs_std_types.c
diff --git a/drivers/infiniband/core/uverbs_std_types_cq.c b/drivers/infiniband/core/uverbs_std_types_cq.c
index b0dbae9dd0d7..6cc2ec07f80c 100644
--- a/drivers/infiniband/core/uverbs_std_types_cq.c
+++ b/drivers/infiniband/core/uverbs_std_types_cq.c
@@ -164,7 +164,7 @@ static DECLARE_UVERBS_NAMED_METHOD(UVERBS_METHOD_CQ_CREATE,
 	&UVERBS_ATTR_PTR_IN(UVERBS_ATTR_CREATE_CQ_FLAGS, UVERBS_ATTR_TYPE(u32)),
 	&UVERBS_ATTR_PTR_OUT(UVERBS_ATTR_CREATE_CQ_RESP_CQE, UVERBS_ATTR_TYPE(u32),
 			     UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)),
-	&uverbs_uhw_compat_in, &uverbs_uhw_compat_out);
+	UVERBS_ATTR_UHW());
 
 static int UVERBS_HANDLER(UVERBS_METHOD_CQ_DESTROY)(struct ib_device *ib_dev,
 						    struct ib_uverbs_file *file,
* Unmerged path drivers/infiniband/hw/mlx5/devx.c
* Unmerged path include/rdma/uverbs_ioctl.h
* Unmerged path include/rdma/uverbs_named_ioctl.h
