RDMA/uverbs: Combine MIN_SZ_OR_ZERO with UVERBS_ATTR_STRUCT

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [rdma] uverbs: Combine MIN_SZ_OR_ZERO with UVERBS_ATTR_STRUCT (Kamal Heib) [1655920]
Rebuild_FUZZ: 95.58%
commit-author Jason Gunthorpe <jgg@mellanox.com>
commit 422e3d37ed7ea8b421208a44913c420055334976
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/422e3d37.failed

After all the rework is done it is now possible to include single flags in
the type macros. Any user of UVERBS_ATTR_STRUCT needs to zero check data
past the end of the known struct to be correct, so make this mandatory,
and get rid of MIN_SZ_OR_ZERO as a user flag.

This changes UVERBS_ATTR_TYPE to refer to a struct of exact size with not
possibility of extension, convert the few users of UVERBS_ATTR_TYPE and
MIN_SZ_OR_ZERO to use UVERBS_ATTR_STRUCT.

The one user of UVERBS_ATTR_STRUCT without MIN_SZ_OR_ZERO is just
confused. There is some padding at the end of that struct, but userspace
always provides it with the padding. The construction doesn't test if the
padding is zero, so it is pointless. Just use UVERBS_ATTR_TYPE.

Finally, rename min_sz_or_zero to zero_trailing to better reflect what it
does and hopefully avoid such mis-uses in the future.

	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
	Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
(cherry picked from commit 422e3d37ed7ea8b421208a44913c420055334976)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/core/uverbs_ioctl.c
#	drivers/infiniband/core/uverbs_ioctl_merge.c
#	drivers/infiniband/core/uverbs_std_types_flow_action.c
#	include/rdma/uverbs_ioctl.h
diff --cc drivers/infiniband/core/uverbs_ioctl.c
index ec7b453e622b,5b59c6f0feed..000000000000
--- a/drivers/infiniband/core/uverbs_ioctl.c
+++ b/drivers/infiniband/core/uverbs_ioctl.c
@@@ -98,16 -97,16 +98,28 @@@ static int uverbs_process_attr(struct i
  		 * longer struct will fail here if used with an old kernel and
  		 * non-zero content, making ABI compat/discovery simpler.
  		 */
++<<<<<<< HEAD
 +		if (uattr->len > val_spec->ptr.len &&
 +		    val_spec->flags & UVERBS_ATTR_SPEC_F_MIN_SZ_OR_ZERO &&
 +		    !uverbs_is_attr_cleared(uattr, val_spec->ptr.len))
++=======
+ 		if (uattr->len > val_spec->u.ptr.len &&
+ 		    val_spec->zero_trailing &&
+ 		    !uverbs_is_attr_cleared(uattr, val_spec->u.ptr.len))
++>>>>>>> 422e3d37ed7e (RDMA/uverbs: Combine MIN_SZ_OR_ZERO with UVERBS_ATTR_STRUCT)
  			return -EOPNOTSUPP;
  
  	/* fall through */
  	case UVERBS_ATTR_TYPE_PTR_OUT:
++<<<<<<< HEAD
 +		if (uattr->len < val_spec->ptr.min_len ||
 +		    (!(val_spec->flags & UVERBS_ATTR_SPEC_F_MIN_SZ_OR_ZERO) &&
 +		     uattr->len > val_spec->ptr.len))
++=======
+ 		if (uattr->len < val_spec->u.ptr.min_len ||
+ 		    (!val_spec->zero_trailing &&
+ 		     uattr->len > val_spec->u.ptr.len))
++>>>>>>> 422e3d37ed7e (RDMA/uverbs: Combine MIN_SZ_OR_ZERO with UVERBS_ATTR_STRUCT)
  			return -EINVAL;
  
  		if (spec->type != UVERBS_ATTR_TYPE_ENUM_IN &&
diff --cc drivers/infiniband/core/uverbs_ioctl_merge.c
index 0f88a1919d51,f81aa888ce5c..000000000000
--- a/drivers/infiniband/core/uverbs_ioctl_merge.c
+++ b/drivers/infiniband/core/uverbs_ioctl_merge.c
@@@ -379,7 -378,7 +379,11 @@@ static struct uverbs_method_spec *build
  				 "ib_uverbs: Tried to merge attr (%d) but it's an object with new/destroy access but isn't mandatory\n",
  				 min_id) ||
  			    WARN(IS_ATTR_OBJECT(attr) &&
++<<<<<<< HEAD
 +				 attr->flags & UVERBS_ATTR_SPEC_F_MIN_SZ_OR_ZERO,
++=======
+ 				 attr->zero_trailing,
++>>>>>>> 422e3d37ed7e (RDMA/uverbs: Combine MIN_SZ_OR_ZERO with UVERBS_ATTR_STRUCT)
  				 "ib_uverbs: Tried to merge attr (%d) but it's an object with min_sz flag\n",
  				 min_id)) {
  				res = -EINVAL;
diff --cc include/rdma/uverbs_ioctl.h
index 2cc45699a237,017ccf75890c..000000000000
--- a/include/rdma/uverbs_ioctl.h
+++ b/include/rdma/uverbs_ioctl.h
@@@ -61,34 -61,33 +61,52 @@@ enum uverbs_obj_access 
  	UVERBS_ACCESS_DESTROY
  };
  
 +enum {
 +	UVERBS_ATTR_SPEC_F_MANDATORY	= 1U << 0,
 +	/* Support extending attributes by length, validate all unknown size == zero  */
 +	UVERBS_ATTR_SPEC_F_MIN_SZ_OR_ZERO = 1U << 1,
 +};
 +
  /* Specification of a single attribute inside the ioctl message */
 -/* good size 16 */
  struct uverbs_attr_spec {
++<<<<<<< HEAD
++=======
+ 	u8 type;
+ 
+ 	/*
+ 	 * Support extending attributes by length. Allow the user to provide
+ 	 * more bytes than ptr.len, but check that everything after is zero'd
+ 	 * by the user.
+ 	 */
+ 	u8 zero_trailing:1;
+ 	/*
+ 	 * Valid only for PTR_IN. Allocate and copy the data inside
+ 	 * the parser
+ 	 */
+ 	u8 alloc_and_copy:1;
+ 	u8 mandatory:1;
+ 
++>>>>>>> 422e3d37ed7e (RDMA/uverbs: Combine MIN_SZ_OR_ZERO with UVERBS_ATTR_STRUCT)
  	union {
 +		/* Header shared by all following union members - to reduce space. */
 +		struct {
 +			enum uverbs_attr_type		type;
 +			/* Combination of bits from enum UVERBS_ATTR_SPEC_F_XXXX */
 +			u8				flags;
 +		};
  		struct {
 +			enum uverbs_attr_type		type;
 +			/* Combination of bits from enum UVERBS_ATTR_SPEC_F_XXXX */
 +			u8				flags;
  			/* Current known size to kernel */
 -			u16 len;
 +			u16				len;
  			/* User isn't allowed to provide something < min_len */
 -			u16 min_len;
 +			u16				min_len;
  		} ptr;
 -
  		struct {
 +			enum uverbs_attr_type		type;
 +			/* Combination of bits from enum UVERBS_ATTR_SPEC_F_XXXX */
 +			u8				flags;
  			/*
  			 * higher bits mean the namespace and lower bits mean
  			 * the type id within the namespace.
@@@ -192,132 -195,112 +210,207 @@@ struct uverbs_object_tree_def 
  	const struct uverbs_object_def * const (*objects)[];
  };
  
 -/*
 - * =======================================
 - *	Attribute Specifications
 - * =======================================
 - */
 -
 +#define UA_FLAGS(_flags)  .flags = _flags
 +#define __UVERBS_ATTR0(_id, _type, _fld, _attr, ...)              \
 +	((const struct uverbs_attr_def)				  \
 +	 {.id = _id, .attr = {{._fld = {.type = _type, _attr, .flags = 0, } }, } })
 +#define __UVERBS_ATTR1(_id, _type, _fld, _attr, _extra1, ...)      \
 +	((const struct uverbs_attr_def)				  \
 +	 {.id = _id, .attr = {{._fld = {.type = _type, _attr, _extra1 } },} })
 +#define __UVERBS_ATTR2(_id, _type, _fld, _attr, _extra1, _extra2)    \
 +	((const struct uverbs_attr_def)				  \
 +	 {.id = _id, .attr = {{._fld = {.type = _type, _attr, _extra1, _extra2 } },} })
 +#define __UVERBS_ATTR(_id, _type, _fld, _attr, _extra1, _extra2, _n, ...)	\
 +	__UVERBS_ATTR##_n(_id, _type, _fld, _attr, _extra1, _extra2)
 +
++<<<<<<< HEAD
 +#define UVERBS_ATTR_TYPE(_type)					\
 +	.min_len = sizeof(_type), .len = sizeof(_type)
 +#define UVERBS_ATTR_STRUCT(_type, _last)			\
 +	.min_len = ((uintptr_t)(&((_type *)0)->_last + 1)), .len = sizeof(_type)
 +#define UVERBS_ATTR_SIZE(_min_len, _len)			\
 +	.min_len = _min_len, .len = _len
 +#define UVERBS_ATTR_MIN_SIZE(_min_len)				\
 +	UVERBS_ATTR_SIZE(_min_len, USHRT_MAX)
++=======
+ #define UVERBS_ATTR_SIZE(_min_len, _len)			\
+ 	.u.ptr.min_len = _min_len, .u.ptr.len = _len
+ 
+ /*
+  * Specifies a uapi structure that cannot be extended. The user must always
+  * supply the whole structure and nothing more. The structure must be declared
+  * in a header under include/uapi/rdma.
+  */
+ #define UVERBS_ATTR_TYPE(_type)					\
+ 	.u.ptr.min_len = sizeof(_type), .u.ptr.len = sizeof(_type)
+ /*
+  * Specifies a uapi structure where the user must provide at least up to
+  * member 'last'.  Anything after last and up until the end of the structure
+  * can be non-zero, anything longer than the end of the structure must be
+  * zero. The structure must be declared in a header under include/uapi/rdma.
+  */
+ #define UVERBS_ATTR_STRUCT(_type, _last)                                       \
+ 	.zero_trailing = 1,                                                    \
+ 	UVERBS_ATTR_SIZE(((uintptr_t)(&((_type *)0)->_last + 1)),              \
+ 			 sizeof(_type))
+ /*
+  * Specifies at least min_len bytes must be passed in, but the amount can be
+  * larger, up to the protocol maximum size. No check for zeroing is done.
+  */
+ #define UVERBS_ATTR_MIN_SIZE(_min_len) UVERBS_ATTR_SIZE(_min_len, USHRT_MAX)
+ 
+ /* Must be used in the '...' of any UVERBS_ATTR */
+ #define UA_ALLOC_AND_COPY .alloc_and_copy = 1
+ #define UA_MANDATORY .mandatory = 1
+ #define UA_OPTIONAL .mandatory = 0
+ 
+ #define UVERBS_ATTR_IDR(_attr_id, _idr_type, _access, ...)                     \
+ 	(&(const struct uverbs_attr_def){                                      \
+ 		.id = _attr_id,                                                \
+ 		.attr = { .type = UVERBS_ATTR_TYPE_IDR,                        \
+ 			  .u.obj.obj_type = _idr_type,                         \
+ 			  .u.obj.access = _access,                             \
+ 			  __VA_ARGS__ } })
+ 
+ #define UVERBS_ATTR_FD(_attr_id, _fd_type, _access, ...)                       \
+ 	(&(const struct uverbs_attr_def){                                      \
+ 		.id = (_attr_id) +                                             \
+ 		      BUILD_BUG_ON_ZERO((_access) != UVERBS_ACCESS_NEW &&      \
+ 					(_access) != UVERBS_ACCESS_READ),      \
+ 		.attr = { .type = UVERBS_ATTR_TYPE_FD,                         \
+ 			  .u.obj.obj_type = _fd_type,                          \
+ 			  .u.obj.access = _access,                             \
+ 			  __VA_ARGS__ } })
+ 
+ #define UVERBS_ATTR_PTR_IN(_attr_id, _type, ...)                               \
+ 	(&(const struct uverbs_attr_def){                                      \
+ 		.id = _attr_id,                                                \
+ 		.attr = { .type = UVERBS_ATTR_TYPE_PTR_IN,                     \
+ 			  _type,                                               \
+ 			  __VA_ARGS__ } })
+ 
+ #define UVERBS_ATTR_PTR_OUT(_attr_id, _type, ...)                              \
+ 	(&(const struct uverbs_attr_def){                                      \
+ 		.id = _attr_id,                                                \
+ 		.attr = { .type = UVERBS_ATTR_TYPE_PTR_OUT,                    \
+ 			  _type,                                               \
+ 			  __VA_ARGS__ } })
+ 
+ /* _enum_arry should be a 'static const union uverbs_attr_spec[]' */
+ #define UVERBS_ATTR_ENUM_IN(_attr_id, _enum_arr, ...)                          \
+ 	(&(const struct uverbs_attr_def){                                      \
+ 		.id = _attr_id,                                                \
+ 		.attr = { .type = UVERBS_ATTR_TYPE_ENUM_IN,                    \
+ 			  .u2.enum_def.ids = _enum_arr,                        \
+ 			  .u.enum_def.num_elems = ARRAY_SIZE(_enum_arr),       \
+ 			  __VA_ARGS__ },                                       \
+ 	})
++>>>>>>> 422e3d37ed7e (RDMA/uverbs: Combine MIN_SZ_OR_ZERO with UVERBS_ATTR_STRUCT)
  
  /*
 - * This spec is used in order to pass information to the hardware driver in a
 - * legacy way. Every verb that could get driver specific data should get this
 - * spec.
 + * In new compiler, UVERBS_ATTR could be simplified by declaring it as
 + * [_id] = {.type = _type, .len = _len, ##__VA_ARGS__}
 + * But since we support older compilers too, we need the more complex code.
   */
 -#define UVERBS_ATTR_UHW()                                                      \
 -	UVERBS_ATTR_PTR_IN(UVERBS_ATTR_UHW_IN,                                 \
 -			   UVERBS_ATTR_MIN_SIZE(0),			       \
 -			   UA_OPTIONAL),				       \
 -	UVERBS_ATTR_PTR_OUT(UVERBS_ATTR_UHW_OUT,                               \
 -			    UVERBS_ATTR_MIN_SIZE(0),			       \
 -			    UA_OPTIONAL)
 +#define UVERBS_ATTR(_id, _type, _fld, _attr, ...)			\
 +	__UVERBS_ATTR(_id, _type, _fld, _attr, ##__VA_ARGS__, 2, 1, 0)
 +#define UVERBS_ATTR_PTR_IN_SZ(_id, _len, ...)				\
 +	UVERBS_ATTR(_id, UVERBS_ATTR_TYPE_PTR_IN, ptr, _len, ##__VA_ARGS__)
 +/* If sizeof(_type) <= sizeof(u64), this will be inlined rather than a pointer */
 +#define UVERBS_ATTR_PTR_IN(_id, _type, ...)				\
 +	UVERBS_ATTR_PTR_IN_SZ(_id, _type, ##__VA_ARGS__)
 +#define UVERBS_ATTR_PTR_OUT_SZ(_id, _len, ...)				\
 +	UVERBS_ATTR(_id, UVERBS_ATTR_TYPE_PTR_OUT, ptr, _len, ##__VA_ARGS__)
 +#define UVERBS_ATTR_PTR_OUT(_id, _type, ...)				\
 +	UVERBS_ATTR_PTR_OUT_SZ(_id, _type, ##__VA_ARGS__)
 +#define UVERBS_ATTR_ENUM_IN(_id, _enum_arr, ...)			\
 +	UVERBS_ATTR(_id, UVERBS_ATTR_TYPE_ENUM_IN, enum_def,		\
 +		    .ids = (_enum_arr),					\
 +		    .num_elems = ARRAY_SIZE(_enum_arr), ##__VA_ARGS__)
  
  /*
 - * =======================================
 - *	Declaration helpers
 - * =======================================
 + * In new compiler, UVERBS_ATTR_IDR (and FD) could be simplified by declaring
 + * it as
 + * {.id = _id,								\
 + *  .attr {.type = __obj_class,						\
 + *         .obj = {.obj_type = _idr_type,				\
 + *                       .access = _access                              \
 + *                }, ##__VA_ARGS__ } }
 + * But since we support older compilers too, we need the more complex code.
   */
 -
 -#define DECLARE_UVERBS_OBJECT_TREE(_name, ...)                                 \
 -	static const struct uverbs_object_def *const _name##_ptr[] = {         \
 -		__VA_ARGS__,                                                   \
 -	};                                                                     \
 -	static const struct uverbs_object_tree_def _name = {                   \
 -		.num_objects = ARRAY_SIZE(_name##_ptr),                        \
 -		.objects = &_name##_ptr,                                       \
 +#define ___UVERBS_ATTR_OBJ0(_id, _obj_class, _obj_type, _access, ...)\
 +	((const struct uverbs_attr_def)					\
 +	{.id = _id,							\
 +	 .attr = { {.obj = {.type = _obj_class, .obj_type = _obj_type,	\
 +			    .access = _access, .flags = 0 } }, } })
 +#define ___UVERBS_ATTR_OBJ1(_id, _obj_class, _obj_type, _access, _flags)\
 +	((const struct uverbs_attr_def)					\
 +	{.id = _id,							\
 +	.attr = { {.obj = {.type = _obj_class, .obj_type = _obj_type,	\
 +			   .access = _access, _flags} }, } })
 +#define ___UVERBS_ATTR_OBJ(_id, _obj_class, _obj_type, _access, _flags, \
 +			   _n, ...)					\
 +	___UVERBS_ATTR_OBJ##_n(_id, _obj_class, _obj_type, _access, _flags)
 +#define __UVERBS_ATTR_OBJ(_id, _obj_class, _obj_type, _access, ...)	\
 +	___UVERBS_ATTR_OBJ(_id, _obj_class, _obj_type, _access,		\
 +			   ##__VA_ARGS__, 1, 0)
 +#define UVERBS_ATTR_IDR(_id, _idr_type, _access, ...)			 \
 +	__UVERBS_ATTR_OBJ(_id, UVERBS_ATTR_TYPE_IDR, _idr_type, _access,\
 +			  ##__VA_ARGS__)
 +#define UVERBS_ATTR_FD(_id, _fd_type, _access, ...)			\
 +	__UVERBS_ATTR_OBJ(_id, UVERBS_ATTR_TYPE_FD, _fd_type,		\
 +			  (_access) + BUILD_BUG_ON_ZERO(		\
 +				(_access) != UVERBS_ACCESS_NEW &&	\
 +				(_access) != UVERBS_ACCESS_READ),	\
 +			  ##__VA_ARGS__)
 +#define DECLARE_UVERBS_ATTR_SPEC(_name, ...)				\
 +	const struct uverbs_attr_def _name = __VA_ARGS__
 +
 +#define DECLARE_UVERBS_ENUM(_name, ...)					\
 +	const struct uverbs_enum_spec _name = {				\
 +		.len = ARRAY_SIZE(((struct uverbs_attr_spec[]){__VA_ARGS__})),\
 +		.ids = {__VA_ARGS__},					\
  	}
 +#define _UVERBS_METHOD_ATTRS_SZ(...)					\
 +	(sizeof((const struct uverbs_attr_def * const []){__VA_ARGS__}) /\
 +	 sizeof(const struct uverbs_attr_def *))
 +#define _UVERBS_METHOD(_id, _handler, _flags, ...)			\
 +	((const struct uverbs_method_def) {				\
 +	 .id = _id,							\
 +	 .flags = _flags,						\
 +	 .handler = _handler,						\
 +	 .num_attrs = _UVERBS_METHOD_ATTRS_SZ(__VA_ARGS__),		\
 +	 .attrs = &(const struct uverbs_attr_def * const []){__VA_ARGS__} })
 +#define DECLARE_UVERBS_METHOD(_name, _id, _handler, ...)		\
 +	const struct uverbs_method_def _name =				\
 +		_UVERBS_METHOD(_id, _handler, 0, ##__VA_ARGS__)
 +#define DECLARE_UVERBS_CTX_METHOD(_name, _id, _handler, _flags, ...)	\
 +	const struct uverbs_method_def _name =				\
 +		_UVERBS_METHOD(_id, _handler,				\
 +			       UVERBS_ACTION_FLAG_CREATE_ROOT,		\
 +			       ##__VA_ARGS__)
 +#define _UVERBS_OBJECT_METHODS_SZ(...)					\
 +	(sizeof((const struct uverbs_method_def * const []){__VA_ARGS__}) / \
 +	 sizeof(const struct uverbs_method_def *))
 +#define _UVERBS_OBJECT(_id, _type_attrs, ...)				\
 +	((const struct uverbs_object_def) {				\
 +	 .id = _id,							\
 +	 .type_attrs = _type_attrs,					\
 +	 .num_methods = _UVERBS_OBJECT_METHODS_SZ(__VA_ARGS__),		\
 +	 .methods = &(const struct uverbs_method_def * const []){__VA_ARGS__} })
 +#define DECLARE_UVERBS_OBJECT(_name, _id, _type_attrs, ...)		\
 +	const struct uverbs_object_def _name =				\
 +		_UVERBS_OBJECT(_id, _type_attrs, ##__VA_ARGS__)
 +#define _UVERBS_TREE_OBJECTS_SZ(...)					\
 +	(sizeof((const struct uverbs_object_def * const []){__VA_ARGS__}) / \
 +	 sizeof(const struct uverbs_object_def *))
 +#define _UVERBS_OBJECT_TREE(...)					\
 +	((const struct uverbs_object_tree_def) {			\
 +	 .num_objects = _UVERBS_TREE_OBJECTS_SZ(__VA_ARGS__),		\
 +	 .objects = &(const struct uverbs_object_def * const []){__VA_ARGS__} })
 +#define DECLARE_UVERBS_OBJECT_TREE(_name, ...)				\
 +	const struct uverbs_object_tree_def _name =			\
 +		_UVERBS_OBJECT_TREE(__VA_ARGS__)
  
  /* =================================================
   *              Parsing infrastructure
* Unmerged path drivers/infiniband/core/uverbs_std_types_flow_action.c
* Unmerged path drivers/infiniband/core/uverbs_ioctl.c
* Unmerged path drivers/infiniband/core/uverbs_ioctl_merge.c
* Unmerged path drivers/infiniband/core/uverbs_std_types_flow_action.c
* Unmerged path include/rdma/uverbs_ioctl.h
