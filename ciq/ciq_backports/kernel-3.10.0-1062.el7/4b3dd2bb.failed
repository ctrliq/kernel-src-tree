IB/uverbs: Provide implementation private memory for the uverbs_attr_bundle

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Jason Gunthorpe <jgg@mellanox.com>
commit 4b3dd2bbf0818ccb23e7f2831f2ca4a86789cd1f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/4b3dd2bb.failed

This already existed as the anonymous 'ctx' structure, but this was not
really a useful form. Hoist this struct into bundle_priv and rework the
internal things to use it instead.

Move a bunch of the processing internal state into the priv and reduce the
excessive use of function arguments.

	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
	Reviewed-by: Leon Romanovsky <leonro@mellanox.com>
(cherry picked from commit 4b3dd2bbf0818ccb23e7f2831f2ca4a86789cd1f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/core/uverbs_ioctl.c
diff --cc drivers/infiniband/core/uverbs_ioctl.c
index ec7b453e622b,efb7adcc21fb..000000000000
--- a/drivers/infiniband/core/uverbs_ioctl.c
+++ b/drivers/infiniband/core/uverbs_ioctl.c
@@@ -46,8 -58,7 +58,12 @@@ static bool uverbs_is_attr_cleared(cons
  			   0, uattr->len - len);
  }
  
++<<<<<<< HEAD
 +static int uverbs_process_attr(struct ib_device *ibdev,
 +			       struct ib_ucontext *ucontext,
++=======
+ static int uverbs_process_attr(struct bundle_priv *pbundle,
++>>>>>>> 4b3dd2bbf081 (IB/uverbs: Provide implementation private memory for the uverbs_attr_bundle)
  			       const struct ib_uverbs_attr *uattr,
  			       u16 attr_id,
  			       const struct uverbs_attr_spec_hash *attr_spec_bucket,
@@@ -131,15 -155,24 +147,35 @@@
  			return -EINVAL;
  
  		o_attr = &e->obj_attr;
 +		object = uverbs_get_object(ibdev, spec->obj.obj_type);
 +		if (!object)
 +			return -EINVAL;
  
++<<<<<<< HEAD
 +		o_attr->uobject = uverbs_get_uobject_from_context(
 +					object->type_attrs,
 +					ucontext,
 +					spec->obj.access,
 +					(int)uattr->data);
++=======
+ 		/* specs are allowed to have only one destroy attribute */
+ 		WARN_ON(spec->u.obj.access == UVERBS_ACCESS_DESTROY &&
+ 			pbundle->destroy_attr);
+ 		if (spec->u.obj.access == UVERBS_ACCESS_DESTROY)
+ 			pbundle->destroy_attr = o_attr;
+ 
+ 		/*
+ 		 * The type of uattr->data is u64 for UVERBS_ATTR_TYPE_IDR and
+ 		 * s64 for UVERBS_ATTR_TYPE_FD. We can cast the u64 to s64
+ 		 * here without caring about truncation as we know that the
+ 		 * IDR implementation today rejects negative IDs
+ 		 */
+ 		o_attr->uobject = uverbs_get_uobject_from_file(
+ 					spec->u.obj.obj_type,
+ 					pbundle->bundle.ufile,
+ 					spec->u.obj.access,
+ 					uattr->data_s64);
++>>>>>>> 4b3dd2bbf081 (IB/uverbs: Provide implementation private memory for the uverbs_attr_bundle)
  
  		if (IS_ERR(o_attr->uobject))
  			return PTR_ERR(o_attr->uobject);
@@@ -207,14 -245,12 +244,22 @@@ static int uverbs_finalize_attrs(struc
  	return ret;
  }
  
++<<<<<<< HEAD
 +static int uverbs_uattrs_process(struct ib_device *ibdev,
 +				 struct ib_ucontext *ucontext,
 +				 const struct ib_uverbs_attr *uattrs,
 +				 size_t num_uattrs,
 +				 const struct uverbs_method_spec *method,
 +				 struct uverbs_attr_bundle *attr_bundle,
 +				 struct ib_uverbs_attr __user *uattr_ptr)
++=======
+ static int uverbs_uattrs_process(size_t num_uattrs,
+ 				 const struct uverbs_method_spec *method,
+ 				 struct bundle_priv *pbundle)
++>>>>>>> 4b3dd2bbf081 (IB/uverbs: Provide implementation private memory for the uverbs_attr_bundle)
  {
+ 	struct uverbs_attr_bundle *attr_bundle = &pbundle->bundle;
+ 	struct ib_uverbs_attr __user *uattr_ptr = pbundle->user_attrs;
  	size_t i;
  	int ret = 0;
  	int num_given_buckets = 0;
@@@ -244,11 -280,13 +289,18 @@@
  			num_given_buckets = ret + 1;
  
  		attr_spec_bucket = method->attr_buckets[ret];
++<<<<<<< HEAD
 +		ret = uverbs_process_attr(ibdev, ucontext, uattr, attr_id,
 +					  attr_spec_bucket, &attr_bundle->hash[ret],
++=======
+ 		ret = uverbs_process_attr(pbundle,
+ 					  uattr, attr_id,
+ 					  attr_spec_bucket,
+ 					  &attr_bundle->hash[ret],
++>>>>>>> 4b3dd2bbf081 (IB/uverbs: Provide implementation private memory for the uverbs_attr_bundle)
  					  uattr_ptr++);
  		if (ret) {
- 			uverbs_finalize_attrs(attr_bundle,
+ 			uverbs_finalize_attrs(pbundle,
  					      method->attr_buckets,
  					      num_given_buckets,
  					      false);
@@@ -301,9 -337,8 +351,14 @@@ static int uverbs_handle_method(size_t 
  	int finalize_ret;
  	int num_given_buckets;
  
++<<<<<<< HEAD
 +	num_given_buckets = uverbs_uattrs_process(ibdev, ufile->ucontext, uattrs,
 +						  num_uattrs, method_spec,
 +						  attr_bundle, uattr_ptr);
++=======
+ 	num_given_buckets =
+ 		uverbs_uattrs_process(num_uattrs, method_spec, pbundle);
++>>>>>>> 4b3dd2bbf081 (IB/uverbs: Provide implementation private memory for the uverbs_attr_bundle)
  	if (num_given_buckets <= 0)
  		return -EINVAL;
  
@@@ -312,9 -347,25 +367,29 @@@
  	if (ret)
  		goto cleanup;
  
++<<<<<<< HEAD
 +	ret = method_spec->handler(ibdev, ufile, attr_bundle);
++=======
+ 	/*
+ 	 * We destroy the HW object before invoking the handler, handlers do
+ 	 * not get to manipulate the HW objects.
+ 	 */
+ 	if (pbundle->destroy_attr) {
+ 		ret = uobj_destroy(pbundle->destroy_attr->uobject);
+ 		if (ret)
+ 			goto cleanup;
+ 	}
+ 
+ 	ret = method_spec->handler(pbundle->bundle.ufile, attr_bundle);
+ 
+ 	if (pbundle->destroy_attr) {
+ 		uobj_put_destroy(pbundle->destroy_attr->uobject);
+ 		pbundle->destroy_attr->uobject = NULL;
+ 	}
+ 
++>>>>>>> 4b3dd2bbf081 (IB/uverbs: Provide implementation private memory for the uverbs_attr_bundle)
  cleanup:
- 	finalize_ret = uverbs_finalize_attrs(attr_bundle,
+ 	finalize_ret = uverbs_finalize_attrs(pbundle,
  					     method_spec->attr_buckets,
  					     attr_bundle->num_buckets,
  					     !ret);
@@@ -349,16 -400,12 +421,15 @@@ static long ib_uverbs_cmd_verbs(struct 
  	if (!method_spec)
  		return -EPROTONOSUPPORT;
  
 +	if ((method_spec->flags & UVERBS_ACTION_FLAG_CREATE_ROOT) ^ !file->ucontext)
 +		return -EINVAL;
 +
  	ctx_size = sizeof(*ctx) +
- 		   sizeof(struct uverbs_attr_bundle) +
  		   sizeof(struct uverbs_attr_bundle_hash) * method_spec->num_buckets +
  		   sizeof(*ctx->uattrs) * hdr->num_attrs +
- 		   sizeof(*ctx->uverbs_attr_bundle->hash[0].attrs) *
+ 		   sizeof(*ctx->bundle.hash[0].attrs) *
  		   method_spec->num_child_attrs +
- 		   sizeof(*ctx->uverbs_attr_bundle->hash[0].valid_bitmap) *
+ 		   sizeof(*ctx->bundle.hash[0].valid_bitmap) *
  			(method_spec->num_child_attrs / BITS_PER_LONG +
  			 method_spec->num_buckets);
  
* Unmerged path drivers/infiniband/core/uverbs_ioctl.c
diff --git a/include/rdma/uverbs_ioctl.h b/include/rdma/uverbs_ioctl.h
index 2cc45699a237..fed2a0bf8bde 100644
--- a/include/rdma/uverbs_ioctl.h
+++ b/include/rdma/uverbs_ioctl.h
@@ -360,6 +360,7 @@ struct uverbs_attr_bundle_hash {
 };
 
 struct uverbs_attr_bundle {
+	struct ib_uverbs_file *ufile;
 	size_t				num_buckets;
 	struct uverbs_attr_bundle_hash  hash[];
 };
