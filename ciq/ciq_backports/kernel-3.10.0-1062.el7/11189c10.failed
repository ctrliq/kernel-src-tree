acpi/nfit: Fix command-supported detection

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [acpi] nfit: Fix command-supported detection (Charles Rose) [1665811]
Rebuild_FUZZ: 93.67%
commit-author Dan Williams <dan.j.williams@intel.com>
commit 11189c1089da413aa4b5fd6be4c4d47c78968819
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/11189c10.failed

The _DSM function number validation only happens to succeed when the
generic Linux command number translation corresponds with a
DSM-family-specific function number. This breaks NVDIMM-N
implementations that correctly implement _LSR, _LSW, and _LSI, but do
not happen to publish support for DSM function numbers 4, 5, and 6.

Recall that the support for _LS{I,R,W} family of methods results in the
DIMM being marked as supporting those command numbers at
acpi_nfit_register_dimms() time. The DSM function mask is only used for
ND_CMD_CALL support of non-NVDIMM_FAMILY_INTEL devices.

Fixes: 31eca76ba2fc ("nfit, libnvdimm: limited/whitelisted dimm command...")
	Cc: <stable@vger.kernel.org>
Link: https://github.com/pmem/ndctl/issues/78
	Reported-by: Sujith Pandel <sujith_pandel@dell.com>
	Tested-by: Sujith Pandel <sujith_pandel@dell.com>
	Reviewed-by: Vishal Verma <vishal.l.verma@intel.com>
	Reviewed-by: Jeff Moyer <jmoyer@redhat.com>
	Signed-off-by: Dan Williams <dan.j.williams@intel.com>
(cherry picked from commit 11189c1089da413aa4b5fd6be4c4d47c78968819)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/acpi/nfit/core.c
diff --cc drivers/acpi/nfit/core.c
index 61006aea42ad,e18ade5d74e9..000000000000
--- a/drivers/acpi/nfit/core.c
+++ b/drivers/acpi/nfit/core.c
@@@ -391,6 -398,43 +391,46 @@@ static u8 nfit_dsm_revid(unsigned famil
  	return id;
  }
  
++<<<<<<< HEAD
++=======
+ static bool payload_dumpable(struct nvdimm *nvdimm, unsigned int func)
+ {
+ 	struct nfit_mem *nfit_mem = nvdimm_provider_data(nvdimm);
+ 
+ 	if (nfit_mem && nfit_mem->family == NVDIMM_FAMILY_INTEL
+ 			&& func >= NVDIMM_INTEL_GET_SECURITY_STATE
+ 			&& func <= NVDIMM_INTEL_MASTER_SECURE_ERASE)
+ 		return IS_ENABLED(CONFIG_NFIT_SECURITY_DEBUG);
+ 	return true;
+ }
+ 
+ static int cmd_to_func(struct nfit_mem *nfit_mem, unsigned int cmd,
+ 		struct nd_cmd_pkg *call_pkg)
+ {
+ 	if (call_pkg) {
+ 		int i;
+ 
+ 		if (nfit_mem->family != call_pkg->nd_family)
+ 			return -ENOTTY;
+ 
+ 		for (i = 0; i < ARRAY_SIZE(call_pkg->nd_reserved2); i++)
+ 			if (call_pkg->nd_reserved2[i])
+ 				return -EINVAL;
+ 		return call_pkg->nd_command;
+ 	}
+ 
+ 	/* Linux ND commands == NVDIMM_FAMILY_INTEL function numbers */
+ 	if (nfit_mem->family == NVDIMM_FAMILY_INTEL)
+ 		return cmd;
+ 
+ 	/*
+ 	 * Force function number validation to fail since 0 is never
+ 	 * published as a valid function in dsm_mask.
+ 	 */
+ 	return 0;
+ }
+ 
++>>>>>>> 11189c1089da (acpi/nfit: Fix command-supported detection)
  int acpi_nfit_ctl(struct nvdimm_bus_descriptor *nd_desc, struct nvdimm *nvdimm,
  		unsigned int cmd, void *buf, unsigned int buf_len, int *cmd_rc)
  {
@@@ -404,19 -448,11 +444,23 @@@
  	unsigned long cmd_mask, dsm_mask;
  	u32 offset, fw_status = 0;
  	acpi_handle handle;
- 	unsigned int func;
  	const guid_t *guid;
- 	int rc, i;
+ 	int func, rc, i;
  
++<<<<<<< HEAD
 +	func = cmd;
 +	if (cmd == ND_CMD_CALL) {
 +		call_pkg = buf;
 +		func = call_pkg->nd_command;
 +
 +		for (i = 0; i < ARRAY_SIZE(call_pkg->nd_reserved2); i++)
 +			if (call_pkg->nd_reserved2[i])
 +				return -EINVAL;
 +	}
++=======
+ 	if (cmd_rc)
+ 		*cmd_rc = -EINVAL;
++>>>>>>> 11189c1089da (acpi/nfit: Fix command-supported detection)
  
  	if (nvdimm) {
  		struct acpi_device *adev = nfit_mem->adev;
* Unmerged path drivers/acpi/nfit/core.c
