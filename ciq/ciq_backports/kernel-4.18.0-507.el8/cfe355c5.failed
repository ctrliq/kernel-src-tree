Bonding: return HWTSTAMP_FLAG_BONDED_PHC_INDEX to notify user space

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-507.el8
commit-author Hangbin Liu <liuhangbin@gmail.com>
commit cfe355c56e3a5eb993fd4ea807b60f34f91b0cde
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-507.el8/cfe355c5.failed

If the userspace program is distributed in binary form (distro package),
there is no way to know on which kernel versions it will run.

Let's only check if the flag was set when do SIOCSHWTSTAMP. And return
hwtstamp_config with flag HWTSTAMP_FLAG_BONDED_PHC_INDEX to notify
userspace whether the new feature is supported or not.

	Suggested-by: Jakub Kicinski <kuba@kernel.org>
Fixes: 085d61000845 ("Bonding: force user to add HWTSTAMP_FLAG_BONDED_PHC_INDEX when get/set HWTSTAMP")
	Signed-off-by: Hangbin Liu <liuhangbin@gmail.com>
	Acked-by: Richard Cochran <richardcochran@gmail.com>
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit cfe355c56e3a5eb993fd4ea807b60f34f91b0cde)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/bonding/bond_main.c
diff --cc drivers/net/bonding/bond_main.c
index f99aa29504af,1bb8fa9fd3aa..000000000000
--- a/drivers/net/bonding/bond_main.c
+++ b/drivers/net/bonding/bond_main.c
@@@ -4045,8 -4122,64 +4045,69 @@@ static int bond_do_ioctl(struct net_dev
  				mii->val_out = BMSR_LSTATUS;
  		}
  
++<<<<<<< HEAD
 +		return 0;
 +	case BOND_INFO_QUERY_OLD:
++=======
+ 		break;
+ 	case SIOCSHWTSTAMP:
+ 		if (copy_from_user(&cfg, ifr->ifr_data, sizeof(cfg)))
+ 			return -EFAULT;
+ 
+ 		if (!(cfg.flags & HWTSTAMP_FLAG_BONDED_PHC_INDEX))
+ 			return -EOPNOTSUPP;
+ 
+ 		fallthrough;
+ 	case SIOCGHWTSTAMP:
+ 		rcu_read_lock();
+ 		real_dev = bond_option_active_slave_get_rcu(bond);
+ 		rcu_read_unlock();
+ 		if (!real_dev)
+ 			return -EOPNOTSUPP;
+ 
+ 		strscpy_pad(ifrr.ifr_name, real_dev->name, IFNAMSIZ);
+ 		ifrr.ifr_ifru = ifr->ifr_ifru;
+ 
+ 		ops = real_dev->netdev_ops;
+ 		if (netif_device_present(real_dev) && ops->ndo_eth_ioctl) {
+ 			res = ops->ndo_eth_ioctl(real_dev, &ifrr, cmd);
+ 			if (res)
+ 				return res;
+ 
+ 			ifr->ifr_ifru = ifrr.ifr_ifru;
+ 			if (copy_from_user(&cfg, ifr->ifr_data, sizeof(cfg)))
+ 				return -EFAULT;
+ 
+ 			/* Set the BOND_PHC_INDEX flag to notify user space */
+ 			cfg.flags |= HWTSTAMP_FLAG_BONDED_PHC_INDEX;
+ 
+ 			return copy_to_user(ifr->ifr_data, &cfg, sizeof(cfg)) ?
+ 				-EFAULT : 0;
+ 		}
+ 		fallthrough;
+ 	default:
+ 		res = -EOPNOTSUPP;
+ 	}
+ 
+ 	return res;
+ }
+ 
+ static int bond_do_ioctl(struct net_device *bond_dev, struct ifreq *ifr, int cmd)
+ {
+ 	struct bonding *bond = netdev_priv(bond_dev);
+ 	struct net_device *slave_dev = NULL;
+ 	struct ifbond k_binfo;
+ 	struct ifbond __user *u_binfo = NULL;
+ 	struct ifslave k_sinfo;
+ 	struct ifslave __user *u_sinfo = NULL;
+ 	struct bond_opt_value newval;
+ 	struct net *net;
+ 	int res = 0;
+ 
+ 	netdev_dbg(bond_dev, "bond_ioctl: cmd=%d\n", cmd);
+ 
+ 	switch (cmd) {
++>>>>>>> cfe355c56e3a (Bonding: return HWTSTAMP_FLAG_BONDED_PHC_INDEX to notify user space)
  	case SIOCBONDINFOQUERY:
  		u_binfo = (struct ifbond __user *)ifr->ifr_data;
  
* Unmerged path drivers/net/bonding/bond_main.c
