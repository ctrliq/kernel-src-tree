Bonding: force user to add HWTSTAMP_FLAG_BONDED_PHC_INDEX when get/set HWTSTAMP

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-507.el8
commit-author Hangbin Liu <liuhangbin@gmail.com>
commit 085d61000845188a9aa9a9524f13a0622a1380d7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-507.el8/085d6100.failed

When there is a failover, the PHC index of bond active interface will be
changed. This may break the user space program if the author didn't aware.

By setting this flag, the user should aware that the PHC index get/set
by syscall is not stable. And the user space is able to deal with it.
Without this flag, the kernel will reject the request forwarding to
bonding.

	Reported-by: Jakub Kicinski <kuba@kernel.org>
Fixes: 94dd016ae538 ("bond: pass get_ts_info and SIOC[SG]HWTSTAMP ioctl to active device")
	Signed-off-by: Hangbin Liu <liuhangbin@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 085d61000845188a9aa9a9524f13a0622a1380d7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/bonding/bond_main.c
diff --cc drivers/net/bonding/bond_main.c
index f99aa29504af,b60e22f6394a..000000000000
--- a/drivers/net/bonding/bond_main.c
+++ b/drivers/net/bonding/bond_main.c
@@@ -4008,20 -4088,17 +4008,27 @@@ static void bond_get_stats(struct net_d
  	rcu_read_unlock();
  }
  
 -static int bond_eth_ioctl(struct net_device *bond_dev, struct ifreq *ifr, int cmd)
 +static int bond_do_ioctl(struct net_device *bond_dev, struct ifreq *ifr, int cmd)
  {
  	struct bonding *bond = netdev_priv(bond_dev);
 +	struct net_device *slave_dev = NULL;
 +	struct ifbond k_binfo;
 +	struct ifbond __user *u_binfo = NULL;
 +	struct ifslave k_sinfo;
 +	struct ifslave __user *u_sinfo = NULL;
  	struct mii_ioctl_data *mii = NULL;
++<<<<<<< HEAD
 +	struct bond_opt_value newval;
 +	struct net *net;
++=======
+ 	const struct net_device_ops *ops;
+ 	struct net_device *real_dev;
+ 	struct hwtstamp_config cfg;
+ 	struct ifreq ifrr;
++>>>>>>> 085d61000845 (Bonding: force user to add HWTSTAMP_FLAG_BONDED_PHC_INDEX when get/set HWTSTAMP)
  	int res = 0;
  
 -	netdev_dbg(bond_dev, "bond_eth_ioctl: cmd=%d\n", cmd);
 +	netdev_dbg(bond_dev, "bond_ioctl: cmd=%d\n", cmd);
  
  	switch (cmd) {
  	case SIOCGMIIPHY:
@@@ -4045,8 -4122,54 +4052,59 @@@
  				mii->val_out = BMSR_LSTATUS;
  		}
  
++<<<<<<< HEAD
 +		return 0;
 +	case BOND_INFO_QUERY_OLD:
++=======
+ 		break;
+ 	case SIOCSHWTSTAMP:
+ 	case SIOCGHWTSTAMP:
+ 		if (copy_from_user(&cfg, ifr->ifr_data, sizeof(cfg)))
+ 			return -EFAULT;
+ 
+ 		if (cfg.flags & HWTSTAMP_FLAG_BONDED_PHC_INDEX) {
+ 			rcu_read_lock();
+ 			real_dev = bond_option_active_slave_get_rcu(bond);
+ 			rcu_read_unlock();
+ 			if (real_dev) {
+ 				strscpy_pad(ifrr.ifr_name, real_dev->name, IFNAMSIZ);
+ 				ifrr.ifr_ifru = ifr->ifr_ifru;
+ 
+ 				ops = real_dev->netdev_ops;
+ 				if (netif_device_present(real_dev) && ops->ndo_eth_ioctl) {
+ 					res = ops->ndo_eth_ioctl(real_dev, &ifrr, cmd);
+ 
+ 					if (!res)
+ 						ifr->ifr_ifru = ifrr.ifr_ifru;
+ 
+ 					return res;
+ 				}
+ 			}
+ 		}
+ 		fallthrough;
+ 	default:
+ 		res = -EOPNOTSUPP;
+ 	}
+ 
+ 	return res;
+ }
+ 
+ static int bond_do_ioctl(struct net_device *bond_dev, struct ifreq *ifr, int cmd)
+ {
+ 	struct bonding *bond = netdev_priv(bond_dev);
+ 	struct net_device *slave_dev = NULL;
+ 	struct ifbond k_binfo;
+ 	struct ifbond __user *u_binfo = NULL;
+ 	struct ifslave k_sinfo;
+ 	struct ifslave __user *u_sinfo = NULL;
+ 	struct bond_opt_value newval;
+ 	struct net *net;
+ 	int res = 0;
+ 
+ 	netdev_dbg(bond_dev, "bond_ioctl: cmd=%d\n", cmd);
+ 
+ 	switch (cmd) {
++>>>>>>> 085d61000845 (Bonding: force user to add HWTSTAMP_FLAG_BONDED_PHC_INDEX when get/set HWTSTAMP)
  	case SIOCBONDINFOQUERY:
  		u_binfo = (struct ifbond __user *)ifr->ifr_data;
  
* Unmerged path drivers/net/bonding/bond_main.c
