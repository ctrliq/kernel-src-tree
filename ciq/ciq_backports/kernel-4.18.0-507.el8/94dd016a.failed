bond: pass get_ts_info and SIOC[SG]HWTSTAMP ioctl to active device

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-507.el8
commit-author Hangbin Liu <liuhangbin@gmail.com>
commit 94dd016ae538b12ea665015e5fd0c9844b184005
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-507.el8/94dd016a.failed

We have VLAN PTP support(via get_ts_info) on kernel, and bond support(by
getting active interface via netlink message) on userspace tool linuxptp.
But there are always some users who want to use PTP with VLAN over bond,
which is not able to do with the current implementation.

This patch passed get_ts_info and SIOC[SG]HWTSTAMP ioctl to active device
with bond mode active-backup/tlb/alb. With this users could get kernel native
bond or VLAN over bond PTP support.

Test with ptp4l and it works with VLAN over bond after this patch:
]# ptp4l -m -i bond0.23
ptp4l[53377.141]: selected /dev/ptp4 as PTP clock
ptp4l[53377.142]: port 1: INITIALIZING to LISTENING on INIT_COMPLETE
ptp4l[53377.143]: port 0: INITIALIZING to LISTENING on INIT_COMPLETE
ptp4l[53377.143]: port 0: INITIALIZING to LISTENING on INIT_COMPLETE
ptp4l[53384.127]: port 1: LISTENING to MASTER on ANNOUNCE_RECEIPT_TIMEOUT_EXPIRES
ptp4l[53384.127]: selected local clock e41d2d.fffe.123db0 as best master
ptp4l[53384.127]: port 1: assuming the grand master role

	Signed-off-by: Hangbin Liu <liuhangbin@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 94dd016ae538b12ea665015e5fd0c9844b184005)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/bonding/bond_main.c
diff --cc drivers/net/bonding/bond_main.c
index f99aa29504af,0f39ad2af81c..000000000000
--- a/drivers/net/bonding/bond_main.c
+++ b/drivers/net/bonding/bond_main.c
@@@ -4008,20 -4088,16 +4009,26 @@@ static void bond_get_stats(struct net_d
  	rcu_read_unlock();
  }
  
 -static int bond_eth_ioctl(struct net_device *bond_dev, struct ifreq *ifr, int cmd)
 +static int bond_do_ioctl(struct net_device *bond_dev, struct ifreq *ifr, int cmd)
  {
  	struct bonding *bond = netdev_priv(bond_dev);
 +	struct net_device *slave_dev = NULL;
 +	struct ifbond k_binfo;
 +	struct ifbond __user *u_binfo = NULL;
 +	struct ifslave k_sinfo;
 +	struct ifslave __user *u_sinfo = NULL;
  	struct mii_ioctl_data *mii = NULL;
++<<<<<<< HEAD
 +	struct bond_opt_value newval;
 +	struct net *net;
++=======
+ 	const struct net_device_ops *ops;
+ 	struct net_device *real_dev;
+ 	struct ifreq ifrr;
++>>>>>>> 94dd016ae538 (bond: pass get_ts_info and SIOC[SG]HWTSTAMP ioctl to active device)
  	int res = 0;
  
 -	netdev_dbg(bond_dev, "bond_eth_ioctl: cmd=%d\n", cmd);
 +	netdev_dbg(bond_dev, "bond_ioctl: cmd=%d\n", cmd);
  
  	switch (cmd) {
  	case SIOCGMIIPHY:
@@@ -4045,8 -4121,46 +4052,51 @@@
  				mii->val_out = BMSR_LSTATUS;
  		}
  
++<<<<<<< HEAD
 +		return 0;
 +	case BOND_INFO_QUERY_OLD:
++=======
+ 		break;
+ 	case SIOCSHWTSTAMP:
+ 	case SIOCGHWTSTAMP:
+ 		rcu_read_lock();
+ 		real_dev = bond_option_active_slave_get_rcu(bond);
+ 		rcu_read_unlock();
+ 		if (real_dev) {
+ 			strscpy_pad(ifrr.ifr_name, real_dev->name, IFNAMSIZ);
+ 			ifrr.ifr_ifru = ifr->ifr_ifru;
+ 
+ 			ops = real_dev->netdev_ops;
+ 			if (netif_device_present(real_dev) && ops->ndo_eth_ioctl)
+ 				res = ops->ndo_eth_ioctl(real_dev, &ifrr, cmd);
+ 
+ 			if (!res)
+ 				ifr->ifr_ifru = ifrr.ifr_ifru;
+ 		}
+ 		break;
+ 	default:
+ 		res = -EOPNOTSUPP;
+ 	}
+ 
+ 	return res;
+ }
+ 
+ static int bond_do_ioctl(struct net_device *bond_dev, struct ifreq *ifr, int cmd)
+ {
+ 	struct bonding *bond = netdev_priv(bond_dev);
+ 	struct net_device *slave_dev = NULL;
+ 	struct ifbond k_binfo;
+ 	struct ifbond __user *u_binfo = NULL;
+ 	struct ifslave k_sinfo;
+ 	struct ifslave __user *u_sinfo = NULL;
+ 	struct bond_opt_value newval;
+ 	struct net *net;
+ 	int res = 0;
+ 
+ 	netdev_dbg(bond_dev, "bond_ioctl: cmd=%d\n", cmd);
+ 
+ 	switch (cmd) {
++>>>>>>> 94dd016ae538 (bond: pass get_ts_info and SIOC[SG]HWTSTAMP ioctl to active device)
  	case SIOCBONDINFOQUERY:
  		u_binfo = (struct ifbond __user *)ifr->ifr_data;
  
* Unmerged path drivers/net/bonding/bond_main.c
