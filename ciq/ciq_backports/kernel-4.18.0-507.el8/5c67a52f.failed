Compiler Attributes: always use the extra-underscores syntax

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-507.el8
commit-author Miguel Ojeda <miguel.ojeda.sandonis@gmail.com>
commit 5c67a52f3da0f0d22764f2daec417702695a8112
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-507.el8/5c67a52f.failed

The attribute syntax optionally allows to surround attribute names
with "__" in order to avoid collisions with macros of the same name
(see https://gcc.gnu.org/onlinedocs/gcc/Attribute-Syntax.html).

This homogenizes all attributes to use the syntax with underscores.
While there are currently only a handful of cases of some TUs defining
macros like "error" which may collide with the attributes,
this should prevent futures surprises.

This has been done only for "standard" attributes supported by
the major compilers. In other words, those of third-party tools
(e.g. sparse, plugins...) have not been changed for the moment.

	Tested-by: Sedat Dilek <sedat.dilek@gmail.com> # on top of v4.19-rc5, clang 7
	Reviewed-by: Nick Desaulniers <ndesaulniers@google.com>
	Reviewed-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
	Signed-off-by: Miguel Ojeda <miguel.ojeda.sandonis@gmail.com>
(cherry picked from commit 5c67a52f3da0f0d22764f2daec417702695a8112)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/compiler-clang.h
#	include/linux/compiler-gcc.h
#	include/linux/compiler-intel.h
#	include/linux/compiler.h
#	include/linux/compiler_types.h
diff --cc include/linux/compiler-clang.h
index 7f432aad8ccb,d11cad61ba5c..000000000000
--- a/include/linux/compiler-clang.h
+++ b/include/linux/compiler-clang.h
@@@ -20,30 -16,12 +20,34 @@@
  /* all clang versions usable with the kernel support KASAN ABI version 5 */
  #define KASAN_ABI_VERSION 5
  
 -/* emulate gcc's __SANITIZE_ADDRESS__ flag */
 -#if __has_feature(address_sanitizer)
 +#undef __no_sanitize_address
 +#if __has_feature(address_sanitizer) || __has_feature(hwaddress_sanitizer)
 +/* Emulate GCC's __SANITIZE_ADDRESS__ flag */
  #define __SANITIZE_ADDRESS__
 +#define __no_sanitize_address \
 +		__attribute__((no_sanitize("address", "hwaddress")))
 +#else
 +#define __no_sanitize_address
 +#endif
 +
++<<<<<<< HEAD
 +/* Clang doesn't have a way to turn it off per-function, yet. */
 +#ifdef __noretpoline
 +#undef __noretpoline
  #endif
  
 +#undef __no_sanitize_thread
 +#if __has_feature(thread_sanitizer)
 +/* emulate gcc's __SANITIZE_THREAD__ flag */
 +#define __SANITIZE_THREAD__
 +#define __no_sanitize_thread \
 +		__attribute__((no_sanitize("thread")))
 +#else
 +#define __no_sanitize_thread
 +#endif
++=======
+ #define __no_sanitize_address __attribute__((__no_sanitize__("address")))
++>>>>>>> 5c67a52f3da0 (Compiler Attributes: always use the extra-underscores syntax)
  
  /*
   * Not all versions of clang implement the the type-generic versions
diff --cc include/linux/compiler-gcc.h
index 86782a1b73c9,7a1de7683df5..000000000000
--- a/include/linux/compiler-gcc.h
+++ b/include/linux/compiler-gcc.h
@@@ -75,117 -75,12 +75,117 @@@
  #define __must_be_array(a)	BUILD_BUG_ON_ZERO(__same_type((a), &(a)[0]))
  #endif
  
 +/*
 + * Feature detection for gnu_inline (gnu89 extern inline semantics). Either
 + * __GNUC_STDC_INLINE__ is defined (not using gnu89 extern inline semantics,
 + * and we opt in to the gnu89 semantics), or __GNUC_STDC_INLINE__ is not
 + * defined so the gnu89 semantics are the default.
 + */
 +#ifdef __GNUC_STDC_INLINE__
 +# define __gnu_inline	__attribute__((gnu_inline))
 +#else
 +# define __gnu_inline
 +#endif
 +
 +/*
 + * Force always-inline if the user requests it so via the .config,
 + * or if gcc is too old.
 + * GCC does not warn about unused static inline functions for
 + * -Wunused-function.  This turns out to avoid the need for complex #ifdef
 + * directives.  Suppress the warning in clang as well by using "unused"
 + * function attribute, which is redundant but not harmful for gcc.
 + * Prefer gnu_inline, so that extern inline functions do not emit an
 + * externally visible function. This makes extern inline behave as per gnu89
 + * semantics rather than c99. This prevents multiple symbol definition errors
 + * of extern inline functions at link time.
 + * A lot of inline functions can cause havoc with function tracing.
 + */
 +#if !defined(CONFIG_ARCH_SUPPORTS_OPTIMIZED_INLINING) ||		\
 +    !defined(CONFIG_OPTIMIZE_INLINING)
 +#define inline \
 +	inline __attribute__((always_inline, unused)) notrace __gnu_inline
 +#else
 +#define inline inline		__attribute__((unused)) notrace __gnu_inline
 +#endif
 +
 +#define __inline__ inline
 +#define __inline inline
 +#define __always_inline	inline __attribute__((always_inline))
 +#define  noinline	__attribute__((noinline))
 +
 +#define __packed	__attribute__((packed))
 +#define __weak		__attribute__((weak))
 +#define __alias(symbol)	__attribute__((alias(#symbol)))
 +
 +/*
 + * Used by functions that use '__builtin_return_address'. These function
 + * don't want to be splited or made inline, which can make
 + * the '__builtin_return_address' get unexpected address.
 + */
 +#define __fix_address noinline __noclone
 +
  #ifdef RETPOLINE
- #define __noretpoline __attribute__((indirect_branch("keep")))
+ #define __noretpoline __attribute__((__indirect_branch__("keep")))
  #endif
  
 +/*
 + * it doesn't make sense on ARM (currently the only user of __naked)
 + * to trace naked functions because then mcount is called without
 + * stack and frame pointer being set up and there is no chance to
 + * restore the lr register to the value before mcount was called.
 + */
 +#define __naked		__attribute__((naked)) notrace
 +
 +#define __noreturn	__attribute__((noreturn))
 +
 +/*
 + * From the GCC manual:
 + *
 + * Many functions have no effects except the return value and their
 + * return value depends only on the parameters and/or global
 + * variables.  Such a function can be subject to common subexpression
 + * elimination and loop optimization just as an arithmetic operator
 + * would be.
 + * [...]
 + */
 +#define __pure			__attribute__((pure))
 +#define __aligned(x)		__attribute__((aligned(x)))
 +#define __aligned_largest	__attribute__((aligned))
 +#define __printf(a, b)		__attribute__((format(printf, a, b)))
 +#define __scanf(a, b)		__attribute__((format(scanf, a, b)))
 +#define __attribute_const__	__attribute__((__const__))
 +#define __maybe_unused		__attribute__((unused))
 +#define __always_unused		__attribute__((unused))
 +#define __mode(x)               __attribute__((mode(x)))
 +
 +#define __must_check		__attribute__((warn_unused_result))
 +#define __malloc		__attribute__((__malloc__))
 +
 +#define __used			__attribute__((__used__))
 +#define __compiler_offsetof(a, b)					\
 +	__builtin_offsetof(a, b)
 +
 +/* Mark functions as cold. gcc will assume any path leading to a call
 + * to them will be unlikely.  This means a lot of manual unlikely()s
 + * are unnecessary now for any paths leading to the usual suspects
 + * like BUG(), printk(), panic() etc. [but let's keep them for now for
 + * older compilers]
 + *
 + * Early snapshots of gcc 4.3 don't support this and we can't detect this
 + * in the preprocessor, but we can live with this because they're unreleased.
 + * Maketime probing would be overkill here.
 + *
 + * gcc also has a __attribute__((__hot__)) to move hot functions into
 + * a special section, but I don't see any sense in this right now in
 + * the kernel context
 + */
 +#define __cold			__attribute__((__cold__))
 +
  #define __UNIQUE_ID(prefix) __PASTE(__PASTE(__UNIQUE_ID_, prefix), __COUNTER__)
  
 +#define __optimize(level)	__attribute__((__optimize__(level)))
 +#define __nostackprotector	__optimize("no-stack-protector")
 +
  #define __compiletime_object_size(obj) __builtin_object_size(obj, 0)
  
  #ifndef __CHECKER__
@@@ -290,17 -185,13 +290,27 @@@
  #define KASAN_ABI_VERSION 3
  #endif
  
++<<<<<<< HEAD
 +#if __has_attribute(__no_sanitize_address__)
 +#define __no_sanitize_address __attribute__((no_sanitize_address))
 +#else
 +#define __no_sanitize_address
 +#endif
 +
 +#if defined(__SANITIZE_THREAD__) && __has_attribute(__no_sanitize_thread__)
 +#define __no_sanitize_thread                                                   \
 +	__attribute__((__noinline__)) __attribute__((no_sanitize_thread))
 +#else
 +#define __no_sanitize_thread
++=======
+ #if GCC_VERSION >= 40902
+ /*
+  * Tell the compiler that address safety instrumentation (KASAN)
+  * should not be applied to that function.
+  * Conflicts with inlining: https://gcc.gnu.org/bugzilla/show_bug.cgi?id=67368
+  */
+ #define __no_sanitize_address __attribute__((__no_sanitize_address__))
++>>>>>>> 5c67a52f3da0 (Compiler Attributes: always use the extra-underscores syntax)
  #endif
  
  #if GCC_VERSION >= 50100
diff --cc include/linux/compiler-intel.h
index 547cdc920a3c,fef8bb3e53ef..000000000000
--- a/include/linux/compiler-intel.h
+++ b/include/linux/compiler-intel.h
@@@ -42,9 -37,9 +42,13 @@@
  /* icc has this, but it's called _bswap16 */
  #define __HAVE_BUILTIN_BSWAP16__
  #define __builtin_bswap16 _bswap16
 +#endif
  
 -/* The following are for compatibility with GCC, from compiler-gcc.h,
 - * and may be redefined here because they should not be shared with other
 - * compilers, like clang.
 +/*
 + * icc defines __GNUC__, but does not implement the builtin overflow checkers.
   */
++<<<<<<< HEAD
 +#undef COMPILER_HAS_GENERIC_BUILTIN_OVERFLOW
++=======
+ #define __visible	__attribute__((__externally_visible__))
++>>>>>>> 5c67a52f3da0 (Compiler Attributes: always use the extra-underscores syntax)
diff --cc include/linux/compiler.h
index 24a0e7ee0618,ec4a28bad2c6..000000000000
--- a/include/linux/compiler.h
+++ b/include/linux/compiler.h
@@@ -390,8 -287,17 +390,22 @@@ unsigned long read_word_at_a_time(cons
   * visible to the compiler.
   */
  #define __ADDRESSABLE(sym) \
++<<<<<<< HEAD
 +        static void * __section(".discard.addressable") __used \
 +                __UNIQUE_ID(__PASTE(__addressable_,sym)) = (void *)&sym;
++=======
+ 	static void * __attribute__((__section__(".discard.addressable"), used)) \
+ 		__PASTE(__addressable_##sym, __LINE__) = (void *)&sym;
+ 
+ /**
+  * offset_to_ptr - convert a relative memory offset to an absolute pointer
+  * @off:	the address of the 32-bit offset value
+  */
+ static inline void *offset_to_ptr(const int *off)
+ {
+ 	return (void *)((unsigned long)off + *off);
+ }
++>>>>>>> 5c67a52f3da0 (Compiler Attributes: always use the extra-underscores syntax)
  
  #endif /* __ASSEMBLY__ */
  
diff --cc include/linux/compiler_types.h
index 4fb18f107703,8fbdd47dd3d0..000000000000
--- a/include/linux/compiler_types.h
+++ b/include/linux/compiler_types.h
@@@ -292,4 -185,100 +292,103 @@@ struct ftrace_likely_data 
  #define __diag_error(compiler, version, option, comment) \
  	__diag_ ## compiler(version, error, option)
  
++<<<<<<< HEAD
++=======
+ /*
+  * From the GCC manual:
+  *
+  * Many functions have no effects except the return value and their
+  * return value depends only on the parameters and/or global
+  * variables.  Such a function can be subject to common subexpression
+  * elimination and loop optimization just as an arithmetic operator
+  * would be.
+  * [...]
+  */
+ #define __pure			__attribute__((__pure__))
+ #define __aligned(x)		__attribute__((__aligned__(x)))
+ #define __aligned_largest	__attribute__((__aligned__))
+ #define __printf(a, b)		__attribute__((__format__(printf, a, b)))
+ #define __scanf(a, b)		__attribute__((__format__(scanf, a, b)))
+ #define __maybe_unused		__attribute__((__unused__))
+ #define __always_unused		__attribute__((__unused__))
+ #define __mode(x)		__attribute__((__mode__(x)))
+ #define __malloc		__attribute__((__malloc__))
+ #define __used			__attribute__((__used__))
+ #define __noreturn		__attribute__((__noreturn__))
+ #define __packed		__attribute__((__packed__))
+ #define __weak			__attribute__((__weak__))
+ #define __alias(symbol)		__attribute__((__alias__(#symbol)))
+ #define __cold			__attribute__((__cold__))
+ #define __section(S)		__attribute__((__section__(#S)))
+ 
+ 
+ #ifdef CONFIG_ENABLE_MUST_CHECK
+ #define __must_check		__attribute__((__warn_unused_result__))
+ #else
+ #define __must_check
+ #endif
+ 
+ #if defined(CC_USING_HOTPATCH) && !defined(__CHECKER__)
+ #define notrace			__attribute__((hotpatch(0, 0)))
+ #else
+ #define notrace			__attribute__((__no_instrument_function__))
+ #endif
+ 
+ /*
+  * it doesn't make sense on ARM (currently the only user of __naked)
+  * to trace naked functions because then mcount is called without
+  * stack and frame pointer being set up and there is no chance to
+  * restore the lr register to the value before mcount was called.
+  */
+ #define __naked			__attribute__((__naked__)) notrace
+ 
+ #define __compiler_offsetof(a, b)	__builtin_offsetof(a, b)
+ 
+ /*
+  * Feature detection for gnu_inline (gnu89 extern inline semantics). Either
+  * __GNUC_STDC_INLINE__ is defined (not using gnu89 extern inline semantics,
+  * and we opt in to the gnu89 semantics), or __GNUC_STDC_INLINE__ is not
+  * defined so the gnu89 semantics are the default.
+  */
+ #ifdef __GNUC_STDC_INLINE__
+ # define __gnu_inline	__attribute__((__gnu_inline__))
+ #else
+ # define __gnu_inline
+ #endif
+ 
+ /*
+  * Force always-inline if the user requests it so via the .config.
+  * GCC does not warn about unused static inline functions for
+  * -Wunused-function.  This turns out to avoid the need for complex #ifdef
+  * directives.  Suppress the warning in clang as well by using "unused"
+  * function attribute, which is redundant but not harmful for gcc.
+  * Prefer gnu_inline, so that extern inline functions do not emit an
+  * externally visible function. This makes extern inline behave as per gnu89
+  * semantics rather than c99. This prevents multiple symbol definition errors
+  * of extern inline functions at link time.
+  * A lot of inline functions can cause havoc with function tracing.
+  */
+ #if !defined(CONFIG_ARCH_SUPPORTS_OPTIMIZED_INLINING) || \
+ 	!defined(CONFIG_OPTIMIZE_INLINING)
+ #define inline \
+ 	inline __attribute__((__always_inline__, __unused__)) notrace __gnu_inline
+ #else
+ #define inline inline	__attribute__((__unused__)) notrace __gnu_inline
+ #endif
+ 
+ #define __inline__ inline
+ #define __inline inline
+ #define noinline	__attribute__((__noinline__))
+ 
+ #ifndef __always_inline
+ #define __always_inline inline __attribute__((__always_inline__))
+ #endif
+ 
+ /*
+  * Rather then using noinline to prevent stack consumption, use
+  * noinline_for_stack instead.  For documentation reasons.
+  */
+ #define noinline_for_stack noinline
+ 
++>>>>>>> 5c67a52f3da0 (Compiler Attributes: always use the extra-underscores syntax)
  #endif /* __LINUX_COMPILER_TYPES_H */
* Unmerged path include/linux/compiler-clang.h
* Unmerged path include/linux/compiler-gcc.h
* Unmerged path include/linux/compiler-intel.h
* Unmerged path include/linux/compiler.h
* Unmerged path include/linux/compiler_types.h
