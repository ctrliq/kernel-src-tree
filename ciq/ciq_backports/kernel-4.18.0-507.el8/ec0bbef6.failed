Compiler Attributes: homogenize __must_be_array

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-507.el8
commit-author Miguel Ojeda <miguel.ojeda.sandonis@gmail.com>
commit ec0bbef66f867854691d5af18c2231d746958e0e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-507.el8/ec0bbef6.failed

Different definitions of __must_be_array:

  * gcc: disabled for __CHECKER__

  * clang: same definition as gcc's, but without __CHECKER__

  * intel: the comment claims __builtin_types_compatible_p()
    is unsupported; but icc seems to support it since 13.0.1
    (released in 2012). See https://godbolt.org/z/S0l6QQ

Therefore, we can remove all of them and have a single definition
in compiler.h

	Tested-by: Sedat Dilek <sedat.dilek@gmail.com> # on top of v4.19-rc5, clang 7
	Reviewed-by: Nick Desaulniers <ndesaulniers@google.com>
	Reviewed-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
	Signed-off-by: Miguel Ojeda <miguel.ojeda.sandonis@gmail.com>
(cherry picked from commit ec0bbef66f867854691d5af18c2231d746958e0e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/compiler-clang.h
#	include/linux/compiler-gcc.h
diff --cc include/linux/compiler-clang.h
index 7f432aad8ccb,fa9532f8d885..000000000000
--- a/include/linux/compiler-clang.h
+++ b/include/linux/compiler-clang.h
@@@ -59,6 -36,10 +59,16 @@@
  #define COMPILER_HAS_GENERIC_BUILTIN_OVERFLOW 1
  #endif
  
++<<<<<<< HEAD
 +#if __has_feature(shadow_call_stack)
 +# define __noscs	__attribute__((__no_sanitize__("shadow-call-stack")))
 +#endif
++=======
+ /* The following are for compatibility with GCC, from compiler-gcc.h,
+  * and may be redefined here because they should not be shared with other
+  * compilers, like ICC.
+  */
+ #define barrier() __asm__ __volatile__("" : : : "memory")
+ #define __assume_aligned(a, ...)	\
+ 	__attribute__((__assume_aligned__(a, ## __VA_ARGS__)))
++>>>>>>> ec0bbef66f86 (Compiler Attributes: homogenize __must_be_array)
diff --cc include/linux/compiler-gcc.h
index 86782a1b73c9,3b32bbfa5a49..000000000000
--- a/include/linux/compiler-gcc.h
+++ b/include/linux/compiler-gcc.h
@@@ -68,124 -68,12 +68,129 @@@
   */
  #define uninitialized_var(x) x = x
  
++<<<<<<< HEAD
 +#ifdef __CHECKER__
 +#define __must_be_array(a)	0
 +#else
 +/* &a[0] degrades to a pointer: a different type from an array */
 +#define __must_be_array(a)	BUILD_BUG_ON_ZERO(__same_type((a), &(a)[0]))
 +#endif
 +
 +/*
 + * Feature detection for gnu_inline (gnu89 extern inline semantics). Either
 + * __GNUC_STDC_INLINE__ is defined (not using gnu89 extern inline semantics,
 + * and we opt in to the gnu89 semantics), or __GNUC_STDC_INLINE__ is not
 + * defined so the gnu89 semantics are the default.
 + */
 +#ifdef __GNUC_STDC_INLINE__
 +# define __gnu_inline	__attribute__((gnu_inline))
 +#else
 +# define __gnu_inline
++=======
+ #ifdef RETPOLINE
+ #define __noretpoline __attribute__((__indirect_branch__("keep")))
++>>>>>>> ec0bbef66f86 (Compiler Attributes: homogenize __must_be_array)
 +#endif
 +
 +/*
 + * Force always-inline if the user requests it so via the .config,
 + * or if gcc is too old.
 + * GCC does not warn about unused static inline functions for
 + * -Wunused-function.  This turns out to avoid the need for complex #ifdef
 + * directives.  Suppress the warning in clang as well by using "unused"
 + * function attribute, which is redundant but not harmful for gcc.
 + * Prefer gnu_inline, so that extern inline functions do not emit an
 + * externally visible function. This makes extern inline behave as per gnu89
 + * semantics rather than c99. This prevents multiple symbol definition errors
 + * of extern inline functions at link time.
 + * A lot of inline functions can cause havoc with function tracing.
 + */
 +#if !defined(CONFIG_ARCH_SUPPORTS_OPTIMIZED_INLINING) ||		\
 +    !defined(CONFIG_OPTIMIZE_INLINING)
 +#define inline \
 +	inline __attribute__((always_inline, unused)) notrace __gnu_inline
 +#else
 +#define inline inline		__attribute__((unused)) notrace __gnu_inline
 +#endif
 +
 +#define __inline__ inline
 +#define __inline inline
 +#define __always_inline	inline __attribute__((always_inline))
 +#define  noinline	__attribute__((noinline))
 +
 +#define __packed	__attribute__((packed))
 +#define __weak		__attribute__((weak))
 +#define __alias(symbol)	__attribute__((alias(#symbol)))
 +
 +/*
 + * Used by functions that use '__builtin_return_address'. These function
 + * don't want to be splited or made inline, which can make
 + * the '__builtin_return_address' get unexpected address.
 + */
 +#define __fix_address noinline __noclone
 +
 +#ifdef RETPOLINE
 +#define __noretpoline __attribute__((indirect_branch("keep")))
  #endif
  
 +/*
 + * it doesn't make sense on ARM (currently the only user of __naked)
 + * to trace naked functions because then mcount is called without
 + * stack and frame pointer being set up and there is no chance to
 + * restore the lr register to the value before mcount was called.
 + */
 +#define __naked		__attribute__((naked)) notrace
 +
 +#define __noreturn	__attribute__((noreturn))
 +
 +/*
 + * From the GCC manual:
 + *
 + * Many functions have no effects except the return value and their
 + * return value depends only on the parameters and/or global
 + * variables.  Such a function can be subject to common subexpression
 + * elimination and loop optimization just as an arithmetic operator
 + * would be.
 + * [...]
 + */
 +#define __pure			__attribute__((pure))
 +#define __aligned(x)		__attribute__((aligned(x)))
 +#define __aligned_largest	__attribute__((aligned))
 +#define __printf(a, b)		__attribute__((format(printf, a, b)))
 +#define __scanf(a, b)		__attribute__((format(scanf, a, b)))
 +#define __attribute_const__	__attribute__((__const__))
 +#define __maybe_unused		__attribute__((unused))
 +#define __always_unused		__attribute__((unused))
 +#define __mode(x)               __attribute__((mode(x)))
 +
 +#define __must_check		__attribute__((warn_unused_result))
 +#define __malloc		__attribute__((__malloc__))
 +
 +#define __used			__attribute__((__used__))
 +#define __compiler_offsetof(a, b)					\
 +	__builtin_offsetof(a, b)
 +
 +/* Mark functions as cold. gcc will assume any path leading to a call
 + * to them will be unlikely.  This means a lot of manual unlikely()s
 + * are unnecessary now for any paths leading to the usual suspects
 + * like BUG(), printk(), panic() etc. [but let's keep them for now for
 + * older compilers]
 + *
 + * Early snapshots of gcc 4.3 don't support this and we can't detect this
 + * in the preprocessor, but we can live with this because they're unreleased.
 + * Maketime probing would be overkill here.
 + *
 + * gcc also has a __attribute__((__hot__)) to move hot functions into
 + * a special section, but I don't see any sense in this right now in
 + * the kernel context
 + */
 +#define __cold			__attribute__((__cold__))
 +
  #define __UNIQUE_ID(prefix) __PASTE(__PASTE(__UNIQUE_ID_, prefix), __COUNTER__)
  
 +#define __optimize(level)	__attribute__((__optimize__(level)))
 +#define __nostackprotector	__optimize("no-stack-protector")
 +
  #define __compiletime_object_size(obj) __builtin_object_size(obj, 0)
  
  #ifndef __CHECKER__
* Unmerged path include/linux/compiler-clang.h
* Unmerged path include/linux/compiler-gcc.h
diff --git a/include/linux/compiler-intel.h b/include/linux/compiler-intel.h
index 547cdc920a3c..5a344a4d7de7 100644
--- a/include/linux/compiler-intel.h
+++ b/include/linux/compiler-intel.h
@@ -33,9 +33,6 @@
  */
 #define OPTIMIZER_HIDE_VAR(var) barrier()
 
-/* Intel ECC compiler doesn't support __builtin_types_compatible_p() */
-#define __must_be_array(a) 0
-
 #endif
 
 #ifndef __HAVE_BUILTIN_BSWAP16__
diff --git a/include/linux/compiler.h b/include/linux/compiler.h
index 24a0e7ee0618..d8763873a999 100644
--- a/include/linux/compiler.h
+++ b/include/linux/compiler.h
@@ -455,4 +455,11 @@ unsigned long read_word_at_a_time(const void *addr)
 	compiletime_assert(__native_word(t),				\
 		"Need native word sized stores/loads for atomicity.")
 
+#ifdef __CHECKER__
+#define __must_be_array(a)	0
+#else
+/* &a[0] degrades to a pointer: a different type from an array */
+#define __must_be_array(a)	BUILD_BUG_ON_ZERO(__same_type((a), &(a)[0]))
+#endif
+
 #endif /* __LINUX_COMPILER_H */
