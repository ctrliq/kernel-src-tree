Compiler Attributes: naked can be shared

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-507.el8
commit-author Miguel Ojeda <miguel.ojeda.sandonis@gmail.com>
commit ae596de1a0c8c2c924dc99d23c026259372ab234
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-507.el8/ae596de1.failed

The naked attribute is supported by at least gcc >= 4.6 (for ARM,
which is the only current user), gcc >= 8 (for x86), clang >= 3.1
and icc >= 13. See https://godbolt.org/z/350Dyc

Therefore, move it out of compiler-gcc.h so that the definition
is shared by all compilers.

This also fixes Clang support for ARM32 --- 815f0ddb346c
("include/linux/compiler*.h: make compiler-*.h mutually exclusive").

Fixes: 815f0ddb346c ("include/linux/compiler*.h: make compiler-*.h mutually exclusive")
	Cc: Rasmus Villemoes <linux@rasmusvillemoes.dk>
	Cc: Eli Friedman <efriedma@codeaurora.org>
	Cc: Christopher Li <sparse@chrisli.org>
	Cc: Kees Cook <keescook@chromium.org>
	Cc: Ingo Molnar <mingo@kernel.org>
	Cc: Geert Uytterhoeven <geert@linux-m68k.org>
	Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
	Cc: Masahiro Yamada <yamada.masahiro@socionext.com>
	Cc: Joe Perches <joe@perches.com>
	Cc: Dominique Martinet <asmadeus@codewreck.org>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: linux-sparse@vger.kernel.org
	Suggested-by: Arnd Bergmann <arnd@arndb.de>
	Tested-by: Stefan Agner <stefan@agner.ch>
	Reviewed-by: Stefan Agner <stefan@agner.ch>
	Reviewed-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
	Reviewed-by: Nick Desaulniers <ndesaulniers@google.com>
	Signed-off-by: Miguel Ojeda <miguel.ojeda.sandonis@gmail.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit ae596de1a0c8c2c924dc99d23c026259372ab234)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/compiler-gcc.h
#	include/linux/compiler_types.h
diff --cc include/linux/compiler-gcc.h
index 86782a1b73c9,4d36b27214fd..000000000000
--- a/include/linux/compiler-gcc.h
+++ b/include/linux/compiler-gcc.h
@@@ -128,59 -79,6 +128,62 @@@
  #define __noretpoline __attribute__((indirect_branch("keep")))
  #endif
  
++<<<<<<< HEAD
 +/*
 + * it doesn't make sense on ARM (currently the only user of __naked)
 + * to trace naked functions because then mcount is called without
 + * stack and frame pointer being set up and there is no chance to
 + * restore the lr register to the value before mcount was called.
 + */
 +#define __naked		__attribute__((naked)) notrace
 +
 +#define __noreturn	__attribute__((noreturn))
 +
 +/*
 + * From the GCC manual:
 + *
 + * Many functions have no effects except the return value and their
 + * return value depends only on the parameters and/or global
 + * variables.  Such a function can be subject to common subexpression
 + * elimination and loop optimization just as an arithmetic operator
 + * would be.
 + * [...]
 + */
 +#define __pure			__attribute__((pure))
 +#define __aligned(x)		__attribute__((aligned(x)))
 +#define __aligned_largest	__attribute__((aligned))
 +#define __printf(a, b)		__attribute__((format(printf, a, b)))
 +#define __scanf(a, b)		__attribute__((format(scanf, a, b)))
 +#define __attribute_const__	__attribute__((__const__))
 +#define __maybe_unused		__attribute__((unused))
 +#define __always_unused		__attribute__((unused))
 +#define __mode(x)               __attribute__((mode(x)))
 +
 +#define __must_check		__attribute__((warn_unused_result))
 +#define __malloc		__attribute__((__malloc__))
 +
 +#define __used			__attribute__((__used__))
 +#define __compiler_offsetof(a, b)					\
 +	__builtin_offsetof(a, b)
 +
 +/* Mark functions as cold. gcc will assume any path leading to a call
 + * to them will be unlikely.  This means a lot of manual unlikely()s
 + * are unnecessary now for any paths leading to the usual suspects
 + * like BUG(), printk(), panic() etc. [but let's keep them for now for
 + * older compilers]
 + *
 + * Early snapshots of gcc 4.3 don't support this and we can't detect this
 + * in the preprocessor, but we can live with this because they're unreleased.
 + * Maketime probing would be overkill here.
 + *
 + * gcc also has a __attribute__((__hot__)) to move hot functions into
 + * a special section, but I don't see any sense in this right now in
 + * the kernel context
 + */
 +#define __cold			__attribute__((__cold__))
 +
++=======
++>>>>>>> ae596de1a0c8 (Compiler Attributes: naked can be shared)
  #define __UNIQUE_ID(prefix) __PASTE(__PASTE(__UNIQUE_ID_, prefix), __COUNTER__)
  
  #define __optimize(level)	__attribute__((__optimize__(level)))
diff --cc include/linux/compiler_types.h
index 4fb18f107703,db192becfec4..000000000000
--- a/include/linux/compiler_types.h
+++ b/include/linux/compiler_types.h
@@@ -292,4 -186,100 +292,103 @@@ struct ftrace_likely_data 
  #define __diag_error(compiler, version, option, comment) \
  	__diag_ ## compiler(version, error, option)
  
++<<<<<<< HEAD
++=======
+ /*
+  * From the GCC manual:
+  *
+  * Many functions have no effects except the return value and their
+  * return value depends only on the parameters and/or global
+  * variables.  Such a function can be subject to common subexpression
+  * elimination and loop optimization just as an arithmetic operator
+  * would be.
+  * [...]
+  */
+ #define __pure			__attribute__((pure))
+ #define __aligned(x)		__attribute__((aligned(x)))
+ #define __aligned_largest	__attribute__((aligned))
+ #define __printf(a, b)		__attribute__((format(printf, a, b)))
+ #define __scanf(a, b)		__attribute__((format(scanf, a, b)))
+ #define __maybe_unused		__attribute__((unused))
+ #define __always_unused		__attribute__((unused))
+ #define __mode(x)		__attribute__((mode(x)))
+ #define __malloc		__attribute__((__malloc__))
+ #define __used			__attribute__((__used__))
+ #define __noreturn		__attribute__((noreturn))
+ #define __packed		__attribute__((packed))
+ #define __weak			__attribute__((weak))
+ #define __alias(symbol)		__attribute__((alias(#symbol)))
+ #define __cold			__attribute__((cold))
+ #define __section(S)		__attribute__((__section__(#S)))
+ 
+ 
+ #ifdef CONFIG_ENABLE_MUST_CHECK
+ #define __must_check		__attribute__((warn_unused_result))
+ #else
+ #define __must_check
+ #endif
+ 
+ #if defined(CC_USING_HOTPATCH) && !defined(__CHECKER__)
+ #define notrace			__attribute__((hotpatch(0, 0)))
+ #else
+ #define notrace			__attribute__((no_instrument_function))
+ #endif
+ 
+ /*
+  * it doesn't make sense on ARM (currently the only user of __naked)
+  * to trace naked functions because then mcount is called without
+  * stack and frame pointer being set up and there is no chance to
+  * restore the lr register to the value before mcount was called.
+  */
+ #define __naked			__attribute__((naked)) notrace
+ 
+ #define __compiler_offsetof(a, b)	__builtin_offsetof(a, b)
+ 
+ /*
+  * Feature detection for gnu_inline (gnu89 extern inline semantics). Either
+  * __GNUC_STDC_INLINE__ is defined (not using gnu89 extern inline semantics,
+  * and we opt in to the gnu89 semantics), or __GNUC_STDC_INLINE__ is not
+  * defined so the gnu89 semantics are the default.
+  */
+ #ifdef __GNUC_STDC_INLINE__
+ # define __gnu_inline	__attribute__((gnu_inline))
+ #else
+ # define __gnu_inline
+ #endif
+ 
+ /*
+  * Force always-inline if the user requests it so via the .config.
+  * GCC does not warn about unused static inline functions for
+  * -Wunused-function.  This turns out to avoid the need for complex #ifdef
+  * directives.  Suppress the warning in clang as well by using "unused"
+  * function attribute, which is redundant but not harmful for gcc.
+  * Prefer gnu_inline, so that extern inline functions do not emit an
+  * externally visible function. This makes extern inline behave as per gnu89
+  * semantics rather than c99. This prevents multiple symbol definition errors
+  * of extern inline functions at link time.
+  * A lot of inline functions can cause havoc with function tracing.
+  */
+ #if !defined(CONFIG_ARCH_SUPPORTS_OPTIMIZED_INLINING) || \
+ 	!defined(CONFIG_OPTIMIZE_INLINING)
+ #define inline \
+ 	inline __attribute__((always_inline, unused)) notrace __gnu_inline
+ #else
+ #define inline inline	__attribute__((unused)) notrace __gnu_inline
+ #endif
+ 
+ #define __inline__ inline
+ #define __inline inline
+ #define noinline	__attribute__((noinline))
+ 
+ #ifndef __always_inline
+ #define __always_inline inline __attribute__((always_inline))
+ #endif
+ 
+ /*
+  * Rather then using noinline to prevent stack consumption, use
+  * noinline_for_stack instead.  For documentation reasons.
+  */
+ #define noinline_for_stack noinline
+ 
++>>>>>>> ae596de1a0c8 (Compiler Attributes: naked can be shared)
  #endif /* __LINUX_COMPILER_TYPES_H */
* Unmerged path include/linux/compiler-gcc.h
* Unmerged path include/linux/compiler_types.h
