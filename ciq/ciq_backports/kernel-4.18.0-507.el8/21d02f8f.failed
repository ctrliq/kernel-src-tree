mm/page_alloc: move free_the_page

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-507.el8
commit-author Mel Gorman <mgorman@techsingularity.net>
commit 21d02f8f8464e27434f477c73431075197a9f72f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-507.el8/21d02f8f.failed

Patch series "Allow high order pages to be stored on PCP", v2.

The per-cpu page allocator (PCP) only handles order-0 pages.  With the
series "Use local_lock for pcp protection and reduce stat overhead" and
"Calculate pcp->high based on zone sizes and active CPUs", it's now
feasible to store high-order pages on PCP lists.

This small series allows PCP to store "cheap" orders where cheap is
determined by PAGE_ALLOC_COSTLY_ORDER and THP-sized allocations.

This patch (of 2):

In the next page, free_compount_page is going to use the common helper
free_the_page.  This patch moves the definition to ease review.  No
functional change.

Link: https://lkml.kernel.org/r/20210603142220.10851-1-mgorman@techsingularity.net
Link: https://lkml.kernel.org/r/20210603142220.10851-2-mgorman@techsingularity.net
	Signed-off-by: Mel Gorman <mgorman@techsingularity.net>
	Acked-by: Vlastimil Babka <vbabka@suse.cz>
	Cc: Dave Hansen <dave.hansen@linux.intel.com>
	Cc: Jesper Dangaard Brouer <brouer@redhat.com>
	Cc: Michal Hocko <mhocko@kernel.org>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 21d02f8f8464e27434f477c73431075197a9f72f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/page_alloc.c
diff --cc mm/page_alloc.c
index 5ee43c5e468f,58f7a321598f..000000000000
--- a/mm/page_alloc.c
+++ b/mm/page_alloc.c
@@@ -5070,22 -5357,31 +5078,45 @@@ unsigned long get_zeroed_page(gfp_t gfp
  }
  EXPORT_SYMBOL(get_zeroed_page);
  
++<<<<<<< HEAD
 +static inline void free_the_page(struct page *page, unsigned int order)
 +{
 +	if (order == 0)		/* Via pcp? */
 +		free_unref_page(page);
 +	else
 +		__free_pages_ok(page, order, FPI_NONE);
 +}
 +
++=======
+ /**
+  * __free_pages - Free pages allocated with alloc_pages().
+  * @page: The page pointer returned from alloc_pages().
+  * @order: The order of the allocation.
+  *
+  * This function can free multi-page allocations that are not compound
+  * pages.  It does not check that the @order passed in matches that of
+  * the allocation, so it is easy to leak memory.  Freeing more memory
+  * than was allocated will probably emit a warning.
+  *
+  * If the last reference to this page is speculative, it will be released
+  * by put_page() which only frees the first page of a non-compound
+  * allocation.  To prevent the remaining pages from being leaked, we free
+  * the subsequent pages here.  If you want to use the page's reference
+  * count to decide when to free the allocation, you should allocate a
+  * compound page, and use put_page() instead of __free_pages().
+  *
+  * Context: May be called in interrupt context or while holding a normal
+  * spinlock, but not in NMI context or while holding a raw spinlock.
+  */
++>>>>>>> 21d02f8f8464 (mm/page_alloc: move free_the_page)
  void __free_pages(struct page *page, unsigned int order)
  {
 +	/* get PageHead before we drop reference */
 +	int head = PageHead(page);
 +
  	if (put_page_testzero(page))
  		free_the_page(page, order);
 -	else if (!PageHead(page))
 +	else if (!head)
  		while (order-- > 0)
  			free_the_page(page + (1 << order), order);
  }
* Unmerged path mm/page_alloc.c
