include/linux/compiler*.h: make compiler-*.h mutually exclusive

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-507.el8
commit-author Nick Desaulniers <ndesaulniers@google.com>
commit 815f0ddb346c196018d4d8f8f55c12b83da1de3f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-507.el8/815f0ddb.failed

Commit cafa0010cd51 ("Raise the minimum required gcc version to 4.6")
recently exposed a brittle part of the build for supporting non-gcc
compilers.

Both Clang and ICC define __GNUC__, __GNUC_MINOR__, and
__GNUC_PATCHLEVEL__ for quick compatibility with code bases that haven't
added compiler specific checks for __clang__ or __INTEL_COMPILER.

This is brittle, as they happened to get compatibility by posing as a
certain version of GCC.  This broke when upgrading the minimal version
of GCC required to build the kernel, to a version above what ICC and
Clang claim to be.

Rather than always including compiler-gcc.h then undefining or
redefining macros in compiler-intel.h or compiler-clang.h, let's
separate out the compiler specific macro definitions into mutually
exclusive headers, do more proper compiler detection, and keep shared
definitions in compiler_types.h.

Fixes: cafa0010cd51 ("Raise the minimum required gcc version to 4.6")
	Reported-by: Masahiro Yamada <yamada.masahiro@socionext.com>
	Suggested-by: Eli Friedman <efriedma@codeaurora.org>
	Suggested-by: Joe Perches <joe@perches.com>
	Signed-off-by: Nick Desaulniers <ndesaulniers@google.com>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 815f0ddb346c196018d4d8f8f55c12b83da1de3f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/i915_utils.h
#	include/linux/compiler-clang.h
#	include/linux/compiler-gcc.h
#	include/linux/compiler_types.h
diff --cc drivers/gpu/drm/i915/i915_utils.h
index b64192d9c7da,395dd2511568..000000000000
--- a/drivers/gpu/drm/i915/i915_utils.h
+++ b/drivers/gpu/drm/i915/i915_utils.h
@@@ -45,42 -43,14 +45,48 @@@ struct timer_list
  #define MISSING_CASE(x) WARN(1, "Missing case (%s == %ld)\n", \
  			     __stringify(x), (long)(x))
  
++<<<<<<< HEAD
 +void __printf(3, 4)
 +__i915_printk(struct drm_i915_private *dev_priv, const char *level,
 +	      const char *fmt, ...);
 +
 +#define i915_report_error(dev_priv, fmt, ...)				   \
 +	__i915_printk(dev_priv, KERN_ERR, fmt, ##__VA_ARGS__)
 +
 +#if IS_ENABLED(CONFIG_DRM_I915_DEBUG)
 +
 +int __i915_inject_probe_error(struct drm_i915_private *i915, int err,
 +			      const char *func, int line);
 +#define i915_inject_probe_error(_i915, _err) \
 +	__i915_inject_probe_error((_i915), (_err), __func__, __LINE__)
 +bool i915_error_injected(void);
 +
++=======
+ #if defined(GCC_VERSION) && GCC_VERSION >= 70000
+ #define add_overflows(A, B) \
+ 	__builtin_add_overflow_p((A), (B), (typeof((A) + (B)))0)
++>>>>>>> 815f0ddb346c (include/linux/compiler*.h: make compiler-*.h mutually exclusive)
 +#else
 +
 +#define i915_inject_probe_error(i915, e) ({ BUILD_BUG_ON_INVALID(i915); 0; })
 +#define i915_error_injected() false
 +
 +#endif
 +
 +#define i915_inject_probe_failure(i915) i915_inject_probe_error((i915), -ENODEV)
 +
 +#define i915_probe_error(i915, fmt, ...)				   \
 +	__i915_printk(i915, i915_error_injected() ? KERN_DEBUG : KERN_ERR, \
 +		      fmt, ##__VA_ARGS__)
 +
 +#if defined(GCC_VERSION) && GCC_VERSION >= 70000
 +#define add_overflows_t(T, A, B) \
 +	__builtin_add_overflow_p((A), (B), (T)0)
  #else
 -#define add_overflows(A, B) ({ \
 +#define add_overflows_t(T, A, B) ({ \
  	typeof(A) a = (A); \
  	typeof(B) b = (B); \
 -	a + b < a; \
 +	(T)(a + b) < a; \
  })
  #endif
  
diff --cc include/linux/compiler-clang.h
index 7f432aad8ccb,b1ce500fe8b3..000000000000
--- a/include/linux/compiler-clang.h
+++ b/include/linux/compiler-clang.h
@@@ -20,31 -16,13 +16,41 @@@
  /* all clang versions usable with the kernel support KASAN ABI version 5 */
  #define KASAN_ABI_VERSION 5
  
++<<<<<<< HEAD
 +#undef __no_sanitize_address
 +#if __has_feature(address_sanitizer) || __has_feature(hwaddress_sanitizer)
 +/* Emulate GCC's __SANITIZE_ADDRESS__ flag */
 +#define __SANITIZE_ADDRESS__
 +#define __no_sanitize_address \
 +		__attribute__((no_sanitize("address", "hwaddress")))
 +#else
 +#define __no_sanitize_address
 +#endif
 +
 +/* Clang doesn't have a way to turn it off per-function, yet. */
 +#ifdef __noretpoline
 +#undef __noretpoline
 +#endif
 +
 +#undef __no_sanitize_thread
 +#if __has_feature(thread_sanitizer)
 +/* emulate gcc's __SANITIZE_THREAD__ flag */
 +#define __SANITIZE_THREAD__
 +#define __no_sanitize_thread \
 +		__attribute__((no_sanitize("thread")))
 +#else
 +#define __no_sanitize_thread
 +#endif
 +
++=======
+ /* emulate gcc's __SANITIZE_ADDRESS__ flag */
+ #if __has_feature(address_sanitizer)
+ #define __SANITIZE_ADDRESS__
+ #endif
+ 
+ #define __no_sanitize_address __attribute__((no_sanitize("address")))
+ 
++>>>>>>> 815f0ddb346c (include/linux/compiler*.h: make compiler-*.h mutually exclusive)
  /*
   * Not all versions of clang implement the the type-generic versions
   * of the builtin overflow checkers. Fortunately, clang implements
@@@ -59,6 -36,11 +64,17 @@@
  #define COMPILER_HAS_GENERIC_BUILTIN_OVERFLOW 1
  #endif
  
++<<<<<<< HEAD
 +#if __has_feature(shadow_call_stack)
 +# define __noscs	__attribute__((__no_sanitize__("shadow-call-stack")))
 +#endif
++=======
+ /* The following are for compatibility with GCC, from compiler-gcc.h,
+  * and may be redefined here because they should not be shared with other
+  * compilers, like ICC.
+  */
+ #define barrier() __asm__ __volatile__("" : : : "memory")
+ #define __must_be_array(a) BUILD_BUG_ON_ZERO(__same_type((a), &(a)[0]))
+ #define __assume_aligned(a, ...)	\
+ 	__attribute__((__assume_aligned__(a, ## __VA_ARGS__)))
++>>>>>>> 815f0ddb346c (include/linux/compiler*.h: make compiler-*.h mutually exclusive)
diff --cc include/linux/compiler-gcc.h
index 065db28ca17a,763bbad1e258..000000000000
--- a/include/linux/compiler-gcc.h
+++ b/include/linux/compiler-gcc.h
@@@ -75,55 -75,6 +75,58 @@@
  #define __must_be_array(a)	BUILD_BUG_ON_ZERO(__same_type((a), &(a)[0]))
  #endif
  
++<<<<<<< HEAD
 +/*
 + * Feature detection for gnu_inline (gnu89 extern inline semantics). Either
 + * __GNUC_STDC_INLINE__ is defined (not using gnu89 extern inline semantics,
 + * and we opt in to the gnu89 semantics), or __GNUC_STDC_INLINE__ is not
 + * defined so the gnu89 semantics are the default.
 + */
 +#ifdef __GNUC_STDC_INLINE__
 +# define __gnu_inline	__attribute__((gnu_inline))
 +#else
 +# define __gnu_inline
 +#endif
 +
 +/*
 + * Force always-inline if the user requests it so via the .config,
 + * or if gcc is too old.
 + * GCC does not warn about unused static inline functions for
 + * -Wunused-function.  This turns out to avoid the need for complex #ifdef
 + * directives.  Suppress the warning in clang as well by using "unused"
 + * function attribute, which is redundant but not harmful for gcc.
 + * Prefer gnu_inline, so that extern inline functions do not emit an
 + * externally visible function. This makes extern inline behave as per gnu89
 + * semantics rather than c99. This prevents multiple symbol definition errors
 + * of extern inline functions at link time.
 + * A lot of inline functions can cause havoc with function tracing.
 + */
 +#if !defined(CONFIG_ARCH_SUPPORTS_OPTIMIZED_INLINING) ||		\
 +    !defined(CONFIG_OPTIMIZE_INLINING)
 +#define inline \
 +	inline __attribute__((always_inline, unused)) notrace __gnu_inline
 +#else
 +#define inline inline		__attribute__((unused)) notrace __gnu_inline
 +#endif
 +
 +#define __inline__ inline
 +#define __inline inline
 +#define __always_inline	inline __attribute__((always_inline))
 +#define  noinline	__attribute__((noinline))
 +
 +#define __packed	__attribute__((packed))
 +#define __weak		__attribute__((weak))
 +#define __alias(symbol)	__attribute__((alias(#symbol)))
 +
 +/*
 + * Used by functions that use '__builtin_return_address'. These function
 + * don't want to be splited or made inline, which can make
 + * the '__builtin_return_address' get unexpected address.
 + */
 +#define __fix_address noinline __noclone
 +
++=======
++>>>>>>> 815f0ddb346c (include/linux/compiler*.h: make compiler-*.h mutually exclusive)
  #ifdef RETPOLINE
  #define __noretpoline __attribute__((indirect_branch("keep")))
  #endif
diff --cc include/linux/compiler_types.h
index 4fb18f107703,90479a0f3986..000000000000
--- a/include/linux/compiler_types.h
+++ b/include/linux/compiler_types.h
@@@ -79,19 -67,7 +67,23 @@@ extern void __chk_io_ptr(const volatil
  #endif
  
  /*
++<<<<<<< HEAD
 + * Some architectures need to provide custom definitions of macros provided
 + * by linux/compiler-*.h, and can do so using asm/compiler.h. We include that
 + * conditionally rather than using an asm-generic wrapper in order to avoid
 + * build failures if any C compilation, which will include this file via an
 + * -include argument in c_flags, occurs prior to the asm-generic wrappers being
 + * generated.
 + */
 +#ifdef CONFIG_HAVE_ARCH_COMPILER_H
 +#include <asm/compiler.h>
 +#endif
 +
 +/*
 + * Generic compiler-dependent macros required for kernel
++=======
+  * Generic compiler-independent macros required for kernel
++>>>>>>> 815f0ddb346c (include/linux/compiler*.h: make compiler-*.h mutually exclusive)
   * build go below this comment. Actual compiler/compiler version
   * specific implementations come from the above header files
   */
@@@ -118,16 -94,6 +110,19 @@@ struct ftrace_likely_data 
  	unsigned long			constant;
  };
  
++<<<<<<< HEAD
 +/* Section for code which can't be instrumented at all */
 +#define noinstr								\
 +	noinline notrace __attribute((__section__(".noinstr.text")))
 +
 +#endif /* __KERNEL__ */
 +
 +#endif /* __ASSEMBLY__ */
 +
 +#ifdef __KERNEL__
 +
++=======
++>>>>>>> 815f0ddb346c (include/linux/compiler*.h: make compiler-*.h mutually exclusive)
  /* Don't. Just don't. */
  #define __deprecated
  #define __deprecated_for_modules
@@@ -230,24 -128,6 +157,27 @@@
  # define randomized_struct_fields_end
  #endif
  
++<<<<<<< HEAD
 +#ifndef __noscs
 +# define __noscs
 +#endif
 +
 +/*
 + * Tell gcc if a function is cold. The compiler will assume any path
 + * directly leading to the call is unlikely.
 + */
 +
 +#ifndef __cold
 +#define __cold
 +#endif
 +
 +/* Simple shorthand for a section definition */
 +#ifndef __section
 +# define __section(S) __attribute__ ((__section__(#S)))
 +#endif
 +
++=======
++>>>>>>> 815f0ddb346c (include/linux/compiler*.h: make compiler-*.h mutually exclusive)
  #ifndef __visible
  #define __visible
  #endif
diff --git a/arch/arm/kernel/asm-offsets.c b/arch/arm/kernel/asm-offsets.c
index 4c5701f865e9..d2553bf8b816 100644
--- a/arch/arm/kernel/asm-offsets.c
+++ b/arch/arm/kernel/asm-offsets.c
@@ -35,25 +35,14 @@
 #error Sorry, your compiler targets APCS-26 but this kernel requires APCS-32
 #endif
 /*
- * GCC 3.0, 3.1: general bad code generation.
- * GCC 3.2.0: incorrect function argument offset calculation.
- * GCC 3.2.x: miscompiles NEW_AUX_ENT in fs/binfmt_elf.c
- *            (http://gcc.gnu.org/PR8896) and incorrect structure
- *	      initialisation in fs/jffs2/erase.c
  * GCC 4.8.0-4.8.2: https://gcc.gnu.org/bugzilla/show_bug.cgi?id=58854
  *	      miscompiles find_get_entry(), and can result in EXT3 and EXT4
  *	      filesystem corruption (possibly other FS too).
  */
-#ifdef __GNUC__
-#if (__GNUC__ == 3 && __GNUC_MINOR__ < 3)
-#error Your compiler is too buggy; it is known to miscompile kernels.
-#error    Known good compilers: 3.3, 4.x
-#endif
-#if GCC_VERSION >= 40800 && GCC_VERSION < 40803
+#if defined(GCC_VERSION) && GCC_VERSION >= 40800 && GCC_VERSION < 40803
 #error Your compiler is too buggy; it is known to miscompile kernels
 #error and result in filesystem corruption and oopses.
 #endif
-#endif
 
 int main(void)
 {
* Unmerged path drivers/gpu/drm/i915/i915_utils.h
diff --git a/drivers/watchdog/kempld_wdt.c b/drivers/watchdog/kempld_wdt.c
index 2f3b049ea301..e268add43010 100644
--- a/drivers/watchdog/kempld_wdt.c
+++ b/drivers/watchdog/kempld_wdt.c
@@ -146,12 +146,7 @@ static int kempld_wdt_set_stage_timeout(struct kempld_wdt_data *wdt_data,
 	u32 remainder;
 	u8 stage_cfg;
 
-#if GCC_VERSION < 40400
-	/* work around a bug compiling do_div() */
-	prescaler = READ_ONCE(kempld_prescaler[PRESCALER_21]);
-#else
 	prescaler = kempld_prescaler[PRESCALER_21];
-#endif
 
 	if (!stage)
 		return -EINVAL;
* Unmerged path include/linux/compiler-clang.h
* Unmerged path include/linux/compiler-gcc.h
diff --git a/include/linux/compiler-intel.h b/include/linux/compiler-intel.h
index 547cdc920a3c..4c7f9befa9f6 100644
--- a/include/linux/compiler-intel.h
+++ b/include/linux/compiler-intel.h
@@ -14,10 +14,6 @@
 /* Intel ECC compiler doesn't support gcc specific asm stmts.
  * It uses intrinsics to do the equivalent things.
  */
-#undef barrier
-#undef barrier_data
-#undef RELOC_HIDE
-#undef OPTIMIZER_HIDE_VAR
 
 #define barrier() __memory_barrier()
 #define barrier_data(ptr) barrier()
@@ -38,13 +34,12 @@
 
 #endif
 
-#ifndef __HAVE_BUILTIN_BSWAP16__
 /* icc has this, but it's called _bswap16 */
 #define __HAVE_BUILTIN_BSWAP16__
 #define __builtin_bswap16 _bswap16
-#endif
 
-/*
- * icc defines __GNUC__, but does not implement the builtin overflow checkers.
+/* The following are for compatibility with GCC, from compiler-gcc.h,
+ * and may be redefined here because they should not be shared with other
+ * compilers, like clang.
  */
-#undef COMPILER_HAS_GENERIC_BUILTIN_OVERFLOW
+#define __visible	__attribute__((externally_visible))
* Unmerged path include/linux/compiler_types.h
diff --git a/mm/ksm.c b/mm/ksm.c
index 702cc8599093..6a0bd1fcfb83 100644
--- a/mm/ksm.c
+++ b/mm/ksm.c
@@ -651,9 +651,9 @@ static void remove_node_from_stable_tree(struct stable_node *stable_node)
 	 * list_head to stay clear from the rb_parent_color union
 	 * (aligned and different than any node) and also different
 	 * from &migrate_nodes. This will verify that future list.h changes
-	 * don't break STABLE_NODE_DUP_HEAD.
+	 * don't break STABLE_NODE_DUP_HEAD. Only recent gcc can handle it.
 	 */
-#if GCC_VERSION >= 40903 /* only recent gcc can handle it */
+#if defined(GCC_VERSION) && GCC_VERSION >= 40903
 	BUILD_BUG_ON(STABLE_NODE_DUP_HEAD <= &migrate_nodes);
 	BUILD_BUG_ON(STABLE_NODE_DUP_HEAD >= &migrate_nodes + 1);
 #endif
diff --git a/mm/migrate.c b/mm/migrate.c
index fd5d8ac0bb45..f7498769feab 100644
--- a/mm/migrate.c
+++ b/mm/migrate.c
@@ -1167,7 +1167,8 @@ static int __unmap_and_move(struct page *page, struct page *newpage,
  * gcc 4.7 and 4.8 on arm get an ICEs when inlining unmap_and_move().  Work
  * around it.
  */
-#if (GCC_VERSION >= 40700 && GCC_VERSION < 40900) && defined(CONFIG_ARM)
+#if defined(CONFIG_ARM) && \
+	defined(GCC_VERSION) && GCC_VERSION < 40900 && GCC_VERSION >= 40700
 #define ICE_noinline noinline
 #else
 #define ICE_noinline
