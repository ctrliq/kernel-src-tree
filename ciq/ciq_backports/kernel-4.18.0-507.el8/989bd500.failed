Compiler Attributes: remove unneeded sparse (__CHECKER__) tests

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-507.el8
commit-author Miguel Ojeda <miguel.ojeda.sandonis@gmail.com>
commit 989bd5000f36052df604888ed12bb6ef390786b7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-507.el8/989bd500.failed

Sparse knows about a few more attributes now, so we can remove
the __CHECKER__ conditions from them (which, in turn, allow us
to move some of them later on to compiler_attributes.h).

  * assume_aligned: since sparse's commit ffc860b ("sparse:
    ignore __assume_aligned__ attribute"), included in 0.5.1

  * error: since sparse's commit 0a04210 ("sparse: Add 'error'
    to ignored attributes"), included in 0.5.0

  * hotpatch: since sparse's commit 6043210 ("sparse/parse.c:
    ignore hotpatch attribute"), included in 0.5.1

  * warning: since sparse's commit 977365d ("Avoid "attribute
    'warning': unknown attribute" warning"), included in 0.4.2

On top of that, __must_be_array does not need it either because:

  * Even ancient versions of sparse do not have a problem

  * BUILD_BUG_ON_ZERO() is currently disabled for __CHECKER__

	Tested-by: Sedat Dilek <sedat.dilek@gmail.com> # on top of v4.19-rc5, clang 7
	Reviewed-by: Nick Desaulniers <ndesaulniers@google.com>
	Reviewed-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
	Signed-off-by: Miguel Ojeda <miguel.ojeda.sandonis@gmail.com>
(cherry picked from commit 989bd5000f36052df604888ed12bb6ef390786b7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/compiler-gcc.h
#	include/linux/compiler.h
#	include/linux/compiler_types.h
diff --cc include/linux/compiler-gcc.h
index 86782a1b73c9,1ca6a51cfaa9..000000000000
--- a/include/linux/compiler-gcc.h
+++ b/include/linux/compiler-gcc.h
@@@ -68,134 -68,20 +68,138 @@@
   */
  #define uninitialized_var(x) x = x
  
 +#ifdef __CHECKER__
 +#define __must_be_array(a)	0
 +#else
 +/* &a[0] degrades to a pointer: a different type from an array */
 +#define __must_be_array(a)	BUILD_BUG_ON_ZERO(__same_type((a), &(a)[0]))
 +#endif
 +
 +/*
 + * Feature detection for gnu_inline (gnu89 extern inline semantics). Either
 + * __GNUC_STDC_INLINE__ is defined (not using gnu89 extern inline semantics,
 + * and we opt in to the gnu89 semantics), or __GNUC_STDC_INLINE__ is not
 + * defined so the gnu89 semantics are the default.
 + */
 +#ifdef __GNUC_STDC_INLINE__
 +# define __gnu_inline	__attribute__((gnu_inline))
 +#else
 +# define __gnu_inline
 +#endif
 +
 +/*
 + * Force always-inline if the user requests it so via the .config,
 + * or if gcc is too old.
 + * GCC does not warn about unused static inline functions for
 + * -Wunused-function.  This turns out to avoid the need for complex #ifdef
 + * directives.  Suppress the warning in clang as well by using "unused"
 + * function attribute, which is redundant but not harmful for gcc.
 + * Prefer gnu_inline, so that extern inline functions do not emit an
 + * externally visible function. This makes extern inline behave as per gnu89
 + * semantics rather than c99. This prevents multiple symbol definition errors
 + * of extern inline functions at link time.
 + * A lot of inline functions can cause havoc with function tracing.
 + */
 +#if !defined(CONFIG_ARCH_SUPPORTS_OPTIMIZED_INLINING) ||		\
 +    !defined(CONFIG_OPTIMIZE_INLINING)
 +#define inline \
 +	inline __attribute__((always_inline, unused)) notrace __gnu_inline
 +#else
 +#define inline inline		__attribute__((unused)) notrace __gnu_inline
 +#endif
 +
 +#define __inline__ inline
 +#define __inline inline
 +#define __always_inline	inline __attribute__((always_inline))
 +#define  noinline	__attribute__((noinline))
 +
 +#define __packed	__attribute__((packed))
 +#define __weak		__attribute__((weak))
 +#define __alias(symbol)	__attribute__((alias(#symbol)))
 +
 +/*
 + * Used by functions that use '__builtin_return_address'. These function
 + * don't want to be splited or made inline, which can make
 + * the '__builtin_return_address' get unexpected address.
 + */
 +#define __fix_address noinline __noclone
 +
  #ifdef RETPOLINE
 -#define __noretpoline __attribute__((__indirect_branch__("keep")))
 +#define __noretpoline __attribute__((indirect_branch("keep")))
  #endif
  
 +/*
 + * it doesn't make sense on ARM (currently the only user of __naked)
 + * to trace naked functions because then mcount is called without
 + * stack and frame pointer being set up and there is no chance to
 + * restore the lr register to the value before mcount was called.
 + */
 +#define __naked		__attribute__((naked)) notrace
 +
 +#define __noreturn	__attribute__((noreturn))
 +
 +/*
 + * From the GCC manual:
 + *
 + * Many functions have no effects except the return value and their
 + * return value depends only on the parameters and/or global
 + * variables.  Such a function can be subject to common subexpression
 + * elimination and loop optimization just as an arithmetic operator
 + * would be.
 + * [...]
 + */
 +#define __pure			__attribute__((pure))
 +#define __aligned(x)		__attribute__((aligned(x)))
 +#define __aligned_largest	__attribute__((aligned))
 +#define __printf(a, b)		__attribute__((format(printf, a, b)))
 +#define __scanf(a, b)		__attribute__((format(scanf, a, b)))
 +#define __attribute_const__	__attribute__((__const__))
 +#define __maybe_unused		__attribute__((unused))
 +#define __always_unused		__attribute__((unused))
 +#define __mode(x)               __attribute__((mode(x)))
 +
 +#define __must_check		__attribute__((warn_unused_result))
 +#define __malloc		__attribute__((__malloc__))
 +
 +#define __used			__attribute__((__used__))
 +#define __compiler_offsetof(a, b)					\
 +	__builtin_offsetof(a, b)
 +
 +/* Mark functions as cold. gcc will assume any path leading to a call
 + * to them will be unlikely.  This means a lot of manual unlikely()s
 + * are unnecessary now for any paths leading to the usual suspects
 + * like BUG(), printk(), panic() etc. [but let's keep them for now for
 + * older compilers]
 + *
 + * Early snapshots of gcc 4.3 don't support this and we can't detect this
 + * in the preprocessor, but we can live with this because they're unreleased.
 + * Maketime probing would be overkill here.
 + *
 + * gcc also has a __attribute__((__hot__)) to move hot functions into
 + * a special section, but I don't see any sense in this right now in
 + * the kernel context
 + */
 +#define __cold			__attribute__((__cold__))
 +
  #define __UNIQUE_ID(prefix) __PASTE(__PASTE(__UNIQUE_ID_, prefix), __COUNTER__)
  
 +#define __optimize(level)	__attribute__((__optimize__(level)))
 +#define __nostackprotector	__optimize("no-stack-protector")
 +
  #define __compiletime_object_size(obj) __builtin_object_size(obj, 0)
  
++<<<<<<< HEAD
 +#ifndef __CHECKER__
 +#define __compiletime_warning(message) __attribute__((warning(message)))
 +#define __compiletime_error(message) __attribute__((error(message)))
++=======
+ #define __compiletime_warning(message) __attribute__((__warning__(message)))
+ #define __compiletime_error(message) __attribute__((__error__(message)))
++>>>>>>> 989bd5000f36 (Compiler Attributes: remove unneeded sparse (__CHECKER__) tests)
  
- #ifdef LATENT_ENTROPY_PLUGIN
+ #if defined(LATENT_ENTROPY_PLUGIN) && !defined(__CHECKER__)
  #define __latent_entropy __attribute__((latent_entropy))
  #endif
- #endif /* __CHECKER__ */
  
  /*
   * calling noreturn functions, __builtin_unreachable() and __builtin_trap()
diff --cc include/linux/compiler.h
index 24a0e7ee0618,4030a2940d6b..000000000000
--- a/include/linux/compiler.h
+++ b/include/linux/compiler.h
@@@ -455,4 -357,7 +455,10 @@@ unsigned long read_word_at_a_time(cons
  	compiletime_assert(__native_word(t),				\
  		"Need native word sized stores/loads for atomicity.")
  
++<<<<<<< HEAD
++=======
+ /* &a[0] degrades to a pointer: a different type from an array */
+ #define __must_be_array(a)	BUILD_BUG_ON_ZERO(__same_type((a), &(a)[0]))
+ 
++>>>>>>> 989bd5000f36 (Compiler Attributes: remove unneeded sparse (__CHECKER__) tests)
  #endif /* __LINUX_COMPILER_H */
diff --cc include/linux/compiler_types.h
index 4fb18f107703,a3eceb3ad1b3..000000000000
--- a/include/linux/compiler_types.h
+++ b/include/linux/compiler_types.h
@@@ -292,4 -181,87 +292,90 @@@ struct ftrace_likely_data 
  #define __diag_error(compiler, version, option, comment) \
  	__diag_ ## compiler(version, error, option)
  
++<<<<<<< HEAD
++=======
+ /*
+  * From the GCC manual:
+  *
+  * Many functions have no effects except the return value and their
+  * return value depends only on the parameters and/or global
+  * variables.  Such a function can be subject to common subexpression
+  * elimination and loop optimization just as an arithmetic operator
+  * would be.
+  * [...]
+  */
+ #define __pure			__attribute__((__pure__))
+ #define __attribute_const__	__attribute__((__const__))
+ #define __aligned(x)		__attribute__((__aligned__(x)))
+ #define __aligned_largest	__attribute__((__aligned__))
+ #define __printf(a, b)		__attribute__((__format__(printf, a, b)))
+ #define __scanf(a, b)		__attribute__((__format__(scanf, a, b)))
+ #define __maybe_unused		__attribute__((__unused__))
+ #define __always_unused		__attribute__((__unused__))
+ #define __mode(x)		__attribute__((__mode__(x)))
+ #define __malloc		__attribute__((__malloc__))
+ #define __used			__attribute__((__used__))
+ #define __noreturn		__attribute__((__noreturn__))
+ #define __packed		__attribute__((__packed__))
+ #define __weak			__attribute__((__weak__))
+ #define __alias(symbol)		__attribute__((__alias__(#symbol)))
+ #define __cold			__attribute__((__cold__))
+ #define __section(S)		__attribute__((__section__(#S)))
+ #define __always_inline		inline __attribute__((__always_inline__))
+ #define __gnu_inline		__attribute__((__gnu_inline__))
+ 
+ 
+ #ifdef CONFIG_ENABLE_MUST_CHECK
+ #define __must_check		__attribute__((__warn_unused_result__))
+ #else
+ #define __must_check
+ #endif
+ 
+ #if defined(CC_USING_HOTPATCH)
+ #define notrace			__attribute__((hotpatch(0, 0)))
+ #else
+ #define notrace			__attribute__((__no_instrument_function__))
+ #endif
+ 
+ /*
+  * it doesn't make sense on ARM (currently the only user of __naked)
+  * to trace naked functions because then mcount is called without
+  * stack and frame pointer being set up and there is no chance to
+  * restore the lr register to the value before mcount was called.
+  */
+ #define __naked			__attribute__((__naked__)) notrace
+ 
+ #define __compiler_offsetof(a, b)	__builtin_offsetof(a, b)
+ 
+ /*
+  * Force always-inline if the user requests it so via the .config.
+  * GCC does not warn about unused static inline functions for
+  * -Wunused-function.  This turns out to avoid the need for complex #ifdef
+  * directives.  Suppress the warning in clang as well by using "unused"
+  * function attribute, which is redundant but not harmful for gcc.
+  * Prefer gnu_inline, so that extern inline functions do not emit an
+  * externally visible function. This makes extern inline behave as per gnu89
+  * semantics rather than c99. This prevents multiple symbol definition errors
+  * of extern inline functions at link time.
+  * A lot of inline functions can cause havoc with function tracing.
+  */
+ #if !defined(CONFIG_ARCH_SUPPORTS_OPTIMIZED_INLINING) || \
+ 	!defined(CONFIG_OPTIMIZE_INLINING)
+ #define inline \
+ 	inline __attribute__((__always_inline__, __unused__)) notrace __gnu_inline
+ #else
+ #define inline inline	__attribute__((__unused__)) notrace __gnu_inline
+ #endif
+ 
+ #define __inline__ inline
+ #define __inline inline
+ #define noinline	__attribute__((__noinline__))
+ 
+ /*
+  * Rather then using noinline to prevent stack consumption, use
+  * noinline_for_stack instead.  For documentation reasons.
+  */
+ #define noinline_for_stack noinline
+ 
++>>>>>>> 989bd5000f36 (Compiler Attributes: remove unneeded sparse (__CHECKER__) tests)
  #endif /* __LINUX_COMPILER_TYPES_H */
* Unmerged path include/linux/compiler-gcc.h
* Unmerged path include/linux/compiler.h
* Unmerged path include/linux/compiler_types.h
