ipv4: Fix incorrect route flushing when table ID 0 is used

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-485.el8
commit-author Ido Schimmel <idosch@nvidia.com>
commit c0d999348e01df03e0a7f550351f3907fabbf611
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-485.el8/c0d99934.failed

Cited commit added the table ID to the FIB info structure, but did not
properly initialize it when table ID 0 is used. This can lead to a route
in the default VRF with a preferred source address not being flushed
when the address is deleted.

Consider the following example:

 # ip address add dev dummy1 192.0.2.1/28
 # ip address add dev dummy1 192.0.2.17/28
 # ip route add 198.51.100.0/24 via 192.0.2.2 src 192.0.2.17 metric 100
 # ip route add table 0 198.51.100.0/24 via 192.0.2.2 src 192.0.2.17 metric 200
 # ip route show 198.51.100.0/24
 198.51.100.0/24 via 192.0.2.2 dev dummy1 src 192.0.2.17 metric 100
 198.51.100.0/24 via 192.0.2.2 dev dummy1 src 192.0.2.17 metric 200

Both routes are installed in the default VRF, but they are using two
different FIB info structures. One with a metric of 100 and table ID of
254 (main) and one with a metric of 200 and table ID of 0. Therefore,
when the preferred source address is deleted from the default VRF,
the second route is not flushed:

 # ip address del dev dummy1 192.0.2.17/28
 # ip route show 198.51.100.0/24
 198.51.100.0/24 via 192.0.2.2 dev dummy1 src 192.0.2.17 metric 200

Fix by storing a table ID of 254 instead of 0 in the route configuration
structure.

Add a test case that fails before the fix:

 # ./fib_tests.sh -t ipv4_del_addr

 IPv4 delete address route tests
     Regular FIB info
     TEST: Route removed from VRF when source address deleted            [ OK ]
     TEST: Route in default VRF not removed                              [ OK ]
     TEST: Route removed in default VRF when source address deleted      [ OK ]
     TEST: Route in VRF is not removed by address delete                 [ OK ]
     Identical FIB info with different table ID
     TEST: Route removed from VRF when source address deleted            [ OK ]
     TEST: Route in default VRF not removed                              [ OK ]
     TEST: Route removed in default VRF when source address deleted      [ OK ]
     TEST: Route in VRF is not removed by address delete                 [ OK ]
     Table ID 0
     TEST: Route removed in default VRF when source address deleted      [FAIL]

 Tests passed:   8
 Tests failed:   1

And passes after:

 # ./fib_tests.sh -t ipv4_del_addr

 IPv4 delete address route tests
     Regular FIB info
     TEST: Route removed from VRF when source address deleted            [ OK ]
     TEST: Route in default VRF not removed                              [ OK ]
     TEST: Route removed in default VRF when source address deleted      [ OK ]
     TEST: Route in VRF is not removed by address delete                 [ OK ]
     Identical FIB info with different table ID
     TEST: Route removed from VRF when source address deleted            [ OK ]
     TEST: Route in default VRF not removed                              [ OK ]
     TEST: Route removed in default VRF when source address deleted      [ OK ]
     TEST: Route in VRF is not removed by address delete                 [ OK ]
     Table ID 0
     TEST: Route removed in default VRF when source address deleted      [ OK ]

 Tests passed:   9
 Tests failed:   0

Fixes: 5a56a0b3a45d ("net: Don't delete routes in different VRFs")
	Reported-by: Donald Sharp <sharpd@nvidia.com>
	Signed-off-by: Ido Schimmel <idosch@nvidia.com>
	Reviewed-by: David Ahern <dsahern@kernel.org>
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit c0d999348e01df03e0a7f550351f3907fabbf611)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/fib_frontend.c
#	tools/testing/selftests/net/fib_tests.sh
diff --cc net/ipv4/fib_frontend.c
index 5f77efd41930,b5736ef16ed2..000000000000
--- a/net/ipv4/fib_frontend.c
+++ b/net/ipv4/fib_frontend.c
@@@ -763,6 -823,27 +763,27 @@@ static int rtm_to_fib_config(struct ne
  		}
  	}
  
++<<<<<<< HEAD
++=======
+ 	if (cfg->fc_nh_id) {
+ 		if (cfg->fc_oif || cfg->fc_gw_family ||
+ 		    cfg->fc_encap || cfg->fc_mp) {
+ 			NL_SET_ERR_MSG(extack,
+ 				       "Nexthop specification and nexthop id are mutually exclusive");
+ 			return -EINVAL;
+ 		}
+ 	}
+ 
+ 	if (has_gw && has_via) {
+ 		NL_SET_ERR_MSG(extack,
+ 			       "Nexthop configuration can not contain both GATEWAY and VIA");
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (!cfg->fc_table)
+ 		cfg->fc_table = RT_TABLE_MAIN;
+ 
++>>>>>>> c0d999348e01 (ipv4: Fix incorrect route flushing when table ID 0 is used)
  	return 0;
  errout:
  	return err;
diff --cc tools/testing/selftests/net/fib_tests.sh
index c85734602cdf,5637b5dadabd..000000000000
--- a/tools/testing/selftests/net/fib_tests.sh
+++ b/tools/testing/selftests/net/fib_tests.sh
@@@ -1509,6 -1692,359 +1509,362 @@@ ipv4_route_metrics_test(
  	route_cleanup
  }
  
++<<<<<<< HEAD
++=======
+ ipv4_del_addr_test()
+ {
+ 	echo
+ 	echo "IPv4 delete address route tests"
+ 
+ 	setup
+ 
+ 	set -e
+ 	$IP li add dummy1 type dummy
+ 	$IP li set dummy1 up
+ 	$IP li add dummy2 type dummy
+ 	$IP li set dummy2 up
+ 	$IP li add red type vrf table 1111
+ 	$IP li set red up
+ 	$IP ro add vrf red unreachable default
+ 	$IP li set dummy2 vrf red
+ 
+ 	$IP addr add dev dummy1 172.16.104.1/24
+ 	$IP addr add dev dummy1 172.16.104.11/24
+ 	$IP addr add dev dummy1 172.16.104.12/24
+ 	$IP addr add dev dummy1 172.16.104.13/24
+ 	$IP addr add dev dummy2 172.16.104.1/24
+ 	$IP addr add dev dummy2 172.16.104.11/24
+ 	$IP addr add dev dummy2 172.16.104.12/24
+ 	$IP route add 172.16.105.0/24 via 172.16.104.2 src 172.16.104.11
+ 	$IP route add 172.16.106.0/24 dev lo src 172.16.104.12
+ 	$IP route add table 0 172.16.107.0/24 via 172.16.104.2 src 172.16.104.13
+ 	$IP route add vrf red 172.16.105.0/24 via 172.16.104.2 src 172.16.104.11
+ 	$IP route add vrf red 172.16.106.0/24 dev lo src 172.16.104.12
+ 	set +e
+ 
+ 	# removing address from device in vrf should only remove route from vrf table
+ 	echo "    Regular FIB info"
+ 
+ 	$IP addr del dev dummy2 172.16.104.11/24
+ 	$IP ro ls vrf red | grep -q 172.16.105.0/24
+ 	log_test $? 1 "Route removed from VRF when source address deleted"
+ 
+ 	$IP ro ls | grep -q 172.16.105.0/24
+ 	log_test $? 0 "Route in default VRF not removed"
+ 
+ 	$IP addr add dev dummy2 172.16.104.11/24
+ 	$IP route add vrf red 172.16.105.0/24 via 172.16.104.2 src 172.16.104.11
+ 
+ 	$IP addr del dev dummy1 172.16.104.11/24
+ 	$IP ro ls | grep -q 172.16.105.0/24
+ 	log_test $? 1 "Route removed in default VRF when source address deleted"
+ 
+ 	$IP ro ls vrf red | grep -q 172.16.105.0/24
+ 	log_test $? 0 "Route in VRF is not removed by address delete"
+ 
+ 	# removing address from device in vrf should only remove route from vrf
+ 	# table even when the associated fib info only differs in table ID
+ 	echo "    Identical FIB info with different table ID"
+ 
+ 	$IP addr del dev dummy2 172.16.104.12/24
+ 	$IP ro ls vrf red | grep -q 172.16.106.0/24
+ 	log_test $? 1 "Route removed from VRF when source address deleted"
+ 
+ 	$IP ro ls | grep -q 172.16.106.0/24
+ 	log_test $? 0 "Route in default VRF not removed"
+ 
+ 	$IP addr add dev dummy2 172.16.104.12/24
+ 	$IP route add vrf red 172.16.106.0/24 dev lo src 172.16.104.12
+ 
+ 	$IP addr del dev dummy1 172.16.104.12/24
+ 	$IP ro ls | grep -q 172.16.106.0/24
+ 	log_test $? 1 "Route removed in default VRF when source address deleted"
+ 
+ 	$IP ro ls vrf red | grep -q 172.16.106.0/24
+ 	log_test $? 0 "Route in VRF is not removed by address delete"
+ 
+ 	# removing address from device in default vrf should remove route from
+ 	# the default vrf even when route was inserted with a table ID of 0.
+ 	echo "    Table ID 0"
+ 
+ 	$IP addr del dev dummy1 172.16.104.13/24
+ 	$IP ro ls | grep -q 172.16.107.0/24
+ 	log_test $? 1 "Route removed in default VRF when source address deleted"
+ 
+ 	$IP li del dummy1
+ 	$IP li del dummy2
+ 	cleanup
+ }
+ 
+ 
+ ipv4_route_v6_gw_test()
+ {
+ 	local rc
+ 
+ 	echo
+ 	echo "IPv4 route with IPv6 gateway tests"
+ 
+ 	route_setup
+ 	sleep 2
+ 
+ 	#
+ 	# single path route
+ 	#
+ 	run_cmd "$IP ro add 172.16.104.0/24 via inet6 2001:db8:101::2"
+ 	rc=$?
+ 	log_test $rc 0 "Single path route with IPv6 gateway"
+ 	if [ $rc -eq 0 ]; then
+ 		check_route "172.16.104.0/24 via inet6 2001:db8:101::2 dev veth1"
+ 	fi
+ 
+ 	run_cmd "ip netns exec ns1 ping -w1 -c1 172.16.104.1"
+ 	log_test $rc 0 "Single path route with IPv6 gateway - ping"
+ 
+ 	run_cmd "$IP ro del 172.16.104.0/24 via inet6 2001:db8:101::2"
+ 	rc=$?
+ 	log_test $rc 0 "Single path route delete"
+ 	if [ $rc -eq 0 ]; then
+ 		check_route "172.16.112.0/24"
+ 	fi
+ 
+ 	#
+ 	# multipath - v6 then v4
+ 	#
+ 	run_cmd "$IP ro add 172.16.104.0/24 nexthop via inet6 2001:db8:101::2 dev veth1 nexthop via 172.16.103.2 dev veth3"
+ 	rc=$?
+ 	log_test $rc 0 "Multipath route add - v6 nexthop then v4"
+ 	if [ $rc -eq 0 ]; then
+ 		check_route "172.16.104.0/24 nexthop via inet6 2001:db8:101::2 dev veth1 weight 1 nexthop via 172.16.103.2 dev veth3 weight 1"
+ 	fi
+ 
+ 	run_cmd "$IP ro del 172.16.104.0/24 nexthop via 172.16.103.2 dev veth3 nexthop via inet6 2001:db8:101::2 dev veth1"
+ 	log_test $? 2 "    Multipath route delete - nexthops in wrong order"
+ 
+ 	run_cmd "$IP ro del 172.16.104.0/24 nexthop via inet6 2001:db8:101::2 dev veth1 nexthop via 172.16.103.2 dev veth3"
+ 	log_test $? 0 "    Multipath route delete exact match"
+ 
+ 	#
+ 	# multipath - v4 then v6
+ 	#
+ 	run_cmd "$IP ro add 172.16.104.0/24 nexthop via 172.16.103.2 dev veth3 nexthop via inet6 2001:db8:101::2 dev veth1"
+ 	rc=$?
+ 	log_test $rc 0 "Multipath route add - v4 nexthop then v6"
+ 	if [ $rc -eq 0 ]; then
+ 		check_route "172.16.104.0/24 nexthop via 172.16.103.2 dev veth3 weight 1 nexthop via inet6 2001:db8:101::2 dev veth1 weight 1"
+ 	fi
+ 
+ 	run_cmd "$IP ro del 172.16.104.0/24 nexthop via inet6 2001:db8:101::2 dev veth1 nexthop via 172.16.103.2 dev veth3"
+ 	log_test $? 2 "    Multipath route delete - nexthops in wrong order"
+ 
+ 	run_cmd "$IP ro del 172.16.104.0/24 nexthop via 172.16.103.2 dev veth3 nexthop via inet6 2001:db8:101::2 dev veth1"
+ 	log_test $? 0 "    Multipath route delete exact match"
+ 
+ 	route_cleanup
+ }
+ 
+ socat_check()
+ {
+ 	if [ ! -x "$(command -v socat)" ]; then
+ 		echo "socat command not found. Skipping test"
+ 		return 1
+ 	fi
+ 
+ 	return 0
+ }
+ 
+ iptables_check()
+ {
+ 	iptables -t mangle -L OUTPUT &> /dev/null
+ 	if [ $? -ne 0 ]; then
+ 		echo "iptables configuration not supported. Skipping test"
+ 		return 1
+ 	fi
+ 
+ 	return 0
+ }
+ 
+ ip6tables_check()
+ {
+ 	ip6tables -t mangle -L OUTPUT &> /dev/null
+ 	if [ $? -ne 0 ]; then
+ 		echo "ip6tables configuration not supported. Skipping test"
+ 		return 1
+ 	fi
+ 
+ 	return 0
+ }
+ 
+ ipv4_mangle_test()
+ {
+ 	local rc
+ 
+ 	echo
+ 	echo "IPv4 mangling tests"
+ 
+ 	socat_check || return 1
+ 	iptables_check || return 1
+ 
+ 	route_setup
+ 	sleep 2
+ 
+ 	local tmp_file=$(mktemp)
+ 	ip netns exec ns2 socat UDP4-LISTEN:54321,fork $tmp_file &
+ 
+ 	# Add a FIB rule and a route that will direct our connection to the
+ 	# listening server.
+ 	$IP rule add pref 100 ipproto udp sport 12345 dport 54321 table 123
+ 	$IP route add table 123 172.16.101.0/24 dev veth1
+ 
+ 	# Add an unreachable route to the main table that will block our
+ 	# connection in case the FIB rule is not hit.
+ 	$IP route add unreachable 172.16.101.2/32
+ 
+ 	run_cmd "echo a | $NS_EXEC socat STDIN UDP4:172.16.101.2:54321,sourceport=12345"
+ 	log_test $? 0 "    Connection with correct parameters"
+ 
+ 	run_cmd "echo a | $NS_EXEC socat STDIN UDP4:172.16.101.2:54321,sourceport=11111"
+ 	log_test $? 1 "    Connection with incorrect parameters"
+ 
+ 	# Add a mangling rule and make sure connection is still successful.
+ 	$NS_EXEC iptables -t mangle -A OUTPUT -j MARK --set-mark 1
+ 
+ 	run_cmd "echo a | $NS_EXEC socat STDIN UDP4:172.16.101.2:54321,sourceport=12345"
+ 	log_test $? 0 "    Connection with correct parameters - mangling"
+ 
+ 	# Delete the mangling rule and make sure connection is still
+ 	# successful.
+ 	$NS_EXEC iptables -t mangle -D OUTPUT -j MARK --set-mark 1
+ 
+ 	run_cmd "echo a | $NS_EXEC socat STDIN UDP4:172.16.101.2:54321,sourceport=12345"
+ 	log_test $? 0 "    Connection with correct parameters - no mangling"
+ 
+ 	# Verify connections were indeed successful on server side.
+ 	[[ $(cat $tmp_file | wc -l) -eq 3 ]]
+ 	log_test $? 0 "    Connection check - server side"
+ 
+ 	$IP route del unreachable 172.16.101.2/32
+ 	$IP route del table 123 172.16.101.0/24 dev veth1
+ 	$IP rule del pref 100
+ 
+ 	{ kill %% && wait %%; } 2>/dev/null
+ 	rm $tmp_file
+ 
+ 	route_cleanup
+ }
+ 
+ ipv6_mangle_test()
+ {
+ 	local rc
+ 
+ 	echo
+ 	echo "IPv6 mangling tests"
+ 
+ 	socat_check || return 1
+ 	ip6tables_check || return 1
+ 
+ 	route_setup
+ 	sleep 2
+ 
+ 	local tmp_file=$(mktemp)
+ 	ip netns exec ns2 socat UDP6-LISTEN:54321,fork $tmp_file &
+ 
+ 	# Add a FIB rule and a route that will direct our connection to the
+ 	# listening server.
+ 	$IP -6 rule add pref 100 ipproto udp sport 12345 dport 54321 table 123
+ 	$IP -6 route add table 123 2001:db8:101::/64 dev veth1
+ 
+ 	# Add an unreachable route to the main table that will block our
+ 	# connection in case the FIB rule is not hit.
+ 	$IP -6 route add unreachable 2001:db8:101::2/128
+ 
+ 	run_cmd "echo a | $NS_EXEC socat STDIN UDP6:[2001:db8:101::2]:54321,sourceport=12345"
+ 	log_test $? 0 "    Connection with correct parameters"
+ 
+ 	run_cmd "echo a | $NS_EXEC socat STDIN UDP6:[2001:db8:101::2]:54321,sourceport=11111"
+ 	log_test $? 1 "    Connection with incorrect parameters"
+ 
+ 	# Add a mangling rule and make sure connection is still successful.
+ 	$NS_EXEC ip6tables -t mangle -A OUTPUT -j MARK --set-mark 1
+ 
+ 	run_cmd "echo a | $NS_EXEC socat STDIN UDP6:[2001:db8:101::2]:54321,sourceport=12345"
+ 	log_test $? 0 "    Connection with correct parameters - mangling"
+ 
+ 	# Delete the mangling rule and make sure connection is still
+ 	# successful.
+ 	$NS_EXEC ip6tables -t mangle -D OUTPUT -j MARK --set-mark 1
+ 
+ 	run_cmd "echo a | $NS_EXEC socat STDIN UDP6:[2001:db8:101::2]:54321,sourceport=12345"
+ 	log_test $? 0 "    Connection with correct parameters - no mangling"
+ 
+ 	# Verify connections were indeed successful on server side.
+ 	[[ $(cat $tmp_file | wc -l) -eq 3 ]]
+ 	log_test $? 0 "    Connection check - server side"
+ 
+ 	$IP -6 route del unreachable 2001:db8:101::2/128
+ 	$IP -6 route del table 123 2001:db8:101::/64 dev veth1
+ 	$IP -6 rule del pref 100
+ 
+ 	{ kill %% && wait %%; } 2>/dev/null
+ 	rm $tmp_file
+ 
+ 	route_cleanup
+ }
+ 
+ ip_neigh_get_check()
+ {
+ 	ip neigh help 2>&1 | grep -q 'ip neigh get'
+ 	if [ $? -ne 0 ]; then
+ 		echo "iproute2 command does not support neigh get. Skipping test"
+ 		return 1
+ 	fi
+ 
+ 	return 0
+ }
+ 
+ ipv4_bcast_neigh_test()
+ {
+ 	local rc
+ 
+ 	echo
+ 	echo "IPv4 broadcast neighbour tests"
+ 
+ 	ip_neigh_get_check || return 1
+ 
+ 	setup
+ 
+ 	set -e
+ 	run_cmd "$IP neigh add 192.0.2.111 lladdr 00:11:22:33:44:55 nud perm dev dummy0"
+ 	run_cmd "$IP neigh add 192.0.2.255 lladdr 00:11:22:33:44:55 nud perm dev dummy0"
+ 
+ 	run_cmd "$IP neigh get 192.0.2.111 dev dummy0"
+ 	run_cmd "$IP neigh get 192.0.2.255 dev dummy0"
+ 
+ 	run_cmd "$IP address add 192.0.2.1/24 broadcast 192.0.2.111 dev dummy0"
+ 
+ 	run_cmd "$IP neigh add 203.0.113.111 nud failed dev dummy0"
+ 	run_cmd "$IP neigh add 203.0.113.255 nud failed dev dummy0"
+ 
+ 	run_cmd "$IP neigh get 203.0.113.111 dev dummy0"
+ 	run_cmd "$IP neigh get 203.0.113.255 dev dummy0"
+ 
+ 	run_cmd "$IP address add 203.0.113.1/24 broadcast 203.0.113.111 dev dummy0"
+ 	set +e
+ 
+ 	run_cmd "$IP neigh get 192.0.2.111 dev dummy0"
+ 	log_test $? 0 "Resolved neighbour for broadcast address"
+ 
+ 	run_cmd "$IP neigh get 192.0.2.255 dev dummy0"
+ 	log_test $? 0 "Resolved neighbour for network broadcast address"
+ 
+ 	run_cmd "$IP neigh get 203.0.113.111 dev dummy0"
+ 	log_test $? 2 "Unresolved neighbour for broadcast address"
+ 
+ 	run_cmd "$IP neigh get 203.0.113.255 dev dummy0"
+ 	log_test $? 2 "Unresolved neighbour for network broadcast address"
+ 
+ 	cleanup
+ }
++>>>>>>> c0d999348e01 (ipv4: Fix incorrect route flushing when table ID 0 is used)
  
  ################################################################################
  # usage
* Unmerged path net/ipv4/fib_frontend.c
* Unmerged path tools/testing/selftests/net/fib_tests.sh
