timers: Add shutdown mechanism to the internal functions

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-485.el8
commit-author Thomas Gleixner <tglx@linutronix.de>
commit 0cc04e80458a822300b93f82ed861a513edde194
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-485.el8/0cc04e80.failed

Tearing down timers which have circular dependencies to other
functionality, e.g. workqueues, where the timer can schedule work and work
can arm timers, is not trivial.

In those cases it is desired to shutdown the timer in a way which prevents
rearming of the timer. The mechanism to do so is to set timer->function to
NULL and use this as an indicator for the timer arming functions to ignore
the (re)arm request.

Add a shutdown argument to the relevant internal functions which makes the
actual deactivation code set timer->function to NULL which in turn prevents
rearming of the timer.

Co-developed-by: Steven Rostedt <rostedt@goodmis.org>
	Signed-off-by: Steven Rostedt <rostedt@goodmis.org>
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Tested-by: Guenter Roeck <linux@roeck-us.net>
	Reviewed-by: Jacob Keller <jacob.e.keller@intel.com>
	Reviewed-by: Anna-Maria Behnsen <anna-maria@linutronix.de>
Link: https://lore.kernel.org/all/20220407161745.7d6754b3@gandalf.local.home
Link: https://lore.kernel.org/all/20221110064101.429013735@goodmis.org
Link: https://lore.kernel.org/r/20221123201625.253883224@linutronix.de

(cherry picked from commit 0cc04e80458a822300b93f82ed861a513edde194)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/time/timer.c
diff --cc kernel/time/timer.c
index b0baa8d43497,167e43c9451c..000000000000
--- a/kernel/time/timer.c
+++ b/kernel/time/timer.c
@@@ -1244,20 -1298,21 +1244,31 @@@ out_unlock
  EXPORT_SYMBOL_GPL(add_timer_on);
  
  /**
 - * __timer_delete - Internal function: Deactivate a timer
 + * del_timer - Deactivate a timer.
   * @timer:	The timer to be deactivated
+  * @shutdown:	If true, this indicates that the timer is about to be
+  *		shutdown permanently.
+  *
+  * If @shutdown is true then @timer->function is set to NULL under the
+  * timer base lock which prevents further rearming of the time. In that
+  * case any attempt to rearm @timer after this function returns will be
+  * silently ignored.
   *
 + * The function only deactivates a pending timer, but contrary to
 + * timer_delete_sync() it does not take into account whether the timer's
 + * callback function is concurrently executed on a different CPU or not.
 + * It neither prevents rearming of the timer. If @timer can be rearmed
 + * concurrently then the return value of this function is meaningless.
 + *
   * Return:
   * * %0 - The timer was not pending
   * * %1 - The timer was pending and deactivated
   */
++<<<<<<< HEAD
 +int del_timer(struct timer_list *timer)
++=======
+ static int __timer_delete(struct timer_list *timer, bool shutdown)
++>>>>>>> 0cc04e80458a (timers: Add shutdown mechanism to the internal functions)
  {
  	struct timer_base *base;
  	unsigned long flags;
@@@ -1273,7 -1341,66 +1297,70 @@@
  
  	return ret;
  }
++<<<<<<< HEAD
 +EXPORT_SYMBOL(del_timer);
++=======
+ 
+ /**
+  * timer_delete - Deactivate a timer
+  * @timer:	The timer to be deactivated
+  *
+  * The function only deactivates a pending timer, but contrary to
+  * timer_delete_sync() it does not take into account whether the timer's
+  * callback function is concurrently executed on a different CPU or not.
+  * It neither prevents rearming of the timer.  If @timer can be rearmed
+  * concurrently then the return value of this function is meaningless.
+  *
+  * Return:
+  * * %0 - The timer was not pending
+  * * %1 - The timer was pending and deactivated
+  */
+ int timer_delete(struct timer_list *timer)
+ {
+ 	return __timer_delete(timer, false);
+ }
+ EXPORT_SYMBOL(timer_delete);
+ 
+ /**
+  * __try_to_del_timer_sync - Internal function: Try to deactivate a timer
+  * @timer:	Timer to deactivate
+  * @shutdown:	If true, this indicates that the timer is about to be
+  *		shutdown permanently.
+  *
+  * If @shutdown is true then @timer->function is set to NULL under the
+  * timer base lock which prevents further rearming of the timer. Any
+  * attempt to rearm @timer after this function returns will be silently
+  * ignored.
+  *
+  * This function cannot guarantee that the timer cannot be rearmed
+  * right after dropping the base lock if @shutdown is false. That
+  * needs to be prevented by the calling code if necessary.
+  *
+  * Return:
+  * * %0  - The timer was not pending
+  * * %1  - The timer was pending and deactivated
+  * * %-1 - The timer callback function is running on a different CPU
+  */
+ static int __try_to_del_timer_sync(struct timer_list *timer, bool shutdown)
+ {
+ 	struct timer_base *base;
+ 	unsigned long flags;
+ 	int ret = -1;
+ 
+ 	debug_assert_init(timer);
+ 
+ 	base = lock_timer_base(timer, &flags);
+ 
+ 	if (base->running_timer != timer)
+ 		ret = detach_if_pending(timer, base, true);
+ 	if (shutdown)
+ 		timer->function = NULL;
+ 
+ 	raw_spin_unlock_irqrestore(&base->lock, flags);
+ 
+ 	return ret;
+ }
++>>>>>>> 0cc04e80458a (timers: Add shutdown mechanism to the internal functions)
  
  /**
   * try_to_del_timer_sync - Try to deactivate a timer
@@@ -1293,20 -1420,7 +1380,24 @@@
   */
  int try_to_del_timer_sync(struct timer_list *timer)
  {
++<<<<<<< HEAD
 +	struct timer_base *base;
 +	unsigned long flags;
 +	int ret = -1;
 +
 +	debug_assert_init(timer);
 +
 +	base = lock_timer_base(timer, &flags);
 +
 +	if (base->running_timer != timer)
 +		ret = detach_if_pending(timer, base, true);
 +
 +	raw_spin_unlock_irqrestore(&base->lock, flags);
 +
 +	return ret;
++=======
+ 	return __try_to_del_timer_sync(timer, false);
++>>>>>>> 0cc04e80458a (timers: Add shutdown mechanism to the internal functions)
  }
  EXPORT_SYMBOL(try_to_del_timer_sync);
  
@@@ -1382,6 -1498,69 +1473,72 @@@ static inline void del_timer_wait_runni
  #endif
  
  /**
++<<<<<<< HEAD
++=======
+  * __timer_delete_sync - Internal function: Deactivate a timer and wait
+  *			 for the handler to finish.
+  * @timer:	The timer to be deactivated
+  * @shutdown:	If true, @timer->function will be set to NULL under the
+  *		timer base lock which prevents rearming of @timer
+  *
+  * If @shutdown is not set the timer can be rearmed later. If the timer can
+  * be rearmed concurrently, i.e. after dropping the base lock then the
+  * return value is meaningless.
+  *
+  * If @shutdown is set then @timer->function is set to NULL under timer
+  * base lock which prevents rearming of the timer. Any attempt to rearm
+  * a shutdown timer is silently ignored.
+  *
+  * If the timer should be reused after shutdown it has to be initialized
+  * again.
+  *
+  * Return:
+  * * %0	- The timer was not pending
+  * * %1	- The timer was pending and deactivated
+  */
+ static int __timer_delete_sync(struct timer_list *timer, bool shutdown)
+ {
+ 	int ret;
+ 
+ #ifdef CONFIG_LOCKDEP
+ 	unsigned long flags;
+ 
+ 	/*
+ 	 * If lockdep gives a backtrace here, please reference
+ 	 * the synchronization rules above.
+ 	 */
+ 	local_irq_save(flags);
+ 	lock_map_acquire(&timer->lockdep_map);
+ 	lock_map_release(&timer->lockdep_map);
+ 	local_irq_restore(flags);
+ #endif
+ 	/*
+ 	 * don't use it in hardirq context, because it
+ 	 * could lead to deadlock.
+ 	 */
+ 	WARN_ON(in_hardirq() && !(timer->flags & TIMER_IRQSAFE));
+ 
+ 	/*
+ 	 * Must be able to sleep on PREEMPT_RT because of the slowpath in
+ 	 * del_timer_wait_running().
+ 	 */
+ 	if (IS_ENABLED(CONFIG_PREEMPT_RT) && !(timer->flags & TIMER_IRQSAFE))
+ 		lockdep_assert_preemption_enabled();
+ 
+ 	do {
+ 		ret = __try_to_del_timer_sync(timer, shutdown);
+ 
+ 		if (unlikely(ret < 0)) {
+ 			del_timer_wait_running(timer);
+ 			cpu_relax();
+ 		}
+ 	} while (ret < 0);
+ 
+ 	return ret;
+ }
+ 
+ /**
++>>>>>>> 0cc04e80458a (timers: Add shutdown mechanism to the internal functions)
   * timer_delete_sync - Deactivate a timer and wait for the handler to finish.
   * @timer:	The timer to be deactivated
   *
@@@ -1422,43 -1601,7 +1579,47 @@@
   */
  int timer_delete_sync(struct timer_list *timer)
  {
++<<<<<<< HEAD
 +	int ret;
 +
 +#ifdef CONFIG_LOCKDEP
 +	unsigned long flags;
 +
 +	/*
 +	 * If lockdep gives a backtrace here, please reference
 +	 * the synchronization rules above.
 +	 */
 +	local_irq_save(flags);
 +	lock_map_acquire(&timer->lockdep_map);
 +	lock_map_release(&timer->lockdep_map);
 +	local_irq_restore(flags);
 +#endif
 +	/*
 +	 * don't use it in hardirq context, because it
 +	 * could lead to deadlock.
 +	 */
 +	WARN_ON(in_irq() && !(timer->flags & TIMER_IRQSAFE));
 +
 +	/*
 +	 * Must be able to sleep on PREEMPT_RT because of the slowpath in
 +	 * del_timer_wait_running().
 +	 */
 +	if (IS_ENABLED(CONFIG_PREEMPT_RT) && !(timer->flags & TIMER_IRQSAFE))
 +		lockdep_assert_preemption_enabled();
 +
 +	do {
 +		ret = try_to_del_timer_sync(timer);
 +
 +		if (unlikely(ret < 0)) {
 +			del_timer_wait_running(timer);
 +			cpu_relax();
 +		}
 +	} while (ret < 0);
 +
 +	return ret;
++=======
+ 	return __timer_delete_sync(timer, false);
++>>>>>>> 0cc04e80458a (timers: Add shutdown mechanism to the internal functions)
  }
  EXPORT_SYMBOL(timer_delete_sync);
  
* Unmerged path kernel/time/timer.c
