net: tls: fix possible race condition between do_tls_getsockopt_conf() and do_tls_setsockopt_conf()

jira LE-1907
cve CVE-2023-28466
Rebuild_History Non-Buildable kernel-4.18.0-485.el8
commit-author Hangyu Hua <hbh25y@gmail.com>
commit 49c47cc21b5b7a3d8deb18fc57b0aa2ab1286962
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-485.el8/49c47cc2.failed

ctx->crypto_send.info is not protected by lock_sock in
do_tls_getsockopt_conf(). A race condition between do_tls_getsockopt_conf()
and error paths of do_tls_setsockopt_conf() may lead to a use-after-free
or null-deref.

More discussion:  https://lore.kernel.org/all/Y/ht6gQL+u6fj3dG@hog/

Fixes: 3c4d7559159b ("tls: kernel TLS support")
	Signed-off-by: Hangyu Hua <hbh25y@gmail.com>
Link: https://lore.kernel.org/r/20230228023344.9623-1-hbh25y@gmail.com
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit 49c47cc21b5b7a3d8deb18fc57b0aa2ab1286962)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/tls/tls_main.c
diff --cc net/tls/tls_main.c
index a4ca1bfaadc5,b32c112984dd..000000000000
--- a/net/tls/tls_main.c
+++ b/net/tls/tls_main.c
@@@ -423,6 -438,124 +419,127 @@@ static int do_tls_getsockopt_conf(struc
  			rc = -EFAULT;
  		break;
  	}
++<<<<<<< HEAD
++=======
+ 	case TLS_CIPHER_AES_CCM_128: {
+ 		struct tls12_crypto_info_aes_ccm_128 *aes_ccm_128 =
+ 			container_of(crypto_info,
+ 				struct tls12_crypto_info_aes_ccm_128, info);
+ 
+ 		if (len != sizeof(*aes_ccm_128)) {
+ 			rc = -EINVAL;
+ 			goto out;
+ 		}
+ 		memcpy(aes_ccm_128->iv,
+ 		       cctx->iv + TLS_CIPHER_AES_CCM_128_SALT_SIZE,
+ 		       TLS_CIPHER_AES_CCM_128_IV_SIZE);
+ 		memcpy(aes_ccm_128->rec_seq, cctx->rec_seq,
+ 		       TLS_CIPHER_AES_CCM_128_REC_SEQ_SIZE);
+ 		if (copy_to_user(optval, aes_ccm_128, sizeof(*aes_ccm_128)))
+ 			rc = -EFAULT;
+ 		break;
+ 	}
+ 	case TLS_CIPHER_CHACHA20_POLY1305: {
+ 		struct tls12_crypto_info_chacha20_poly1305 *chacha20_poly1305 =
+ 			container_of(crypto_info,
+ 				struct tls12_crypto_info_chacha20_poly1305,
+ 				info);
+ 
+ 		if (len != sizeof(*chacha20_poly1305)) {
+ 			rc = -EINVAL;
+ 			goto out;
+ 		}
+ 		memcpy(chacha20_poly1305->iv,
+ 		       cctx->iv + TLS_CIPHER_CHACHA20_POLY1305_SALT_SIZE,
+ 		       TLS_CIPHER_CHACHA20_POLY1305_IV_SIZE);
+ 		memcpy(chacha20_poly1305->rec_seq, cctx->rec_seq,
+ 		       TLS_CIPHER_CHACHA20_POLY1305_REC_SEQ_SIZE);
+ 		if (copy_to_user(optval, chacha20_poly1305,
+ 				sizeof(*chacha20_poly1305)))
+ 			rc = -EFAULT;
+ 		break;
+ 	}
+ 	case TLS_CIPHER_SM4_GCM: {
+ 		struct tls12_crypto_info_sm4_gcm *sm4_gcm_info =
+ 			container_of(crypto_info,
+ 				struct tls12_crypto_info_sm4_gcm, info);
+ 
+ 		if (len != sizeof(*sm4_gcm_info)) {
+ 			rc = -EINVAL;
+ 			goto out;
+ 		}
+ 		memcpy(sm4_gcm_info->iv,
+ 		       cctx->iv + TLS_CIPHER_SM4_GCM_SALT_SIZE,
+ 		       TLS_CIPHER_SM4_GCM_IV_SIZE);
+ 		memcpy(sm4_gcm_info->rec_seq, cctx->rec_seq,
+ 		       TLS_CIPHER_SM4_GCM_REC_SEQ_SIZE);
+ 		if (copy_to_user(optval, sm4_gcm_info, sizeof(*sm4_gcm_info)))
+ 			rc = -EFAULT;
+ 		break;
+ 	}
+ 	case TLS_CIPHER_SM4_CCM: {
+ 		struct tls12_crypto_info_sm4_ccm *sm4_ccm_info =
+ 			container_of(crypto_info,
+ 				struct tls12_crypto_info_sm4_ccm, info);
+ 
+ 		if (len != sizeof(*sm4_ccm_info)) {
+ 			rc = -EINVAL;
+ 			goto out;
+ 		}
+ 		memcpy(sm4_ccm_info->iv,
+ 		       cctx->iv + TLS_CIPHER_SM4_CCM_SALT_SIZE,
+ 		       TLS_CIPHER_SM4_CCM_IV_SIZE);
+ 		memcpy(sm4_ccm_info->rec_seq, cctx->rec_seq,
+ 		       TLS_CIPHER_SM4_CCM_REC_SEQ_SIZE);
+ 		if (copy_to_user(optval, sm4_ccm_info, sizeof(*sm4_ccm_info)))
+ 			rc = -EFAULT;
+ 		break;
+ 	}
+ 	case TLS_CIPHER_ARIA_GCM_128: {
+ 		struct tls12_crypto_info_aria_gcm_128 *
+ 		  crypto_info_aria_gcm_128 =
+ 		  container_of(crypto_info,
+ 			       struct tls12_crypto_info_aria_gcm_128,
+ 			       info);
+ 
+ 		if (len != sizeof(*crypto_info_aria_gcm_128)) {
+ 			rc = -EINVAL;
+ 			goto out;
+ 		}
+ 		memcpy(crypto_info_aria_gcm_128->iv,
+ 		       cctx->iv + TLS_CIPHER_ARIA_GCM_128_SALT_SIZE,
+ 		       TLS_CIPHER_ARIA_GCM_128_IV_SIZE);
+ 		memcpy(crypto_info_aria_gcm_128->rec_seq, cctx->rec_seq,
+ 		       TLS_CIPHER_ARIA_GCM_128_REC_SEQ_SIZE);
+ 		if (copy_to_user(optval,
+ 				 crypto_info_aria_gcm_128,
+ 				 sizeof(*crypto_info_aria_gcm_128)))
+ 			rc = -EFAULT;
+ 		break;
+ 	}
+ 	case TLS_CIPHER_ARIA_GCM_256: {
+ 		struct tls12_crypto_info_aria_gcm_256 *
+ 		  crypto_info_aria_gcm_256 =
+ 		  container_of(crypto_info,
+ 			       struct tls12_crypto_info_aria_gcm_256,
+ 			       info);
+ 
+ 		if (len != sizeof(*crypto_info_aria_gcm_256)) {
+ 			rc = -EINVAL;
+ 			goto out;
+ 		}
+ 		memcpy(crypto_info_aria_gcm_256->iv,
+ 		       cctx->iv + TLS_CIPHER_ARIA_GCM_256_SALT_SIZE,
+ 		       TLS_CIPHER_ARIA_GCM_256_IV_SIZE);
+ 		memcpy(crypto_info_aria_gcm_256->rec_seq, cctx->rec_seq,
+ 		       TLS_CIPHER_ARIA_GCM_256_REC_SEQ_SIZE);
+ 		if (copy_to_user(optval,
+ 				 crypto_info_aria_gcm_256,
+ 				 sizeof(*crypto_info_aria_gcm_256)))
+ 			rc = -EFAULT;
+ 		break;
+ 	}
++>>>>>>> 49c47cc21b5b (net: tls: fix possible race condition between do_tls_getsockopt_conf() and do_tls_setsockopt_conf())
  	default:
  		rc = -EINVAL;
  	}
@@@ -431,6 -564,54 +548,57 @@@ out
  	return rc;
  }
  
++<<<<<<< HEAD
++=======
+ static int do_tls_getsockopt_tx_zc(struct sock *sk, char __user *optval,
+ 				   int __user *optlen)
+ {
+ 	struct tls_context *ctx = tls_get_ctx(sk);
+ 	unsigned int value;
+ 	int len;
+ 
+ 	if (get_user(len, optlen))
+ 		return -EFAULT;
+ 
+ 	if (len != sizeof(value))
+ 		return -EINVAL;
+ 
+ 	value = ctx->zerocopy_sendfile;
+ 	if (copy_to_user(optval, &value, sizeof(value)))
+ 		return -EFAULT;
+ 
+ 	return 0;
+ }
+ 
+ static int do_tls_getsockopt_no_pad(struct sock *sk, char __user *optval,
+ 				    int __user *optlen)
+ {
+ 	struct tls_context *ctx = tls_get_ctx(sk);
+ 	int value, len;
+ 
+ 	if (ctx->prot_info.version != TLS_1_3_VERSION)
+ 		return -EINVAL;
+ 
+ 	if (get_user(len, optlen))
+ 		return -EFAULT;
+ 	if (len < sizeof(value))
+ 		return -EINVAL;
+ 
+ 	value = -EINVAL;
+ 	if (ctx->rx_conf == TLS_SW || ctx->rx_conf == TLS_HW)
+ 		value = ctx->rx_no_pad;
+ 	if (value < 0)
+ 		return value;
+ 
+ 	if (put_user(sizeof(value), optlen))
+ 		return -EFAULT;
+ 	if (copy_to_user(optval, &value, sizeof(value)))
+ 		return -EFAULT;
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> 49c47cc21b5b (net: tls: fix possible race condition between do_tls_getsockopt_conf() and do_tls_setsockopt_conf())
  static int do_tls_getsockopt(struct sock *sk, int optname,
  			     char __user *optval, int __user *optlen)
  {
* Unmerged path net/tls/tls_main.c
