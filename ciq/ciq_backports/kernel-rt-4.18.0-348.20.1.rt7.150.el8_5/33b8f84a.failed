mm/hugetlb: change hugetlb_reserve_pages() to type bool

jira NONE_AUTOMATION
Rebuild_History Non-Buildable kernel-rt-4.18.0-348.20.1.rt7.150.el8_5
commit-author Mike Kravetz <mike.kravetz@oracle.com>
commit 33b8f84a4ee78491a8f4f9e4c5520c9da4a10983
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-rt-4.18.0-348.20.1.rt7.150.el8_5/33b8f84a.failed

While reviewing a bug in hugetlb_reserve_pages, it was noticed that all
callers ignore the return value.  Any failure is considered an ENOMEM
error by the callers.

Change the function to be of type bool.  The function will return true if
the reservation was successful, false otherwise.  Callers currently assume
a zero return code indicates success.  Change the callers to look for true
to indicate success.  No functional change, only code cleanup.

Link: https://lkml.kernel.org/r/20201221192542.15732-1-mike.kravetz@oracle.com
	Signed-off-by: Mike Kravetz <mike.kravetz@oracle.com>
	Reviewed-by: Matthew Wilcox (Oracle) <willy@infradead.org>
	Cc: David Hildenbrand <david@redhat.com>
	Cc: Dan Carpenter <dan.carpenter@oracle.com>
	Cc: Michal Hocko <mhocko@kernel.org>
	Cc: Davidlohr Bueso <dave@stgolabs.net>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 33b8f84a4ee78491a8f4f9e4c5520c9da4a10983)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/hugetlbfs/inode.c
diff --cc fs/hugetlbfs/inode.c
index 678236745579,3eca85a4d940..000000000000
--- a/fs/hugetlbfs/inode.c
+++ b/fs/hugetlbfs/inode.c
@@@ -1416,27 -1490,21 +1416,34 @@@ struct file *hugetlb_file_setup(const c
  	if (creat_flags == HUGETLB_SHMFS_INODE)
  		inode->i_flags |= S_PRIVATE;
  
++<<<<<<< HEAD
 +	file = ERR_PTR(-ENOMEM);
 +	if (hugetlb_reserve_pages(inode, 0,
++=======
+ 	inode->i_size = size;
+ 	clear_nlink(inode);
+ 
+ 	if (!hugetlb_reserve_pages(inode, 0,
++>>>>>>> 33b8f84a4ee7 (mm/hugetlb: change hugetlb_reserve_pages() to type bool)
  			size >> huge_page_shift(hstate_inode(inode)), NULL,
  			acctflag))
 -		file = ERR_PTR(-ENOMEM);
 -	else
 -		file = alloc_file_pseudo(inode, mnt, name, O_RDWR,
 -					&hugetlbfs_file_operations);
 -	if (!IS_ERR(file))
 -		return file;
 +		goto out_inode;
 +
 +	d_instantiate(path.dentry, inode);
 +	inode->i_size = size;
 +	clear_nlink(inode);
  
 +	file = alloc_file(&path, O_RDWR, &hugetlbfs_file_operations);
 +	if (IS_ERR(file))
 +		goto out_dentry; /* inode is already attached */
 +
 +	return file;
 +
 +out_inode:
  	iput(inode);
 -out:
 +out_dentry:
 +	path_put(&path);
 +out_shm_unlock:
  	if (*user) {
  		user_shm_unlock(size, *user);
  		*user = NULL;
* Unmerged path fs/hugetlbfs/inode.c
diff --git a/include/linux/hugetlb.h b/include/linux/hugetlb.h
index 4c1be68ecd05..37befc173d54 100644
--- a/include/linux/hugetlb.h
+++ b/include/linux/hugetlb.h
@@ -140,7 +140,7 @@ int hugetlb_mcopy_atomic_pte(struct mm_struct *dst_mm, pte_t *dst_pte,
 				unsigned long dst_addr,
 				unsigned long src_addr,
 				struct page **pagep);
-int hugetlb_reserve_pages(struct inode *inode, long from, long to,
+bool hugetlb_reserve_pages(struct inode *inode, long from, long to,
 						struct vm_area_struct *vma,
 						vm_flags_t vm_flags);
 long hugetlb_unreserve_pages(struct inode *inode, long start, long end,
diff --git a/mm/hugetlb.c b/mm/hugetlb.c
index 9d3da614a436..4e1cb7f4c4c6 100644
--- a/mm/hugetlb.c
+++ b/mm/hugetlb.c
@@ -5063,12 +5063,13 @@ unsigned long hugetlb_change_protection(struct vm_area_struct *vma,
 	return pages << h->order;
 }
 
-int hugetlb_reserve_pages(struct inode *inode,
+/* Return true if reservation was successful, false otherwise.  */
+bool hugetlb_reserve_pages(struct inode *inode,
 					long from, long to,
 					struct vm_area_struct *vma,
 					vm_flags_t vm_flags)
 {
-	long ret, chg, add = -1;
+	long chg, add = -1;
 	struct hstate *h = hstate_inode(inode);
 	struct hugepage_subpool *spool = subpool_inode(inode);
 	struct resv_map *resv_map;
@@ -5078,7 +5079,7 @@ int hugetlb_reserve_pages(struct inode *inode,
 	/* This should never happen */
 	if (from > to) {
 		VM_WARN(1, "%s called with a negative range\n", __func__);
-		return -EINVAL;
+		return false;
 	}
 
 	/*
@@ -5087,7 +5088,7 @@ int hugetlb_reserve_pages(struct inode *inode,
 	 * without using reserves
 	 */
 	if (vm_flags & VM_NORESERVE)
-		return 0;
+		return true;
 
 	/*
 	 * Shared mappings base their reservation on the number of pages that
@@ -5109,7 +5110,7 @@ int hugetlb_reserve_pages(struct inode *inode,
 		/* Private mapping. */
 		resv_map = resv_map_alloc();
 		if (!resv_map)
-			return -ENOMEM;
+			return false;
 
 		chg = to - from;
 
@@ -5117,18 +5118,12 @@ int hugetlb_reserve_pages(struct inode *inode,
 		set_vma_resv_flags(vma, HPAGE_RESV_OWNER);
 	}
 
-	if (chg < 0) {
-		ret = chg;
+	if (chg < 0)
 		goto out_err;
-	}
-
-	ret = hugetlb_cgroup_charge_cgroup_rsvd(
-		hstate_index(h), chg * pages_per_huge_page(h), &h_cg);
 
-	if (ret < 0) {
-		ret = -ENOMEM;
+	if (hugetlb_cgroup_charge_cgroup_rsvd(hstate_index(h),
+				chg * pages_per_huge_page(h), &h_cg) < 0)
 		goto out_err;
-	}
 
 	if (vma && !(vma->vm_flags & VM_MAYSHARE) && h_cg) {
 		/* For private mappings, the hugetlb_cgroup uncharge info hangs
@@ -5143,19 +5138,15 @@ int hugetlb_reserve_pages(struct inode *inode,
 	 * reservations already in place (gbl_reserve).
 	 */
 	gbl_reserve = hugepage_subpool_get_pages(spool, chg);
-	if (gbl_reserve < 0) {
-		ret = -ENOSPC;
+	if (gbl_reserve < 0)
 		goto out_uncharge_cgroup;
-	}
 
 	/*
 	 * Check enough hugepages are available for the reservation.
 	 * Hand the pages back to the subpool if there are not
 	 */
-	ret = hugetlb_acct_memory(h, gbl_reserve);
-	if (ret < 0) {
+	if (hugetlb_acct_memory(h, gbl_reserve) < 0)
 		goto out_put_pages;
-	}
 
 	/*
 	 * Account for the reservations made. Shared mappings record regions
@@ -5173,7 +5164,6 @@ int hugetlb_reserve_pages(struct inode *inode,
 
 		if (unlikely(add < 0)) {
 			hugetlb_acct_memory(h, -gbl_reserve);
-			ret = add;
 			goto out_put_pages;
 		} else if (unlikely(chg > add)) {
 			/*
@@ -5194,7 +5184,8 @@ int hugetlb_reserve_pages(struct inode *inode,
 			hugetlb_acct_memory(h, -rsv_adjust);
 		}
 	}
-	return 0;
+	return true;
+
 out_put_pages:
 	/* put back original number of pages, chg */
 	(void)hugepage_subpool_put_pages(spool, chg);
@@ -5210,7 +5201,7 @@ int hugetlb_reserve_pages(struct inode *inode,
 			region_abort(resv_map, from, to, regions_needed);
 	if (vma && is_vma_resv_set(vma, HPAGE_RESV_OWNER))
 		kref_put(&resv_map->refs, resv_map_release);
-	return ret;
+	return false;
 }
 
 long hugetlb_unreserve_pages(struct inode *inode, long start, long end,
