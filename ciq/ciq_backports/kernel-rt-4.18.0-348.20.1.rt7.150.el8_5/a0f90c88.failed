drm/vmwgfx: Fix stale file descriptors on failed usercopy

jira NONE_AUTOMATION
cve CVE-2022-22942
Rebuild_History Non-Buildable kernel-rt-4.18.0-348.20.1.rt7.150.el8_5
commit-author Mathias Krause <minipli@grsecurity.net>
commit a0f90c8815706981c483a652a6aefca51a5e191c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-rt-4.18.0-348.20.1.rt7.150.el8_5/a0f90c88.failed

A failing usercopy of the fence_rep object will lead to a stale entry in
the file descriptor table as put_unused_fd() won't release it. This
enables userland to refer to a dangling 'file' object through that still
valid file descriptor, leading to all kinds of use-after-free
exploitation scenarios.

Fix this by deferring the call to fd_install() until after the usercopy
has succeeded.

Fixes: c906965dee22 ("drm/vmwgfx: Add export fence to file descriptor support")
	Signed-off-by: Mathias Krause <minipli@grsecurity.net>
	Signed-off-by: Zack Rusin <zackr@vmware.com>
	Signed-off-by: Dave Airlie <airlied@redhat.com>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit a0f90c8815706981c483a652a6aefca51a5e191c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c
diff --cc drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c
index 462f17320708,dd2ff441068e..000000000000
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c
@@@ -3842,16 -3917,7 +3842,20 @@@ vmw_execbuf_copy_fence_user(struct vmw_
  	 * handle.
  	 */
  	if (unlikely(ret != 0) && (fence_rep.error == 0)) {
++<<<<<<< HEAD
 +		if (sync_file)
 +			fput(sync_file->file);
 +
 +		if (fence_rep.fd != -1) {
 +			put_unused_fd(fence_rep.fd);
 +			fence_rep.fd = -1;
 +		}
 +
 +		ttm_ref_object_base_unref(vmw_fp->tfile, fence_handle,
 +					  TTM_REF_USAGE);
++=======
+ 		ttm_ref_object_base_unref(vmw_fp->tfile, fence_handle);
++>>>>>>> a0f90c881570 (drm/vmwgfx: Fix stale file descriptors on failed usercopy)
  		VMW_DEBUG_USER("Fence copy error. Syncing.\n");
  		(void) vmw_fence_obj_wait(fence, false, false,
  					  VMW_FENCE_WAIT_TIMEOUT);
diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h b/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h
index eb76a6b9ebca..2f4f39446240 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h
@@ -1069,15 +1069,14 @@ extern int vmw_execbuf_fence_commands(struct drm_file *file_priv,
 				      struct vmw_private *dev_priv,
 				      struct vmw_fence_obj **p_fence,
 				      uint32_t *p_handle);
-extern void vmw_execbuf_copy_fence_user(struct vmw_private *dev_priv,
+extern int vmw_execbuf_copy_fence_user(struct vmw_private *dev_priv,
 					struct vmw_fpriv *vmw_fp,
 					int ret,
 					struct drm_vmw_fence_rep __user
 					*user_fence_rep,
 					struct vmw_fence_obj *fence,
 					uint32_t fence_handle,
-					int32_t out_fence_fd,
-					struct sync_file *sync_file);
+					int32_t out_fence_fd);
 bool vmw_cmd_describe(const void *buf, u32 *size, char const **cmd);
 
 /**
* Unmerged path drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c
diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c b/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c
index 378ec7600154..23cf8a264f3d 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c
@@ -1167,7 +1167,7 @@ int vmw_fence_event_ioctl(struct drm_device *dev, void *data,
 	}
 
 	vmw_execbuf_copy_fence_user(dev_priv, vmw_fp, 0, user_fence_rep, fence,
-				    handle, -1, NULL);
+				    handle, -1);
 	vmw_fence_obj_unreference(&fence);
 	return 0;
 out_no_create:
diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c
index 9a89f658e501..bb0448044ced 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c
@@ -2477,7 +2477,7 @@ void vmw_kms_helper_validation_finish(struct vmw_private *dev_priv,
 	if (file_priv)
 		vmw_execbuf_copy_fence_user(dev_priv, vmw_fpriv(file_priv),
 					    ret, user_fence_rep, fence,
-					    handle, -1, NULL);
+					    handle, -1);
 	if (out_fence)
 		*out_fence = fence;
 	else
