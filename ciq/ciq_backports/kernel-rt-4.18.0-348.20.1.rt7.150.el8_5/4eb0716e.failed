hugetlb: allow to free gigantic pages regardless of the configuration

jira NONE_AUTOMATION
Rebuild_History Non-Buildable kernel-rt-4.18.0-348.20.1.rt7.150.el8_5
commit-author Alexandre Ghiti <alex@ghiti.fr>
commit 4eb0716e868eed963967adb0b1b11d9bd8ca1d01
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-rt-4.18.0-348.20.1.rt7.150.el8_5/4eb0716e.failed

On systems without CONTIG_ALLOC activated but that support gigantic pages,
boottime reserved gigantic pages can not be freed at all.  This patch
simply enables the possibility to hand back those pages to memory
allocator.

Link: http://lkml.kernel.org/r/20190327063626.18421-5-alex@ghiti.fr
	Signed-off-by: Alexandre Ghiti <alex@ghiti.fr>
	Acked-by: David S. Miller <davem@davemloft.net> [sparc]
	Reviewed-by: Mike Kravetz <mike.kravetz@oracle.com>
	Cc: Andy Lutomirsky <luto@kernel.org>
	Cc: Aneesh Kumar K.V <aneesh.kumar@linux.ibm.com>
	Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
	Cc: Borislav Petkov <bp@alien8.de>
	Cc: Catalin Marinas <catalin.marinas@arm.com>
	Cc: Dave Hansen <dave.hansen@linux.intel.com>
	Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
	Cc: "H . Peter Anvin" <hpa@zytor.com>
	Cc: Ingo Molnar <mingo@redhat.com>
	Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
	Cc: Michael Ellerman <mpe@ellerman.id.au>
	Cc: Paul Mackerras <paulus@samba.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Rich Felker <dalias@libc.org>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: Vlastimil Babka <vbabka@suse.cz>
	Cc: Will Deacon <will.deacon@arm.com>
	Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 4eb0716e868eed963967adb0b1b11d9bd8ca1d01)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/platforms/Kconfig.cputype
#	arch/sh/Kconfig
#	arch/sparc/Kconfig
#	mm/hugetlb.c
diff --cc arch/powerpc/platforms/Kconfig.cputype
index 4fee4a32154e,2794235e9d3e..000000000000
--- a/arch/powerpc/platforms/Kconfig.cputype
+++ b/arch/powerpc/platforms/Kconfig.cputype
@@@ -299,8 -330,10 +299,15 @@@ config ARCH_ENABLE_SPLIT_PMD_PTLOC
  
  config PPC_RADIX_MMU
  	bool "Radix MMU Support"
++<<<<<<< HEAD
 +	depends on PPC_BOOK3S_64
 +	select ARCH_HAS_GIGANTIC_PAGE if CONTIG_ALLOC
++=======
+ 	depends on PPC_BOOK3S_64 && HUGETLB_PAGE
+ 	select ARCH_HAS_GIGANTIC_PAGE
+ 	select PPC_HAVE_KUEP
+ 	select PPC_HAVE_KUAP
++>>>>>>> 4eb0716e868e (hugetlb: allow to free gigantic pages regardless of the configuration)
  	default y
  	help
  	  Enable support for the Power ISA 3.0 Radix style MMU. Currently this
diff --cc arch/sh/Kconfig
index 8f08bac975d4,2a77033e1e7c..000000000000
--- a/arch/sh/Kconfig
+++ b/arch/sh/Kconfig
@@@ -49,8 -51,9 +49,12 @@@ config SUPER
  	select HAVE_ARCH_AUDITSYSCALL
  	select HAVE_FUTEX_CMPXCHG if FUTEX
  	select HAVE_NMI
 +	select NEED_DMA_MAP_STATE
  	select NEED_SG_DMA_LENGTH
++<<<<<<< HEAD
++=======
+ 	select ARCH_HAS_GIGANTIC_PAGE
++>>>>>>> 4eb0716e868e (hugetlb: allow to free gigantic pages regardless of the configuration)
  
  	help
  	  The SuperH is a RISC processor targeted for use in embedded systems
diff --cc arch/sparc/Kconfig
index 12d490d796fe,7c93f3121ee6..000000000000
--- a/arch/sparc/Kconfig
+++ b/arch/sparc/Kconfig
@@@ -87,6 -91,8 +87,11 @@@ config SPARC6
  	select GENERIC_TIME_VSYSCALL
  	select ARCH_CLOCKSOURCE_DATA
  	select ARCH_HAS_PTE_SPECIAL
++<<<<<<< HEAD
++=======
+ 	select PCI_DOMAINS if PCI
+ 	select ARCH_HAS_GIGANTIC_PAGE
++>>>>>>> 4eb0716e868e (hugetlb: allow to free gigantic pages regardless of the configuration)
  
  config ARCH_DEFCONFIG
  	string
diff --cc mm/hugetlb.c
index f0e3d20fabc2,2f901a6e13d2..000000000000
--- a/mm/hugetlb.c
+++ b/mm/hugetlb.c
@@@ -1167,9 -1166,8 +1177,9 @@@ static inline void destroy_compound_gig
  static void update_and_free_page(struct hstate *h, struct page *page)
  {
  	int i;
 +	struct page *subpage = page;
  
- 	if (hstate_is_gigantic(h) && !gigantic_page_supported())
+ 	if (hstate_is_gigantic(h) && !gigantic_page_runtime_supported())
  		return;
  
  	h->nr_huge_pages--;
@@@ -2394,25 -2288,26 +2404,43 @@@ found
  }
  
  #define persistent_huge_pages(h) (h->nr_huge_pages - h->surplus_huge_pages)
- static unsigned long set_max_huge_pages(struct hstate *h, unsigned long count,
- 						nodemask_t *nodes_allowed)
+ static int set_max_huge_pages(struct hstate *h, unsigned long count,
+ 			      nodemask_t *nodes_allowed)
  {
  	unsigned long min_count, ret;
 +	NODEMASK_ALLOC(nodemask_t, node_alloc_noretry, GFP_KERNEL);
  
++<<<<<<< HEAD
 +	/*
 +	 * Bit mask controlling how hard we retry per-node allocations.
 +	 * If we can not allocate the bit mask, do not attempt to allocate
 +	 * the requested huge pages.
 +	 */
 +	if (node_alloc_noretry)
 +		nodes_clear(*node_alloc_noretry);
 +	else
 +		return -ENOMEM;
 +
 +	if (hstate_is_gigantic(h) && !gigantic_page_supported()) {
 +		NODEMASK_FREE(node_alloc_noretry);
 +		return h->max_huge_pages;
++=======
+ 	spin_lock(&hugetlb_lock);
+ 
+ 	/*
+ 	 * Gigantic pages runtime allocation depend on the capability for large
+ 	 * page range allocation.
+ 	 * If the system does not provide this feature, return an error when
+ 	 * the user tries to allocate gigantic pages but let the user free the
+ 	 * boottime allocated gigantic pages.
+ 	 */
+ 	if (hstate_is_gigantic(h) && !IS_ENABLED(CONFIG_CONTIG_ALLOC)) {
+ 		if (count > persistent_huge_pages(h)) {
+ 			spin_unlock(&hugetlb_lock);
+ 			return -EINVAL;
+ 		}
+ 		/* Fall through to decrease pool */
++>>>>>>> 4eb0716e868e (hugetlb: allow to free gigantic pages regardless of the configuration)
  	}
  
  	/*
@@@ -2482,10 -2375,10 +2509,15 @@@
  			break;
  	}
  out:
- 	ret = persistent_huge_pages(h);
+ 	h->max_huge_pages = persistent_huge_pages(h);
  	spin_unlock(&hugetlb_lock);
++<<<<<<< HEAD
 +	NODEMASK_FREE(node_alloc_noretry);
 +	return ret;
++=======
+ 
+ 	return 0;
++>>>>>>> 4eb0716e868e (hugetlb: allow to free gigantic pages regardless of the configuration)
  }
  
  #define HSTATE_ATTR_RO(_name) \
diff --git a/arch/arm64/Kconfig b/arch/arm64/Kconfig
index 6104a392b6b7..90be2b7fc306 100644
--- a/arch/arm64/Kconfig
+++ b/arch/arm64/Kconfig
@@ -16,7 +16,7 @@ config ARM64
 	select ARCH_HAS_FAST_MULTIPLIER
 	select ARCH_HAS_FORTIFY_SOURCE
 	select ARCH_HAS_GCOV_PROFILE_ALL
-	select ARCH_HAS_GIGANTIC_PAGE if CONTIG_ALLOC
+	select ARCH_HAS_GIGANTIC_PAGE
 	select ARCH_HAS_KCOV
 	select ARCH_HAS_MEMBARRIER_SYNC_CORE
 	select ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE
diff --git a/arch/arm64/include/asm/hugetlb.h b/arch/arm64/include/asm/hugetlb.h
index 4bb999633abc..8c03567d7b81 100644
--- a/arch/arm64/include/asm/hugetlb.h
+++ b/arch/arm64/include/asm/hugetlb.h
@@ -85,8 +85,4 @@ extern void set_huge_swap_pte_at(struct mm_struct *mm, unsigned long addr,
 
 #include <asm-generic/hugetlb.h>
 
-#ifdef CONFIG_ARCH_HAS_GIGANTIC_PAGE
-static inline bool gigantic_page_supported(void) { return true; }
-#endif
-
 #endif /* __ASM_HUGETLB_H */
diff --git a/arch/powerpc/include/asm/book3s/64/hugetlb.h b/arch/powerpc/include/asm/book3s/64/hugetlb.h
index 02544939ef0b..a3e4eeb8edb1 100644
--- a/arch/powerpc/include/asm/book3s/64/hugetlb.h
+++ b/arch/powerpc/include/asm/book3s/64/hugetlb.h
@@ -32,8 +32,8 @@ static inline int hstate_get_psize(struct hstate *hstate)
 	}
 }
 
-#ifdef CONFIG_ARCH_HAS_GIGANTIC_PAGE
-static inline bool gigantic_page_supported(void)
+#define __HAVE_ARCH_GIGANTIC_PAGE_RUNTIME_SUPPORTED
+static inline bool gigantic_page_runtime_supported(void)
 {
 	/*
 	 * We used gigantic page reservation with hypervisor assist in some case.
@@ -45,6 +45,5 @@ static inline bool gigantic_page_supported(void)
 
 	return true;
 }
-#endif
 
 #endif
* Unmerged path arch/powerpc/platforms/Kconfig.cputype
diff --git a/arch/s390/Kconfig b/arch/s390/Kconfig
index 68206b69cbe4..5b02c2d0cfbf 100644
--- a/arch/s390/Kconfig
+++ b/arch/s390/Kconfig
@@ -60,7 +60,7 @@ config S390
 	select ARCH_HAS_ELF_RANDOMIZE
 	select ARCH_HAS_FORTIFY_SOURCE
 	select ARCH_HAS_GCOV_PROFILE_ALL
-	select ARCH_HAS_GIGANTIC_PAGE if CONTIG_ALLOC
+	select ARCH_HAS_GIGANTIC_PAGE
 	select ARCH_HAS_KCOV
 	select ARCH_HAS_MEM_ENCRYPT
 	select ARCH_HAS_PTE_SPECIAL
diff --git a/arch/s390/include/asm/hugetlb.h b/arch/s390/include/asm/hugetlb.h
index 2d1afa58a4b6..bb59dd964590 100644
--- a/arch/s390/include/asm/hugetlb.h
+++ b/arch/s390/include/asm/hugetlb.h
@@ -116,7 +116,9 @@ static inline pte_t huge_pte_modify(pte_t pte, pgprot_t newprot)
 	return pte_modify(pte, newprot);
 }
 
-#ifdef CONFIG_ARCH_HAS_GIGANTIC_PAGE
-static inline bool gigantic_page_supported(void) { return true; }
-#endif
+static inline bool gigantic_page_runtime_supported(void)
+{
+	return true;
+}
+
 #endif /* _ASM_S390_HUGETLB_H */
* Unmerged path arch/sh/Kconfig
* Unmerged path arch/sparc/Kconfig
diff --git a/arch/x86/Kconfig b/arch/x86/Kconfig
index 7bb357cc30d0..5e7a766911fc 100644
--- a/arch/x86/Kconfig
+++ b/arch/x86/Kconfig
@@ -25,7 +25,7 @@ config X86_64
 	def_bool y
 	depends on 64BIT
 	# Options that are inherently 64-bit kernel only:
-	select ARCH_HAS_GIGANTIC_PAGE if CONTIG_ALLOC
+	select ARCH_HAS_GIGANTIC_PAGE
 	select ARCH_SUPPORTS_INT128
 	select ARCH_SUPPORTS_RT
 	select ARCH_USE_CMPXCHG_LOCKREF
diff --git a/arch/x86/include/asm/hugetlb.h b/arch/x86/include/asm/hugetlb.h
index 398da3b3414c..072631467e4f 100644
--- a/arch/x86/include/asm/hugetlb.h
+++ b/arch/x86/include/asm/hugetlb.h
@@ -78,8 +78,4 @@ static inline void arch_clear_hugepage_flags(struct page *page)
 {
 }
 
-#ifdef CONFIG_ARCH_HAS_GIGANTIC_PAGE
-static inline bool gigantic_page_supported(void) { return true; }
-#endif
-
 #endif /* _ASM_X86_HUGETLB_H */
diff --git a/include/asm-generic/hugetlb.h b/include/asm-generic/hugetlb.h
index 2c157ee8c63d..ba19c29f1957 100644
--- a/include/asm-generic/hugetlb.h
+++ b/include/asm-generic/hugetlb.h
@@ -51,4 +51,11 @@ static inline void hugetlb_free_pgd_range(struct mmu_gather *tlb,
 
 #endif
 
+#ifndef __HAVE_ARCH_GIGANTIC_PAGE_RUNTIME_SUPPORTED
+static inline bool gigantic_page_runtime_supported(void)
+{
+	return IS_ENABLED(CONFIG_ARCH_HAS_GIGANTIC_PAGE);
+}
+#endif /* __HAVE_ARCH_GIGANTIC_PAGE_RUNTIME_SUPPORTED */
+
 #endif /* _ASM_GENERIC_HUGETLB_H */
diff --git a/include/linux/gfp.h b/include/linux/gfp.h
index e4c9f1016251..66f5851b879d 100644
--- a/include/linux/gfp.h
+++ b/include/linux/gfp.h
@@ -603,8 +603,8 @@ static inline bool pm_suspended_storage(void)
 /* The below functions must be run on a range from a single zone. */
 extern int alloc_contig_range(unsigned long start, unsigned long end,
 			      unsigned migratetype, gfp_t gfp_mask);
-extern void free_contig_range(unsigned long pfn, unsigned nr_pages);
 #endif
+void free_contig_range(unsigned long pfn, unsigned int nr_pages);
 
 #ifdef CONFIG_CMA
 /* CMA stuff */
* Unmerged path mm/hugetlb.c
diff --git a/mm/page_alloc.c b/mm/page_alloc.c
index 4c1a2cc85d7c..91cd336f81aa 100644
--- a/mm/page_alloc.c
+++ b/mm/page_alloc.c
@@ -8699,8 +8699,9 @@ int alloc_contig_range(unsigned long start, unsigned long end,
 				pfn_max_align_up(end), migratetype);
 	return ret;
 }
+#endif /* CONFIG_CONTIG_ALLOC */
 
-void free_contig_range(unsigned long pfn, unsigned nr_pages)
+void free_contig_range(unsigned long pfn, unsigned int nr_pages)
 {
 	unsigned int count = 0;
 
@@ -8712,7 +8713,6 @@ void free_contig_range(unsigned long pfn, unsigned nr_pages)
 	}
 	WARN(count != 0, "%d pages are still in use!\n", count);
 }
-#endif
 
 #ifdef CONFIG_MEMORY_HOTPLUG
 /*
