vt_ioctl: move vt_kdsetmode out of vt_k_ioctl

jira LE-1907
cve CVE-2021-3753
Rebuild_History Non-Buildable kernel-4.18.0-524.el8
commit-author Jiri Slaby <jslaby@suse.cz>
commit a4c53c830b2722f7cd30f58740fd9955ea4eed2c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-524.el8/a4c53c83.failed

It's too long to be inlined.

	Signed-off-by: Jiri Slaby <jslaby@suse.cz>
Link: https://lore.kernel.org/r/20200615074910.19267-37-jslaby@suse.cz
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit a4c53c830b2722f7cd30f58740fd9955ea4eed2c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/tty/vt/vt_ioctl.c
diff --cc drivers/tty/vt/vt_ioctl.c
index 33d9d0c2947c,224f2a564e13..000000000000
--- a/drivers/tty/vt/vt_ioctl.c
+++ b/drivers/tty/vt/vt_ioctl.c
@@@ -241,10 -241,318 +241,312 @@@ int vt_waitactive(int n
  #define GPLAST 0x3df
  #define GPNUM (GPLAST - GPFIRST + 1)
  
++<<<<<<< HEAD
++=======
+ /*
+  * currently, setting the mode from KD_TEXT to KD_GRAPHICS doesn't do a whole
+  * lot. i'm not sure if it should do any restoration of modes or what...
+  *
+  * XXX It should at least call into the driver, fbdev's definitely need to
+  * restore their engine state. --BenH
+  */
+ static int vt_kdsetmode(struct vc_data *vc, unsigned long mode)
+ {
+ 	switch (mode) {
+ 	case KD_GRAPHICS:
+ 		break;
+ 	case KD_TEXT0:
+ 	case KD_TEXT1:
+ 		mode = KD_TEXT;
+ 		fallthrough;
+ 	case KD_TEXT:
+ 		break;
+ 	default:
+ 		return -EINVAL;
+ 	}
  
+ 	/* FIXME: this needs the console lock extending */
+ 	if (vc->vc_mode == mode)
+ 		return 0;
+ 
+ 	vc->vc_mode = mode;
+ 	if (vc->vc_num != fg_console)
+ 		return 0;
  
+ 	/* explicitly blank/unblank the screen if switching modes */
+ 	console_lock();
+ 	if (mode == KD_TEXT)
+ 		do_unblank_screen(1);
+ 	else
+ 		do_blank_screen(1);
+ 	console_unlock();
+ 
+ 	return 0;
+ }
+ 
+ static int vt_k_ioctl(struct tty_struct *tty, unsigned int cmd,
+ 		unsigned long arg, bool perm)
+ {
+ 	struct vc_data *vc = tty->driver_data;
+ 	void __user *up = (void __user *)arg;
+ 	unsigned int console = vc->vc_num;
+ 	int ret;
++>>>>>>> a4c53c830b27 (vt_ioctl: move vt_kdsetmode out of vt_k_ioctl)
+ 
 -	switch (cmd) {
 -	case KIOCSOUND:
 -		if (!perm)
 -			return -EPERM;
 -		/*
 -		 * The use of PIT_TICK_RATE is historic, it used to be
 -		 * the platform-dependent CLOCK_TICK_RATE between 2.6.12
 -		 * and 2.6.36, which was a minor but unfortunate ABI
 -		 * change. kd_mksound is locked by the input layer.
 -		 */
 -		if (arg)
 -			arg = PIT_TICK_RATE / arg;
 -		kd_mksound(arg, 0);
 -		break;
+ 
++<<<<<<< HEAD
 +static inline int 
 +do_unimap_ioctl(int cmd, struct unimapdesc __user *user_ud, int perm, struct vc_data *vc)
++=======
+ 	case KDMKTONE:
+ 		if (!perm)
+ 			return -EPERM;
+ 	{
+ 		unsigned int ticks, count;
+ 
+ 		/*
+ 		 * Generate the tone for the appropriate number of ticks.
+ 		 * If the time is zero, turn off sound ourselves.
+ 		 */
+ 		ticks = msecs_to_jiffies((arg >> 16) & 0xffff);
+ 		count = ticks ? (arg & 0xffff) : 0;
+ 		if (count)
+ 			count = PIT_TICK_RATE / count;
+ 		kd_mksound(count, ticks);
+ 		break;
+ 	}
+ 
+ 	case KDGKBTYPE:
+ 		/*
+ 		 * this is na√Øve.
+ 		 */
+ 		return put_user(KB_101, (char __user *)arg);
+ 
+ 		/*
+ 		 * These cannot be implemented on any machine that implements
+ 		 * ioperm() in user level (such as Alpha PCs) or not at all.
+ 		 *
+ 		 * XXX: you should never use these, just call ioperm directly..
+ 		 */
+ #ifdef CONFIG_X86
+ 	case KDADDIO:
+ 	case KDDELIO:
+ 		/*
+ 		 * KDADDIO and KDDELIO may be able to add ports beyond what
+ 		 * we reject here, but to be safe...
+ 		 *
+ 		 * These are locked internally via sys_ioperm
+ 		 */
+ 		if (arg < GPFIRST || arg > GPLAST)
+ 			return -EINVAL;
+ 
+ 		return ksys_ioperm(arg, 1, (cmd == KDADDIO)) ? -ENXIO : 0;
+ 
+ 	case KDENABIO:
+ 	case KDDISABIO:
+ 		return ksys_ioperm(GPFIRST, GPNUM,
+ 				  (cmd == KDENABIO)) ? -ENXIO : 0;
+ #endif
+ 
+ 	/* Linux m68k/i386 interface for setting the keyboard delay/repeat rate */
+ 
+ 	case KDKBDREP:
+ 	{
+ 		struct kbd_repeat kbrep;
+ 
+ 		if (!capable(CAP_SYS_TTY_CONFIG))
+ 			return -EPERM;
+ 
+ 		if (copy_from_user(&kbrep, up, sizeof(struct kbd_repeat)))
+ 			return -EFAULT;
+ 
+ 		ret = kbd_rate(&kbrep);
+ 		if (ret)
+ 			return ret;
+ 		if (copy_to_user(up, &kbrep, sizeof(struct kbd_repeat)))
+ 			return -EFAULT;
+ 		break;
+ 	}
+ 
+ 	case KDSETMODE:
+ 		if (!perm)
+ 			return -EPERM;
+ 
+ 		return vt_kdsetmode(vc, arg);
+ 
+ 	case KDGETMODE:
+ 		return put_user(vc->vc_mode, (int __user *)arg);
+ 
+ 	case KDMAPDISP:
+ 	case KDUNMAPDISP:
+ 		/*
+ 		 * these work like a combination of mmap and KDENABIO.
+ 		 * this could be easily finished.
+ 		 */
+ 		return -EINVAL;
+ 
+ 	case KDSKBMODE:
+ 		if (!perm)
+ 			return -EPERM;
+ 		ret = vt_do_kdskbmode(console, arg);
+ 		if (ret)
+ 			return ret;
+ 		tty_ldisc_flush(tty);
+ 		break;
+ 
+ 	case KDGKBMODE:
+ 		return put_user(vt_do_kdgkbmode(console), (int __user *)arg);
+ 
+ 	/* this could be folded into KDSKBMODE, but for compatibility
+ 	   reasons it is not so easy to fold KDGKBMETA into KDGKBMODE */
+ 	case KDSKBMETA:
+ 		return vt_do_kdskbmeta(console, arg);
+ 
+ 	case KDGKBMETA:
+ 		/* FIXME: should review whether this is worth locking */
+ 		return put_user(vt_do_kdgkbmeta(console), (int __user *)arg);
+ 
+ 	case KDGETKEYCODE:
+ 	case KDSETKEYCODE:
+ 		if(!capable(CAP_SYS_TTY_CONFIG))
+ 			perm = 0;
+ 		return vt_do_kbkeycode_ioctl(cmd, up, perm);
+ 
+ 	case KDGKBENT:
+ 	case KDSKBENT:
+ 		return vt_do_kdsk_ioctl(cmd, up, perm, console);
+ 
+ 	case KDGKBSENT:
+ 	case KDSKBSENT:
+ 		return vt_do_kdgkb_ioctl(cmd, up, perm);
+ 
+ 	/* Diacritical processing. Handled in keyboard.c as it has
+ 	   to operate on the keyboard locks and structures */
+ 	case KDGKBDIACR:
+ 	case KDGKBDIACRUC:
+ 	case KDSKBDIACR:
+ 	case KDSKBDIACRUC:
+ 		return vt_do_diacrit(cmd, up, perm);
+ 
+ 	/* the ioctls below read/set the flags usually shown in the leds */
+ 	/* don't use them - they will go away without warning */
+ 	case KDGKBLED:
+ 	case KDSKBLED:
+ 	case KDGETLED:
+ 	case KDSETLED:
+ 		return vt_do_kdskled(console, cmd, arg, perm);
+ 
+ 	/*
+ 	 * A process can indicate its willingness to accept signals
+ 	 * generated by pressing an appropriate key combination.
+ 	 * Thus, one can have a daemon that e.g. spawns a new console
+ 	 * upon a keypress and then changes to it.
+ 	 * See also the kbrequest field of inittab(5).
+ 	 */
+ 	case KDSIGACCEPT:
+ 		if (!perm || !capable(CAP_KILL))
+ 			return -EPERM;
+ 		if (!valid_signal(arg) || arg < 1 || arg == SIGKILL)
+ 			return -EINVAL;
+ 
+ 		spin_lock_irq(&vt_spawn_con.lock);
+ 		put_pid(vt_spawn_con.pid);
+ 		vt_spawn_con.pid = get_pid(task_pid(current));
+ 		vt_spawn_con.sig = arg;
+ 		spin_unlock_irq(&vt_spawn_con.lock);
+ 		break;
+ 
+ 	case KDFONTOP: {
+ 		struct console_font_op op;
+ 
+ 		if (copy_from_user(&op, up, sizeof(op)))
+ 			return -EFAULT;
+ 		if (!perm && op.op != KD_FONT_OP_GET)
+ 			return -EPERM;
+ 		ret = con_font_op(vc, &op);
+ 		if (ret)
+ 			return ret;
+ 		if (copy_to_user(up, &op, sizeof(op)))
+ 			return -EFAULT;
+ 		break;
+ 	}
+ 
+ 	default:
+ 		return -ENOIOCTLCMD;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static inline int do_fontx_ioctl(int cmd,
+ 		struct consolefontdesc __user *user_cfd, int perm,
+ 		struct console_font_op *op)
+ {
+ 	struct consolefontdesc cfdarg;
+ 	int i;
+ 
+ 	if (copy_from_user(&cfdarg, user_cfd, sizeof(struct consolefontdesc)))
+ 		return -EFAULT;
+ 
+ 	switch (cmd) {
+ 	case PIO_FONTX:
+ 		if (!perm)
+ 			return -EPERM;
+ 		op->op = KD_FONT_OP_SET;
+ 		op->flags = KD_FONT_FLAG_OLD;
+ 		op->width = 8;
+ 		op->height = cfdarg.charheight;
+ 		op->charcount = cfdarg.charcount;
+ 		op->data = cfdarg.chardata;
+ 		return con_font_op(vc_cons[fg_console].d, op);
+ 	case GIO_FONTX: {
+ 		op->op = KD_FONT_OP_GET;
+ 		op->flags = KD_FONT_FLAG_OLD;
+ 		op->width = 8;
+ 		op->height = cfdarg.charheight;
+ 		op->charcount = cfdarg.charcount;
+ 		op->data = cfdarg.chardata;
+ 		i = con_font_op(vc_cons[fg_console].d, op);
+ 		if (i)
+ 			return i;
+ 		cfdarg.charheight = op->height;
+ 		cfdarg.charcount = op->charcount;
+ 		if (copy_to_user(user_cfd, &cfdarg, sizeof(struct consolefontdesc)))
+ 			return -EFAULT;
+ 		return 0;
+ 		}
+ 	}
+ 	return -EINVAL;
+ }
+ 
+ static int vt_io_fontreset(struct console_font_op *op)
+ {
+ 	int ret;
+ 
+ 	if (__is_defined(BROKEN_GRAPHICS_PROGRAMS)) {
+ 		/*
+ 		 * With BROKEN_GRAPHICS_PROGRAMS defined, the default font is
+ 		 * not saved.
+ 		 */
+ 		return -ENOSYS;
+ 	}
+ 
+ 	op->op = KD_FONT_OP_SET_DEFAULT;
+ 	op->data = NULL;
+ 	ret = con_font_op(vc_cons[fg_console].d, op);
+ 	if (ret)
+ 		return ret;
+ 
+ 	console_lock();
+ 	con_set_default_unimap(vc_cons[fg_console].d);
+ 	console_unlock();
+ 
+ 	return 0;
+ }
+ 
+ static inline int do_unimap_ioctl(int cmd, struct unimapdesc __user *user_ud,
+ 		int perm, struct vc_data *vc)
++>>>>>>> a4c53c830b27 (vt_ioctl: move vt_kdsetmode out of vt_k_ioctl)
  {
  	struct unimapdesc tmp;
  
* Unmerged path drivers/tty/vt/vt_ioctl.c
