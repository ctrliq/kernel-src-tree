mm/slub: move free_debug_processing() further

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-524.el8
commit-author Vlastimil Babka <vbabka@suse.cz>
commit a579b0560cd74e9edacbc5d6a021bae90159fb91
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-524.el8/a579b056.failed

In the following patch, the function free_debug_processing() will be
calling add_partial(), remove_partial() and discard_slab(), se move it
below their definitions to avoid forward declarations. To make review
easier, separate the move from functional changes.

	Signed-off-by: Vlastimil Babka <vbabka@suse.cz>
	Reviewed-by: Hyeonggon Yoo <42.hyeyoo@gmail.com>
	Acked-by: David Rientjes <rientjes@google.com>
(cherry picked from commit a579b0560cd74e9edacbc5d6a021bae90159fb91)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/slub.c
diff --cc mm/slub.c
index 4ece4a8929e7,87e794ab101a..000000000000
--- a/mm/slub.c
+++ b/mm/slub.c
@@@ -1335,59 -1385,6 +1335,62 @@@ static inline int free_consistency_chec
  	return 1;
  }
  
++<<<<<<< HEAD
 +/* Supports checking bulk free of a constructed freelist */
 +static noinline int free_debug_processing(
 +	struct kmem_cache *s, struct page *page,
 +	void *head, void *tail, int bulk_cnt,
 +	unsigned long addr)
 +{
 +	struct kmem_cache_node *n = get_node(s, page_to_nid(page));
 +	void *object = head;
 +	int cnt = 0;
 +	unsigned long flags, flags2;
 +	int ret = 0;
 +
 +	spin_lock_irqsave(&n->list_lock, flags);
 +	slab_lock(page, &flags2);
 +
 +	if (s->flags & SLAB_CONSISTENCY_CHECKS) {
 +		if (!check_slab(s, page))
 +			goto out;
 +	}
 +
 +next_object:
 +	cnt++;
 +
 +	if (s->flags & SLAB_CONSISTENCY_CHECKS) {
 +		if (!free_consistency_checks(s, page, object, addr))
 +			goto out;
 +	}
 +
 +	if (s->flags & SLAB_STORE_USER)
 +		set_track(s, object, TRACK_FREE, addr);
 +	trace(s, page, object, 0);
 +	/* Freepointer not overwritten by init_object(), SLAB_POISON moved it */
 +	init_object(s, object, SLUB_RED_INACTIVE);
 +
 +	/* Reached end of constructed freelist yet? */
 +	if (object != tail) {
 +		object = get_freepointer(s, object);
 +		goto next_object;
 +	}
 +	ret = 1;
 +
 +out:
 +	if (cnt != bulk_cnt)
 +		slab_err(s, page, "Bulk freelist count(%d) invalid(%d)\n",
 +			 bulk_cnt, cnt);
 +
 +	slab_unlock(page, &flags2);
 +	spin_unlock_irqrestore(&n->list_lock, flags);
 +	if (!ret)
 +		slab_fix(s, "Object at 0x%p not freed", object);
 +	return ret;
 +}
 +
++=======
++>>>>>>> a579b0560cd7 (mm/slub: move free_debug_processing() further)
  /*
   * Parse a block of slub_debug options. Blocks are delimited by ';'
   *
* Unmerged path mm/slub.c
