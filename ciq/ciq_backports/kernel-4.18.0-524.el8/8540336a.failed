s390/lcs: Remove FDDI option

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-524.el8
commit-author Alexandra Winter <wintera@linux.ibm.com>
commit 8540336adadb84d5fc7864384e6d32506fa17560
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-524.el8/8540336a.failed

The last s390 machine that supported FDDI was z900 ('7th generation',
released in 2000). The oldest machine generation currently supported by
the Linux kernel is MARCH_Z10 (released 2008). If there is still a usecase
for connecting a Linux on s390 instance to a LAN Channel Station (LCS), it
can only do so via Ethernet.

Randy Dunlap[1] found that LCS over FDDI has never worked, when FDDI
was compiled as module. Instead of fixing that, remove the FDDI option
from the lcs driver.

While at it, make the CONFIG_LCS description a bit more helpful.

References:
[1] https://lore.kernel.org/netdev/20230621213742.8245-1-rdunlap@infradead.org/

	Signed-off-by: Alexandra Winter <wintera@linux.ibm.com>
	Acked-by: Christian Borntraeger <borntraeger@linux.ibm.com>
	Reviewed-by: Randy Dunlap <rdunlap@infradead.org>
	Reviewed-by: Simon Horman <simon.horman@corigine.com>
Link: https://lore.kernel.org/r/20230724131546.3597001-1-wintera@linux.ibm.com
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit 8540336adadb84d5fc7864384e6d32506fa17560)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/s390/net/Kconfig
diff --cc drivers/s390/net/Kconfig
index fc1227149543,74760c1a163b..000000000000
--- a/drivers/s390/net/Kconfig
+++ b/drivers/s390/net/Kconfig
@@@ -5,12 -5,11 +5,18 @@@ menu "S/390 network device drivers
  config LCS
  	def_tristate m
  	prompt "Lan Channel Station Interface"
- 	depends on CCW && NETDEVICES && (ETHERNET || FDDI)
+ 	depends on CCW && NETDEVICES && ETHERNET
  	help
++<<<<<<< HEAD
 +	   Select this option if you want to use LCS networking on IBM System z.
 +	   This device driver supports FDDI (IEEE 802.7) and Ethernet.
 +	   To compile as a module, choose M. The module name is lcs.
 +	   If you do not know what it is, it's safe to choose Y.
++=======
+ 	  Select this option if you want to use LCS networking on IBM System z.
+ 	  To compile as a module, choose M. The module name is lcs.
+ 	  If you do not use LCS, choose N.
++>>>>>>> 8540336adadb (s390/lcs: Remove FDDI option)
  
  config CTCM
  	def_tristate m
* Unmerged path drivers/s390/net/Kconfig
diff --git a/drivers/s390/net/lcs.c b/drivers/s390/net/lcs.c
index f04e89d0a2b8..f79b391ab446 100644
--- a/drivers/s390/net/lcs.c
+++ b/drivers/s390/net/lcs.c
@@ -17,7 +17,6 @@
 #include <linux/if.h>
 #include <linux/netdevice.h>
 #include <linux/etherdevice.h>
-#include <linux/fddidevice.h>
 #include <linux/inetdevice.h>
 #include <linux/in.h>
 #include <linux/igmp.h>
@@ -36,10 +35,6 @@
 #include "lcs.h"
 
 
-#if !defined(CONFIG_ETHERNET) && !defined(CONFIG_FDDI)
-#error Cannot compile lcs.c without some net devices switched on.
-#endif
-
 /*
  * initialization string for output
  */
@@ -1601,19 +1596,11 @@ lcs_startlan_auto(struct lcs_card *card)
 	int rc;
 
 	LCS_DBF_TEXT(2, trace, "strtauto");
-#ifdef CONFIG_ETHERNET
 	card->lan_type = LCS_FRAME_TYPE_ENET;
 	rc = lcs_send_startlan(card, LCS_INITIATOR_TCPIP);
 	if (rc == 0)
 		return 0;
 
-#endif
-#ifdef CONFIG_FDDI
-	card->lan_type = LCS_FRAME_TYPE_FDDI;
-	rc = lcs_send_startlan(card, LCS_INITIATOR_TCPIP);
-	if (rc == 0)
-		return 0;
-#endif
 	return -EIO;
 }
 
@@ -1806,22 +1793,16 @@ lcs_get_frames_cb(struct lcs_channel *channel, struct lcs_buffer *buffer)
 			card->stats.rx_errors++;
 			return;
 		}
-		/* What kind of frame is it? */
-		if (lcs_hdr->type == LCS_FRAME_TYPE_CONTROL) {
-			/* Control frame. */
+		if (lcs_hdr->type == LCS_FRAME_TYPE_CONTROL)
 			lcs_get_control(card, (struct lcs_cmd *) lcs_hdr);
-		} else if (lcs_hdr->type == LCS_FRAME_TYPE_ENET ||
-			   lcs_hdr->type == LCS_FRAME_TYPE_TR ||
-			   lcs_hdr->type == LCS_FRAME_TYPE_FDDI) {
-			/* Normal network packet. */
+		else if (lcs_hdr->type == LCS_FRAME_TYPE_ENET)
 			lcs_get_skb(card, (char *)(lcs_hdr + 1),
 				    lcs_hdr->offset - offset -
 				    sizeof(struct lcs_header));
-		} else {
-			/* Unknown frame type. */
-			; // FIXME: error message ?
-		}
-		/* Proceed to next frame. */
+		else
+			dev_info_once(&card->dev->dev,
+				      "Unknown frame type %d\n",
+				      lcs_hdr->type);
 		offset = lcs_hdr->offset;
 		lcs_hdr->offset = LCS_ILLEGAL_OFFSET;
 		lcs_hdr = (struct lcs_header *) (buffer->data + offset);
@@ -2139,18 +2120,10 @@ lcs_new_device(struct ccwgroup_device *ccwgdev)
 		goto netdev_out;
 	}
 	switch (card->lan_type) {
-#ifdef CONFIG_ETHERNET
 	case LCS_FRAME_TYPE_ENET:
 		card->lan_type_trans = eth_type_trans;
 		dev = alloc_etherdev(0);
 		break;
-#endif
-#ifdef CONFIG_FDDI
-	case LCS_FRAME_TYPE_FDDI:
-		card->lan_type_trans = fddi_type_trans;
-		dev = alloc_fddidev(0);
-		break;
-#endif
 	default:
 		LCS_DBF_TEXT(3, setup, "errinit");
 		pr_err(" Initialization failed\n");
