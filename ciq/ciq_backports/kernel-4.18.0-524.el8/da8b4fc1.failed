dm integrity: only allocate recalculate buffer when needed

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-524.el8
commit-author Mikulas Patocka <mpatocka@redhat.com>
commit da8b4fc1f63a01a0eca9338ae338b804c437b51f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-524.el8/da8b4fc1.failed

dm-integrity preallocated 8MiB buffer for recalculating in the
constructor and freed it in the destructor. This wastes memory when
the user has many dm-integrity devices.

Fix dm-integrity so that the buffer is only allocated when
recalculation is in progress; allocate the buffer at the beginning of
integrity_recalc() and free it at the end.

Note that integrity_recalc() doesn't hold any locks when allocating
the buffer, so it shouldn't cause low-memory deadlock.

	Signed-off-by: Mikulas Patocka <mpatocka@redhat.com>
	Signed-off-by: Mike Snitzer <snitzer@kernel.org>
(cherry picked from commit da8b4fc1f63a01a0eca9338ae338b804c437b51f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/md/dm-integrity.c
diff --cc drivers/md/dm-integrity.c
index e5a0e84241c9,16d1aa263066..000000000000
--- a/drivers/md/dm-integrity.c
+++ b/drivers/md/dm-integrity.c
@@@ -2622,13 -2652,27 +2623,27 @@@ static void integrity_recalc(struct wor
  	struct dm_io_region io_loc;
  	sector_t area, offset;
  	sector_t metadata_block;
 -	unsigned int metadata_offset;
 +	unsigned metadata_offset;
  	sector_t logical_sector, n_sectors;
  	__u8 *t;
 -	unsigned int i;
 +	unsigned i;
  	int r;
 -	unsigned int super_counter = 0;
 +	unsigned super_counter = 0;
  
+ 	recalc_buffer = __vmalloc(RECALC_SECTORS << SECTOR_SHIFT, GFP_NOIO);
+ 	if (!recalc_buffer) {
+ 		DMCRIT("out of memory for recalculate buffer - recalculation disabled");
+ 		goto free_ret;
+ 	}
+ 	recalc_tags_size = (RECALC_SECTORS >> ic->sb->log2_sectors_per_block) * ic->tag_size;
+ 	if (crypto_shash_digestsize(ic->internal_hash) > ic->tag_size)
+ 		recalc_tags_size += crypto_shash_digestsize(ic->internal_hash) - ic->tag_size;
+ 	recalc_tags = kvmalloc(recalc_tags_size, GFP_NOIO);
+ 	if (!recalc_tags) {
+ 		DMCRIT("out of memory for recalculate buffer - recalculation disabled");
+ 		goto free_ret;
+ 	}
+ 
  	DEBUG_print("start recalculation... (position %llx)\n", le64_to_cpu(ic->sb->recalc_sector));
  
  	spin_lock_irq(&ic->endio_wait.lock);
@@@ -2689,10 -2733,9 +2704,10 @@@ next_chunk
  	if (unlikely(dm_integrity_failed(ic)))
  		goto err;
  
 -	io_req.bi_opf = REQ_OP_READ;
 +	io_req.bi_op = REQ_OP_READ;
 +	io_req.bi_op_flags = 0;
  	io_req.mem.type = DM_IO_VMA;
- 	io_req.mem.ptr.addr = ic->recalc_buffer;
+ 	io_req.mem.ptr.addr = recalc_buffer;
  	io_req.notify.fn = NULL;
  	io_req.client = ic->io;
  	io_loc.bdev = ic->dev->bdev;
@@@ -4367,9 -4458,8 +4386,12 @@@ try_smaller_buffer
  	}
  
  	if (ic->internal_hash) {
++<<<<<<< HEAD
 +		size_t recalc_tags_size;
++=======
++>>>>>>> da8b4fc1f63a (dm integrity: only allocate recalculate buffer when needed)
  		ic->recalc_wq = alloc_workqueue("dm-integrity-recalc", WQ_MEM_RECLAIM, 1);
 -		if (!ic->recalc_wq) {
 +		if (!ic->recalc_wq ) {
  			ti->error = "Cannot allocate workqueue";
  			r = -ENOMEM;
  			goto bad;
* Unmerged path drivers/md/dm-integrity.c
