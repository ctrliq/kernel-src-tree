cifs: Fix uninitialized memory reads for oparms.mode

jira LE-2169
Rebuild_History Non-Buildable kernel-4.18.0-553.30.1.el8_10
commit-author Volker Lendecke <vl@samba.org>
commit de036dcaca65cf94bf7ff09c571c077f02bc92b4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.30.1.el8_10/de036dca.failed

Use a struct assignment with implicit member initialization

	Signed-off-by: Volker Lendecke <vl@samba.org>
	Cc: stable@vger.kernel.org
	Signed-off-by: Steve French <stfrench@microsoft.com>
(cherry picked from commit de036dcaca65cf94bf7ff09c571c077f02bc92b4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/cifs/cached_dir.c
#	fs/cifs/smb1ops.c
#	fs/cifs/smb2ops.c
diff --cc fs/cifs/smb1ops.c
index 017d0207befe,abda6148be10..000000000000
--- a/fs/cifs/smb1ops.c
+++ b/fs/cifs/smb1ops.c
@@@ -576,14 -571,20 +576,31 @@@ cifs_query_path_info(const unsigned in
  		struct cifs_fid fid;
  		struct cifs_open_parms oparms;
  
++<<<<<<< HEAD
 +		oparms.tcon = tcon;
 +		oparms.cifs_sb = cifs_sb;
 +		oparms.desired_access = FILE_READ_ATTRIBUTES;
 +		oparms.create_options = cifs_create_options(cifs_sb, 0);
 +		oparms.disposition = FILE_OPEN;
 +		oparms.path = full_path;
 +		oparms.fid = &fid;
 +		oparms.reconnect = false;
++=======
+ 		move_cifs_info_to_smb2(&data->fi, &fi);
+ 
+ 		if (!(le32_to_cpu(fi.Attributes) & ATTR_REPARSE))
+ 			return 0;
+ 
+ 		oparms = (struct cifs_open_parms) {
+ 			.tcon = tcon,
+ 			.cifs_sb = cifs_sb,
+ 			.desired_access = FILE_READ_ATTRIBUTES,
+ 			.create_options = cifs_create_options(cifs_sb, 0),
+ 			.disposition = FILE_OPEN,
+ 			.path = full_path,
+ 			.fid = &fid,
+ 		};
++>>>>>>> de036dcaca65 (cifs: Fix uninitialized memory reads for oparms.mode)
  
  		/* Need to check if this is a symbolic link or not */
  		tmprc = CIFS_open(xid, &oparms, &oplock, NULL);
@@@ -1096,21 -1118,16 +1115,34 @@@ cifs_make_node(unsigned int xid, struc
  
  	cifs_dbg(FYI, "sfu compat create special file\n");
  
++<<<<<<< HEAD
 +	buf = kmalloc(sizeof(FILE_ALL_INFO), GFP_KERNEL);
 +	if (buf == NULL) {
 +		rc = -ENOMEM;
 +		goto out;
 +	}
 +
 +	oparms.tcon = tcon;
 +	oparms.cifs_sb = cifs_sb;
 +	oparms.desired_access = GENERIC_WRITE;
 +	oparms.create_options = cifs_create_options(cifs_sb, CREATE_NOT_DIR |
 +						    CREATE_OPTION_SPECIAL);
 +	oparms.disposition = FILE_CREATE;
 +	oparms.path = full_path;
 +	oparms.fid = &fid;
 +	oparms.reconnect = false;
++=======
+ 	oparms = (struct cifs_open_parms) {
+ 		.tcon = tcon,
+ 		.cifs_sb = cifs_sb,
+ 		.desired_access = GENERIC_WRITE,
+ 		.create_options = cifs_create_options(cifs_sb, CREATE_NOT_DIR |
+ 						      CREATE_OPTION_SPECIAL),
+ 		.disposition = FILE_CREATE,
+ 		.path = full_path,
+ 		.fid = &fid,
+ 	};
++>>>>>>> de036dcaca65 (cifs: Fix uninitialized memory reads for oparms.mode)
  
  	if (tcon->ses->server->oplocks)
  		oplock = REQ_OPLOCK;
diff --cc fs/cifs/smb2ops.c
index bfffaf91afb2,43beec54710f..000000000000
--- a/fs/cifs/smb2ops.c
+++ b/fs/cifs/smb2ops.c
@@@ -1019,18 -818,34 +1020,19 @@@ smb2_is_path_accessible(const unsigned 
  	if (!utf16_path)
  		return -ENOMEM;
  
- 	oparms.tcon = tcon;
- 	oparms.desired_access = FILE_READ_ATTRIBUTES;
- 	oparms.disposition = FILE_OPEN;
- 	oparms.create_options = cifs_create_options(cifs_sb, 0);
- 	oparms.fid = &fid;
- 	oparms.reconnect = false;
+ 	oparms = (struct cifs_open_parms) {
+ 		.tcon = tcon,
+ 		.desired_access = FILE_READ_ATTRIBUTES,
+ 		.disposition = FILE_OPEN,
+ 		.create_options = cifs_create_options(cifs_sb, 0),
+ 		.fid = &fid,
+ 	};
  
 -	rc = SMB2_open(xid, &oparms, utf16_path, &oplock, NULL, NULL,
 -		       &err_iov, &err_buftype);
 +	rc = SMB2_open(xid, &oparms, utf16_path, &oplock, NULL, NULL, NULL,
 +		       NULL);
  	if (rc) {
 -		struct smb2_hdr *hdr = err_iov.iov_base;
 -
 -		if (unlikely(!hdr || err_buftype == CIFS_NO_BUFFER))
 -			goto out;
 -		/*
 -		 * Handle weird Windows SMB server behaviour. It responds with
 -		 * STATUS_OBJECT_NAME_INVALID code to SMB2 QUERY_INFO request
 -		 * for "\<server>\<dfsname>\<linkpath>" DFS reference,
 -		 * where <dfsname> contains non-ASCII unicode symbols.
 -		 */
 -		if (rc != -EREMOTE && IS_ENABLED(CONFIG_CIFS_DFS_UPCALL) &&
 -		    hdr->Status == STATUS_OBJECT_NAME_INVALID)
 -			rc = -EREMOTE;
 -		if (rc == -EREMOTE && IS_ENABLED(CONFIG_CIFS_DFS_UPCALL) && cifs_sb &&
 -		    (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NO_DFS))
 -			rc = -EOPNOTSUPP;
 -		goto out;
 +		kfree(utf16_path);
 +		return rc;
  	}
  
  	rc = SMB2_close(xid, tcon, fid.persistent_fid, fid.volatile_fid);
@@@ -5197,21 -5149,16 +5207,34 @@@ smb2_make_node(unsigned int xid, struc
  
  	cifs_dbg(FYI, "sfu compat create special file\n");
  
++<<<<<<< HEAD
 +	buf = kmalloc(sizeof(FILE_ALL_INFO), GFP_KERNEL);
 +	if (buf == NULL) {
 +		rc = -ENOMEM;
 +		goto out;
 +	}
 +
 +	oparms.tcon = tcon;
 +	oparms.cifs_sb = cifs_sb;
 +	oparms.desired_access = GENERIC_WRITE;
 +	oparms.create_options = cifs_create_options(cifs_sb, CREATE_NOT_DIR |
 +						    CREATE_OPTION_SPECIAL);
 +	oparms.disposition = FILE_CREATE;
 +	oparms.path = full_path;
 +	oparms.fid = &fid;
 +	oparms.reconnect = false;
++=======
+ 	oparms = (struct cifs_open_parms) {
+ 		.tcon = tcon,
+ 		.cifs_sb = cifs_sb,
+ 		.desired_access = GENERIC_WRITE,
+ 		.create_options = cifs_create_options(cifs_sb, CREATE_NOT_DIR |
+ 						      CREATE_OPTION_SPECIAL),
+ 		.disposition = FILE_CREATE,
+ 		.path = full_path,
+ 		.fid = &fid,
+ 	};
++>>>>>>> de036dcaca65 (cifs: Fix uninitialized memory reads for oparms.mode)
  
  	if (tcon->ses->server->oplocks)
  		oplock = REQ_OPLOCK;
* Unmerged path fs/cifs/cached_dir.c
* Unmerged path fs/cifs/cached_dir.c
diff --git a/fs/cifs/cifsacl.c b/fs/cifs/cifsacl.c
index a80494408111..0af6988cb2f4 100644
--- a/fs/cifs/cifsacl.c
+++ b/fs/cifs/cifsacl.c
@@ -1424,14 +1424,15 @@ static struct cifs_ntsd *get_cifs_acl_by_path(struct cifs_sb_info *cifs_sb,
 	tcon = tlink_tcon(tlink);
 	xid = get_xid();
 
-	oparms.tcon = tcon;
-	oparms.cifs_sb = cifs_sb;
-	oparms.desired_access = READ_CONTROL;
-	oparms.create_options = cifs_create_options(cifs_sb, 0);
-	oparms.disposition = FILE_OPEN;
-	oparms.path = path;
-	oparms.fid = &fid;
-	oparms.reconnect = false;
+	oparms = (struct cifs_open_parms) {
+		.tcon = tcon,
+		.cifs_sb = cifs_sb,
+		.desired_access = READ_CONTROL,
+		.create_options = cifs_create_options(cifs_sb, 0),
+		.disposition = FILE_OPEN,
+		.path = path,
+		.fid = &fid,
+	};
 
 	rc = CIFS_open(xid, &oparms, &oplock, NULL);
 	if (!rc) {
@@ -1490,14 +1491,15 @@ int set_cifs_acl(struct cifs_ntsd *pnntsd, __u32 acllen,
 	else
 		access_flags = WRITE_DAC;
 
-	oparms.tcon = tcon;
-	oparms.cifs_sb = cifs_sb;
-	oparms.desired_access = access_flags;
-	oparms.create_options = cifs_create_options(cifs_sb, 0);
-	oparms.disposition = FILE_OPEN;
-	oparms.path = path;
-	oparms.fid = &fid;
-	oparms.reconnect = false;
+	oparms = (struct cifs_open_parms) {
+		.tcon = tcon,
+		.cifs_sb = cifs_sb,
+		.desired_access = access_flags,
+		.create_options = cifs_create_options(cifs_sb, 0),
+		.disposition = FILE_OPEN,
+		.path = path,
+		.fid = &fid,
+	};
 
 	rc = CIFS_open(xid, &oparms, &oplock, NULL);
 	if (rc) {
diff --git a/fs/cifs/cifssmb.c b/fs/cifs/cifssmb.c
index 031af258a3f0..aa48ef74690f 100644
--- a/fs/cifs/cifssmb.c
+++ b/fs/cifs/cifssmb.c
@@ -5810,14 +5810,15 @@ CIFSSMBSetPathInfoFB(const unsigned int xid, struct cifs_tcon *tcon,
 	struct cifs_fid fid;
 	int rc;
 
-	oparms.tcon = tcon;
-	oparms.cifs_sb = cifs_sb;
-	oparms.desired_access = GENERIC_WRITE;
-	oparms.create_options = cifs_create_options(cifs_sb, 0);
-	oparms.disposition = FILE_OPEN;
-	oparms.path = fileName;
-	oparms.fid = &fid;
-	oparms.reconnect = false;
+	oparms = (struct cifs_open_parms) {
+		.tcon = tcon,
+		.cifs_sb = cifs_sb,
+		.desired_access = GENERIC_WRITE,
+		.create_options = cifs_create_options(cifs_sb, 0),
+		.disposition = FILE_OPEN,
+		.path = fileName,
+		.fid = &fid,
+	};
 
 	rc = CIFS_open(xid, &oparms, &oplock, NULL);
 	if (rc)
diff --git a/fs/cifs/dir.c b/fs/cifs/dir.c
index f0874fb7c2f1..82b8a84d4180 100644
--- a/fs/cifs/dir.c
+++ b/fs/cifs/dir.c
@@ -299,15 +299,16 @@ cifs_do_create(struct inode *inode, struct dentry *direntry, unsigned int xid,
 	if (!tcon->unix_ext && (mode & S_IWUGO) == 0)
 		create_options |= CREATE_OPTION_READONLY;
 
-	oparms.tcon = tcon;
-	oparms.cifs_sb = cifs_sb;
-	oparms.desired_access = desired_access;
-	oparms.create_options = cifs_create_options(cifs_sb, create_options);
-	oparms.disposition = disposition;
-	oparms.path = full_path;
-	oparms.fid = fid;
-	oparms.reconnect = false;
-	oparms.mode = mode;
+	oparms = (struct cifs_open_parms) {
+		.tcon = tcon,
+		.cifs_sb = cifs_sb,
+		.desired_access = desired_access,
+		.create_options = cifs_create_options(cifs_sb, create_options),
+		.disposition = disposition,
+		.path = full_path,
+		.fid = fid,
+		.mode = mode,
+	};
 	rc = server->ops->open(xid, &oparms, oplock, buf);
 	if (rc) {
 		cifs_dbg(FYI, "cifs_create returned 0x%x\n", rc);
diff --git a/fs/cifs/file.c b/fs/cifs/file.c
index c97ff0db423c..6aaac9bc59dc 100644
--- a/fs/cifs/file.c
+++ b/fs/cifs/file.c
@@ -217,14 +217,15 @@ cifs_nt_open(const char *full_path, struct inode *inode, struct cifs_sb_info *ci
 	if (f_flags & O_DIRECT)
 		create_options |= CREATE_NO_BUFFER;
 
-	oparms.tcon = tcon;
-	oparms.cifs_sb = cifs_sb;
-	oparms.desired_access = desired_access;
-	oparms.create_options = cifs_create_options(cifs_sb, create_options);
-	oparms.disposition = disposition;
-	oparms.path = full_path;
-	oparms.fid = fid;
-	oparms.reconnect = false;
+	oparms = (struct cifs_open_parms) {
+		.tcon = tcon,
+		.cifs_sb = cifs_sb,
+		.desired_access = desired_access,
+		.create_options = cifs_create_options(cifs_sb, create_options),
+		.disposition = disposition,
+		.path = full_path,
+		.fid = fid,
+	};
 
 	rc = server->ops->open(xid, &oparms, oplock, buf);
 
@@ -751,14 +752,16 @@ cifs_reopen_file(struct cifsFileInfo *cfile, bool can_flush)
 	if (server->ops->get_lease_key)
 		server->ops->get_lease_key(inode, &cfile->fid);
 
-	oparms.tcon = tcon;
-	oparms.cifs_sb = cifs_sb;
-	oparms.desired_access = desired_access;
-	oparms.create_options = cifs_create_options(cifs_sb, create_options);
-	oparms.disposition = disposition;
-	oparms.path = full_path;
-	oparms.fid = &cfile->fid;
-	oparms.reconnect = true;
+	oparms = (struct cifs_open_parms) {
+		.tcon = tcon,
+		.cifs_sb = cifs_sb,
+		.desired_access = desired_access,
+		.create_options = cifs_create_options(cifs_sb, create_options),
+		.disposition = disposition,
+		.path = full_path,
+		.fid = &cfile->fid,
+		.reconnect = true,
+	};
 
 	/*
 	 * Can not refresh inode by passing in file_info buf to be returned by
diff --git a/fs/cifs/inode.c b/fs/cifs/inode.c
index 1beb424ecfad..ffd475b42888 100644
--- a/fs/cifs/inode.c
+++ b/fs/cifs/inode.c
@@ -464,14 +464,15 @@ cifs_sfu_type(struct cifs_fattr *fattr, const char *path,
 		return PTR_ERR(tlink);
 	tcon = tlink_tcon(tlink);
 
-	oparms.tcon = tcon;
-	oparms.cifs_sb = cifs_sb;
-	oparms.desired_access = GENERIC_READ;
-	oparms.create_options = cifs_create_options(cifs_sb, CREATE_NOT_DIR);
-	oparms.disposition = FILE_OPEN;
-	oparms.path = path;
-	oparms.fid = &fid;
-	oparms.reconnect = false;
+	oparms = (struct cifs_open_parms) {
+		.tcon = tcon,
+		.cifs_sb = cifs_sb,
+		.desired_access = GENERIC_READ,
+		.create_options = cifs_create_options(cifs_sb, CREATE_NOT_DIR),
+		.disposition = FILE_OPEN,
+		.path = path,
+		.fid = &fid,
+	};
 
 	if (tcon->ses->server->oplocks)
 		oplock = REQ_OPLOCK;
@@ -1464,14 +1465,15 @@ cifs_rename_pending_delete(const char *full_path, struct dentry *dentry,
 		goto out;
 	}
 
-	oparms.tcon = tcon;
-	oparms.cifs_sb = cifs_sb;
-	oparms.desired_access = DELETE | FILE_WRITE_ATTRIBUTES;
-	oparms.create_options = cifs_create_options(cifs_sb, CREATE_NOT_DIR);
-	oparms.disposition = FILE_OPEN;
-	oparms.path = full_path;
-	oparms.fid = &fid;
-	oparms.reconnect = false;
+	oparms = (struct cifs_open_parms) {
+		.tcon = tcon,
+		.cifs_sb = cifs_sb,
+		.desired_access = DELETE | FILE_WRITE_ATTRIBUTES,
+		.create_options = cifs_create_options(cifs_sb, CREATE_NOT_DIR),
+		.disposition = FILE_OPEN,
+		.path = full_path,
+		.fid = &fid,
+	};
 
 	rc = CIFS_open(xid, &oparms, &oplock, NULL);
 	if (rc != 0)
@@ -2029,15 +2031,16 @@ cifs_do_rename(const unsigned int xid, struct dentry *from_dentry,
 	if (to_dentry->d_parent != from_dentry->d_parent)
 		goto do_rename_exit;
 
-	oparms.tcon = tcon;
-	oparms.cifs_sb = cifs_sb;
-	/* open the file to be renamed -- we need DELETE perms */
-	oparms.desired_access = DELETE;
-	oparms.create_options = cifs_create_options(cifs_sb, CREATE_NOT_DIR);
-	oparms.disposition = FILE_OPEN;
-	oparms.path = from_path;
-	oparms.fid = &fid;
-	oparms.reconnect = false;
+	oparms = (struct cifs_open_parms) {
+		.tcon = tcon,
+		.cifs_sb = cifs_sb,
+		/* open the file to be renamed -- we need DELETE perms */
+		.desired_access = DELETE,
+		.create_options = cifs_create_options(cifs_sb, CREATE_NOT_DIR),
+		.disposition = FILE_OPEN,
+		.path = from_path,
+		.fid = &fid,
+	};
 
 	rc = CIFS_open(xid, &oparms, &oplock, NULL);
 	if (rc == 0) {
diff --git a/fs/cifs/link.c b/fs/cifs/link.c
index 87d1cf088e9c..8c4b578a431c 100644
--- a/fs/cifs/link.c
+++ b/fs/cifs/link.c
@@ -299,14 +299,15 @@ cifs_query_mf_symlink(unsigned int xid, struct cifs_tcon *tcon,
 	int buf_type = CIFS_NO_BUFFER;
 	FILE_ALL_INFO file_info;
 
-	oparms.tcon = tcon;
-	oparms.cifs_sb = cifs_sb;
-	oparms.desired_access = GENERIC_READ;
-	oparms.create_options = cifs_create_options(cifs_sb, CREATE_NOT_DIR);
-	oparms.disposition = FILE_OPEN;
-	oparms.path = path;
-	oparms.fid = &fid;
-	oparms.reconnect = false;
+	oparms = (struct cifs_open_parms) {
+		.tcon = tcon,
+		.cifs_sb = cifs_sb,
+		.desired_access = GENERIC_READ,
+		.create_options = cifs_create_options(cifs_sb, CREATE_NOT_DIR),
+		.disposition = FILE_OPEN,
+		.path = path,
+		.fid = &fid,
+	};
 
 	rc = CIFS_open(xid, &oparms, &oplock, &file_info);
 	if (rc)
@@ -341,14 +342,15 @@ cifs_create_mf_symlink(unsigned int xid, struct cifs_tcon *tcon,
 	struct cifs_open_parms oparms;
 	struct cifs_io_parms io_parms = {0};
 
-	oparms.tcon = tcon;
-	oparms.cifs_sb = cifs_sb;
-	oparms.desired_access = GENERIC_WRITE;
-	oparms.create_options = cifs_create_options(cifs_sb, CREATE_NOT_DIR);
-	oparms.disposition = FILE_CREATE;
-	oparms.path = path;
-	oparms.fid = &fid;
-	oparms.reconnect = false;
+	oparms = (struct cifs_open_parms) {
+		.tcon = tcon,
+		.cifs_sb = cifs_sb,
+		.desired_access = GENERIC_WRITE,
+		.create_options = cifs_create_options(cifs_sb, CREATE_NOT_DIR),
+		.disposition = FILE_CREATE,
+		.path = path,
+		.fid = &fid,
+	};
 
 	rc = CIFS_open(xid, &oparms, &oplock, NULL);
 	if (rc)
@@ -382,13 +384,14 @@ smb3_query_mf_symlink(unsigned int xid, struct cifs_tcon *tcon,
 	__u8 oplock = SMB2_OPLOCK_LEVEL_NONE;
 	struct smb2_file_all_info *pfile_info = NULL;
 
-	oparms.tcon = tcon;
-	oparms.cifs_sb = cifs_sb;
-	oparms.desired_access = GENERIC_READ;
-	oparms.create_options = cifs_create_options(cifs_sb, CREATE_NOT_DIR);
-	oparms.disposition = FILE_OPEN;
-	oparms.fid = &fid;
-	oparms.reconnect = false;
+	oparms = (struct cifs_open_parms) {
+		.tcon = tcon,
+		.cifs_sb = cifs_sb,
+		.desired_access = GENERIC_READ,
+		.create_options = cifs_create_options(cifs_sb, CREATE_NOT_DIR),
+		.disposition = FILE_OPEN,
+		.fid = &fid,
+	};
 
 	utf16_path = cifs_convert_path_to_utf16(path, cifs_sb);
 	if (utf16_path == NULL)
@@ -448,14 +451,15 @@ smb3_create_mf_symlink(unsigned int xid, struct cifs_tcon *tcon,
 	if (!utf16_path)
 		return -ENOMEM;
 
-	oparms.tcon = tcon;
-	oparms.cifs_sb = cifs_sb;
-	oparms.desired_access = GENERIC_WRITE;
-	oparms.create_options = cifs_create_options(cifs_sb, CREATE_NOT_DIR);
-	oparms.disposition = FILE_CREATE;
-	oparms.fid = &fid;
-	oparms.reconnect = false;
-	oparms.mode = 0644;
+	oparms = (struct cifs_open_parms) {
+		.tcon = tcon,
+		.cifs_sb = cifs_sb,
+		.desired_access = GENERIC_WRITE,
+		.create_options = cifs_create_options(cifs_sb, CREATE_NOT_DIR),
+		.disposition = FILE_CREATE,
+		.fid = &fid,
+		.mode = 0644,
+	};
 
 	rc = SMB2_open(xid, &oparms, utf16_path, &oplock, NULL, NULL,
 		       NULL, NULL);
* Unmerged path fs/cifs/smb1ops.c
diff --git a/fs/cifs/smb2inode.c b/fs/cifs/smb2inode.c
index 1ebb1e3c4f54..1b07cda3f429 100644
--- a/fs/cifs/smb2inode.c
+++ b/fs/cifs/smb2inode.c
@@ -99,14 +99,15 @@ smb2_compound_op(const unsigned int xid, struct cifs_tcon *tcon,
 		goto finished;
 	}
 
-	vars->oparms.tcon = tcon;
-	vars->oparms.desired_access = desired_access;
-	vars->oparms.disposition = create_disposition;
-	vars->oparms.create_options = cifs_create_options(cifs_sb, create_options);
-	vars->oparms.fid = &fid;
-	vars->oparms.reconnect = false;
-	vars->oparms.mode = mode;
-	vars->oparms.cifs_sb = cifs_sb;
+	vars->oparms = (struct cifs_open_parms) {
+		.tcon = tcon,
+		.desired_access = desired_access,
+		.disposition = create_disposition,
+		.create_options = cifs_create_options(cifs_sb, create_options),
+		.fid = &fid,
+		.mode = mode,
+		.cifs_sb = cifs_sb,
+	};
 
 	rqst[num_rqst].rq_iov = &vars->open_iov[0];
 	rqst[num_rqst].rq_nvec = SMB2_CREATE_IOV_SIZE;
* Unmerged path fs/cifs/smb2ops.c
