efi: libstub: Move screen_info handling to common code

jira LE-2157
Rebuild_History Non-Buildable kernel-5.14.0-503.14.1.el9_5
commit-author Ard Biesheuvel <ardb@kernel.org>
commit 732ea9db9d8a6a0444d18ed810cccb2428d8766b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-5.14.0-503.14.1.el9_5/732ea9db.failed

Currently, arm64, RISC-V and LoongArch rely on the fact that struct
screen_info can be accessed directly, due to the fact that the EFI stub
and the core kernel are part of the same image. This will change after a
future patch, so let's ensure that the screen_info handling is able to
deal with this, by adopting the arm32 approach of passing it as a
configuration table. While at it, switch to ACPI reclaim memory to hold
the screen_info data, which is more appropriate for this kind of
allocation.

	Signed-off-by: Ard Biesheuvel <ardb@kernel.org>
(cherry picked from commit 732ea9db9d8a6a0444d18ed810cccb2428d8766b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/arm64/include/asm/efi.h
#	arch/loongarch/include/asm/efi.h
#	arch/loongarch/kernel/efi.c
#	arch/riscv/include/asm/efi.h
#	drivers/firmware/efi/efi-init.c
#	drivers/firmware/efi/efi.c
#	drivers/firmware/efi/libstub/Makefile
#	drivers/firmware/efi/libstub/screen_info.c
diff --cc arch/arm64/include/asm/efi.h
index 4cf2cb053bc8,8604473a85b8..000000000000
--- a/arch/arm64/include/asm/efi.h
+++ b/arch/arm64/include/asm/efi.h
@@@ -97,25 -84,7 +97,28 @@@ static inline unsigned long efi_get_max
  	return (image_addr & ~(SZ_1G - 1UL)) + (1UL << (VA_BITS_MIN - 1));
  }
  
++<<<<<<< HEAD
 +static inline unsigned long efi_get_kimg_min_align(void)
 +{
 +	extern bool efi_nokaslr;
 +
 +	/*
 +	 * Although relocatable kernels can fix up the misalignment with
 +	 * respect to MIN_KIMG_ALIGN, the resulting virtual text addresses are
 +	 * subtly out of sync with those recorded in the vmlinux when kaslr is
 +	 * disabled but the image required relocation anyway. Therefore retain
 +	 * 2M alignment if KASLR was explicitly disabled, even if it was not
 +	 * going to be activated to begin with.
 +	 */
 +	return efi_nokaslr ? MIN_KIMG_ALIGN : EFI_KIMG_ALIGN;
 +}
 +
++=======
++>>>>>>> 732ea9db9d8a (efi: libstub: Move screen_info handling to common code)
  #define EFI_ALLOC_ALIGN		SZ_64K
 +#define EFI_ALLOC_LIMIT		((1UL << 48) - 1)
 +
 +extern unsigned long primary_entry_offset(void);
  
  /*
   * On ARM systems, virtually remapped UEFI runtime services are set up in two
diff --cc arch/riscv/include/asm/efi.h
index 1950fff0b9de,d0570936cb8c..000000000000
--- a/arch/riscv/include/asm/efi.h
+++ b/arch/riscv/include/asm/efi.h
@@@ -31,17 -31,6 +31,20 @@@ static inline unsigned long efi_get_max
  	return ULONG_MAX;
  }
  
++<<<<<<< HEAD
 +static inline unsigned long efi_get_kimg_min_align(void)
 +{
 +	/*
 +	 * RISC-V requires the kernel image to placed 2 MB aligned base for 64
 +	 * bit and 4MB for 32 bit.
 +	 */
 +	return IS_ENABLED(CONFIG_64BIT) ? SZ_2M : SZ_4M;
 +}
 +
 +#define EFI_KIMG_PREFERRED_ADDRESS	efi_get_kimg_min_align()
 +
++=======
++>>>>>>> 732ea9db9d8a (efi: libstub: Move screen_info handling to common code)
  void efi_virtmap_load(void);
  void efi_virtmap_unload(void);
  
diff --cc drivers/firmware/efi/efi-init.c
index ef0820f1a924,1639159493e3..000000000000
--- a/drivers/firmware/efi/efi-init.c
+++ b/drivers/firmware/efi/efi-init.c
@@@ -72,9 -72,6 +72,12 @@@ static void __init init_screen_info(voi
  		if (memblock_is_map_memory(screen_info.lfb_base))
  			memblock_mark_nomap(screen_info.lfb_base,
  					    screen_info.lfb_size);
++<<<<<<< HEAD
 +
 +		if (IS_ENABLED(CONFIG_EFI_EARLYCON))
 +			efi_earlycon_reprobe();
++=======
++>>>>>>> 732ea9db9d8a (efi: libstub: Move screen_info handling to common code)
  	}
  }
  
diff --cc drivers/firmware/efi/efi.c
index 5e01d9ba614c,951a42d27cf4..000000000000
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@@ -604,8 -549,8 +604,13 @@@ static const efi_config_table_type_t co
  #ifdef CONFIG_EFI_COCO_SECRET
  	{LINUX_EFI_COCO_SECRET_AREA_GUID,	&efi.coco_secret,	"CocoSecret"	},
  #endif
++<<<<<<< HEAD
 +#ifdef CONFIG_UNACCEPTED_MEMORY
 +	{LINUX_EFI_UNACCEPTED_MEM_TABLE_GUID,	&efi.unaccepted,	"Unaccepted"	},
++=======
+ #ifdef CONFIG_EFI_GENERIC_STUB
+ 	{LINUX_EFI_SCREEN_INFO_TABLE_GUID,	&screen_info_table			},
++>>>>>>> 732ea9db9d8a (efi: libstub: Move screen_info handling to common code)
  #endif
  	{},
  };
diff --cc drivers/firmware/efi/libstub/Makefile
index 200d57ba0a5a,3f44e272ff9c..000000000000
--- a/drivers/firmware/efi/libstub/Makefile
+++ b/drivers/firmware/efi/libstub/Makefile
@@@ -77,15 -81,15 +77,20 @@@ efi-deps-y := fdt_rw.c fdt_ro.c fdt_wip
  $(obj)/lib-%.o: $(srctree)/lib/%.c FORCE
  	$(call if_changed_rule,cc_o_c)
  
++<<<<<<< HEAD
 +lib-$(CONFIG_EFI_GENERIC_STUB)	+= efi-stub.o fdt.o string.o intrinsics.o \
 +				   $(patsubst %.c,lib-%.o,$(efi-deps-y)) \
 +				   systable.o screen_info.o efi-stub-entry.o
++=======
+ lib-$(CONFIG_EFI_GENERIC_STUB)	+= efi-stub.o string.o intrinsics.o systable.o \
+ 				   screen_info.o
++>>>>>>> 732ea9db9d8a (efi: libstub: Move screen_info handling to common code)
  
  lib-$(CONFIG_ARM)		+= arm32-stub.o
 -lib-$(CONFIG_ARM64)		+= arm64-stub.o arm64-entry.o
 +lib-$(CONFIG_ARM64)		+= arm64.o arm64-stub.o
  lib-$(CONFIG_X86)		+= x86-stub.o
 +lib-$(CONFIG_X86_64)		+= x86-5lvl.o
  lib-$(CONFIG_RISCV)		+= riscv-stub.o
 -lib-$(CONFIG_LOONGARCH)		+= loongarch-stub.o
 -
  CFLAGS_arm32-stub.o		:= -DTEXT_OFFSET=$(TEXT_OFFSET)
  
  zboot-obj-$(CONFIG_RISCV)	:= lib-clz_ctz.o lib-ashldi3.o
diff --cc drivers/firmware/efi/libstub/screen_info.c
index a51ec201ca3c,8e76a8b384ba..000000000000
--- a/drivers/firmware/efi/libstub/screen_info.c
+++ b/drivers/firmware/efi/libstub/screen_info.c
@@@ -1,8 -1,6 +1,11 @@@
  // SPDX-License-Identifier: GPL-2.0
  
  #include <linux/efi.h>
++<<<<<<< HEAD
 +#include <linux/screen_info.h>
 +
++=======
++>>>>>>> 732ea9db9d8a (efi: libstub: Move screen_info handling to common code)
  #include <asm/efi.h>
  
  #include "efistub.h"
@@@ -17,11 -15,18 +20,26 @@@
   * early, but it only works if the EFI stub is part of the core kernel image
   * itself. The zboot decompressor can only use the configuration table
   * approach.
++<<<<<<< HEAD
 + */
 +
 +static efi_guid_t screen_info_guid = LINUX_EFI_SCREEN_INFO_TABLE_GUID;
 +
 +struct screen_info *__alloc_screen_info(void)
++=======
+  *
+  * In order to support both methods from the same build of the EFI stub
+  * library, provide this dummy global definition of struct screen_info. If it
+  * is required to satisfy a link dependency, it means we need to override the
+  * __weak alloc and free methods with the ones below, and those will be pulled
+  * in as well.
+  */
+ struct screen_info screen_info;
+ 
+ static efi_guid_t screen_info_guid = LINUX_EFI_SCREEN_INFO_TABLE_GUID;
+ 
+ struct screen_info *alloc_screen_info(void)
++>>>>>>> 732ea9db9d8a (efi: libstub: Move screen_info handling to common code)
  {
  	struct screen_info *si;
  	efi_status_t status;
* Unmerged path arch/loongarch/include/asm/efi.h
* Unmerged path arch/loongarch/kernel/efi.c
* Unmerged path arch/arm64/include/asm/efi.h
* Unmerged path arch/loongarch/include/asm/efi.h
* Unmerged path arch/loongarch/kernel/efi.c
* Unmerged path arch/riscv/include/asm/efi.h
* Unmerged path drivers/firmware/efi/efi-init.c
* Unmerged path drivers/firmware/efi/efi.c
* Unmerged path drivers/firmware/efi/libstub/Makefile
diff --git a/drivers/firmware/efi/libstub/efi-stub.c b/drivers/firmware/efi/libstub/efi-stub.c
index 164a248ee1b8..d07cd6ab9846 100644
--- a/drivers/firmware/efi/libstub/efi-stub.c
+++ b/drivers/firmware/efi/libstub/efi-stub.c
@@ -43,6 +43,15 @@ void __weak free_screen_info(struct screen_info *si)
 {
 }
 
+struct screen_info * __weak alloc_screen_info(void)
+{
+	return &screen_info;
+}
+
+void __weak free_screen_info(struct screen_info *si)
+{
+}
+
 static struct screen_info *setup_graphics(void)
 {
 	efi_guid_t gop_proto = EFI_GRAPHICS_OUTPUT_PROTOCOL_GUID;
diff --git a/drivers/firmware/efi/libstub/efistub.h b/drivers/firmware/efi/libstub/efistub.h
index 0b51ef7ffe30..e45434ac5029 100644
--- a/drivers/firmware/efi/libstub/efistub.h
+++ b/drivers/firmware/efi/libstub/efistub.h
@@ -1156,4 +1156,7 @@ void arch_accept_memory(phys_addr_t start, phys_addr_t end);
 asmlinkage efi_status_t __efiapi
 efi_zboot_entry(efi_handle_t handle, efi_system_table_t *systab);
 
+struct screen_info *alloc_screen_info(void);
+void free_screen_info(struct screen_info *si);
+
 #endif
* Unmerged path drivers/firmware/efi/libstub/screen_info.c
