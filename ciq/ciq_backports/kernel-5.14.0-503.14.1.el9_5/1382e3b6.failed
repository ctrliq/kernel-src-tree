net: change maximum number of UDP segments to 128

jira LE-2157
cve CVE-2024-43817
Rebuild_History Non-Buildable kernel-5.14.0-503.14.1.el9_5
commit-author Yuri Benditovich <yuri.benditovich@daynix.com>
commit 1382e3b6a3500c245e5278c66d210c02926f804f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-5.14.0-503.14.1.el9_5/1382e3b6.failed

The commit fc8b2a619469
("net: more strict VIRTIO_NET_HDR_GSO_UDP_L4 validation")
adds check of potential number of UDP segments vs
UDP_MAX_SEGMENTS in linux/virtio_net.h.
After this change certification test of USO guest-to-guest
transmit on Windows driver for virtio-net device fails,
for example with packet size of ~64K and mss of 536 bytes.
In general the USO should not be more restrictive than TSO.
Indeed, in case of unreasonably small mss a lot of segments
can cause queue overflow and packet loss on the destination.
Limit of 128 segments is good for any practical purpose,
with minimal meaningful mss of 536 the maximal UDP packet will
be divided to ~120 segments.
The number of segments for UDP packets is validated vs
UDP_MAX_SEGMENTS also in udp.c (v4,v6), this does not affect
quest-to-guest path but does affect packets sent to host, for
example.
It is important to mention that UDP_MAX_SEGMENTS is kernel-only
define and not available to user mode socket applications.
In order to request MSS smaller than MTU the applications
just uses setsockopt with SOL_UDP and UDP_SEGMENT and there is
no limitations on socket API level.

Fixes: fc8b2a619469 ("net: more strict VIRTIO_NET_HDR_GSO_UDP_L4 validation")
	Signed-off-by: Yuri Benditovich <yuri.benditovich@daynix.com>
	Reviewed-by: Willem de Bruijn <willemb@google.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 1382e3b6a3500c245e5278c66d210c02926f804f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/udp.h
diff --cc include/linux/udp.h
index 52e4245ad17e,e398e1dbd2d3..000000000000
--- a/include/linux/udp.h
+++ b/include/linux/udp.h
@@@ -89,13 -92,31 +89,28 @@@ struct udp_sock 
  
  	/* This fields follows rcvbuf value, and is touched by udp_recvmsg */
  	int		forward_threshold;
 -
 -	/* Cache friendly copy of sk->sk_peek_off >= 0 */
 -	bool		peeking_with_offset;
  };
  
++<<<<<<< HEAD
 +#define UDP_MAX_SEGMENTS	(1 << 6UL)
++=======
+ #define udp_test_bit(nr, sk)			\
+ 	test_bit(UDP_FLAGS_##nr, &udp_sk(sk)->udp_flags)
+ #define udp_set_bit(nr, sk)			\
+ 	set_bit(UDP_FLAGS_##nr, &udp_sk(sk)->udp_flags)
+ #define udp_test_and_set_bit(nr, sk)		\
+ 	test_and_set_bit(UDP_FLAGS_##nr, &udp_sk(sk)->udp_flags)
+ #define udp_clear_bit(nr, sk)			\
+ 	clear_bit(UDP_FLAGS_##nr, &udp_sk(sk)->udp_flags)
+ #define udp_assign_bit(nr, sk, val)		\
+ 	assign_bit(UDP_FLAGS_##nr, &udp_sk(sk)->udp_flags, val)
+ 
+ #define UDP_MAX_SEGMENTS	(1 << 7UL)
++>>>>>>> 1382e3b6a350 (net: change maximum number of UDP segments to 128)
  
 -#define udp_sk(ptr) container_of_const(ptr, struct udp_sock, inet.sk)
 -
 -static inline int udp_set_peek_off(struct sock *sk, int val)
 +static inline struct udp_sock *udp_sk(const struct sock *sk)
  {
 -	sk_set_peek_off(sk, val);
 -	WRITE_ONCE(udp_sk(sk)->peeking_with_offset, val >= 0);
 -	return 0;
 +	return (struct udp_sock *)sk;
  }
  
  static inline void udp_set_no_check6_tx(struct sock *sk, bool val)
* Unmerged path include/linux/udp.h
diff --git a/tools/testing/selftests/net/udpgso.c b/tools/testing/selftests/net/udpgso.c
index 7badaf215de2..b02080d09fbc 100644
--- a/tools/testing/selftests/net/udpgso.c
+++ b/tools/testing/selftests/net/udpgso.c
@@ -34,7 +34,7 @@
 #endif
 
 #ifndef UDP_MAX_SEGMENTS
-#define UDP_MAX_SEGMENTS	(1 << 6UL)
+#define UDP_MAX_SEGMENTS	(1 << 7UL)
 #endif
 
 #define CONST_MTU_TEST	1500
