xfs: fix integer overflows in the fsmap rtbitmap and logdev backends

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-539.el8
commit-author Darrick J. Wong <djwong@kernel.org>
commit 7975aba19cba4eba7ff60410f9294c90edc96dcf
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-539.el8/7975aba1.failed

It's not correct to use the rmap irec structure to hold query key
information to query the rtbitmap because the realtime volume can be
longer than 2^32 fsblocks in length.  Because the rt volume doesn't have
allocation groups, introduce a daddr-based record filtering algorithm
and compute the rtextent values using 64-bit variables.  The same
problem exists in the external log device fsmap implementation, so use
the same solution to fix it too.

After this patch, all the code that touches info->low and info->high
under xfs_getfsmap_logdev and __xfs_getfsmap_rtdev are unnecessary.
Cleaning this up will be done in subsequent patches.

Fixes: 4c934c7dd60c ("xfs: report realtime space information via the rtbitmap")
	Signed-off-by: Darrick J. Wong <djwong@kernel.org>
	Reviewed-by: Dave Chinner <dchinner@redhat.com>
(cherry picked from commit 7975aba19cba4eba7ff60410f9294c90edc96dcf)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_fsmap.c
diff --cc fs/xfs/xfs_fsmap.c
index a34989b10f79,901918116d3d..000000000000
--- a/fs/xfs/xfs_fsmap.c
+++ b/fs/xfs/xfs_fsmap.c
@@@ -263,8 -268,9 +268,14 @@@ STATIC in
  xfs_getfsmap_helper(
  	struct xfs_trans		*tp,
  	struct xfs_getfsmap_info	*info,
++<<<<<<< HEAD
 +	struct xfs_rmap_irec		*rec,
 +	xfs_daddr_t			rec_daddr)
++=======
+ 	const struct xfs_rmap_irec	*rec,
+ 	xfs_daddr_t			rec_daddr,
+ 	xfs_daddr_t			len_daddr)
++>>>>>>> 7975aba19cba (xfs: fix integer overflows in the fsmap rtbitmap and logdev backends)
  {
  	struct xfs_fsmap		fmr;
  	struct xfs_mount		*mp = tp->t_mountp;
@@@ -468,18 -487,24 +492,24 @@@ xfs_getfsmap_logdev
  /* Transform a rtbitmap "record" into a fsmap */
  STATIC int
  xfs_getfsmap_rtdev_rtbitmap_helper(
 -	struct xfs_mount		*mp,
  	struct xfs_trans		*tp,
 -	const struct xfs_rtalloc_rec	*rec,
 +	struct xfs_rtalloc_rec		*rec,
  	void				*priv)
  {
 +	struct xfs_mount		*mp = tp->t_mountp;
  	struct xfs_getfsmap_info	*info = priv;
  	struct xfs_rmap_irec		irec;
- 	xfs_daddr_t			rec_daddr;
+ 	xfs_rtblock_t			rtbno;
+ 	xfs_daddr_t			rec_daddr, len_daddr;
+ 
+ 	rtbno = rec->ar_startext * mp->m_sb.sb_rextsize;
+ 	rec_daddr = XFS_FSB_TO_BB(mp, rtbno);
+ 	irec.rm_startblock = rtbno;
+ 
+ 	rtbno = rec->ar_extcount * mp->m_sb.sb_rextsize;
+ 	len_daddr = XFS_FSB_TO_BB(mp, rtbno);
+ 	irec.rm_blockcount = rtbno;
  
- 	irec.rm_startblock = rec->ar_startext * mp->m_sb.sb_rextsize;
- 	rec_daddr = XFS_FSB_TO_BB(mp, irec.rm_startblock);
- 	irec.rm_blockcount = rec->ar_extcount * mp->m_sb.sb_rextsize;
  	irec.rm_owner = XFS_RMAP_OWN_NULL;	/* "free" */
  	irec.rm_offset = 0;
  	irec.rm_flags = 0;
@@@ -539,16 -576,21 +581,27 @@@ xfs_getfsmap_rtdev_rtbitmap_query
  {
  	struct xfs_rtalloc_rec		alow = { 0 };
  	struct xfs_rtalloc_rec		ahigh = { 0 };
 -	struct xfs_mount		*mp = tp->t_mountp;
  	int				error;
  
 -	xfs_ilock(mp->m_rbmip, XFS_ILOCK_SHARED | XFS_ILOCK_RTBITMAP);
 +	xfs_ilock(tp->t_mountp->m_rbmip, XFS_ILOCK_SHARED);
  
++<<<<<<< HEAD
 +	alow.ar_startext = info->low.rm_startblock;
 +	ahigh.ar_startext = info->high.rm_startblock;
 +	do_div(alow.ar_startext, tp->t_mountp->m_sb.sb_rextsize);
 +	if (do_div(ahigh.ar_startext, tp->t_mountp->m_sb.sb_rextsize))
++=======
+ 	/*
+ 	 * Set up query parameters to return free rtextents covering the range
+ 	 * we want.
+ 	 */
+ 	alow.ar_startext = start_rtb;
+ 	ahigh.ar_startext = end_rtb;
+ 	do_div(alow.ar_startext, mp->m_sb.sb_rextsize);
+ 	if (do_div(ahigh.ar_startext, mp->m_sb.sb_rextsize))
++>>>>>>> 7975aba19cba (xfs: fix integer overflows in the fsmap rtbitmap and logdev backends)
  		ahigh.ar_startext++;
 -	error = xfs_rtalloc_query_range(mp, tp, &alow, &ahigh,
 +	error = xfs_rtalloc_query_range(tp, &alow, &ahigh,
  			xfs_getfsmap_rtdev_rtbitmap_helper, info);
  	if (error)
  		goto err;
* Unmerged path fs/xfs/xfs_fsmap.c
