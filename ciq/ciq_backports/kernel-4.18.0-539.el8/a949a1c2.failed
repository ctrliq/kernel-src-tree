xfs: fix logdev fsmap query result filtering

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-539.el8
commit-author Darrick J. Wong <djwong@kernel.org>
commit a949a1c2a198e048630a8b0741a99b85a5d88136
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-539.el8/a949a1c2.failed

The external log device fsmap backend doesn't have an rmapbt to query,
so it's wasteful to spend time initializing the rmap_irec objects.
Worse yet, the log could (someday) be longer than 2^32 fsblocks, so
using the rmap irec structure will result in integer overflows.

Fix this mess by computing the start address that we want from keys[0]
directly, and use the daddr-based record filtering algorithm that we
also use for rtbitmap queries.

Fixes: e89c041338ed ("xfs: implement the GETFSMAP ioctl")
	Signed-off-by: Darrick J. Wong <djwong@kernel.org>
	Reviewed-by: Dave Chinner <dchinner@redhat.com>
(cherry picked from commit a949a1c2a198e048630a8b0741a99b85a5d88136)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_fsmap.c
diff --cc fs/xfs/xfs_fsmap.c
index a34989b10f79,ae20aba6ebfe..000000000000
--- a/fs/xfs/xfs_fsmap.c
+++ b/fs/xfs/xfs_fsmap.c
@@@ -427,31 -436,25 +427,51 @@@ xfs_getfsmap_logdev
  {
  	struct xfs_mount		*mp = tp->t_mountp;
  	struct xfs_rmap_irec		rmap;
++<<<<<<< HEAD
 +	int				error;
 +
 +	/* Set up search keys */
 +	info->low.rm_startblock = XFS_BB_TO_FSBT(mp, keys[0].fmr_physical);
 +	info->low.rm_offset = XFS_BB_TO_FSBT(mp, keys[0].fmr_offset);
 +	error = xfs_fsmap_owner_to_rmap(&info->low, keys);
 +	if (error)
 +		return error;
 +	info->low.rm_blockcount = 0;
 +	xfs_getfsmap_set_irec_flags(&info->low, &keys[0]);
 +
 +	error = xfs_fsmap_owner_to_rmap(&info->high, keys + 1);
 +	if (error)
 +		return error;
 +	info->high.rm_startblock = -1U;
 +	info->high.rm_owner = ULLONG_MAX;
 +	info->high.rm_offset = ULLONG_MAX;
 +	info->high.rm_blockcount = 0;
 +	info->high.rm_flags = XFS_RMAP_KEY_FLAGS | XFS_RMAP_REC_FLAGS;
 +	info->missing_owner = XFS_FMR_OWN_FREE;
 +
 +	trace_xfs_fsmap_low_key(mp, info->dev, NULLAGNUMBER, &info->low);
 +	trace_xfs_fsmap_high_key(mp, info->dev, NULLAGNUMBER, &info->high);
++=======
+ 	xfs_daddr_t			rec_daddr, len_daddr;
+ 	xfs_fsblock_t			start_fsb, end_fsb;
+ 	uint64_t			eofs;
+ 
+ 	eofs = XFS_FSB_TO_BB(mp, mp->m_sb.sb_logblocks);
+ 	if (keys[0].fmr_physical >= eofs)
+ 		return 0;
+ 	start_fsb = XFS_BB_TO_FSBT(mp,
+ 				keys[0].fmr_physical + keys[0].fmr_length);
+ 	end_fsb = XFS_BB_TO_FSB(mp, min(eofs - 1, keys[1].fmr_physical));
+ 
+ 	/* Adjust the low key if we are continuing from where we left off. */
+ 	if (keys[0].fmr_length > 0)
+ 		info->low_daddr = XFS_FSB_TO_BB(mp, start_fsb);
+ 
+ 	trace_xfs_fsmap_low_key_linear(mp, info->dev, start_fsb);
+ 	trace_xfs_fsmap_high_key_linear(mp, info->dev, end_fsb);
++>>>>>>> a949a1c2a198 (xfs: fix logdev fsmap query result filtering)
  
 -	if (start_fsb > 0)
 +	if (keys[0].fmr_physical > 0)
  		return 0;
  
  	/* Fabricate an rmap entry for the external log device. */
* Unmerged path fs/xfs/xfs_fsmap.c
