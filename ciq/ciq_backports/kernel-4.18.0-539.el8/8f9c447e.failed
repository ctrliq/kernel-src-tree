tools/vm/page_owner_sort.c: support sorting pid and time

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-539.el8
commit-author Chongxi Zhao <zhaochongxi2019@email.szu.edu.cn>
commit 8f9c447e2e2b53c2db4fac85fc42ecada8b39e52
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-539.el8/8f9c447e.failed

When viewing the page owner information, we expect that the information
can be sorted by PID, so that we can quickly combine PID with the program
to check the information together.

We also expect that the information can be sorted by time.  Time sorting
helps to view the running status of the program according to the time
interval when the program hangs up.

Finally, we hope to pass the page_ owner_ Sort.  C can reduce part of the
output and only output the plate information whose memory has not been
released, which can make us locate the problem of the program faster.
Therefore, the following adjustments have been made:

1. Add the static functions search_pattern and check_regcomp to
   improve the cleanliness.

2. Add member attributes and their corresponding sorting methods.  In
   terms of comparison time, int will overflow because the data of ull is
   too large, so the ternary operator is used

3. Add the -f parameter to filter out the information of blocks whose
   memory has not been released

Link: https://lkml.kernel.org/r/20211206165653.5093-1-zhaochongxi2019@email.szu.edu.cn
	Signed-off-by: Chongxi Zhao <zhaochongxi2019@email.szu.edu.cn>
	Reviewed-by: Sean Anderson <seanga2@gmail.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 8f9c447e2e2b53c2db4fac85fc42ecada8b39e52)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/vm/page_owner_sort.c
diff --cc tools/vm/page_owner_sort.c
index 85eb65ea16d3,c9fedc1806d5..000000000000
--- a/tools/vm/page_owner_sort.c
+++ b/tools/vm/page_owner_sort.c
@@@ -16,14 -18,25 +16,33 @@@
  #include <fcntl.h>
  #include <unistd.h>
  #include <string.h>
++<<<<<<< HEAD
++=======
+ #include <regex.h>
+ #include <errno.h>
+ #include <linux/types.h>
++>>>>>>> 8f9c447e2e2b (tools/vm/page_owner_sort.c: support sorting pid and time)
  
  struct block_list {
  	char *txt;
 -	char *stacktrace;
  	int len;
  	int num;
++<<<<<<< HEAD
 +};
 +
 +
++=======
+ 	int page_num;
+ 	pid_t pid;
+ 	__u64 ts_nsec;
+ 	__u64 free_ts_nsec;
+ };
+ 
+ static regex_t order_pattern;
+ static regex_t pid_pattern;
+ static regex_t ts_nsec_pattern;
+ static regex_t free_ts_nsec_pattern;
++>>>>>>> 8f9c447e2e2b (tools/vm/page_owner_sort.c: support sorting pid and time)
  static struct block_list *list;
  static int list_size;
  static int max_size;
@@@ -59,6 -79,133 +78,136 @@@ static int compare_num(const void *p1, 
  	return l2->num - l1->num;
  }
  
++<<<<<<< HEAD
++=======
+ static int compare_page_num(const void *p1, const void *p2)
+ {
+ 	const struct block_list *l1 = p1, *l2 = p2;
+ 
+ 	return l2->page_num - l1->page_num;
+ }
+ 
+ static int compare_pid(const void *p1, const void *p2)
+ {
+ 	const struct block_list *l1 = p1, *l2 = p2;
+ 
+ 	return l1->pid - l2->pid;
+ }
+ 
+ static int compare_ts(const void *p1, const void *p2)
+ {
+ 	const struct block_list *l1 = p1, *l2 = p2;
+ 
+ 	return l1->ts_nsec < l2->ts_nsec ? -1 : 1;
+ }
+ 
+ static int compare_free_ts(const void *p1, const void *p2)
+ {
+ 	const struct block_list *l1 = p1, *l2 = p2;
+ 
+ 	return l1->free_ts_nsec < l2->free_ts_nsec ? -1 : 1;
+ }
+ 
+ static int search_pattern(regex_t *pattern, char *pattern_str, char *buf)
+ {
+ 	int err, val_len;
+ 	regmatch_t pmatch[2];
+ 
+ 	err = regexec(pattern, buf, 2, pmatch, REG_NOTBOL);
+ 	if (err != 0 || pmatch[1].rm_so == -1) {
+ 		printf("no matching pattern in %s\n", buf);
+ 		return -1;
+ 	}
+ 	val_len = pmatch[1].rm_eo - pmatch[1].rm_so;
+ 
+ 	memcpy(pattern_str, buf + pmatch[1].rm_so, val_len);
+ 
+ 	return 0;
+ }
+ 
+ static void check_regcomp(regex_t *pattern, const char *regex)
+ {
+ 	int err;
+ 
+ 	err = regcomp(pattern, regex, REG_EXTENDED | REG_NEWLINE);
+ 	if (err != 0 || pattern->re_nsub != 1) {
+ 		printf("Invalid pattern %s code %d\n", regex, err);
+ 		exit(1);
+ 	}
+ }
+ 
+ # define FIELD_BUFF 25
+ 
+ static int get_page_num(char *buf)
+ {
+ 	int order_val;
+ 	char order_str[FIELD_BUFF] = {0};
+ 	char *endptr;
+ 
+ 	search_pattern(&order_pattern, order_str, buf);
+ 	errno = 0;
+ 	order_val = strtol(order_str, &endptr, 10);
+ 	if (order_val > 64 || errno != 0 || endptr == order_str || *endptr != '\0') {
+ 		printf("wrong order in follow buf:\n%s\n", buf);
+ 		return 0;
+ 	}
+ 
+ 	return 1 << order_val;
+ }
+ 
+ static pid_t get_pid(char *buf)
+ {
+ 	pid_t pid;
+ 	char pid_str[FIELD_BUFF] = {0};
+ 	char *endptr;
+ 
+ 	search_pattern(&pid_pattern, pid_str, buf);
+ 	errno = 0;
+ 	pid = strtol(pid_str, &endptr, 10);
+ 	if (errno != 0 || endptr == pid_str || *endptr != '\0') {
+ 		printf("wrong/invalid pid in follow buf:\n%s\n", buf);
+ 		return -1;
+ 	}
+ 
+ 	return pid;
+ 
+ }
+ 
+ static __u64 get_ts_nsec(char *buf)
+ {
+ 	__u64 ts_nsec;
+ 	char ts_nsec_str[FIELD_BUFF] = {0};
+ 	char *endptr;
+ 
+ 	search_pattern(&ts_nsec_pattern, ts_nsec_str, buf);
+ 	errno = 0;
+ 	ts_nsec = strtoull(ts_nsec_str, &endptr, 10);
+ 	if (errno != 0 || endptr == ts_nsec_str || *endptr != '\0') {
+ 		printf("wrong ts_nsec in follow buf:\n%s\n", buf);
+ 		return -1;
+ 	}
+ 
+ 	return ts_nsec;
+ }
+ 
+ static __u64 get_free_ts_nsec(char *buf)
+ {
+ 	__u64 free_ts_nsec;
+ 	char free_ts_nsec_str[FIELD_BUFF] = {0};
+ 	char *endptr;
+ 
+ 	search_pattern(&free_ts_nsec_pattern, free_ts_nsec_str, buf);
+ 	errno = 0;
+ 	free_ts_nsec = strtoull(free_ts_nsec_str, &endptr, 10);
+ 	if (errno != 0 || endptr == free_ts_nsec_str || *endptr != '\0') {
+ 		printf("wrong free_ts_nsec in follow buf:\n%s\n", buf);
+ 		return -1;
+ 	}
+ 
+ 	return free_ts_nsec;
+ }
+ 
++>>>>>>> 8f9c447e2e2b (tools/vm/page_owner_sort.c: support sorting pid and time)
  static void add_list(char *buf, int len)
  {
  	if (list_size != 0 &&
@@@ -74,8 -222,15 +223,17 @@@
  	list[list_size].txt = malloc(len+1);
  	list[list_size].len = len;
  	list[list_size].num = 1;
 -	list[list_size].page_num = get_page_num(buf);
  	memcpy(list[list_size].txt, buf, len);
  	list[list_size].txt[len] = 0;
++<<<<<<< HEAD
++=======
+ 	list[list_size].stacktrace = strchr(list[list_size].txt, '\n') ?: "";
+ 	list[list_size].pid = get_pid(buf);
+ 	list[list_size].ts_nsec = get_ts_nsec(buf);
+ 	list[list_size].free_ts_nsec = get_free_ts_nsec(buf);
+ 	memcpy(list[list_size].txt, buf, len);
+ 	list[list_size].txt[len] = 0;
++>>>>>>> 8f9c447e2e2b (tools/vm/page_owner_sort.c: support sorting pid and time)
  	list_size++;
  	if (list_size % 1000 == 0) {
  		printf("loaded %d\r", list_size);
@@@ -85,28 -240,79 +243,101 @@@
  
  #define BUF_SIZE	(128 * 1024)
  
++<<<<<<< HEAD
 +int main(int argc, char **argv)
 +{
++=======
+ static void usage(void)
+ {
+ 	printf("Usage: ./page_owner_sort [OPTIONS] <input> <output>\n"
+ 		"-m	Sort by total memory.\n"
+ 		"-s	Sort by the stack trace.\n"
+ 		"-t	Sort by times (default).\n"
+ 		"-p	Sort by pid.\n"
+ 		"-a	Sort by memory allocate time.\n"
+ 		"-r	Sort by memory release time.\n"
+ 		"-c	cull by comparing stacktrace instead of total block.\n"
+ 	);
+ }
+ 
+ int main(int argc, char **argv)
+ {
+ 	int (*cmp)(const void *, const void *) = compare_num;
+ 	int cull_st = 0;
+ 	int filter = 0;
++>>>>>>> 8f9c447e2e2b (tools/vm/page_owner_sort.c: support sorting pid and time)
  	FILE *fin, *fout;
  	char *buf;
  	int ret, i, count;
  	struct block_list *list2;
  	struct stat st;
++<<<<<<< HEAD
 +
 +	if (argc < 3) {
 +		printf("Usage: ./program <input> <output>\n");
++=======
+ 	int opt;
+ 
+ 	while ((opt = getopt(argc, argv, "acfmprst")) != -1)
+ 		switch (opt) {
+ 		case 'a':
+ 			cmp = compare_ts;
+ 			break;
+ 		case 'c':
+ 			cull_st = 1;
+ 			break;
+ 		case 'f':
+ 			filter = 1;
+ 			break;
+ 		case 'm':
+ 			cmp = compare_page_num;
+ 			break;
+ 		case 'p':
+ 			cmp = compare_pid;
+ 			break;
+ 		case 'r':
+ 			cmp = compare_free_ts;
+ 			break;
+ 		case 's':
+ 			cmp = compare_stacktrace;
+ 			break;
+ 		case 't':
+ 			cmp = compare_num;
+ 			break;
+ 		default:
+ 			usage();
+ 			exit(1);
+ 		}
+ 
+ 	if (optind >= (argc - 1)) {
+ 		usage();
+ 		exit(1);
+ 	}
+ 
+ 	fin = fopen(argv[optind], "r");
+ 	fout = fopen(argv[optind + 1], "w");
+ 	if (!fin || !fout) {
+ 		usage();
++>>>>>>> 8f9c447e2e2b (tools/vm/page_owner_sort.c: support sorting pid and time)
  		perror("open: ");
  		exit(1);
  	}
  
++<<<<<<< HEAD
 +	fin = fopen(argv[1], "r");
 +	fout = fopen(argv[2], "w");
 +	if (!fin || !fout) {
 +		printf("Usage: ./program <input> <output>\n");
 +		perror("open: ");
 +		exit(1);
 +	}
 +
++=======
+ 	check_regcomp(&order_pattern, "order\\s*([0-9]*),");
+ 	check_regcomp(&pid_pattern, "pid\\s*([0-9]*),");
+ 	check_regcomp(&ts_nsec_pattern, "ts\\s*([0-9]*)\\s*ns,");
+ 	check_regcomp(&free_ts_nsec_pattern, "free_ts\\s*([0-9]*)\\s*ns");
++>>>>>>> 8f9c447e2e2b (tools/vm/page_owner_sort.c: support sorting pid and time)
  	fstat(fileno(fin), &st);
  	max_size = st.st_size / 100; /* hack ... */
  
@@@ -144,10 -359,18 +375,23 @@@
  		}
  	}
  
 -	qsort(list2, count, sizeof(list[0]), cmp);
 +	qsort(list2, count, sizeof(list[0]), compare_num);
 +
++<<<<<<< HEAD
 +	for (i = 0; i < count; i++)
 +		fprintf(fout, "%d times:\n%s\n", list2[i].num, list2[i].txt);
  
++=======
+ 	for (i = 0; i < count; i++) {
+ 		if (filter == 1 && list2[i].free_ts_nsec != 0)
+ 			continue;
+ 		fprintf(fout, "%d times, %d pages:\n%s\n",
+ 				list2[i].num, list2[i].page_num, list2[i].txt);
+ 	}
+ 	regfree(&order_pattern);
+ 	regfree(&pid_pattern);
+ 	regfree(&ts_nsec_pattern);
+ 	regfree(&free_ts_nsec_pattern);
++>>>>>>> 8f9c447e2e2b (tools/vm/page_owner_sort.c: support sorting pid and time)
  	return 0;
  }
* Unmerged path tools/vm/page_owner_sort.c
