xfs: up(ic_sema) if flushing data device fails

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-539.el8
commit-author Leah Rumancik <leah.rumancik@gmail.com>
commit 471de20303dda0b67981e06d59cc6c4a83fd2a3c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-539.el8/471de203.failed

We flush the data device cache before we issue external log IO. If
the flush fails, we shut down the log immediately and return. However,
the iclog->ic_sema is left in a decremented state so let's add an up().
Prior to this patch, xfs/438 would fail consistently when running with
an external log device:

sync
  -> xfs_log_force
  -> xlog_write_iclog
      -> down(&iclog->ic_sema)
      -> blkdev_issue_flush (fail causes us to intiate shutdown)
          -> xlog_force_shutdown
          -> return

unmount
  -> xfs_log_umount
      -> xlog_wait_iclog_completion
          -> down(&iclog->ic_sema) --------> HANG

There is a second early return / shutdown. Make sure the up() happens
for it as well. Also make sure we cleanup the iclog state,
xlog_state_done_syncing, before dropping the iclog lock.

Fixes: b5d721eaae47 ("xfs: external logs need to flush data device")
Fixes: 842a42d126b4 ("xfs: shutdown on failure to add page to log bio")
Fixes: 7d839e325af2 ("xfs: check return codes when flushing block devices")
	Signed-off-by: Leah Rumancik <leah.rumancik@gmail.com>
	Reviewed-by: "Darrick J. Wong" <djwong@kernel.org>
	Signed-off-by: Chandan Babu R <chandanbabu@kernel.org>
(cherry picked from commit 471de20303dda0b67981e06d59cc6c4a83fd2a3c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_log.c
diff --cc fs/xfs/xfs_log.c
index 75e0aaeef89b,ee206facf0dc..000000000000
--- a/fs/xfs/xfs_log.c
+++ b/fs/xfs/xfs_log.c
@@@ -1841,32 -1893,47 +1841,56 @@@ xlog_write_iclog
  		 * the buffer manually, the code needs to be kept in sync
  		 * with the I/O completion path.
  		 */
- 		xlog_state_done_syncing(iclog);
- 		up(&iclog->ic_sema);
- 		return;
+ 		goto sync;
  	}
  
 +	bio_init(&iclog->ic_bio, iclog->ic_bvec, howmany(count, PAGE_SIZE));
 +	bio_set_dev(&iclog->ic_bio, log->l_targ->bt_bdev);
 +	iclog->ic_bio.bi_iter.bi_sector = log->l_logBBstart + bno;
 +	iclog->ic_bio.bi_end_io = xlog_bio_end_io;
 +	iclog->ic_bio.bi_private = iclog;
 +
  	/*
  	 * We use REQ_SYNC | REQ_IDLE here to tell the block layer the are more
  	 * IOs coming immediately after this one. This prevents the block layer
  	 * writeback throttle from throttling log writes behind background
  	 * metadata writeback and causing priority inversions.
  	 */
 -	bio_init(&iclog->ic_bio, log->l_targ->bt_bdev, iclog->ic_bvec,
 -		 howmany(count, PAGE_SIZE),
 -		 REQ_OP_WRITE | REQ_META | REQ_SYNC | REQ_IDLE);
 -	iclog->ic_bio.bi_iter.bi_sector = log->l_logBBstart + bno;
 -	iclog->ic_bio.bi_end_io = xlog_bio_end_io;
 -	iclog->ic_bio.bi_private = iclog;
 -
 -	if (iclog->ic_flags & XLOG_ICL_NEED_FLUSH) {
 +	iclog->ic_bio.bi_opf = REQ_OP_WRITE | REQ_META | REQ_SYNC |
 +				REQ_IDLE | REQ_FUA;
 +	if (need_flush)
  		iclog->ic_bio.bi_opf |= REQ_PREFLUSH;
++<<<<<<< HEAD
 +
 +	if (xlog_map_iclog_data(&iclog->ic_bio, iclog->ic_data, count)) {
 +		xfs_force_shutdown(log->l_mp, SHUTDOWN_LOG_IO_ERROR);
 +		return;
 +	}
++=======
+ 		/*
+ 		 * For external log devices, we also need to flush the data
+ 		 * device cache first to ensure all metadata writeback covered
+ 		 * by the LSN in this iclog is on stable storage. This is slow,
+ 		 * but it *must* complete before we issue the external log IO.
+ 		 *
+ 		 * If the flush fails, we cannot conclude that past metadata
+ 		 * writeback from the log succeeded.  Repeating the flush is
+ 		 * not possible, hence we must shut down with log IO error to
+ 		 * avoid shutdown re-entering this path and erroring out again.
+ 		 */
+ 		if (log->l_targ != log->l_mp->m_ddev_targp &&
+ 		    blkdev_issue_flush(log->l_mp->m_ddev_targp->bt_bdev))
+ 			goto shutdown;
+ 	}
+ 	if (iclog->ic_flags & XLOG_ICL_NEED_FUA)
+ 		iclog->ic_bio.bi_opf |= REQ_FUA;
+ 
+ 	iclog->ic_flags &= ~(XLOG_ICL_NEED_FLUSH | XLOG_ICL_NEED_FUA);
+ 
+ 	if (xlog_map_iclog_data(&iclog->ic_bio, iclog->ic_data, count))
+ 		goto shutdown;
+ 
++>>>>>>> 471de20303dd (xfs: up(ic_sema) if flushing data device fails)
  	if (is_vmalloc_addr(iclog->ic_data))
  		flush_kernel_vmap_range(iclog->ic_data, count);
  
* Unmerged path fs/xfs/xfs_log.c
