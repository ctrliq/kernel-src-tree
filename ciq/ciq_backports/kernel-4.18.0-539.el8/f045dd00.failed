xfs: clean up the rtbitmap fsmap backend

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-539.el8
commit-author Darrick J. Wong <djwong@kernel.org>
commit f045dd00328d78f25d64913285f4547f772d13e2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-539.el8/f045dd00.failed

The rtbitmap fsmap backend doesn't query the rmapbt, so it's wasteful to
spend time initializing the rmap_irec objects.  Worse yet, the logic to
query the rtbitmap is spread across three separate functions, which is
unnecessarily difficult to follow.

Compute the start rtextent that we want from keys[0] directly and
combine the functions to avoid passing parameters around everywhere, and
consolidate all the logic into a single function.  At one point many
years ago I intended to use __xfs_getfsmap_rtdev as the launching point
for realtime rmapbt queries, but this hasn't been the case for a long
time.

	Signed-off-by: Darrick J. Wong <djwong@kernel.org>
	Reviewed-by: Dave Chinner <dchinner@redhat.com>
(cherry picked from commit f045dd00328d78f25d64913285f4547f772d13e2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_fsmap.c
diff --cc fs/xfs/xfs_fsmap.c
index a34989b10f79,47295067f212..000000000000
--- a/fs/xfs/xfs_fsmap.c
+++ b/fs/xfs/xfs_fsmap.c
@@@ -484,71 -509,56 +484,91 @@@ xfs_getfsmap_rtdev_rtbitmap_helper
  	irec.rm_offset = 0;
  	irec.rm_flags = 0;
  
 -	return xfs_getfsmap_helper(tp, info, &irec, rec_daddr, len_daddr);
 +	return xfs_getfsmap_helper(tp, info, &irec, rec_daddr);
  }
  
- /* Execute a getfsmap query against the realtime device. */
+ /* Execute a getfsmap query against the realtime device rtbitmap. */
  STATIC int
- __xfs_getfsmap_rtdev(
+ xfs_getfsmap_rtdev_rtbitmap(
  	struct xfs_trans		*tp,
  	const struct xfs_fsmap		*keys,
++<<<<<<< HEAD
 +	int				(*query_fn)(struct xfs_trans *,
 +						    struct xfs_getfsmap_info *),
++=======
++>>>>>>> f045dd00328d (xfs: clean up the rtbitmap fsmap backend)
  	struct xfs_getfsmap_info	*info)
  {
+ 
+ 	struct xfs_rtalloc_rec		alow = { 0 };
+ 	struct xfs_rtalloc_rec		ahigh = { 0 };
  	struct xfs_mount		*mp = tp->t_mountp;
 -	xfs_rtblock_t			start_rtb;
 -	xfs_rtblock_t			end_rtb;
 +	xfs_fsblock_t			start_fsb;
 +	xfs_fsblock_t			end_fsb;
  	uint64_t			eofs;
- 	int				error = 0;
+ 	int				error;
  
 -	eofs = XFS_FSB_TO_BB(mp, mp->m_sb.sb_rextents * mp->m_sb.sb_rextsize);
 +	eofs = XFS_FSB_TO_BB(mp, mp->m_sb.sb_rblocks);
  	if (keys[0].fmr_physical >= eofs)
  		return 0;
 -	start_rtb = XFS_BB_TO_FSBT(mp,
 -				keys[0].fmr_physical + keys[0].fmr_length);
 -	end_rtb = XFS_BB_TO_FSB(mp, min(eofs - 1, keys[1].fmr_physical));
 +	start_fsb = XFS_BB_TO_FSBT(mp, keys[0].fmr_physical);
 +	end_fsb = XFS_BB_TO_FSB(mp, min(eofs - 1, keys[1].fmr_physical));
 +
++<<<<<<< HEAD
 +	/* Set up search keys */
 +	info->low.rm_startblock = start_fsb;
 +	error = xfs_fsmap_owner_to_rmap(&info->low, &keys[0]);
 +	if (error)
 +		return error;
 +	info->low.rm_offset = XFS_BB_TO_FSBT(mp, keys[0].fmr_offset);
 +	info->low.rm_blockcount = 0;
 +	xfs_getfsmap_set_irec_flags(&info->low, &keys[0]);
 +
 +	info->high.rm_startblock = end_fsb;
 +	error = xfs_fsmap_owner_to_rmap(&info->high, &keys[1]);
 +	if (error)
 +		return error;
 +	info->high.rm_offset = XFS_BB_TO_FSBT(mp, keys[1].fmr_offset);
 +	info->high.rm_blockcount = 0;
 +	xfs_getfsmap_set_irec_flags(&info->high, &keys[1]);
  
 +	trace_xfs_fsmap_low_key(mp, info->dev, NULLAGNUMBER, &info->low);
 +	trace_xfs_fsmap_high_key(mp, info->dev, NULLAGNUMBER, &info->high);
 +
 +	return query_fn(tp, info);
 +}
 +
 +/* Actually query the realtime bitmap. */
 +STATIC int
 +xfs_getfsmap_rtdev_rtbitmap_query(
 +	struct xfs_trans		*tp,
 +	struct xfs_getfsmap_info	*info)
 +{
 +	struct xfs_rtalloc_rec		alow = { 0 };
 +	struct xfs_rtalloc_rec		ahigh = { 0 };
 +	int				error;
++=======
+ 	info->missing_owner = XFS_FMR_OWN_UNKNOWN;
+ 
+ 	/* Adjust the low key if we are continuing from where we left off. */
+ 	if (keys[0].fmr_length > 0) {
+ 		info->low_daddr = XFS_FSB_TO_BB(mp, start_rtb);
+ 		if (info->low_daddr >= eofs)
+ 			return 0;
+ 	}
+ 
+ 	trace_xfs_fsmap_low_key_linear(mp, info->dev, start_rtb);
+ 	trace_xfs_fsmap_high_key_linear(mp, info->dev, end_rtb);
++>>>>>>> f045dd00328d (xfs: clean up the rtbitmap fsmap backend)
  
 -	xfs_ilock(mp->m_rbmip, XFS_ILOCK_SHARED | XFS_ILOCK_RTBITMAP);
 +	xfs_ilock(tp->t_mountp->m_rbmip, XFS_ILOCK_SHARED);
  
 -	/*
 -	 * Set up query parameters to return free rtextents covering the range
 -	 * we want.
 -	 */
 -	alow.ar_startext = start_rtb;
 -	ahigh.ar_startext = end_rtb;
 -	do_div(alow.ar_startext, mp->m_sb.sb_rextsize);
 -	if (do_div(ahigh.ar_startext, mp->m_sb.sb_rextsize))
 +	alow.ar_startext = info->low.rm_startblock;
 +	ahigh.ar_startext = info->high.rm_startblock;
 +	do_div(alow.ar_startext, tp->t_mountp->m_sb.sb_rextsize);
 +	if (do_div(ahigh.ar_startext, tp->t_mountp->m_sb.sb_rextsize))
  		ahigh.ar_startext++;
 -	error = xfs_rtalloc_query_range(mp, tp, &alow, &ahigh,
 +	error = xfs_rtalloc_query_range(tp, &alow, &ahigh,
  			xfs_getfsmap_rtdev_rtbitmap_helper, info);
  	if (error)
  		goto err;
@@@ -559,21 -574,9 +579,9 @@@
  	if (error)
  		goto err;
  err:
 -	xfs_iunlock(mp->m_rbmip, XFS_ILOCK_SHARED | XFS_ILOCK_RTBITMAP);
 +	xfs_iunlock(tp->t_mountp->m_rbmip, XFS_ILOCK_SHARED);
  	return error;
  }
- 
- /* Execute a getfsmap query against the realtime device rtbitmap. */
- STATIC int
- xfs_getfsmap_rtdev_rtbitmap(
- 	struct xfs_trans		*tp,
- 	const struct xfs_fsmap		*keys,
- 	struct xfs_getfsmap_info	*info)
- {
- 	info->missing_owner = XFS_FMR_OWN_UNKNOWN;
- 	return __xfs_getfsmap_rtdev(tp, keys, xfs_getfsmap_rtdev_rtbitmap_query,
- 			info);
- }
  #endif /* CONFIG_XFS_RT */
  
  /* Execute a getfsmap query against the regular data device. */
* Unmerged path fs/xfs/xfs_fsmap.c
diff --git a/fs/xfs/xfs_trace.h b/fs/xfs/xfs_trace.h
index 2802a8b52f48..9148c0f56302 100644
--- a/fs/xfs/xfs_trace.h
+++ b/fs/xfs/xfs_trace.h
@@ -3358,6 +3358,31 @@ DEFINE_FSMAP_EVENT(xfs_fsmap_low_key);
 DEFINE_FSMAP_EVENT(xfs_fsmap_high_key);
 DEFINE_FSMAP_EVENT(xfs_fsmap_mapping);
 
+DECLARE_EVENT_CLASS(xfs_fsmap_linear_class,
+	TP_PROTO(struct xfs_mount *mp, u32 keydev, uint64_t bno),
+	TP_ARGS(mp, keydev, bno),
+	TP_STRUCT__entry(
+		__field(dev_t, dev)
+		__field(dev_t, keydev)
+		__field(xfs_fsblock_t, bno)
+	),
+	TP_fast_assign(
+		__entry->dev = mp->m_super->s_dev;
+		__entry->keydev = new_decode_dev(keydev);
+		__entry->bno = bno;
+	),
+	TP_printk("dev %d:%d keydev %d:%d bno 0x%llx",
+		  MAJOR(__entry->dev), MINOR(__entry->dev),
+		  MAJOR(__entry->keydev), MINOR(__entry->keydev),
+		  __entry->bno)
+)
+#define DEFINE_FSMAP_LINEAR_EVENT(name) \
+DEFINE_EVENT(xfs_fsmap_linear_class, name, \
+	TP_PROTO(struct xfs_mount *mp, u32 keydev, uint64_t bno), \
+	TP_ARGS(mp, keydev, bno))
+DEFINE_FSMAP_LINEAR_EVENT(xfs_fsmap_low_key_linear);
+DEFINE_FSMAP_LINEAR_EVENT(xfs_fsmap_high_key_linear);
+
 DECLARE_EVENT_CLASS(xfs_getfsmap_class,
 	TP_PROTO(struct xfs_mount *mp, struct xfs_fsmap *fsmap),
 	TP_ARGS(mp, fsmap),
