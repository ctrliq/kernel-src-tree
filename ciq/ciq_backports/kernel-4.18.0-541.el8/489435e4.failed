mxser: remove MOXA_ASPP_LSTATUS ioctl

jira LE-1907
cve CVE-2023-6546
Rebuild_History Non-Buildable kernel-4.18.0-541.el8
commit-author Jiri Slaby <jslaby@suse.cz>
commit 489435e4abc01682d4da31c9666e2e251e697182
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-541.el8/489435e4.failed

1) The semantics are defined exactly nowhere.
2) The ioctl definition was never exposed to userspace, so noone should
   actually be reliably using this.
3) It's not even mentioned in any of the mxser utilities.

Provided the above, remove this mxser-special ioctl.

	Signed-off-by: Jiri Slaby <jslaby@suse.cz>
Link: https://lore.kernel.org/r/20210618061516.662-26-jslaby@suse.cz
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 489435e4abc01682d4da31c9666e2e251e697182)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/tty/mxser.c
diff --cc drivers/tty/mxser.c
index e63665b0a8d7,38e12ff17529..000000000000
--- a/drivers/tty/mxser.c
+++ b/drivers/tty/mxser.c
@@@ -63,25 -63,10 +63,31 @@@
  #define RS485_4WIRE_MODE	3
  #define OP_MODE_MASK		3
  
 +#define MOXA_SDS_RSTICOUNTER	(MOXA + 69)
  #define MOXA_ASPP_OQUEUE	(MOXA + 70)
++<<<<<<< HEAD
 +#define MOXA_ASPP_MON		(MOXA + 73)
 +#define MOXA_ASPP_LSTATUS	(MOXA + 74)
 +#define MOXA_ASPP_MON_EXT	(MOXA + 75)
  
  /* --------------------------------------------------- */
  
 +#define NPPI_NOTIFY_PARITY	0x01
 +#define NPPI_NOTIFY_FRAMING	0x02
 +#define NPPI_NOTIFY_HW_OVERRUN	0x04
 +#define NPPI_NOTIFY_SW_OVERRUN	0x08
 +#define NPPI_NOTIFY_BREAK	0x10
 +
 +#define NPPI_NOTIFY_CTSHOLD         0x01	/* Tx hold by CTS low */
 +#define NPPI_NOTIFY_DSRHOLD         0x02	/* Tx hold by DSR low */
 +#define NPPI_NOTIFY_XOFFHOLD        0x08	/* Tx hold by Xoff received */
 +#define NPPI_NOTIFY_XOFFXENT        0x10	/* Xoff Sent */
 +
++=======
++
++/* --------------------------------------------------- */
++
++>>>>>>> 489435e4abc0 (mxser: remove MOXA_ASPP_LSTATUS ioctl)
  /*
   * Follow just what Moxa Must chip defines.
   *
@@@ -1882,44 -1593,6 +1887,47 @@@ static int mxser_ioctl(struct tty_struc
  
  		return put_user(len, (int __user *)argp);
  	}
++<<<<<<< HEAD
 +	case MOXA_ASPP_MON: {
 +		int mcr, status;
 +
 +		spin_lock_irq(&info->slock);
 +		status = mxser_get_msr(info->ioaddr, 1, tty->index);
 +		mxser_check_modem_status(tty, info, status);
 +
 +		mcr = inb(info->ioaddr + UART_MCR);
 +		spin_unlock_irq(&info->slock);
 +
 +		if (mcr & MOXA_MUST_MCR_XON_FLAG)
 +			info->mon_data.hold_reason &= ~NPPI_NOTIFY_XOFFHOLD;
 +		else
 +			info->mon_data.hold_reason |= NPPI_NOTIFY_XOFFHOLD;
 +
 +		if (mcr & MOXA_MUST_MCR_TX_XON)
 +			info->mon_data.hold_reason &= ~NPPI_NOTIFY_XOFFXENT;
 +		else
 +			info->mon_data.hold_reason |= NPPI_NOTIFY_XOFFXENT;
 +
 +		if (tty->hw_stopped)
 +			info->mon_data.hold_reason |= NPPI_NOTIFY_CTSHOLD;
 +		else
 +			info->mon_data.hold_reason &= ~NPPI_NOTIFY_CTSHOLD;
 +
 +		if (copy_to_user(argp, &info->mon_data,
 +				sizeof(struct mxser_mon)))
 +			return -EFAULT;
 +
 +		return 0;
 +	}
 +	case MOXA_ASPP_LSTATUS: {
 +		if (put_user(info->err_shadow, (unsigned char __user *)argp))
 +			return -EFAULT;
 +
 +		info->err_shadow = 0;
 +		return 0;
 +	}
++=======
++>>>>>>> 489435e4abc0 (mxser: remove MOXA_ASPP_LSTATUS ioctl)
  	default:
  		return -ENOIOCTLCMD;
  	}
@@@ -2312,6 -1995,59 +2320,62 @@@ static void mxser_transmit_chars(struc
  	}
  }
  
++<<<<<<< HEAD
++=======
+ static bool mxser_port_isr(struct mxser_port *port)
+ {
+ 	struct tty_struct *tty;
+ 	u8 iir, msr, status;
+ 	bool error = false;
+ 
+ 	iir = inb(port->ioaddr + UART_IIR);
+ 	if (iir & UART_IIR_NO_INT)
+ 		return true;
+ 
+ 	iir &= MOXA_MUST_IIR_MASK;
+ 	tty = tty_port_tty_get(&port->port);
+ 	if (!tty || port->closing || !tty_port_initialized(&port->port)) {
+ 		status = inb(port->ioaddr + UART_LSR);
+ 		outb(0x27, port->ioaddr + UART_FCR);
+ 		inb(port->ioaddr + UART_MSR);
+ 
+ 		error = true;
+ 		goto put_tty;
+ 	}
+ 
+ 	status = inb(port->ioaddr + UART_LSR);
+ 
+ 	if (port->board->must_hwid) {
+ 		if (iir == MOXA_MUST_IIR_GDA ||
+ 		    iir == MOXA_MUST_IIR_RDA ||
+ 		    iir == MOXA_MUST_IIR_RTO ||
+ 		    iir == MOXA_MUST_IIR_LSR)
+ 			status = mxser_receive_chars(tty, port, status);
+ 	} else {
+ 		status &= port->read_status_mask;
+ 		if (status & UART_LSR_DR)
+ 			status = mxser_receive_chars(tty, port, status);
+ 	}
+ 
+ 	msr = inb(port->ioaddr + UART_MSR);
+ 	if (msr & UART_MSR_ANY_DELTA)
+ 		mxser_check_modem_status(tty, port, msr);
+ 
+ 	if (port->board->must_hwid) {
+ 		if (iir == 0x02 && (status & UART_LSR_THRE))
+ 			mxser_transmit_chars(tty, port);
+ 	} else {
+ 		if (status & UART_LSR_THRE)
+ 			mxser_transmit_chars(tty, port);
+ 	}
+ 
+ put_tty:
+ 	tty_kref_put(tty);
+ 
+ 	return error;
+ }
+ 
++>>>>>>> 489435e4abc0 (mxser: remove MOXA_ASPP_LSTATUS ioctl)
  /*
   * This is the serial driver's generic interrupt routine
   */
@@@ -2499,8 -2148,6 +2563,11 @@@ static int mxser_initbrd(struct mxser_b
  		info->port.close_delay = 5 * HZ / 10;
  		info->port.closing_wait = 30 * HZ;
  		info->normal_termios = mxvar_sdriver->init_termios;
++<<<<<<< HEAD
 +		memset(&info->mon_data, 0, sizeof(struct mxser_mon));
 +		info->err_shadow = 0;
++=======
++>>>>>>> 489435e4abc0 (mxser: remove MOXA_ASPP_LSTATUS ioctl)
  		spin_lock_init(&info->slock);
  
  		/* before set INT ISR, disable all int */
* Unmerged path drivers/tty/mxser.c
