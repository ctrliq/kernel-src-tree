EDAC/ghes: Make ghes_edac a proper module

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-541.el8
commit-author Jia He <justin.he@arm.com>
commit 802e7f1dfed7cc7fb309995e0c4138f08977fdfc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-541.el8/802e7f1d.failed

Commit

  dc4e8c07e9e2 ("ACPI: APEI: explicit init of HEST and GHES in apci_init()")

introduced a bug leading to ghes_edac_register() to be invoked before
edac_init(). Because at that time the bus "edac" hadn't been even
registered, this created sysfs nodes as /devices/mc0 instead of
/sys/devices/system/edac/mc/mc0 on an Ampere eMag server.

Fix this by turning ghes_edac into a proper module.

The list of GHES devices returned is not protected from being modified
concurrently but it is pretty static as it gets created only during GHES
init and latter is not a module so...

  [ bp: Massage. ]

Fixes: dc4e8c07e9e2 ("ACPI: APEI: explicit init of HEST and GHES in apci_init()")
Co-developed-by: Borislav Petkov <bp@alien8.de>
	Signed-off-by: Borislav Petkov <bp@alien8.de>
	Signed-off-by: Jia He <justin.he@arm.com>
	Signed-off-by: Borislav Petkov <bp@suse.de>
Link: https://lore.kernel.org/r/20221010023559.69655-5-justin.he@arm.com
(cherry picked from commit 802e7f1dfed7cc7fb309995e0c4138f08977fdfc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/acpi/apei/ghes.c
#	drivers/edac/Kconfig
#	include/acpi/ghes.h
diff --cc drivers/acpi/apei/ghes.c
index 0b21f8827cc4,249cd01cb920..000000000000
--- a/drivers/acpi/apei/ghes.c
+++ b/drivers/acpi/apei/ghes.c
@@@ -1396,7 -1392,11 +1396,15 @@@ static int ghes_probe(struct platform_d
  
  	platform_set_drvdata(ghes_dev, ghes);
  
++<<<<<<< HEAD
 +	ghes_edac_register(ghes, &ghes_dev->dev);
++=======
+ 	ghes->dev = &ghes_dev->dev;
+ 
+ 	mutex_lock(&ghes_devs_mutex);
+ 	list_add_tail(&ghes->elist, &ghes_devs);
+ 	mutex_unlock(&ghes_devs_mutex);
++>>>>>>> 802e7f1dfed7 (EDAC/ghes: Make ghes_edac a proper module)
  
  	/* Handle any pending errors right away */
  	spin_lock_irqsave(&ghes_notify_lock_irq, flags);
@@@ -1460,7 -1460,9 +1468,13 @@@ static int ghes_remove(struct platform_
  
  	ghes_fini(ghes);
  
++<<<<<<< HEAD
 +	ghes_edac_unregister(ghes);
++=======
+ 	mutex_lock(&ghes_devs_mutex);
+ 	list_del(&ghes->elist);
+ 	mutex_unlock(&ghes_devs_mutex);
++>>>>>>> 802e7f1dfed7 (EDAC/ghes: Make ghes_edac a proper module)
  
  	kfree(ghes);
  
diff --cc drivers/edac/Kconfig
index 97b5cc0edd71,cde0849cf861..000000000000
--- a/drivers/edac/Kconfig
+++ b/drivers/edac/Kconfig
@@@ -53,8 -53,9 +53,14 @@@ config EDAC_DECODE_MC
  	  has been initialized.
  
  config EDAC_GHES
++<<<<<<< HEAD
 +	bool "Output ACPI APEI/GHES BIOS detected errors via EDAC"
 +	depends on ACPI_APEI_GHES && (EDAC=y)
++=======
+ 	tristate "Output ACPI APEI/GHES BIOS detected errors via EDAC"
+ 	depends on ACPI_APEI_GHES
+ 	select UEFI_CPER
++>>>>>>> 802e7f1dfed7 (EDAC/ghes: Make ghes_edac a proper module)
  	help
  	  Not all machines support hardware-driven error report. Some of those
  	  provide a BIOS-driven error report mechanism via ACPI, using the
diff --cc include/acpi/ghes.h
index 292a5c40bd0c,2e785d3554d8..000000000000
--- a/include/acpi/ghes.h
+++ b/include/acpi/ghes.h
@@@ -69,35 -71,14 +69,42 @@@ int ghes_register_vendor_record_notifie
   * @nb: pointer to the notifier_block structure of the vendor record handler.
   */
  void ghes_unregister_vendor_record_notifier(struct notifier_block *nb);
+ 
+ struct list_head *ghes_get_devices(void);
+ #else
+ static inline struct list_head *ghes_get_devices(void) { return NULL; }
  #endif
  
 -int ghes_estatus_pool_init(int num_ghes);
 +int ghes_estatus_pool_init(unsigned int num_ghes);
  
++<<<<<<< HEAD
 +/* From drivers/edac/ghes_edac.c */
 +
 +#ifdef CONFIG_EDAC_GHES
 +void ghes_edac_report_mem_error(int sev, struct cper_sec_mem_err *mem_err);
 +
 +int ghes_edac_register(struct ghes *ghes, struct device *dev);
 +
 +void ghes_edac_unregister(struct ghes *ghes);
 +
 +#else
 +static inline void ghes_edac_report_mem_error(int sev,
 +				       struct cper_sec_mem_err *mem_err)
 +{
 +}
 +
 +static inline int ghes_edac_register(struct ghes *ghes, struct device *dev)
 +{
 +	return -ENODEV;
 +}
 +
 +static inline void ghes_edac_unregister(struct ghes *ghes)
 +{
 +}
 +#endif
 +
++=======
++>>>>>>> 802e7f1dfed7 (EDAC/ghes: Make ghes_edac a proper module)
  static inline int acpi_hest_get_version(struct acpi_hest_generic_data *gdata)
  {
  	return gdata->revision >> 8;
* Unmerged path drivers/acpi/apei/ghes.c
* Unmerged path drivers/edac/Kconfig
diff --git a/drivers/edac/ghes_edac.c b/drivers/edac/ghes_edac.c
index 0365a010a90d..1e832585e6df 100644
--- a/drivers/edac/ghes_edac.c
+++ b/drivers/edac/ghes_edac.c
@@ -49,6 +49,8 @@ static DEFINE_SPINLOCK(ghes_lock);
 static bool __read_mostly force_load;
 module_param(force_load, bool, 0);
 
+static struct list_head *ghes_devs;
+
 /* Memory Device - Type 17 of SMBIOS spec */
 struct memdev_dmi_entry {
 	u8 type;
@@ -483,7 +485,7 @@ static struct acpi_platform_list plat_list[] = {
 	{ } /* End */
 };
 
-int ghes_edac_register(struct ghes *ghes, struct device *dev)
+static int ghes_edac_register(struct device *dev)
 {
 	bool fake = false;
 	int rc = 0, num_dimm = 0;
@@ -591,7 +593,7 @@ int ghes_edac_register(struct ghes *ghes, struct device *dev)
 	return rc;
 }
 
-void ghes_edac_unregister(struct ghes *ghes)
+static void ghes_edac_unregister(struct ghes *ghes)
 {
 	struct mem_ctl_info *mci;
 	unsigned long flags;
@@ -619,3 +621,37 @@ void ghes_edac_unregister(struct ghes *ghes)
 unlock:
 	mutex_unlock(&ghes_reg_mutex);
 }
+
+static int __init ghes_edac_init(void)
+{
+	struct ghes *g, *g_tmp;
+
+	ghes_devs = ghes_get_devices();
+	if (!ghes_devs)
+		return -ENODEV;
+
+	if (list_empty(ghes_devs)) {
+		pr_info("GHES probing device list is empty");
+		return -ENODEV;
+	}
+
+	list_for_each_entry_safe(g, g_tmp, ghes_devs, elist) {
+		ghes_edac_register(g->dev);
+	}
+
+	return 0;
+}
+module_init(ghes_edac_init);
+
+static void __exit ghes_edac_exit(void)
+{
+	struct ghes *g, *g_tmp;
+
+	list_for_each_entry_safe(g, g_tmp, ghes_devs, elist) {
+		ghes_edac_unregister(g);
+	}
+}
+module_exit(ghes_edac_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Output ACPI APEI/GHES BIOS detected errors via EDAC");
* Unmerged path include/acpi/ghes.h
