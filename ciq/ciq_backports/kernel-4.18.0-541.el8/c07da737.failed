tty: n_gsm: name the debug bits

jira LE-1907
cve CVE-2023-6546
Rebuild_History Non-Buildable kernel-4.18.0-541.el8
commit-author Daniel Starke <daniel.starke@siemens.com>
commit c07da737af4dd9a29508ae2863fa2afdec130088
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-541.el8/c07da737.failed

Introduce defines to name the various debug bits used within the code to
improve readability and to make its specific use clear.

	Signed-off-by: Daniel Starke <daniel.starke@siemens.com>
Link: https://lore.kernel.org/r/20220831073800.7459-5-daniel.starke@siemens.com
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit c07da737af4dd9a29508ae2863fa2afdec130088)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/tty/n_gsm.c
diff --cc drivers/tty/n_gsm.c
index 7a503e8fe393,e7ba15522215..000000000000
--- a/drivers/tty/n_gsm.c
+++ b/drivers/tty/n_gsm.c
@@@ -764,6 -815,45 +771,48 @@@ static struct gsm_msg *gsm_data_alloc(s
  }
  
  /**
++<<<<<<< HEAD
++=======
+  *	gsm_send_packet	-	sends a single packet
+  *	@gsm: GSM Mux
+  *	@msg: packet to send
+  *
+  *	The given packet is encoded and sent out. No memory is freed.
+  *	The caller must hold the gsm tx lock.
+  */
+ static int gsm_send_packet(struct gsm_mux *gsm, struct gsm_msg *msg)
+ {
+ 	int len, ret;
+ 
+ 
+ 	if (gsm->encoding == GSM_BASIC_OPT) {
+ 		gsm->txframe[0] = GSM0_SOF;
+ 		memcpy(gsm->txframe + 1, msg->data, msg->len);
+ 		gsm->txframe[msg->len + 1] = GSM0_SOF;
+ 		len = msg->len + 2;
+ 	} else {
+ 		gsm->txframe[0] = GSM1_SOF;
+ 		len = gsm_stuff_frame(msg->data, gsm->txframe + 1, msg->len);
+ 		gsm->txframe[len + 1] = GSM1_SOF;
+ 		len += 2;
+ 	}
+ 
+ 	if (debug & DBG_DATA)
+ 		gsm_hex_dump_bytes(__func__, gsm->txframe, len);
+ 	gsm_print_packet("-->", msg->addr, gsm->initiator, msg->ctrl, msg->data,
+ 			 msg->len);
+ 
+ 	ret = gsmld_output(gsm, gsm->txframe, len);
+ 	if (ret <= 0)
+ 		return ret;
+ 	/* FIXME: Can eliminate one SOF in many more cases */
+ 	gsm->tx_bytes -= msg->len;
+ 
+ 	return 0;
+ }
+ 
+ /**
++>>>>>>> c07da737af4d (tty: n_gsm: name the debug bits)
   *	gsm_is_flow_ctrl_msg	-	checks if flow control message
   *	@msg: message to check
   *
@@@ -1804,11 -1943,10 +1853,16 @@@ static void gsm_dlci_data(struct gsm_dl
  	struct tty_port *port = &dlci->port;
  	struct tty_struct *tty;
  	unsigned int modem = 0;
 -	int len;
 +	int len = clen;
 +	int slen = 0;
  
++<<<<<<< HEAD
 +	if (debug & 16)
 +		pr_debug("%d bytes for tty\n", len);
++=======
+ 	if (debug & DBG_TTY)
+ 		pr_debug("%d bytes for tty\n", clen);
++>>>>>>> c07da737af4d (tty: n_gsm: name the debug bits)
  	switch (dlci->adaption)  {
  	/* Unsupported types */
  	case 4:		/* Packetised interruptible data */
@@@ -1854,24 -1990,50 +1908,71 @@@ static void gsm_dlci_command(struct gsm
  {
  	/* See what command is involved */
  	unsigned int command = 0;
++<<<<<<< HEAD
 +	while (len-- > 0) {
 +		if (gsm_read_ea(&command, *data++) == 1) {
 +			int clen = *data++;
 +			len--;
 +			/* FIXME: this is properly an EA */
 +			clen >>= 1;
 +			/* Malformed command ? */
 +			if (clen > len)
 +				return;
 +			if (command & 1)
 +				gsm_control_message(dlci->gsm, command,
 +								data, clen);
 +			else
 +				gsm_control_response(dlci->gsm, command,
 +								data, clen);
 +			return;
 +		}
 +	}
++=======
+ 	unsigned int clen = 0;
+ 	unsigned int dlen;
+ 
+ 	/* read the command */
+ 	dlen = gsm_read_ea_val(&command, data, len);
+ 	len -= dlen;
+ 	data += dlen;
+ 
+ 	/* read any control data */
+ 	dlen = gsm_read_ea_val(&clen, data, len);
+ 	len -= dlen;
+ 	data += dlen;
+ 
+ 	/* Malformed command? */
+ 	if (clen > len)
+ 		return;
+ 
+ 	if (command & 1)
+ 		gsm_control_message(dlci->gsm, command, data, clen);
+ 	else
+ 		gsm_control_response(dlci->gsm, command, data, clen);
+ }
+ 
+ /**
+  *	gsm_kick_timeout	-	transmit if possible
+  *	@work: work contained in our gsm object
+  *
+  *	Transmit data from DLCIs if the queue is empty. We can't rely on
+  *	a tty wakeup except when we filled the pipe so we need to fire off
+  *	new data ourselves in other cases.
+  */
+ static void gsm_kick_timeout(struct work_struct *work)
+ {
+ 	struct gsm_mux *gsm = container_of(work, struct gsm_mux, kick_timeout.work);
+ 	int sent = 0;
+ 
+ 	mutex_lock(&gsm->tx_mutex);
+ 	/* If we have nothing running then we need to fire up */
+ 	if (gsm->tx_bytes < TX_THRESH_LO)
+ 		sent = gsm_dlci_data_sweep(gsm);
+ 	mutex_unlock(&gsm->tx_mutex);
+ 
+ 	if (sent && debug & DBG_DATA)
+ 		pr_info("%s TX queue stalled\n", __func__);
++>>>>>>> c07da737af4d (tty: n_gsm: name the debug bits)
  }
  
  /*
* Unmerged path drivers/tty/n_gsm.c
