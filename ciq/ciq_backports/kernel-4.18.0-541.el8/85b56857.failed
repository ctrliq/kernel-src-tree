Bluetooth: hci_sync: Add support for waiting specific LE subevents

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-541.el8
commit-author Luiz Augusto von Dentz <luiz.von.dentz@intel.com>
commit 85b56857e194635b772be8af1c7650535d5d112a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-541.el8/85b56857.failed

This adds support for waiting for specific LE subevents instead of
command status which may only indicate that the commands is in progress
and a different event is used to complete the operation.

	Signed-off-by: Luiz Augusto von Dentz <luiz.von.dentz@intel.com>
	Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
(cherry picked from commit 85b56857e194635b772be8af1c7650535d5d112a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/bluetooth/hci_event.c
diff --cc net/bluetooth/hci_event.c
index 05d3245dc86d,f1082b7c0218..000000000000
--- a/net/bluetooth/hci_event.c
+++ b/net/bluetooth/hci_event.c
@@@ -6407,59 -6397,113 +6406,76 @@@ unlock
  	hci_dev_unlock(hdev);
  }
  
 -#define HCI_LE_EV_VL(_op, _func, _min_len, _max_len) \
 -[_op] = { \
 -	.func = _func, \
 -	.min_len = _min_len, \
 -	.max_len = _max_len, \
 -}
 -
 -#define HCI_LE_EV(_op, _func, _len) \
 -	HCI_LE_EV_VL(_op, _func, _len, _len)
 -
 -#define HCI_LE_EV_STATUS(_op, _func) \
 -	HCI_LE_EV(_op, _func, sizeof(struct hci_ev_status))
 -
 -/* Entries in this table shall have their position according to the subevent
 - * opcode they handle so the use of the macros above is recommend since it does
 - * attempt to initialize at its proper index using Designated Initializers that
 - * way events without a callback function can be ommited.
 - */
 -static const struct hci_le_ev {
 -	void (*func)(struct hci_dev *hdev, void *data, struct sk_buff *skb);
 -	u16  min_len;
 -	u16  max_len;
 -} hci_le_ev_table[U8_MAX + 1] = {
 -	/* [0x01 = HCI_EV_LE_CONN_COMPLETE] */
 -	HCI_LE_EV(HCI_EV_LE_CONN_COMPLETE, hci_le_conn_complete_evt,
 -		  sizeof(struct hci_ev_le_conn_complete)),
 -	/* [0x02 = HCI_EV_LE_ADVERTISING_REPORT] */
 -	HCI_LE_EV_VL(HCI_EV_LE_ADVERTISING_REPORT, hci_le_adv_report_evt,
 -		     sizeof(struct hci_ev_le_advertising_report),
 -		     HCI_MAX_EVENT_SIZE),
 -	/* [0x03 = HCI_EV_LE_CONN_UPDATE_COMPLETE] */
 -	HCI_LE_EV(HCI_EV_LE_CONN_UPDATE_COMPLETE,
 -		  hci_le_conn_update_complete_evt,
 -		  sizeof(struct hci_ev_le_conn_update_complete)),
 -	/* [0x04 = HCI_EV_LE_REMOTE_FEAT_COMPLETE] */
 -	HCI_LE_EV(HCI_EV_LE_REMOTE_FEAT_COMPLETE,
 -		  hci_le_remote_feat_complete_evt,
 -		  sizeof(struct hci_ev_le_remote_feat_complete)),
 -	/* [0x05 = HCI_EV_LE_LTK_REQ] */
 -	HCI_LE_EV(HCI_EV_LE_LTK_REQ, hci_le_ltk_request_evt,
 -		  sizeof(struct hci_ev_le_ltk_req)),
 -	/* [0x06 = HCI_EV_LE_REMOTE_CONN_PARAM_REQ] */
 -	HCI_LE_EV(HCI_EV_LE_REMOTE_CONN_PARAM_REQ,
 -		  hci_le_remote_conn_param_req_evt,
 -		  sizeof(struct hci_ev_le_remote_conn_param_req)),
 -	/* [0x0a = HCI_EV_LE_ENHANCED_CONN_COMPLETE] */
 -	HCI_LE_EV(HCI_EV_LE_ENHANCED_CONN_COMPLETE,
 -		  hci_le_enh_conn_complete_evt,
 -		  sizeof(struct hci_ev_le_enh_conn_complete)),
 -	/* [0x0b = HCI_EV_LE_DIRECT_ADV_REPORT] */
 -	HCI_LE_EV_VL(HCI_EV_LE_DIRECT_ADV_REPORT, hci_le_direct_adv_report_evt,
 -		     sizeof(struct hci_ev_le_direct_adv_report),
 -		     HCI_MAX_EVENT_SIZE),
 -	/* [0x0c = HCI_EV_LE_PHY_UPDATE_COMPLETE] */
 -	HCI_LE_EV(HCI_EV_LE_PHY_UPDATE_COMPLETE, hci_le_phy_update_evt,
 -		  sizeof(struct hci_ev_le_phy_update_complete)),
 -	/* [0x0d = HCI_EV_LE_EXT_ADV_REPORT] */
 -	HCI_LE_EV_VL(HCI_EV_LE_EXT_ADV_REPORT, hci_le_ext_adv_report_evt,
 -		     sizeof(struct hci_ev_le_ext_adv_report),
 -		     HCI_MAX_EVENT_SIZE),
 -	/* [0x12 = HCI_EV_LE_EXT_ADV_SET_TERM] */
 -	HCI_LE_EV(HCI_EV_LE_EXT_ADV_SET_TERM, hci_le_ext_adv_term_evt,
 -		  sizeof(struct hci_evt_le_ext_adv_set_term)),
 -};
 -
  static void hci_le_meta_evt(struct hci_dev *hdev, void *data,
- 			    struct sk_buff *skb)
+ 			    struct sk_buff *skb, u16 *opcode, u8 *status,
+ 			    hci_req_complete_t *req_complete,
+ 			    hci_req_complete_skb_t *req_complete_skb)
  {
  	struct hci_ev_le_meta *ev = data;
 -	const struct hci_le_ev *subev;
  
 -	bt_dev_dbg(hdev, "subevent 0x%2.2x", ev->subevent);
 +	switch (ev->subevent) {
 +	case HCI_EV_LE_CONN_COMPLETE:
 +		hci_le_conn_complete_evt(hdev, skb);
 +		break;
  
++<<<<<<< HEAD
 +	case HCI_EV_LE_CONN_UPDATE_COMPLETE:
 +		hci_le_conn_update_complete_evt(hdev, skb);
 +		break;
++=======
+ 	/* Only match event if command OGF is for LE */
+ 	if (hdev->sent_cmd &&
+ 	    hci_opcode_ogf(hci_skb_opcode(hdev->sent_cmd)) == 0x08 &&
+ 	    hci_skb_event(hdev->sent_cmd) == ev->subevent) {
+ 		*opcode = hci_skb_opcode(hdev->sent_cmd);
+ 		hci_req_cmd_complete(hdev, *opcode, 0x00, req_complete,
+ 				     req_complete_skb);
+ 	}
+ 
+ 	subev = &hci_le_ev_table[ev->subevent];
+ 	if (!subev->func)
+ 		return;
++>>>>>>> 85b56857e194 (Bluetooth: hci_sync: Add support for waiting specific LE subevents)
  
 -	if (skb->len < subev->min_len) {
 -		bt_dev_err(hdev, "unexpected subevent 0x%2.2x length: %u < %u",
 -			   ev->subevent, skb->len, subev->min_len);
 -		return;
 -	}
 +	case HCI_EV_LE_ADVERTISING_REPORT:
 +		hci_le_adv_report_evt(hdev, skb);
 +		break;
  
 -	/* Just warn if the length is over max_len size it still be
 -	 * possible to partially parse the event so leave to callback to
 -	 * decide if that is acceptable.
 -	 */
 -	if (skb->len > subev->max_len)
 -		bt_dev_warn(hdev, "unexpected subevent 0x%2.2x length: %u > %u",
 -			    ev->subevent, skb->len, subev->max_len);
 +	case HCI_EV_LE_REMOTE_FEAT_COMPLETE:
 +		hci_le_remote_feat_complete_evt(hdev, skb);
 +		break;
  
 -	data = hci_le_ev_skb_pull(hdev, skb, ev->subevent, subev->min_len);
 -	if (!data)
 -		return;
 +	case HCI_EV_LE_LTK_REQ:
 +		hci_le_ltk_request_evt(hdev, skb);
 +		break;
 +
 +	case HCI_EV_LE_REMOTE_CONN_PARAM_REQ:
 +		hci_le_remote_conn_param_req_evt(hdev, skb);
 +		break;
 +
 +	case HCI_EV_LE_DIRECT_ADV_REPORT:
 +		hci_le_direct_adv_report_evt(hdev, skb);
 +		break;
 +
 +	case HCI_EV_LE_PHY_UPDATE_COMPLETE:
 +		hci_le_phy_update_evt(hdev, skb);
 +		break;
 +
 +	case HCI_EV_LE_EXT_ADV_REPORT:
 +		hci_le_ext_adv_report_evt(hdev, skb);
 +		break;
  
 -	subev->func(hdev, data, skb);
 +	case HCI_EV_LE_ENHANCED_CONN_COMPLETE:
 +		hci_le_enh_conn_complete_evt(hdev, skb);
 +		break;
 +
 +	case HCI_EV_LE_EXT_ADV_SET_TERM:
 +		hci_le_ext_adv_term_evt(hdev, skb);
 +		break;
 +
 +	default:
 +		break;
 +	}
  }
  
  static bool hci_get_cmd_complete(struct hci_dev *hdev, u16 opcode,
diff --git a/include/net/bluetooth/bluetooth.h b/include/net/bluetooth/bluetooth.h
index 77906832353f..4b3d0b16c185 100644
--- a/include/net/bluetooth/bluetooth.h
+++ b/include/net/bluetooth/bluetooth.h
@@ -412,6 +412,7 @@ struct bt_skb_cb {
 #define hci_skb_pkt_type(skb) bt_cb((skb))->pkt_type
 #define hci_skb_expect(skb) bt_cb((skb))->expect
 #define hci_skb_opcode(skb) bt_cb((skb))->hci.opcode
+#define hci_skb_event(skb) bt_cb((skb))->hci.req_event
 #define hci_skb_sk(skb) bt_cb((skb))->hci.sk
 
 static inline struct sk_buff *bt_skb_alloc(unsigned int len, gfp_t how)
* Unmerged path net/bluetooth/hci_event.c
diff --git a/net/bluetooth/hci_sync.c b/net/bluetooth/hci_sync.c
index eb0e0482fa3f..af576fcf320d 100644
--- a/net/bluetooth/hci_sync.c
+++ b/net/bluetooth/hci_sync.c
@@ -97,7 +97,7 @@ static void hci_cmd_sync_add(struct hci_request *req, u16 opcode, u32 plen,
 	if (skb_queue_empty(&req->cmd_q))
 		bt_cb(skb)->hci.req_flags |= HCI_REQ_START;
 
-	bt_cb(skb)->hci.req_event = event;
+	hci_skb_event(skb) = event;
 
 	skb_queue_tail(&req->cmd_q, skb);
 }
