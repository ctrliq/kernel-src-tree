tty: n_gsm: fix missing timer to handle stalled links

jira LE-1907
cve CVE-2023-6546
Rebuild_History Non-Buildable kernel-4.18.0-541.el8
commit-author Daniel Starke <daniel.starke@siemens.com>
commit c568f7086c6e771c77aad13d727c70ef70e07243
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-541.el8/c568f708.failed

The current implementation does not handle the situation that no data is in
the internal queue and needs to be sent out while the user tty fifo is
full.
Add a timer that moves more data from user tty down to the internal queue
which is then serialized on the ldisc. This timer is triggered if no data
was moved from a user tty to the internal queue within 10 * T1.

Fixes: e1eaea46bb40 ("tty: n_gsm line discipline")
	Signed-off-by: Daniel Starke <daniel.starke@siemens.com>
Link: https://lore.kernel.org/r/20220701061652.39604-4-daniel.starke@siemens.com
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit c568f7086c6e771c77aad13d727c70ef70e07243)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/tty/n_gsm.c
diff --cc drivers/tty/n_gsm.c
index c18b3bdd43dc,a01225819b92..000000000000
--- a/drivers/tty/n_gsm.c
+++ b/drivers/tty/n_gsm.c
@@@ -883,41 -888,48 +885,62 @@@ static int gsm_dlci_data_output(struct 
  {
  	struct gsm_msg *msg;
  	u8 *dp;
 -	int h, len, size;
 -
 -	/* for modem bits without break data */
 -	h = ((dlci->adaption == 1) ? 0 : 1);
 -
 -	len = kfifo_len(&dlci->fifo);
 -	if (len == 0)
 -		return 0;
 -
 -	/* MTU/MRU count only the data bits but watch adaption mode */
 -	if ((len + h) > gsm->mtu)
 -		len = gsm->mtu - h;
 +	int len, total_size, size;
 +	int h = dlci->adaption - 1;
  
 +	total_size = 0;
 +	while (1) {
 +		len = kfifo_len(dlci->fifo);
 +		if (len == 0)
 +			return total_size;
 +
 +		/* MTU/MRU count only the data bits */
 +		if (len > gsm->mtu)
 +			len = gsm->mtu;
 +
 +		size = len + h;
 +
++<<<<<<< HEAD
 +		msg = gsm_data_alloc(gsm, dlci->addr, size, gsm->ftype);
 +		/* FIXME: need a timer or something to kick this so it can't
 +		   get stuck with no work outstanding and no buffer free */
 +		if (msg == NULL)
 +			return -ENOMEM;
 +		dp = msg->data;
 +		switch (dlci->adaption) {
 +		case 1:	/* Unstructured */
 +			break;
 +		case 2:	/* Unstructed with modem bits.
 +		Always one byte as we never send inline break data */
 +			*dp++ = (gsm_encode_modem(dlci) << 1) | EA;
 +			break;
 +		}
 +		WARN_ON(kfifo_out_locked(dlci->fifo, dp , len, &dlci->lock) != len);
 +		__gsm_data_queue(dlci, msg);
 +		total_size += size;
++=======
+ 	size = len + h;
+ 
+ 	msg = gsm_data_alloc(gsm, dlci->addr, size, gsm->ftype);
+ 	if (!msg)
+ 		return -ENOMEM;
+ 	dp = msg->data;
+ 	switch (dlci->adaption) {
+ 	case 1: /* Unstructured */
+ 		break;
+ 	case 2: /* Unstructured with modem bits.
+ 		 * Always one byte as we never send inline break data
+ 		 */
+ 		*dp++ = (gsm_encode_modem(dlci) << 1) | EA;
+ 		break;
+ 	default:
+ 		pr_err("%s: unsupported adaption %d\n", __func__,
+ 		       dlci->adaption);
+ 		break;
++>>>>>>> c568f7086c6e (tty: n_gsm: fix missing timer to handle stalled links)
  	}
 -
 -	WARN_ON(len != kfifo_out_locked(&dlci->fifo, dp, len,
 -		&dlci->lock));
 -
 -	/* Notify upper layer about available send space. */
 -	tty_port_tty_wakeup(&dlci->port);
 -
 -	__gsm_data_queue(dlci, msg);
  	/* Bytes of data we used up */
 -	return size;
 +	return total_size;
  }
  
  /**
* Unmerged path drivers/tty/n_gsm.c
