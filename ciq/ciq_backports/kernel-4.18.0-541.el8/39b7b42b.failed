tty: stop using alloc_tty_driver

jira LE-1907
cve CVE-2023-6546
Rebuild_History Non-Buildable kernel-4.18.0-541.el8
commit-author Jiri Slaby <jslaby@suse.cz>
commit 39b7b42be4a82f036c392abc71724b4b7752ac03
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-541.el8/39b7b42b.failed

alloc_tty_driver was deprecated by tty_alloc_driver in commit
7f0bc6a68ed9 (TTY: pass flags to alloc_tty_driver) in 2012.

I never got into eliminating alloc_tty_driver until now. So we still
have two functions for allocating drivers which might be confusing. So
get rid of alloc_tty_driver uses to eliminate it for good in the next
patch.

Note we need to switch return value checking as tty_alloc_driver uses
ERR_PTR. And flags are now a parameter of tty_alloc_driver.

	Cc: Richard Henderson <rth@twiddle.net>(odd fixer:ALPHA PORT)
	Cc: Ivan Kokshaysky <ink@jurassic.park.msu.ru>
	Cc: Matt Turner <mattst88@gmail.com>
	Cc: Geert Uytterhoeven <geert@linux-m68k.org>
	Cc: "James E.J. Bottomley" <James.Bottomley@HansenPartnership.com>
	Cc: Helge Deller <deller@gmx.de>
	Cc: Jeff Dike <jdike@addtoit.com>
	Cc: Richard Weinberger <richard@nod.at>
	Cc: Anton Ivanov <anton.ivanov@cambridgegreys.com>
	Cc: Chris Zankel <chris@zankel.net>
	Cc: Max Filippov <jcmvbkbc@gmail.com>
	Cc: Samuel Iglesias Gonsalvez <siglesias@igalia.com>
	Cc: Jens Taprogge <jens.taprogge@taprogge.org>
	Cc: Karsten Keil <isdn@linux-pingi.de>
	Cc: Ulf Hansson <ulf.hansson@linaro.org>
	Cc: "David S. Miller" <davem@davemloft.net>
	Cc: Jakub Kicinski <kuba@kernel.org>
	Cc: Heiko Carstens <hca@linux.ibm.com>
	Cc: Vasily Gorbik <gor@linux.ibm.com>
	Cc: Christian Borntraeger <borntraeger@de.ibm.com>
	Cc: Laurentiu Tudor <laurentiu.tudor@nxp.com>
	Cc: Jiri Kosina <jikos@kernel.org>
	Cc: David Sterba <dsterba@suse.com>
	Cc: Shawn Guo <shawnguo@kernel.org>
	Cc: Sascha Hauer <s.hauer@pengutronix.de>
	Cc: Oliver Neukum <oneukum@suse.com>
	Cc: Felipe Balbi <balbi@kernel.org>
	Cc: Johan Hovold <johan@kernel.org>
	Cc: Marcel Holtmann <marcel@holtmann.org>
	Cc: Johan Hedberg <johan.hedberg@gmail.com>
	Cc: Luiz Augusto von Dentz <luiz.dentz@gmail.com>
	Acked-by: Samuel Iglesias Gons√°lvez <siglesias@igalia.com>
	Acked-by: Max Filippov <jcmvbkbc@gmail.com>
	Acked-by: David Sterba <dsterba@suse.com>
	Acked-by: Christian Borntraeger <borntraeger@de.ibm.com>
	Signed-off-by: Jiri Slaby <jslaby@suse.cz>
Link: https://lore.kernel.org/r/20210723074317.32690-5-jslaby@suse.cz
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 39b7b42be4a82f036c392abc71724b4b7752ac03)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/m68k/emu/nfcon.c
#	arch/parisc/kernel/pdc_cons.c
#	arch/xtensa/platforms/iss/console.c
#	drivers/tty/amiserial.c
#	drivers/tty/ehv_bytechan.c
#	drivers/tty/hvc/hvsi.c
#	drivers/tty/mxser.c
#	drivers/usb/gadget/function/u_serial.c
diff --cc arch/m68k/emu/nfcon.c
index 57e8c8fb5eba,b3b64d03bad6..000000000000
--- a/arch/m68k/emu/nfcon.c
+++ b/arch/m68k/emu/nfcon.c
@@@ -126,25 -127,24 +126,39 @@@ static int __init nfcon_init(void
  	if (!stderr_id)
  		return -ENODEV;
  
++<<<<<<< HEAD
 +	nfcon_tty_driver = alloc_tty_driver(1);
 +	if (!nfcon_tty_driver)
 +		return -ENOMEM;
 +
 +	tty_port_init(&nfcon_tty_port);
 +
 +	nfcon_tty_driver->driver_name = "nfcon";
 +	nfcon_tty_driver->name = "nfcon";
 +	nfcon_tty_driver->type = TTY_DRIVER_TYPE_SYSTEM;
 +	nfcon_tty_driver->subtype = SYSTEM_TYPE_TTY;
 +	nfcon_tty_driver->init_termios = tty_std_termios;
 +	nfcon_tty_driver->flags = TTY_DRIVER_REAL_RAW;
++=======
+ 	driver = tty_alloc_driver(1, TTY_DRIVER_REAL_RAW);
+ 	if (IS_ERR(driver))
+ 		return PTR_ERR(driver);
+ 
+ 	tty_port_init(&nfcon_tty_port);
+ 
+ 	driver->driver_name = "nfcon";
+ 	driver->name = "nfcon";
+ 	driver->type = TTY_DRIVER_TYPE_SYSTEM;
+ 	driver->subtype = SYSTEM_TYPE_TTY;
+ 	driver->init_termios = tty_std_termios;
++>>>>>>> 39b7b42be4a8 (tty: stop using alloc_tty_driver)
  
 -	tty_set_operations(driver, &nfcon_tty_ops);
 -	tty_port_link_device(&nfcon_tty_port, driver, 0);
 -	res = tty_register_driver(driver);
 +	tty_set_operations(nfcon_tty_driver, &nfcon_tty_ops);
 +	tty_port_link_device(&nfcon_tty_port, nfcon_tty_driver, 0);
 +	res = tty_register_driver(nfcon_tty_driver);
  	if (res) {
  		pr_err("failed to register nfcon tty driver\n");
 -		put_tty_driver(driver);
 +		put_tty_driver(nfcon_tty_driver);
  		tty_port_destroy(&nfcon_tty_port);
  		return res;
  	}
diff --cc arch/parisc/kernel/pdc_cons.c
index c46bf29ae412,70c2a1648fc1..000000000000
--- a/arch/parisc/kernel/pdc_cons.c
+++ b/arch/parisc/kernel/pdc_cons.c
@@@ -180,25 -161,23 +180,43 @@@ static int __init pdc_console_tty_drive
  	printk(KERN_INFO "The PDC console driver is still registered, removing CON_BOOT flag\n");
  	pdc_cons.flags &= ~CON_BOOT;
  
++<<<<<<< HEAD
 +	pdc_console_tty_driver = alloc_tty_driver(1);
 +
 +	if (!pdc_console_tty_driver)
 +		return -ENOMEM;
 +
 +	tty_port_init(&tty_port);
 +
 +	pdc_console_tty_driver->driver_name = "pdc_cons";
 +	pdc_console_tty_driver->name = "ttyB";
 +	pdc_console_tty_driver->major = MUX_MAJOR;
 +	pdc_console_tty_driver->minor_start = 0;
 +	pdc_console_tty_driver->type = TTY_DRIVER_TYPE_SYSTEM;
 +	pdc_console_tty_driver->init_termios = tty_std_termios;
 +	pdc_console_tty_driver->flags = TTY_DRIVER_REAL_RAW |
 +		TTY_DRIVER_RESET_TERMIOS;
 +	tty_set_operations(pdc_console_tty_driver, &pdc_console_tty_ops);
 +	tty_port_link_device(&tty_port, pdc_console_tty_driver, 0);
++=======
+ 	driver = tty_alloc_driver(1, TTY_DRIVER_REAL_RAW |
+ 			TTY_DRIVER_RESET_TERMIOS);
+ 	if (IS_ERR(driver))
+ 		return PTR_ERR(driver);
+ 
+ 	tty_port_init(&tty_port);
+ 
+ 	driver->driver_name = "pdc_cons";
+ 	driver->name = "ttyB";
+ 	driver->major = MUX_MAJOR;
+ 	driver->minor_start = 0;
+ 	driver->type = TTY_DRIVER_TYPE_SYSTEM;
+ 	driver->init_termios = tty_std_termios;
+ 	tty_set_operations(driver, &pdc_console_tty_ops);
+ 	tty_port_link_device(&tty_port, driver, 0);
++>>>>>>> 39b7b42be4a8 (tty: stop using alloc_tty_driver)
  
 -	err = tty_register_driver(driver);
 +	err = tty_register_driver(pdc_console_tty_driver);
  	if (err) {
  		printk(KERN_ERR "Unable to register the PDC console TTY driver\n");
  		tty_port_destroy(&tty_port);
diff --cc arch/xtensa/platforms/iss/console.c
index 075b7d0780f0,0b8a0565cdfd..000000000000
--- a/arch/xtensa/platforms/iss/console.c
+++ b/arch/xtensa/platforms/iss/console.c
@@@ -166,32 -134,43 +166,45 @@@ static const struct tty_operations seri
  	.proc_show = rs_proc_show,
  };
  
 -static int __init rs_init(void)
 +int __init rs_init(void)
  {
++<<<<<<< HEAD
++=======
+ 	struct tty_driver *driver;
+ 	int ret;
+ 
+ 	driver = tty_alloc_driver(SERIAL_MAX_NUM_LINES, TTY_DRIVER_REAL_RAW);
+ 	if (IS_ERR(driver))
+ 		return PTR_ERR(driver);
+ 
++>>>>>>> 39b7b42be4a8 (tty: stop using alloc_tty_driver)
  	tty_port_init(&serial_port);
  
 -	/* Initialize the tty_driver structure */
 -
 -	driver->driver_name = "iss_serial";
 -	driver->name = "ttyS";
 -	driver->major = TTY_MAJOR;
 -	driver->minor_start = 64;
 -	driver->type = TTY_DRIVER_TYPE_SERIAL;
 -	driver->subtype = SERIAL_TYPE_NORMAL;
 -	driver->init_termios = tty_std_termios;
 -	driver->init_termios.c_cflag =
 -		B9600 | CS8 | CREAD | HUPCL | CLOCAL;
 +	serial_driver = alloc_tty_driver(SERIAL_MAX_NUM_LINES);
  
 -	tty_set_operations(driver, &serial_ops);
 -	tty_port_link_device(&serial_port, driver, 0);
 +	pr_info("%s %s\n", serial_name, serial_version);
  
 -	ret = tty_register_driver(driver);
 -	if (ret) {
 -		pr_err("Couldn't register serial driver\n");
 -		tty_driver_kref_put(driver);
 -		tty_port_destroy(&serial_port);
 +	/* Initialize the tty_driver structure */
  
 -		return ret;
 -	}
 +	serial_driver->driver_name = "iss_serial";
 +	serial_driver->name = "ttyS";
 +	serial_driver->major = TTY_MAJOR;
 +	serial_driver->minor_start = 64;
 +	serial_driver->type = TTY_DRIVER_TYPE_SERIAL;
 +	serial_driver->subtype = SERIAL_TYPE_NORMAL;
 +	serial_driver->init_termios = tty_std_termios;
 +	serial_driver->init_termios.c_cflag =
 +		B9600 | CS8 | CREAD | HUPCL | CLOCAL;
++<<<<<<< HEAD
 +	serial_driver->flags = TTY_DRIVER_REAL_RAW;
++=======
++>>>>>>> 39b7b42be4a8 (tty: stop using alloc_tty_driver)
  
 -	serial_driver = driver;
 +	tty_set_operations(serial_driver, &serial_ops);
 +	tty_port_link_device(&serial_port, serial_driver, 0);
  
 +	if (tty_register_driver(serial_driver))
 +		panic("Couldn't register serial driver\n");
  	return 0;
  }
  
diff --cc drivers/tty/amiserial.c
index 13e710e3b8fd,50f1a54ef35a..000000000000
--- a/drivers/tty/amiserial.c
+++ b/drivers/tty/amiserial.c
@@@ -1612,23 -1493,23 +1612,33 @@@ static int __init amiga_serial_probe(st
  	unsigned long flags;
  	int error;
  
++<<<<<<< HEAD
 +	serial_driver = alloc_tty_driver(1);
 +	if (!serial_driver)
 +		return -ENOMEM;
++=======
+ 	driver = tty_alloc_driver(1, TTY_DRIVER_REAL_RAW);
+ 	if (IS_ERR(driver))
+ 		return PTR_ERR(driver);
++>>>>>>> 39b7b42be4a8 (tty: stop using alloc_tty_driver)
  
  	/* Initialize the tty_driver structure */
  
 -	driver->driver_name = "amiserial";
 -	driver->name = "ttyS";
 -	driver->major = TTY_MAJOR;
 -	driver->minor_start = 64;
 -	driver->type = TTY_DRIVER_TYPE_SERIAL;
 -	driver->subtype = SERIAL_TYPE_NORMAL;
 -	driver->init_termios = tty_std_termios;
 -	driver->init_termios.c_cflag =
 +	serial_driver->driver_name = "amiserial";
 +	serial_driver->name = "ttyS";
 +	serial_driver->major = TTY_MAJOR;
 +	serial_driver->minor_start = 64;
 +	serial_driver->type = TTY_DRIVER_TYPE_SERIAL;
 +	serial_driver->subtype = SERIAL_TYPE_NORMAL;
 +	serial_driver->init_termios = tty_std_termios;
 +	serial_driver->init_termios.c_cflag =
  		B9600 | CS8 | CREAD | HUPCL | CLOCAL;
++<<<<<<< HEAD
 +	serial_driver->flags = TTY_DRIVER_REAL_RAW;
 +	tty_set_operations(serial_driver, &serial_ops);
++=======
+ 	tty_set_operations(driver, &serial_ops);
++>>>>>>> 39b7b42be4a8 (tty: stop using alloc_tty_driver)
  
  	memset(state, 0, sizeof(*state));
  	state->port = (int)&amiga_custom.serdatr; /* Just to give it a value */
diff --cc drivers/tty/ehv_bytechan.c
index eea4049b5dcc,f580a5de3c98..000000000000
--- a/drivers/tty/ehv_bytechan.c
+++ b/drivers/tty/ehv_bytechan.c
@@@ -758,21 -774,21 +758,37 @@@ static int __init ehv_bc_init(void
  	if (!bcs)
  		return -ENOMEM;
  
++<<<<<<< HEAD
 +	ehv_bc_driver = alloc_tty_driver(count);
 +	if (!ehv_bc_driver) {
 +		ret = -ENOMEM;
 +		goto err_free_bcs;
 +	}
 +
 +	ehv_bc_driver->driver_name = "ehv-bc";
 +	ehv_bc_driver->name = ehv_bc_console.name;
 +	ehv_bc_driver->type = TTY_DRIVER_TYPE_CONSOLE;
 +	ehv_bc_driver->subtype = SYSTEM_TYPE_CONSOLE;
 +	ehv_bc_driver->init_termios = tty_std_termios;
 +	ehv_bc_driver->flags = TTY_DRIVER_REAL_RAW | TTY_DRIVER_DYNAMIC_DEV;
 +	tty_set_operations(ehv_bc_driver, &ehv_bc_ops);
++=======
+ 	driver = tty_alloc_driver(count, TTY_DRIVER_REAL_RAW |
+ 			TTY_DRIVER_DYNAMIC_DEV);
+ 	if (IS_ERR(driver)) {
+ 		ret = PTR_ERR(driver);
+ 		goto err_free_bcs;
+ 	}
+ 
+ 	driver->driver_name = "ehv-bc";
+ 	driver->name = ehv_bc_console.name;
+ 	driver->type = TTY_DRIVER_TYPE_CONSOLE;
+ 	driver->subtype = SYSTEM_TYPE_CONSOLE;
+ 	driver->init_termios = tty_std_termios;
+ 	tty_set_operations(driver, &ehv_bc_ops);
++>>>>>>> 39b7b42be4a8 (tty: stop using alloc_tty_driver)
  
 -	ret = tty_register_driver(driver);
 +	ret = tty_register_driver(ehv_bc_driver);
  	if (ret) {
  		pr_err("ehv-bc: could not register tty driver (ret=%i)\n", ret);
  		goto err_put_tty_driver;
diff --cc drivers/tty/hvc/hvsi.c
index d6afaae1729a,aa81f4835fef..000000000000
--- a/drivers/tty/hvc/hvsi.c
+++ b/drivers/tty/hvc/hvsi.c
@@@ -1038,23 -1038,23 +1038,40 @@@ static const struct tty_operations hvsi
  
  static int __init hvsi_init(void)
  {
 -	struct tty_driver *driver;
  	int i, ret;
  
++<<<<<<< HEAD
 +	hvsi_driver = alloc_tty_driver(hvsi_count);
 +	if (!hvsi_driver)
 +		return -ENOMEM;
 +
 +	hvsi_driver->driver_name = "hvsi";
 +	hvsi_driver->name = "hvsi";
 +	hvsi_driver->major = HVSI_MAJOR;
 +	hvsi_driver->minor_start = HVSI_MINOR;
 +	hvsi_driver->type = TTY_DRIVER_TYPE_SYSTEM;
 +	hvsi_driver->init_termios = tty_std_termios;
 +	hvsi_driver->init_termios.c_cflag = B9600 | CS8 | CREAD | HUPCL;
 +	hvsi_driver->init_termios.c_ispeed = 9600;
 +	hvsi_driver->init_termios.c_ospeed = 9600;
 +	hvsi_driver->flags = TTY_DRIVER_REAL_RAW;
 +	tty_set_operations(hvsi_driver, &hvsi_ops);
++=======
+ 	driver = tty_alloc_driver(hvsi_count, TTY_DRIVER_REAL_RAW);
+ 	if (IS_ERR(driver))
+ 		return PTR_ERR(driver);
+ 
+ 	driver->driver_name = "hvsi";
+ 	driver->name = "hvsi";
+ 	driver->major = HVSI_MAJOR;
+ 	driver->minor_start = HVSI_MINOR;
+ 	driver->type = TTY_DRIVER_TYPE_SYSTEM;
+ 	driver->init_termios = tty_std_termios;
+ 	driver->init_termios.c_cflag = B9600 | CS8 | CREAD | HUPCL;
+ 	driver->init_termios.c_ispeed = 9600;
+ 	driver->init_termios.c_ospeed = 9600;
+ 	tty_set_operations(driver, &hvsi_ops);
++>>>>>>> 39b7b42be4a8 (tty: stop using alloc_tty_driver)
  
  	for (i=0; i < hvsi_count; i++) {
  		struct hvsi_struct *hp = &hvsi_ports[i];
diff --cc drivers/tty/mxser.c
index b5f4f2beb09c,650fc6fac88e..000000000000
--- a/drivers/tty/mxser.c
+++ b/drivers/tty/mxser.c
@@@ -2784,17 -1974,12 +2784,24 @@@ static struct pci_driver mxser_driver 
  
  static int __init mxser_module_init(void)
  {
 +	struct mxser_board *brd;
 +	struct device *tty_dev;
 +	unsigned int b, i, m;
  	int retval;
  
++<<<<<<< HEAD
 +	mxvar_sdriver = alloc_tty_driver(MXSER_PORTS + 1);
 +	if (!mxvar_sdriver)
 +		return -ENOMEM;
++=======
+ 	mxvar_sdriver = tty_alloc_driver(MXSER_PORTS, TTY_DRIVER_REAL_RAW |
+ 			TTY_DRIVER_DYNAMIC_DEV);
+ 	if (IS_ERR(mxvar_sdriver))
+ 		return PTR_ERR(mxvar_sdriver);
++>>>>>>> 39b7b42be4a8 (tty: stop using alloc_tty_driver)
 +
 +	printk(KERN_INFO "MOXA Smartio/Industio family driver version %s\n",
 +		MXSER_VERSION);
  
  	/* Initialize the tty_driver structure */
  	mxvar_sdriver->name = "ttyMI";
diff --cc drivers/usb/gadget/function/u_serial.c
index 65f634ec7fc2,74289f68a2ab..000000000000
--- a/drivers/usb/gadget/function/u_serial.c
+++ b/drivers/usb/gadget/function/u_serial.c
@@@ -1396,18 -1448,19 +1396,31 @@@ static int userial_init(void
  	unsigned			i;
  	int				status;
  
++<<<<<<< HEAD
 +	gs_tty_driver = alloc_tty_driver(MAX_U_SERIAL_PORTS);
 +	if (!gs_tty_driver)
 +		return -ENOMEM;
++=======
+ 	driver = tty_alloc_driver(MAX_U_SERIAL_PORTS, TTY_DRIVER_REAL_RAW |
+ 			TTY_DRIVER_DYNAMIC_DEV);
+ 	if (IS_ERR(driver))
+ 		return PTR_ERR(driver);
++>>>>>>> 39b7b42be4a8 (tty: stop using alloc_tty_driver)
  
 -	driver->driver_name = "g_serial";
 -	driver->name = "ttyGS";
 +	gs_tty_driver->driver_name = "g_serial";
 +	gs_tty_driver->name = "ttyGS";
  	/* uses dynamically assigned dev_t values */
  
++<<<<<<< HEAD
 +	gs_tty_driver->type = TTY_DRIVER_TYPE_SERIAL;
 +	gs_tty_driver->subtype = SERIAL_TYPE_NORMAL;
 +	gs_tty_driver->flags = TTY_DRIVER_REAL_RAW | TTY_DRIVER_DYNAMIC_DEV;
 +	gs_tty_driver->init_termios = tty_std_termios;
++=======
+ 	driver->type = TTY_DRIVER_TYPE_SERIAL;
+ 	driver->subtype = SERIAL_TYPE_NORMAL;
+ 	driver->init_termios = tty_std_termios;
++>>>>>>> 39b7b42be4a8 (tty: stop using alloc_tty_driver)
  
  	/* 9600-8-N-1 ... matches defaults expected by "usbser.sys" on
  	 * MS-Windows.  Otherwise, most of these flags shouldn't affect
diff --git a/arch/alpha/kernel/srmcons.c b/arch/alpha/kernel/srmcons.c
index 2b7a314b8452..3402712f1ee8 100644
--- a/arch/alpha/kernel/srmcons.c
+++ b/arch/alpha/kernel/srmcons.c
@@ -211,9 +211,9 @@ srmcons_init(void)
 		struct tty_driver *driver;
 		int err;
 
-		driver = alloc_tty_driver(MAX_SRM_CONSOLE_DEVICES);
-		if (!driver)
-			return -ENOMEM;
+		driver = tty_alloc_driver(MAX_SRM_CONSOLE_DEVICES, 0);
+		if (IS_ERR(driver))
+			return PTR_ERR(driver);
 
 		tty_port_init(&srmcons_singleton.port);
 
* Unmerged path arch/m68k/emu/nfcon.c
* Unmerged path arch/parisc/kernel/pdc_cons.c
diff --git a/arch/um/drivers/line.c b/arch/um/drivers/line.c
index 8d80b27502e6..d1fe3c1f76fc 100644
--- a/arch/um/drivers/line.c
+++ b/arch/um/drivers/line.c
@@ -550,12 +550,14 @@ int register_lines(struct line_driver *line_driver,
 		   const struct tty_operations *ops,
 		   struct line *lines, int nlines)
 {
-	struct tty_driver *driver = alloc_tty_driver(nlines);
+	struct tty_driver *driver;
 	int err;
 	int i;
 
-	if (!driver)
-		return -ENOMEM;
+	driver = tty_alloc_driver(nlines, TTY_DRIVER_REAL_RAW |
+			TTY_DRIVER_DYNAMIC_DEV);
+	if (IS_ERR(driver))
+		return PTR_ERR(driver);
 
 	driver->driver_name = line_driver->name;
 	driver->name = line_driver->device_name;
@@ -563,9 +565,8 @@ int register_lines(struct line_driver *line_driver,
 	driver->minor_start = line_driver->minor_start;
 	driver->type = line_driver->type;
 	driver->subtype = line_driver->subtype;
-	driver->flags = TTY_DRIVER_REAL_RAW | TTY_DRIVER_DYNAMIC_DEV;
 	driver->init_termios = tty_std_termios;
-	
+
 	for (i = 0; i < nlines; i++) {
 		tty_port_init(&lines[i].port);
 		lines[i].port.ops = &line_port_ops;
* Unmerged path arch/xtensa/platforms/iss/console.c
diff --git a/drivers/ipack/devices/ipoctal.c b/drivers/ipack/devices/ipoctal.c
index 75dd15d66df6..fcd5958867f5 100644
--- a/drivers/ipack/devices/ipoctal.c
+++ b/drivers/ipack/devices/ipoctal.c
@@ -352,10 +352,10 @@ static int ipoctal_inst_slot(struct ipoctal *ipoctal, unsigned int bus_nr,
 	/* Register the TTY device */
 
 	/* Each IP-OCTAL channel is a TTY port */
-	tty = alloc_tty_driver(NR_CHANNELS);
-
-	if (!tty)
-		return -ENOMEM;
+	tty = tty_alloc_driver(NR_CHANNELS, TTY_DRIVER_REAL_RAW |
+			TTY_DRIVER_DYNAMIC_DEV);
+	if (IS_ERR(tty))
+		return PTR_ERR(tty);
 
 	/* Fill struct tty_driver with ipoctal data */
 	tty->owner = THIS_MODULE;
@@ -367,7 +367,6 @@ static int ipoctal_inst_slot(struct ipoctal *ipoctal, unsigned int bus_nr,
 	tty->minor_start = 0;
 	tty->type = TTY_DRIVER_TYPE_SERIAL;
 	tty->subtype = SERIAL_TYPE_NORMAL;
-	tty->flags = TTY_DRIVER_REAL_RAW | TTY_DRIVER_DYNAMIC_DEV;
 	tty->init_termios = tty_std_termios;
 	tty->init_termios.c_cflag = B9600 | CS8 | CREAD | HUPCL | CLOCAL;
 	tty->init_termios.c_ispeed = 9600;
diff --git a/drivers/isdn/capi/capi.c b/drivers/isdn/capi/capi.c
index 8dac190a978d..c6d84b303c28 100644
--- a/drivers/isdn/capi/capi.c
+++ b/drivers/isdn/capi/capi.c
@@ -1265,10 +1265,11 @@ static int __init capinc_tty_init(void)
 	if (!capiminors)
 		return -ENOMEM;
 
-	drv = alloc_tty_driver(capi_ttyminors);
-	if (!drv) {
+	drv = tty_alloc_driver(capi_ttyminors, TTY_DRIVER_REAL_RAW |
+			TTY_DRIVER_RESET_TERMIOS | TTY_DRIVER_DYNAMIC_DEV);
+	if (IS_ERR(drv)) {
 		kfree(capiminors);
-		return -ENOMEM;
+		return PTR_ERR(drv);
 	}
 	drv->driver_name = "capi_nc";
 	drv->name = "capi!";
@@ -1281,9 +1282,6 @@ static int __init capinc_tty_init(void)
 	drv->init_termios.c_oflag = OPOST | ONLCR;
 	drv->init_termios.c_cflag = B9600 | CS8 | CREAD | HUPCL | CLOCAL;
 	drv->init_termios.c_lflag = 0;
-	drv->flags =
-		TTY_DRIVER_REAL_RAW | TTY_DRIVER_RESET_TERMIOS |
-		TTY_DRIVER_DYNAMIC_DEV;
 	tty_set_operations(drv, &capinc_ops);
 
 	err = tty_register_driver(drv);
diff --git a/drivers/mmc/core/sdio_uart.c b/drivers/mmc/core/sdio_uart.c
index 25e113001a3c..0d22afcf4812 100644
--- a/drivers/mmc/core/sdio_uart.c
+++ b/drivers/mmc/core/sdio_uart.c
@@ -1139,9 +1139,10 @@ static int __init sdio_uart_init(void)
 	int ret;
 	struct tty_driver *tty_drv;
 
-	sdio_uart_tty_driver = tty_drv = alloc_tty_driver(UART_NR);
-	if (!tty_drv)
-		return -ENOMEM;
+	sdio_uart_tty_driver = tty_drv = tty_alloc_driver(UART_NR,
+			TTY_DRIVER_REAL_RAW | TTY_DRIVER_DYNAMIC_DEV);
+	if (IS_ERR(tty_drv))
+		return PTR_ERR(tty_drv);
 
 	tty_drv->driver_name = "sdio_uart";
 	tty_drv->name =   "ttySDIO";
@@ -1149,7 +1150,6 @@ static int __init sdio_uart_init(void)
 	tty_drv->minor_start = 0;
 	tty_drv->type = TTY_DRIVER_TYPE_SERIAL;
 	tty_drv->subtype = SERIAL_TYPE_NORMAL;
-	tty_drv->flags = TTY_DRIVER_REAL_RAW | TTY_DRIVER_DYNAMIC_DEV;
 	tty_drv->init_termios = tty_std_termios;
 	tty_drv->init_termios.c_cflag = B4800 | CS8 | CREAD | HUPCL | CLOCAL;
 	tty_drv->init_termios.c_ispeed = 4800;
diff --git a/drivers/net/usb/hso.c b/drivers/net/usb/hso.c
index e3a52f7886f3..93f4b38b7b17 100644
--- a/drivers/net/usb/hso.c
+++ b/drivers/net/usb/hso.c
@@ -3257,9 +3257,10 @@ static int __init hso_init(void)
 		serial_table[i] = NULL;
 
 	/* allocate our driver using the proper amount of supported minors */
-	tty_drv = alloc_tty_driver(HSO_SERIAL_TTY_MINORS);
-	if (!tty_drv)
-		return -ENOMEM;
+	tty_drv = tty_alloc_driver(HSO_SERIAL_TTY_MINORS, TTY_DRIVER_REAL_RAW |
+			TTY_DRIVER_DYNAMIC_DEV);
+	if (IS_ERR(tty_drv))
+		return PTR_ERR(tty_drv);
 
 	/* fill in all needed values */
 	tty_drv->driver_name = driver_name;
@@ -3272,7 +3273,6 @@ static int __init hso_init(void)
 	tty_drv->minor_start = 0;
 	tty_drv->type = TTY_DRIVER_TYPE_SERIAL;
 	tty_drv->subtype = SERIAL_TYPE_NORMAL;
-	tty_drv->flags = TTY_DRIVER_REAL_RAW | TTY_DRIVER_DYNAMIC_DEV;
 	tty_drv->init_termios = tty_std_termios;
 	hso_init_termios(&tty_drv->init_termios);
 	tty_set_operations(tty_drv, &hso_serial_ops);
diff --git a/drivers/s390/char/con3215.c b/drivers/s390/char/con3215.c
index 1a9698ec0768..10bef5ae4f64 100644
--- a/drivers/s390/char/con3215.c
+++ b/drivers/s390/char/con3215.c
@@ -1179,9 +1179,9 @@ static int __init tty3215_init(void)
 	if (!CONSOLE_IS_3215)
 		return 0;
 
-	driver = alloc_tty_driver(NR_3215);
-	if (!driver)
-		return -ENOMEM;
+	driver = tty_alloc_driver(NR_3215, TTY_DRIVER_REAL_RAW);
+	if (IS_ERR(driver))
+		return PTR_ERR(driver);
 
 	ret = ccw_driver_register(&raw3215_ccw_driver);
 	if (ret) {
@@ -1204,7 +1204,6 @@ static int __init tty3215_init(void)
 	driver->init_termios.c_iflag = IGNBRK | IGNPAR;
 	driver->init_termios.c_oflag = ONLCR;
 	driver->init_termios.c_lflag = ISIG;
-	driver->flags = TTY_DRIVER_REAL_RAW;
 	tty_set_operations(driver, &tty3215_ops);
 	ret = tty_register_driver(driver);
 	if (ret) {
diff --git a/drivers/s390/char/sclp_tty.c b/drivers/s390/char/sclp_tty.c
index 013bcc331305..5a23e92b72dd 100644
--- a/drivers/s390/char/sclp_tty.c
+++ b/drivers/s390/char/sclp_tty.c
@@ -506,9 +506,9 @@ sclp_tty_init(void)
 		return 0;
 	if (!sclp.has_linemode)
 		return 0;
-	driver = alloc_tty_driver(1);
-	if (!driver)
-		return -ENOMEM;
+	driver = tty_alloc_driver(1, TTY_DRIVER_REAL_RAW);
+	if (IS_ERR(driver))
+		return PTR_ERR(driver);
 
 	rc = sclp_rw_init();
 	if (rc) {
@@ -559,7 +559,6 @@ sclp_tty_init(void)
 	driver->init_termios.c_iflag = IGNBRK | IGNPAR;
 	driver->init_termios.c_oflag = ONLCR;
 	driver->init_termios.c_lflag = ISIG | ECHO;
-	driver->flags = TTY_DRIVER_REAL_RAW;
 	tty_set_operations(driver, &sclp_ops);
 	tty_port_link_device(&sclp_port, driver, 0);
 	rc = tty_register_driver(driver);
diff --git a/drivers/s390/char/sclp_vt220.c b/drivers/s390/char/sclp_vt220.c
index 047f812d1a1c..358d49571290 100644
--- a/drivers/s390/char/sclp_vt220.c
+++ b/drivers/s390/char/sclp_vt220.c
@@ -741,9 +741,9 @@ static int __init sclp_vt220_tty_init(void)
 
 	/* Note: we're not testing for CONSOLE_IS_SCLP here to preserve
 	 * symmetry between VM and LPAR systems regarding ttyS1. */
-	driver = alloc_tty_driver(1);
-	if (!driver)
-		return -ENOMEM;
+	driver = tty_alloc_driver(1, TTY_DRIVER_REAL_RAW);
+	if (IS_ERR(driver))
+		return PTR_ERR(driver);
 	rc = __sclp_vt220_init(MAX_KMEM_PAGES);
 	if (rc)
 		goto out_driver;
@@ -755,7 +755,6 @@ static int __init sclp_vt220_tty_init(void)
 	driver->type = TTY_DRIVER_TYPE_SYSTEM;
 	driver->subtype = SYSTEM_TYPE_TTY;
 	driver->init_termios = tty_std_termios;
-	driver->flags = TTY_DRIVER_REAL_RAW;
 	tty_set_operations(driver, &sclp_vt220_ops);
 	tty_port_link_device(&sclp_vt220_port, driver, 0);
 
diff --git a/drivers/staging/gdm724x/gdm_tty.c b/drivers/staging/gdm724x/gdm_tty.c
index e0450c3e01fa..2d590c2934ac 100644
--- a/drivers/staging/gdm724x/gdm_tty.c
+++ b/drivers/staging/gdm724x/gdm_tty.c
@@ -289,9 +289,10 @@ int register_lte_tty_driver(void)
 	int ret;
 
 	for (i = 0; i < TTY_MAX_COUNT; i++) {
-		tty_driver = alloc_tty_driver(GDM_TTY_MINOR);
-		if (!tty_driver)
-			return -ENOMEM;
+		tty_driver = tty_alloc_driver(GDM_TTY_MINOR,
+				TTY_DRIVER_REAL_RAW | TTY_DRIVER_DYNAMIC_DEV);
+		if (IS_ERR(tty_driver))
+			return PTR_ERR(tty_driver);
 
 		tty_driver->owner = THIS_MODULE;
 		tty_driver->driver_name = DRIVER_STRING[i];
@@ -299,8 +300,6 @@ int register_lte_tty_driver(void)
 		tty_driver->major = GDM_TTY_MAJOR;
 		tty_driver->type = TTY_DRIVER_TYPE_SERIAL;
 		tty_driver->subtype = SERIAL_TYPE_NORMAL;
-		tty_driver->flags = TTY_DRIVER_REAL_RAW |
-					TTY_DRIVER_DYNAMIC_DEV;
 		tty_driver->init_termios = tty_std_termios;
 		tty_driver->init_termios.c_cflag = B9600 | CS8 | HUPCL | CLOCAL;
 		tty_driver->init_termios.c_lflag = ISIG | ICANON | IEXTEN;
* Unmerged path drivers/tty/amiserial.c
* Unmerged path drivers/tty/ehv_bytechan.c
diff --git a/drivers/tty/goldfish.c b/drivers/tty/goldfish.c
index c5cab2691bd1..cc57447ce92b 100644
--- a/drivers/tty/goldfish.c
+++ b/drivers/tty/goldfish.c
@@ -252,18 +252,18 @@ static int goldfish_tty_create_driver(void)
 		ret = -ENOMEM;
 		goto err_alloc_goldfish_ttys_failed;
 	}
-	tty = alloc_tty_driver(goldfish_tty_line_count);
-	if (tty == NULL) {
-		ret = -ENOMEM;
-		goto err_alloc_tty_driver_failed;
+	tty = tty_alloc_driver(goldfish_tty_line_count,
+			TTY_DRIVER_RESET_TERMIOS | TTY_DRIVER_REAL_RAW |
+			TTY_DRIVER_DYNAMIC_DEV);
+	if (IS_ERR(tty)) {
+		ret = PTR_ERR(tty);
+		goto err_tty_alloc_driver_failed;
 	}
 	tty->driver_name = "goldfish";
 	tty->name = "ttyGF";
 	tty->type = TTY_DRIVER_TYPE_SERIAL;
 	tty->subtype = SERIAL_TYPE_NORMAL;
 	tty->init_termios = tty_std_termios;
-	tty->flags = TTY_DRIVER_RESET_TERMIOS | TTY_DRIVER_REAL_RAW |
-						TTY_DRIVER_DYNAMIC_DEV;
 	tty_set_operations(tty, &goldfish_tty_ops);
 	ret = tty_register_driver(tty);
 	if (ret)
@@ -274,7 +274,7 @@ static int goldfish_tty_create_driver(void)
 
 err_tty_register_driver_failed:
 	put_tty_driver(tty);
-err_alloc_tty_driver_failed:
+err_tty_alloc_driver_failed:
 	kfree(goldfish_ttys);
 	goldfish_ttys = NULL;
 err_alloc_goldfish_ttys_failed:
diff --git a/drivers/tty/hvc/hvc_console.c b/drivers/tty/hvc/hvc_console.c
index 7709fcc707f4..abf742a4df46 100644
--- a/drivers/tty/hvc/hvc_console.c
+++ b/drivers/tty/hvc/hvc_console.c
@@ -945,9 +945,10 @@ static int hvc_init(void)
 	int err;
 
 	/* We need more than hvc_count adapters due to hotplug additions. */
-	drv = alloc_tty_driver(HVC_ALLOC_TTY_ADAPTERS);
-	if (!drv) {
-		err = -ENOMEM;
+	drv = tty_alloc_driver(HVC_ALLOC_TTY_ADAPTERS, TTY_DRIVER_REAL_RAW |
+			TTY_DRIVER_RESET_TERMIOS);
+	if (IS_ERR(drv)) {
+		err = PTR_ERR(drv);
 		goto out;
 	}
 
@@ -957,7 +958,6 @@ static int hvc_init(void)
 	drv->minor_start = HVC_MINOR;
 	drv->type = TTY_DRIVER_TYPE_SYSTEM;
 	drv->init_termios = tty_std_termios;
-	drv->flags = TTY_DRIVER_REAL_RAW | TTY_DRIVER_RESET_TERMIOS;
 	tty_set_operations(drv, &hvc_ops);
 
 	/* Always start the kthread because there can be hotplug vty adapters
diff --git a/drivers/tty/hvc/hvcs.c b/drivers/tty/hvc/hvcs.c
index 6e7ecb0bb041..305e6be7ecd3 100644
--- a/drivers/tty/hvc/hvcs.c
+++ b/drivers/tty/hvc/hvcs.c
@@ -1457,10 +1457,11 @@ static int hvcs_initialize(void)
 	} else
 		num_ttys_to_alloc = hvcs_parm_num_devs;
 
-	hvcs_tty_driver = alloc_tty_driver(num_ttys_to_alloc);
-	if (!hvcs_tty_driver) {
+	hvcs_tty_driver = tty_alloc_driver(num_ttys_to_alloc,
+			TTY_DRIVER_REAL_RAW);
+	if (IS_ERR(hvcs_tty_driver)) {
 		mutex_unlock(&hvcs_init_mutex);
-		return -ENOMEM;
+		return PTR_ERR(hvcs_tty_driver);
 	}
 
 	if (hvcs_alloc_index_list(num_ttys_to_alloc)) {
@@ -1485,7 +1486,6 @@ static int hvcs_initialize(void)
 	 * throw us into a horrible recursive echo-echo-echo loop.
 	 */
 	hvcs_tty_driver->init_termios = hvcs_tty_termios;
-	hvcs_tty_driver->flags = TTY_DRIVER_REAL_RAW;
 
 	tty_set_operations(hvcs_tty_driver, &hvcs_ops);
 
* Unmerged path drivers/tty/hvc/hvsi.c
diff --git a/drivers/tty/ipwireless/tty.c b/drivers/tty/ipwireless/tty.c
index e3b7580531d8..af78ca1992f8 100644
--- a/drivers/tty/ipwireless/tty.c
+++ b/drivers/tty/ipwireless/tty.c
@@ -566,9 +566,10 @@ int ipwireless_tty_init(void)
 {
 	int result;
 
-	ipw_tty_driver = alloc_tty_driver(IPWIRELESS_PCMCIA_MINORS);
-	if (!ipw_tty_driver)
-		return -ENOMEM;
+	ipw_tty_driver = tty_alloc_driver(IPWIRELESS_PCMCIA_MINORS,
+			TTY_DRIVER_REAL_RAW | TTY_DRIVER_DYNAMIC_DEV);
+	if (IS_ERR(ipw_tty_driver))
+		return PTR_ERR(ipw_tty_driver);
 
 	ipw_tty_driver->driver_name = IPWIRELESS_PCCARD_NAME;
 	ipw_tty_driver->name = "ttyIPWp";
@@ -576,7 +577,6 @@ int ipwireless_tty_init(void)
 	ipw_tty_driver->minor_start = IPWIRELESS_PCMCIA_START;
 	ipw_tty_driver->type = TTY_DRIVER_TYPE_SERIAL;
 	ipw_tty_driver->subtype = SERIAL_TYPE_NORMAL;
-	ipw_tty_driver->flags = TTY_DRIVER_REAL_RAW | TTY_DRIVER_DYNAMIC_DEV;
 	ipw_tty_driver->init_termios = tty_std_termios;
 	ipw_tty_driver->init_termios.c_cflag =
 	    B9600 | CS8 | CREAD | HUPCL | CLOCAL;
* Unmerged path drivers/tty/mxser.c
diff --git a/drivers/tty/n_gsm.c b/drivers/tty/n_gsm.c
index 72a530f4e05c..8b929f6337d7 100644
--- a/drivers/tty/n_gsm.c
+++ b/drivers/tty/n_gsm.c
@@ -3249,10 +3249,11 @@ static int __init gsm_init(void)
 		return status;
 	}
 
-	gsm_tty_driver = alloc_tty_driver(256);
-	if (!gsm_tty_driver) {
+	gsm_tty_driver = tty_alloc_driver(256, TTY_DRIVER_REAL_RAW |
+			TTY_DRIVER_DYNAMIC_DEV | TTY_DRIVER_HARDWARE_BREAK);
+	if (IS_ERR(gsm_tty_driver)) {
 		pr_err("gsm_init: tty allocation failed.\n");
-		status = -ENOMEM;
+		status = PTR_ERR(gsm_tty_driver);
 		goto err_unreg_ldisc;
 	}
 	gsm_tty_driver->driver_name	= "gsmtty";
@@ -3261,8 +3262,6 @@ static int __init gsm_init(void)
 	gsm_tty_driver->minor_start	= 0;
 	gsm_tty_driver->type		= TTY_DRIVER_TYPE_SERIAL;
 	gsm_tty_driver->subtype	= SERIAL_TYPE_NORMAL;
-	gsm_tty_driver->flags	= TTY_DRIVER_REAL_RAW | TTY_DRIVER_DYNAMIC_DEV
-						| TTY_DRIVER_HARDWARE_BREAK;
 	gsm_tty_driver->init_termios	= tty_std_termios;
 	/* Fixme */
 	gsm_tty_driver->init_termios.c_lflag &= ~ECHO;
diff --git a/drivers/tty/nozomi.c b/drivers/tty/nozomi.c
index 931edc306aa0..f4ced1d9cb61 100644
--- a/drivers/tty/nozomi.c
+++ b/drivers/tty/nozomi.c
@@ -1855,16 +1855,16 @@ static __init int nozomi_init(void)
 {
 	int ret;
 
-	ntty_driver = alloc_tty_driver(NTTY_TTY_MAXMINORS);
-	if (!ntty_driver)
-		return -ENOMEM;
+	ntty_driver = tty_alloc_driver(NTTY_TTY_MAXMINORS, TTY_DRIVER_REAL_RAW |
+			TTY_DRIVER_DYNAMIC_DEV);
+	if (IS_ERR(ntty_driver))
+		return PTR_ERR(ntty_driver);
 
 	ntty_driver->driver_name = NOZOMI_NAME_TTY;
 	ntty_driver->name = "noz";
 	ntty_driver->major = 0;
 	ntty_driver->type = TTY_DRIVER_TYPE_SERIAL;
 	ntty_driver->subtype = SERIAL_TYPE_NORMAL;
-	ntty_driver->flags = TTY_DRIVER_REAL_RAW | TTY_DRIVER_DYNAMIC_DEV;
 	ntty_driver->init_termios = tty_std_termios;
 	ntty_driver->init_termios.c_cflag = B115200 | CS8 | CREAD | \
 						HUPCL | CLOCAL;
diff --git a/drivers/tty/serial/kgdb_nmi.c b/drivers/tty/serial/kgdb_nmi.c
index 1921537a9fa3..296e6845e473 100644
--- a/drivers/tty/serial/kgdb_nmi.c
+++ b/drivers/tty/serial/kgdb_nmi.c
@@ -330,17 +330,16 @@ int kgdb_register_nmi_console(void)
 	if (!arch_kgdb_ops.enable_nmi)
 		return 0;
 
-	kgdb_nmi_tty_driver = alloc_tty_driver(1);
-	if (!kgdb_nmi_tty_driver) {
+	kgdb_nmi_tty_driver = tty_alloc_driver(1, TTY_DRIVER_REAL_RAW);
+	if (IS_ERR(kgdb_nmi_tty_driver)) {
 		pr_err("%s: cannot allocate tty\n", __func__);
-		return -ENOMEM;
+		return PTR_ERR(kgdb_nmi_tty_driver);
 	}
 	kgdb_nmi_tty_driver->driver_name	= "ttyNMI";
 	kgdb_nmi_tty_driver->name		= "ttyNMI";
 	kgdb_nmi_tty_driver->num		= 1;
 	kgdb_nmi_tty_driver->type		= TTY_DRIVER_TYPE_SERIAL;
 	kgdb_nmi_tty_driver->subtype		= SERIAL_TYPE_NORMAL;
-	kgdb_nmi_tty_driver->flags		= TTY_DRIVER_REAL_RAW;
 	kgdb_nmi_tty_driver->init_termios	= tty_std_termios;
 	tty_termios_encode_baud_rate(&kgdb_nmi_tty_driver->init_termios,
 				     KGDB_NMI_BAUD, KGDB_NMI_BAUD);
diff --git a/drivers/tty/serial/serial_core.c b/drivers/tty/serial/serial_core.c
index f3a4f00bdaa6..8a61f748f6fc 100644
--- a/drivers/tty/serial/serial_core.c
+++ b/drivers/tty/serial/serial_core.c
@@ -2503,9 +2503,12 @@ int uart_register_driver(struct uart_driver *drv)
 	if (!drv->state)
 		goto out;
 
-	normal = alloc_tty_driver(drv->nr);
-	if (!normal)
+	normal = tty_alloc_driver(drv->nr, TTY_DRIVER_REAL_RAW |
+			TTY_DRIVER_DYNAMIC_DEV);
+	if (IS_ERR(normal)) {
+		retval = PTR_ERR(normal);
 		goto out_kfree;
+	}
 
 	drv->tty_driver = normal;
 
@@ -2518,7 +2521,6 @@ int uart_register_driver(struct uart_driver *drv)
 	normal->init_termios	= tty_std_termios;
 	normal->init_termios.c_cflag = B9600 | CS8 | CREAD | HUPCL | CLOCAL;
 	normal->init_termios.c_ispeed = normal->init_termios.c_ospeed = 9600;
-	normal->flags		= TTY_DRIVER_REAL_RAW | TTY_DRIVER_DYNAMIC_DEV;
 	normal->driver_state    = drv;
 	tty_set_operations(normal, &uart_ops);
 
diff --git a/drivers/tty/synclink_gt.c b/drivers/tty/synclink_gt.c
index 5702269f6dc5..dc1522268379 100644
--- a/drivers/tty/synclink_gt.c
+++ b/drivers/tty/synclink_gt.c
@@ -3760,10 +3760,11 @@ static int __init slgt_init(void)
 
 	printk(KERN_INFO "%s\n", driver_name);
 
-	serial_driver = alloc_tty_driver(MAX_DEVICES);
-	if (!serial_driver) {
+	serial_driver = tty_alloc_driver(MAX_DEVICES, TTY_DRIVER_REAL_RAW |
+			TTY_DRIVER_DYNAMIC_DEV);
+	if (IS_ERR(serial_driver)) {
 		printk("%s can't allocate tty driver\n", driver_name);
-		return -ENOMEM;
+		return PTR_ERR(serial_driver);
 	}
 
 	/* Initialize the tty_driver structure */
@@ -3779,7 +3780,6 @@ static int __init slgt_init(void)
 		B9600 | CS8 | CREAD | HUPCL | CLOCAL;
 	serial_driver->init_termios.c_ispeed = 9600;
 	serial_driver->init_termios.c_ospeed = 9600;
-	serial_driver->flags = TTY_DRIVER_REAL_RAW | TTY_DRIVER_DYNAMIC_DEV;
 	tty_set_operations(serial_driver, &ops);
 	if ((rc = tty_register_driver(serial_driver)) < 0) {
 		DBGERR(("%s can't register serial driver\n", driver_name));
diff --git a/drivers/tty/vt/vt.c b/drivers/tty/vt/vt.c
index 7ae2c1485d50..f2eb9a021973 100644
--- a/drivers/tty/vt/vt.c
+++ b/drivers/tty/vt/vt.c
@@ -3335,8 +3335,9 @@ int __init vty_init(const struct file_operations *console_fops)
 
 	vcs_init();
 
-	console_driver = alloc_tty_driver(MAX_NR_CONSOLES);
-	if (!console_driver)
+	console_driver = tty_alloc_driver(MAX_NR_CONSOLES, TTY_DRIVER_REAL_RAW |
+			TTY_DRIVER_RESET_TERMIOS);
+	if (IS_ERR(console_driver))
 		panic("Couldn't allocate console driver\n");
 
 	console_driver->name = "tty";
@@ -3347,7 +3348,6 @@ int __init vty_init(const struct file_operations *console_fops)
 	console_driver->init_termios = tty_std_termios;
 	if (default_utf8)
 		console_driver->init_termios.c_iflag |= IUTF8;
-	console_driver->flags = TTY_DRIVER_REAL_RAW | TTY_DRIVER_RESET_TERMIOS;
 	tty_set_operations(console_driver, &con_ops);
 	if (tty_register_driver(console_driver))
 		panic("Couldn't register console driver\n");
diff --git a/drivers/usb/class/cdc-acm.c b/drivers/usb/class/cdc-acm.c
index 505a90505114..3e5cfc3e8a51 100644
--- a/drivers/usb/class/cdc-acm.c
+++ b/drivers/usb/class/cdc-acm.c
@@ -2054,16 +2054,16 @@ static const struct tty_operations acm_ops = {
 static int __init acm_init(void)
 {
 	int retval;
-	acm_tty_driver = alloc_tty_driver(ACM_TTY_MINORS);
-	if (!acm_tty_driver)
-		return -ENOMEM;
+	acm_tty_driver = tty_alloc_driver(ACM_TTY_MINORS, TTY_DRIVER_REAL_RAW |
+			TTY_DRIVER_DYNAMIC_DEV);
+	if (IS_ERR(acm_tty_driver))
+		return PTR_ERR(acm_tty_driver);
 	acm_tty_driver->driver_name = "acm",
 	acm_tty_driver->name = "ttyACM",
 	acm_tty_driver->major = ACM_TTY_MAJOR,
 	acm_tty_driver->minor_start = 0,
 	acm_tty_driver->type = TTY_DRIVER_TYPE_SERIAL,
 	acm_tty_driver->subtype = SERIAL_TYPE_NORMAL,
-	acm_tty_driver->flags = TTY_DRIVER_REAL_RAW | TTY_DRIVER_DYNAMIC_DEV;
 	acm_tty_driver->init_termios = tty_std_termios;
 	acm_tty_driver->init_termios.c_cflag = B9600 | CS8 | CREAD |
 								HUPCL | CLOCAL;
* Unmerged path drivers/usb/gadget/function/u_serial.c
diff --git a/drivers/usb/serial/usb-serial.c b/drivers/usb/serial/usb-serial.c
index f64538c079e2..638c603d45ff 100644
--- a/drivers/usb/serial/usb-serial.c
+++ b/drivers/usb/serial/usb-serial.c
@@ -1319,9 +1319,10 @@ static int __init usb_serial_init(void)
 {
 	int result;
 
-	usb_serial_tty_driver = alloc_tty_driver(USB_SERIAL_TTY_MINORS);
-	if (!usb_serial_tty_driver)
-		return -ENOMEM;
+	usb_serial_tty_driver = tty_alloc_driver(USB_SERIAL_TTY_MINORS,
+			TTY_DRIVER_REAL_RAW | TTY_DRIVER_DYNAMIC_DEV);
+	if (IS_ERR(usb_serial_tty_driver))
+		return PTR_ERR(usb_serial_tty_driver);
 
 	/* Initialize our global data */
 	result = bus_register(&usb_serial_bus_type);
@@ -1336,8 +1337,6 @@ static int __init usb_serial_init(void)
 	usb_serial_tty_driver->minor_start = 0;
 	usb_serial_tty_driver->type = TTY_DRIVER_TYPE_SERIAL;
 	usb_serial_tty_driver->subtype = SERIAL_TYPE_NORMAL;
-	usb_serial_tty_driver->flags = TTY_DRIVER_REAL_RAW |
-						TTY_DRIVER_DYNAMIC_DEV;
 	usb_serial_tty_driver->init_termios = tty_std_termios;
 	usb_serial_tty_driver->init_termios.c_cflag = B9600 | CS8 | CREAD
 							| HUPCL | CLOCAL;
diff --git a/net/bluetooth/rfcomm/tty.c b/net/bluetooth/rfcomm/tty.c
index 1d59f3ce0f4b..a865e148762d 100644
--- a/net/bluetooth/rfcomm/tty.c
+++ b/net/bluetooth/rfcomm/tty.c
@@ -1131,9 +1131,10 @@ int __init rfcomm_init_ttys(void)
 {
 	int error;
 
-	rfcomm_tty_driver = alloc_tty_driver(RFCOMM_TTY_PORTS);
-	if (!rfcomm_tty_driver)
-		return -ENOMEM;
+	rfcomm_tty_driver = tty_alloc_driver(RFCOMM_TTY_PORTS,
+			TTY_DRIVER_REAL_RAW | TTY_DRIVER_DYNAMIC_DEV);
+	if (IS_ERR(rfcomm_tty_driver))
+		return PTR_ERR(rfcomm_tty_driver);
 
 	rfcomm_tty_driver->driver_name	= "rfcomm";
 	rfcomm_tty_driver->name		= "rfcomm";
@@ -1141,7 +1142,6 @@ int __init rfcomm_init_ttys(void)
 	rfcomm_tty_driver->minor_start	= RFCOMM_TTY_MINOR;
 	rfcomm_tty_driver->type		= TTY_DRIVER_TYPE_SERIAL;
 	rfcomm_tty_driver->subtype	= SERIAL_TYPE_NORMAL;
-	rfcomm_tty_driver->flags	= TTY_DRIVER_REAL_RAW | TTY_DRIVER_DYNAMIC_DEV;
 	rfcomm_tty_driver->init_termios	= tty_std_termios;
 	rfcomm_tty_driver->init_termios.c_cflag	= B9600 | CS8 | CREAD | HUPCL;
 	rfcomm_tty_driver->init_termios.c_lflag &= ~ICANON;
