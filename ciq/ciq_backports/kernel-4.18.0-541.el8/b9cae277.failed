EDAC/ghes: Scan the system once on driver init

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-541.el8
commit-author Borislav Petkov <bp@suse.de>
commit b9cae27728d1f9c9ed858adf012adddfcd8d3802
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-541.el8/b9cae277.failed

Change the hardware scanning and figuring out how many DIMMs a machine
has to a single, one-time thing which happens once on driver init. After
that scanning completes, struct ghes_hw_desc contains a representation
of the hardware which the driver can then use for later initialization.

Then, copy the DIMM information into the respective EDAC core
representation of those.

Get rid of ghes_edac_dimm_fill and use a struct dimm_info array
directly.

This way, hw detection and further driver initialization is nicely
and logically split. Further additions should all be added to
ghes_scan_system() and the hw representation extended as needed.

There should be no functionality change resulting from this patch.

	Signed-off-by: Borislav Petkov <bp@suse.de>
(cherry picked from commit b9cae27728d1f9c9ed858adf012adddfcd8d3802)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/edac/ghes_edac.c
diff --cc drivers/edac/ghes_edac.c
index 0365a010a90d,da60c29468a7..000000000000
--- a/drivers/edac/ghes_edac.c
+++ b/drivers/edac/ghes_edac.c
@@@ -75,28 -81,16 +84,32 @@@ struct memdev_dmi_entry 
  	u16 conf_mem_clk_speed;
  } __attribute__((__packed__));
  
++<<<<<<< HEAD
 +struct ghes_edac_dimm_fill {
 +	struct mem_ctl_info *mci;
 +	unsigned count;
 +};
 +
 +static void ghes_edac_count_dimms(const struct dmi_header *dh, void *arg)
 +{
 +	int *num_dimm = arg;
 +
 +	if (dh->type == DMI_ENTRY_MEM_DEVICE)
 +		(*num_dimm)++;
 +}
 +
 +static int get_dimm_smbios_index(struct mem_ctl_info *mci, u16 handle)
++=======
+ static struct dimm_info *find_dimm_by_handle(struct mem_ctl_info *mci, u16 handle)
++>>>>>>> b9cae27728d1 (EDAC/ghes: Scan the system once on driver init)
  {
 -	struct dimm_info *dimm;
 +	int i;
  
 -	mci_for_each_dimm(mci, dimm) {
 -		if (dimm->smbios_handle == handle)
 -			return dimm;
 +	for (i = 0; i < mci->tot_dimms; i++) {
 +		if (mci->dimms[i]->smbios_handle == handle)
 +			return i;
  	}
 -
 -	return NULL;
 +	return -1;
  }
  
  static void dimm_setup_label(struct dimm_info *dimm, u16 handle)
@@@ -105,112 -99,140 +118,145 @@@
  
  	dmi_memdev_name(handle, &bank, &device);
  
 -	/* both strings must be non-zero */
 -	if (bank && *bank && device && *device)
 -		snprintf(dimm->label, sizeof(dimm->label), "%s %s", bank, device);
 +	/*
 +	 * Set to a NULL string when both bank and device are zero. In this case,
 +	 * the label assigned by default will be preserved.
 +	 */
 +	snprintf(dimm->label, sizeof(dimm->label), "%s%s%s",
 +		 (bank && *bank) ? bank : "",
 +		 (bank && *bank && device && *device) ? " " : "",
 +		 (device && *device) ? device : "");
  }
  
- static void ghes_edac_dmidecode(const struct dmi_header *dh, void *arg)
+ static void assign_dmi_dimm_info(struct dimm_info *dimm, struct memdev_dmi_entry *entry)
  {
- 	struct ghes_edac_dimm_fill *dimm_fill = arg;
- 	struct mem_ctl_info *mci = dimm_fill->mci;
- 
- 	if (dh->type == DMI_ENTRY_MEM_DEVICE) {
- 		struct memdev_dmi_entry *entry = (struct memdev_dmi_entry *)dh;
- 		struct dimm_info *dimm = edac_get_dimm(mci, dimm_fill->count, 0, 0);
- 		u16 rdr_mask = BIT(7) | BIT(13);
- 
- 		if (entry->size == 0xffff) {
- 			pr_info("Can't get DIMM%i size\n",
- 				dimm_fill->count);
- 			dimm->nr_pages = MiB_TO_PAGES(32);/* Unknown */
- 		} else if (entry->size == 0x7fff) {
- 			dimm->nr_pages = MiB_TO_PAGES(entry->extended_size);
- 		} else {
- 			if (entry->size & BIT(15))
- 				dimm->nr_pages = MiB_TO_PAGES((entry->size & 0x7fff) << 10);
- 			else
- 				dimm->nr_pages = MiB_TO_PAGES(entry->size);
- 		}
+ 	u16 rdr_mask = BIT(7) | BIT(13);
  
- 		switch (entry->memory_type) {
- 		case 0x12:
- 			if (entry->type_detail & BIT(13))
- 				dimm->mtype = MEM_RDDR;
- 			else
- 				dimm->mtype = MEM_DDR;
- 			break;
- 		case 0x13:
- 			if (entry->type_detail & BIT(13))
- 				dimm->mtype = MEM_RDDR2;
- 			else
- 				dimm->mtype = MEM_DDR2;
- 			break;
- 		case 0x14:
- 			dimm->mtype = MEM_FB_DDR2;
- 			break;
- 		case 0x18:
- 			if (entry->type_detail & BIT(12))
- 				dimm->mtype = MEM_NVDIMM;
- 			else if (entry->type_detail & BIT(13))
- 				dimm->mtype = MEM_RDDR3;
- 			else
- 				dimm->mtype = MEM_DDR3;
- 			break;
- 		case 0x1a:
- 			if (entry->type_detail & BIT(12))
- 				dimm->mtype = MEM_NVDIMM;
- 			else if (entry->type_detail & BIT(13))
- 				dimm->mtype = MEM_RDDR4;
- 			else
- 				dimm->mtype = MEM_DDR4;
- 			break;
- 		default:
- 			if (entry->type_detail & BIT(6))
- 				dimm->mtype = MEM_RMBS;
- 			else if ((entry->type_detail & rdr_mask) == rdr_mask)
- 				dimm->mtype = MEM_RDR;
- 			else if (entry->type_detail & BIT(7))
- 				dimm->mtype = MEM_SDR;
- 			else if (entry->type_detail & BIT(9))
- 				dimm->mtype = MEM_EDO;
- 			else
- 				dimm->mtype = MEM_UNKNOWN;
- 		}
+ 	if (entry->size == 0xffff) {
+ 		pr_info("Can't get DIMM%i size\n", dimm->idx);
+ 		dimm->nr_pages = MiB_TO_PAGES(32);/* Unknown */
+ 	} else if (entry->size == 0x7fff) {
+ 		dimm->nr_pages = MiB_TO_PAGES(entry->extended_size);
+ 	} else {
+ 		if (entry->size & BIT(15))
+ 			dimm->nr_pages = MiB_TO_PAGES((entry->size & 0x7fff) << 10);
+ 		else
+ 			dimm->nr_pages = MiB_TO_PAGES(entry->size);
+ 	}
  
- 		/*
- 		 * Actually, we can only detect if the memory has bits for
- 		 * checksum or not
- 		 */
- 		if (entry->total_width == entry->data_width)
- 			dimm->edac_mode = EDAC_NONE;
+ 	switch (entry->memory_type) {
+ 	case 0x12:
+ 		if (entry->type_detail & BIT(13))
+ 			dimm->mtype = MEM_RDDR;
+ 		else
+ 			dimm->mtype = MEM_DDR;
+ 		break;
+ 	case 0x13:
+ 		if (entry->type_detail & BIT(13))
+ 			dimm->mtype = MEM_RDDR2;
  		else
- 			dimm->edac_mode = EDAC_SECDED;
+ 			dimm->mtype = MEM_DDR2;
+ 		break;
+ 	case 0x14:
+ 		dimm->mtype = MEM_FB_DDR2;
+ 		break;
+ 	case 0x18:
+ 		if (entry->type_detail & BIT(12))
+ 			dimm->mtype = MEM_NVDIMM;
+ 		else if (entry->type_detail & BIT(13))
+ 			dimm->mtype = MEM_RDDR3;
+ 		else
+ 			dimm->mtype = MEM_DDR3;
+ 		break;
+ 	case 0x1a:
+ 		if (entry->type_detail & BIT(12))
+ 			dimm->mtype = MEM_NVDIMM;
+ 		else if (entry->type_detail & BIT(13))
+ 			dimm->mtype = MEM_RDDR4;
+ 		else
+ 			dimm->mtype = MEM_DDR4;
+ 		break;
+ 	default:
+ 		if (entry->type_detail & BIT(6))
+ 			dimm->mtype = MEM_RMBS;
+ 		else if ((entry->type_detail & rdr_mask) == rdr_mask)
+ 			dimm->mtype = MEM_RDR;
+ 		else if (entry->type_detail & BIT(7))
+ 			dimm->mtype = MEM_SDR;
+ 		else if (entry->type_detail & BIT(9))
+ 			dimm->mtype = MEM_EDO;
+ 		else
+ 			dimm->mtype = MEM_UNKNOWN;
+ 	}
  
- 		dimm->dtype = DEV_UNKNOWN;
- 		dimm->grain = 128;		/* Likely, worse case */
- 
- 		dimm_setup_label(dimm, entry->handle);
- 
- 		if (dimm->nr_pages) {
- 			edac_dbg(1, "DIMM%i: %s size = %d MB%s\n",
- 				dimm_fill->count, edac_mem_types[dimm->mtype],
- 				PAGES_TO_MiB(dimm->nr_pages),
- 				(dimm->edac_mode != EDAC_NONE) ? "(ECC)" : "");
- 			edac_dbg(2, "\ttype %d, detail 0x%02x, width %d(total %d)\n",
- 				entry->memory_type, entry->type_detail,
- 				entry->total_width, entry->data_width);
- 		}
+ 	/*
+ 	 * Actually, we can only detect if the memory has bits for
+ 	 * checksum or not
+ 	 */
+ 	if (entry->total_width == entry->data_width)
+ 		dimm->edac_mode = EDAC_NONE;
+ 	else
+ 		dimm->edac_mode = EDAC_SECDED;
+ 
+ 	dimm->dtype = DEV_UNKNOWN;
+ 	dimm->grain = 128;		/* Likely, worse case */
  
- 		dimm->smbios_handle = entry->handle;
+ 	dimm_setup_label(dimm, entry->handle);
  
- 		dimm_fill->count++;
+ 	if (dimm->nr_pages) {
+ 		edac_dbg(1, "DIMM%i: %s size = %d MB%s\n",
+ 			dimm->idx, edac_mem_types[dimm->mtype],
+ 			PAGES_TO_MiB(dimm->nr_pages),
+ 			(dimm->edac_mode != EDAC_NONE) ? "(ECC)" : "");
+ 		edac_dbg(2, "\ttype %d, detail 0x%02x, width %d(total %d)\n",
+ 			entry->memory_type, entry->type_detail,
+ 			entry->total_width, entry->data_width);
  	}
+ 
+ 	dimm->smbios_handle = entry->handle;
+ }
+ 
+ static void enumerate_dimms(const struct dmi_header *dh, void *arg)
+ {
+ 	struct memdev_dmi_entry *entry = (struct memdev_dmi_entry *)dh;
+ 	struct ghes_hw_desc *hw = (struct ghes_hw_desc *)arg;
+ 	struct dimm_info *d;
+ 
+ 	if (dh->type != DMI_ENTRY_MEM_DEVICE)
+ 		return;
+ 
+ 	/* Enlarge the array with additional 16 */
+ 	if (!hw->num_dimms || !(hw->num_dimms % 16)) {
+ 		struct dimm_info *new;
+ 
+ 		new = krealloc(hw->dimms, (hw->num_dimms + 16) * sizeof(struct dimm_info),
+ 			        GFP_KERNEL);
+ 		if (!new) {
+ 			WARN_ON_ONCE(1);
+ 			return;
+ 		}
+ 
+ 		hw->dimms = new;
+ 	}
+ 
+ 	d = &hw->dimms[hw->num_dimms];
+ 	d->idx = hw->num_dimms;
+ 
+ 	assign_dmi_dimm_info(d, entry);
+ 
+ 	hw->num_dimms++;
+ }
+ 
+ static void ghes_scan_system(void)
+ {
+ 	static bool scanned;
+ 
+ 	if (scanned)
+ 		return;
+ 
+ 	dmi_walk(enumerate_dimms, &ghes_hw);
+ 
+ 	scanned = true;
  }
  
  void ghes_edac_report_mem_error(int sev, struct cper_sec_mem_err *mem_err)
* Unmerged path drivers/edac/ghes_edac.c
