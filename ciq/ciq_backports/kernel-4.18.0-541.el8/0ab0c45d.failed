r8169: add handling DASH when DASH is disabled

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-541.el8
commit-author ChunHao Lin <hau@realtek.com>
commit 0ab0c45d8aaea5192328bfa6989673aceafc767c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-541.el8/0ab0c45d.failed

For devices that support DASH, even DASH is disabled, there may still
exist a default firmware that will influence device behavior.
So driver needs to handle DASH for devices that support DASH, no
matter the DASH status is.

This patch also prepares for "fix network lost after resume on DASH
systems".

Fixes: ee7a1beb9759 ("r8169:call "rtl8168_driver_start" "rtl8168_driver_stop" only when hardware dash function is enabled")
	Cc: stable@vger.kernel.org
	Signed-off-by: ChunHao Lin <hau@realtek.com>
	Reviewed-by: Heiner Kallweit <hkallweit1@gmail.com>
Link: https://lore.kernel.org/r/20231109173400.4573-2-hau@realtek.com
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit 0ab0c45d8aaea5192328bfa6989673aceafc767c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/realtek/r8169_main.c
diff --cc drivers/net/ethernet/realtek/r8169_main.c
index eb47c73e835f,cfcb40d90920..000000000000
--- a/drivers/net/ethernet/realtek/r8169_main.c
+++ b/drivers/net/ethernet/realtek/r8169_main.c
@@@ -625,8 -616,15 +625,9 @@@ struct rtl8169_private 
  		struct work_struct work;
  	} wk;
  
 -	raw_spinlock_t config25_lock;
 -	raw_spinlock_t mac_ocp_lock;
 -
 -	raw_spinlock_t cfg9346_usage_lock;
 -	int cfg9346_usage_count;
 -
  	unsigned supports_gmii:1;
  	unsigned aspm_manageable:1;
+ 	unsigned dash_enabled:1;
  	dma_addr_t counters_phys_addr;
  	struct rtl8169_counters *counters;
  	struct rtl8169_tc_offsets tc_offset;
@@@ -1235,15 -1254,26 +1236,33 @@@ static bool r8168ep_check_dash(struct r
  	return r8168ep_ocp_read(tp, 0x128) & BIT(0);
  }
  
- static enum rtl_dash_type rtl_check_dash(struct rtl8169_private *tp)
+ static bool rtl_dash_is_enabled(struct rtl8169_private *tp)
+ {
+ 	switch (tp->dash_type) {
+ 	case RTL_DASH_DP:
+ 		return r8168dp_check_dash(tp);
+ 	case RTL_DASH_EP:
+ 		return r8168ep_check_dash(tp);
+ 	default:
+ 		return false;
+ 	}
+ }
+ 
+ static enum rtl_dash_type rtl_get_dash_type(struct rtl8169_private *tp)
  {
  	switch (tp->mac_version) {
 +	case RTL_GIGA_MAC_VER_27:
  	case RTL_GIGA_MAC_VER_28:
  	case RTL_GIGA_MAC_VER_31:
++<<<<<<< HEAD
 +		return r8168dp_check_dash(tp) ? RTL_DASH_DP : RTL_DASH_NONE;
 +	case RTL_GIGA_MAC_VER_49 ... RTL_GIGA_MAC_VER_53:
 +		return r8168ep_check_dash(tp) ? RTL_DASH_EP : RTL_DASH_NONE;
++=======
+ 		return RTL_DASH_DP;
+ 	case RTL_GIGA_MAC_VER_51 ... RTL_GIGA_MAC_VER_53:
+ 		return RTL_DASH_EP;
++>>>>>>> 0ab0c45d8aae (r8169: add handling DASH when DASH is disabled)
  	default:
  		return RTL_DASH_NONE;
  	}
@@@ -5018,11 -4908,7 +5037,15 @@@ static void rtl_shutdown(struct pci_de
  	/* Restore original MAC address */
  	rtl_rar_set(tp, tp->dev->perm_addr);
  
++<<<<<<< HEAD
 +	if (system_state == SYSTEM_POWER_OFF &&
 +	    tp->dash_type == RTL_DASH_NONE) {
 +		if (tp->saved_wolopts)
 +			rtl_wol_shutdown_quirk(tp);
 +
++=======
+ 	if (system_state == SYSTEM_POWER_OFF && !tp->dash_enabled) {
++>>>>>>> 0ab0c45d8aae (r8169: add handling DASH when DASH is disabled)
  		pci_wake_from_d3(pdev, tp->saved_wolopts);
  		pci_set_power_state(pdev, PCI_D3hot);
  	}
@@@ -5399,14 -5251,23 +5422,15 @@@ static int rtl_init_one(struct pci_dev 
  
  	/* Identify chip attached to board */
  	chipset = rtl8169_get_mac_version(xid, tp->supports_gmii);
 -	if (chipset == RTL_GIGA_MAC_NONE)
 -		return dev_err_probe(&pdev->dev, -ENODEV,
 -				     "unknown chip XID %03x, contact r8169 maintainers (see MAINTAINERS file)\n",
 -				     xid);
 -	tp->mac_version = chipset;
 +	if (chipset == RTL_GIGA_MAC_NONE) {
 +		dev_err(&pdev->dev, "unknown chip XID %03x\n", xid);
 +		return -ENODEV;
 +	}
  
 -	/* Disable ASPM L1 as that cause random device stop working
 -	 * problems as well as full system hangs for some PCIe devices users.
 -	 */
 -	if (rtl_aspm_is_safe(tp))
 -		rc = 0;
 -	else
 -		rc = pci_disable_link_state(pdev, PCIE_LINK_STATE_L1);
 -	tp->aspm_manageable = !rc;
 +	tp->mac_version = chipset;
  
- 	tp->dash_type = rtl_check_dash(tp);
+ 	tp->dash_type = rtl_get_dash_type(tp);
+ 	tp->dash_enabled = rtl_dash_is_enabled(tp);
  
  	tp->cp_cmd = RTL_R16(tp, CPlusCmd) & CPCMD_MASK;
  
* Unmerged path drivers/net/ethernet/realtek/r8169_main.c
