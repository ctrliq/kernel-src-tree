EDAC: Remove EDAC_DIMM_OFF() macro

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-541.el8
commit-author Robert Richter <rrichter@marvell.com>
commit 977b1ce7c117905b3138dc727ed25f8af2ba2902
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-541.el8/977b1ce7.failed

The EDAC_DIMM_OFF() macro takes 5 arguments to get the DIMM's index.
Simplify this by storing the index in struct dimm_info to avoid its
calculation and remove the EDAC_DIMM_OFF() macro. The index can be
directly used then.

Another advantage is that edac_mc_alloc() could be used even if the
exact size of the layers is unknown. Only the number of DIMMs would be
needed.

Rename iterator variable to idx, while at it. The name is more handy,
esp. when searching for it in the code.

	Signed-off-by: Robert Richter <rrichter@marvell.com>
	Signed-off-by: Borislav Petkov <bp@suse.de>
	Reviewed-by: Mauro Carvalho Chehab <mchehab@kernel.org>
	Cc: "linux-edac@vger.kernel.org" <linux-edac@vger.kernel.org>
	Cc: James Morse <james.morse@arm.com>
	Cc: Tony Luck <tony.luck@intel.com>
Link: https://lkml.kernel.org/r/20191106093239.25517-3-rrichter@marvell.com
(cherry picked from commit 977b1ce7c117905b3138dc727ed25f8af2ba2902)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/edac/edac_mc.c
diff --cc drivers/edac/edac_mc.c
index 1b23eafb85e3,cb5356411251..000000000000
--- a/drivers/edac/edac_mc.c
+++ b/drivers/edac/edac_mc.c
@@@ -321,11 -313,11 +321,17 @@@ struct mem_ctl_info *edac_mc_alloc(unsi
  	struct rank_info *chan;
  	struct dimm_info *dimm;
  	u32 *ce_per_layer[EDAC_MAX_LAYERS], *ue_per_layer[EDAC_MAX_LAYERS];
++<<<<<<< HEAD
 +	unsigned pos[EDAC_MAX_LAYERS];
 +	unsigned size, tot_dimms = 1, count = 1;
 +	unsigned tot_csrows = 1, tot_channels = 1, tot_errcount = 0;
++=======
+ 	unsigned int pos[EDAC_MAX_LAYERS];
+ 	unsigned int idx, size, tot_dimms = 1, count = 1;
+ 	unsigned int tot_csrows = 1, tot_channels = 1, tot_errcount = 0;
++>>>>>>> 977b1ce7c117 (EDAC: Remove EDAC_DIMM_OFF() macro)
  	void *pvt, *p, *ptr = NULL;
- 	int i, j, row, chn, n, len, off;
+ 	int i, j, row, chn, n, len;
  	bool per_rank = false;
  
  	BUG_ON(n_layers > EDAC_MAX_LAYERS || n_layers == 0);
* Unmerged path drivers/edac/edac_mc.c
diff --git a/drivers/edac/edac_mc_sysfs.c b/drivers/edac/edac_mc_sysfs.c
index 0d28c5e31b29..fd8f84c7a050 100644
--- a/drivers/edac/edac_mc_sysfs.c
+++ b/drivers/edac/edac_mc_sysfs.c
@@ -576,14 +576,8 @@ static ssize_t dimmdev_ce_count_show(struct device *dev,
 {
 	struct dimm_info *dimm = to_dimm(dev);
 	u32 count;
-	int off;
-
-	off = EDAC_DIMM_OFF(dimm->mci->layers,
-			    dimm->mci->n_layers,
-			    dimm->location[0],
-			    dimm->location[1],
-			    dimm->location[2]);
-	count = dimm->mci->ce_per_layer[dimm->mci->n_layers-1][off];
+
+	count = dimm->mci->ce_per_layer[dimm->mci->n_layers-1][dimm->idx];
 	return sprintf(data, "%u\n", count);
 }
 
@@ -593,14 +587,8 @@ static ssize_t dimmdev_ue_count_show(struct device *dev,
 {
 	struct dimm_info *dimm = to_dimm(dev);
 	u32 count;
-	int off;
-
-	off = EDAC_DIMM_OFF(dimm->mci->layers,
-			    dimm->mci->n_layers,
-			    dimm->location[0],
-			    dimm->location[1],
-			    dimm->location[2]);
-	count = dimm->mci->ue_per_layer[dimm->mci->n_layers-1][off];
+
+	count = dimm->mci->ue_per_layer[dimm->mci->n_layers-1][dimm->idx];
 	return sprintf(data, "%u\n", count);
 }
 
diff --git a/include/linux/edac.h b/include/linux/edac.h
index 7b38fd8dd823..ab209bdc4e5f 100644
--- a/include/linux/edac.h
+++ b/include/linux/edac.h
@@ -383,47 +383,6 @@ struct edac_mc_layer {
  */
 #define EDAC_MAX_LAYERS		3
 
-/**
- * EDAC_DIMM_OFF - Macro responsible to get a pointer offset inside a pointer
- *		   array for the element given by [layer0,layer1,layer2]
- *		   position
- *
- * @layers:	a struct edac_mc_layer array, describing how many elements
- *		were allocated for each layer
- * @nlayers:	Number of layers at the @layers array
- * @layer0:	layer0 position
- * @layer1:	layer1 position. Unused if n_layers < 2
- * @layer2:	layer2 position. Unused if n_layers < 3
- *
- * For 1 layer, this macro returns "var[layer0] - var";
- *
- * For 2 layers, this macro is similar to allocate a bi-dimensional array
- * and to return "var[layer0][layer1] - var";
- *
- * For 3 layers, this macro is similar to allocate a tri-dimensional array
- * and to return "var[layer0][layer1][layer2] - var".
- *
- * A loop could be used here to make it more generic, but, as we only have
- * 3 layers, this is a little faster.
- *
- * By design, layers can never be 0 or more than 3. If that ever happens,
- * a NULL is returned, causing an OOPS during the memory allocation routine,
- * with would point to the developer that he's doing something wrong.
- */
-#define EDAC_DIMM_OFF(layers, nlayers, layer0, layer1, layer2) ({		\
-	int __i;							\
-	if ((nlayers) == 1)						\
-		__i = layer0;						\
-	else if ((nlayers) == 2)					\
-		__i = (layer1) + ((layers[1]).size * (layer0));		\
-	else if ((nlayers) == 3)					\
-		__i = (layer2) + ((layers[2]).size * ((layer1) +	\
-			    ((layers[1]).size * (layer0))));		\
-	else								\
-		__i = -EINVAL;						\
-	__i;								\
-})
-
 struct dimm_info {
 	struct device dev;
 
@@ -433,6 +392,7 @@ struct dimm_info {
 	unsigned location[EDAC_MAX_LAYERS];
 
 	struct mem_ctl_info *mci;	/* the parent */
+	unsigned int idx;		/* index within the parent dimm array */
 
 	u32 grain;		/* granularity of reported error in bytes */
 	enum dev_type dtype;	/* memory device type */
@@ -675,6 +635,9 @@ edac_get_dimm_by_index(struct mem_ctl_info *mci, int index)
 	if (index < 0 || index >= mci->tot_dimms)
 		return NULL;
 
+	if (WARN_ON_ONCE(mci->dimms[index]->idx != index))
+		return NULL;
+
 	return mci->dimms[index];
 }
 
