Bluetooth: hci_sync: Add check simultaneous roles support

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-541.el8
commit-author Luiz Augusto von Dentz <luiz.von.dentz@intel.com>
commit 4fc9857ab8c6cfe2152df3288c8cf3300b929f1a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-541.el8/4fc9857a.failed

This attempts to check if the controller can act as both central and
peripheral simultaneously and in case it does skip suspending
advertising or in case of directed advertising don't fail if scanning.

	Signed-off-by: Luiz Augusto von Dentz <luiz.von.dentz@intel.com>
	Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
(cherry picked from commit 4fc9857ab8c6cfe2152df3288c8cf3300b929f1a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/bluetooth/hci_sync.c
diff --cc net/bluetooth/hci_sync.c
index eb0e0482fa3f,61d8a076a3f3..000000000000
--- a/net/bluetooth/hci_sync.c
+++ b/net/bluetooth/hci_sync.c
@@@ -2924,3 -4781,501 +2924,471 @@@ int hci_start_discovery_sync(struct hci
  
  	return 0;
  }
++<<<<<<< HEAD
++=======
+ 
+ static int hci_update_event_filter_sync(struct hci_dev *hdev)
+ {
+ 	struct bdaddr_list_with_flags *b;
+ 	u8 scan = SCAN_DISABLED;
+ 	bool scanning = test_bit(HCI_PSCAN, &hdev->flags);
+ 	int err;
+ 
+ 	if (!hci_dev_test_flag(hdev, HCI_BREDR_ENABLED))
+ 		return 0;
+ 
+ 	/* Always clear event filter when starting */
+ 	hci_clear_event_filter_sync(hdev);
+ 
+ 	list_for_each_entry(b, &hdev->accept_list, list) {
+ 		if (!test_bit(HCI_CONN_FLAG_REMOTE_WAKEUP, b->flags))
+ 			continue;
+ 
+ 		bt_dev_dbg(hdev, "Adding event filters for %pMR", &b->bdaddr);
+ 
+ 		err =  hci_set_event_filter_sync(hdev, HCI_FLT_CONN_SETUP,
+ 						 HCI_CONN_SETUP_ALLOW_BDADDR,
+ 						 &b->bdaddr,
+ 						 HCI_CONN_SETUP_AUTO_ON);
+ 		if (err)
+ 			bt_dev_dbg(hdev, "Failed to set event filter for %pMR",
+ 				   &b->bdaddr);
+ 		else
+ 			scan = SCAN_PAGE;
+ 	}
+ 
+ 	if (scan && !scanning)
+ 		hci_write_scan_enable_sync(hdev, scan);
+ 	else if (!scan && scanning)
+ 		hci_write_scan_enable_sync(hdev, scan);
+ 
+ 	return 0;
+ }
+ 
+ /* This function performs the HCI suspend procedures in the follow order:
+  *
+  * Pause discovery (active scanning/inquiry)
+  * Pause Directed Advertising/Advertising
+  * Disconnect all connections
+  * Set suspend_status to BT_SUSPEND_DISCONNECT if hdev cannot wakeup
+  * otherwise:
+  * Update event mask (only set events that are allowed to wake up the host)
+  * Update event filter (with devices marked with HCI_CONN_FLAG_REMOTE_WAKEUP)
+  * Update passive scanning (lower duty cycle)
+  * Set suspend_status to BT_SUSPEND_CONFIGURE_WAKE
+  */
+ int hci_suspend_sync(struct hci_dev *hdev)
+ {
+ 	int err;
+ 
+ 	/* If marked as suspended there nothing to do */
+ 	if (hdev->suspended)
+ 		return 0;
+ 
+ 	/* Mark device as suspended */
+ 	hdev->suspended = true;
+ 
+ 	/* Pause discovery if not already stopped */
+ 	hci_pause_discovery_sync(hdev);
+ 
+ 	/* Pause other advertisements */
+ 	hci_pause_advertising_sync(hdev);
+ 
+ 	/* Disable page scan if enabled */
+ 	if (test_bit(HCI_PSCAN, &hdev->flags))
+ 		hci_write_scan_enable_sync(hdev, SCAN_DISABLED);
+ 
+ 	/* Suspend monitor filters */
+ 	hci_suspend_monitor_sync(hdev);
+ 
+ 	/* Prevent disconnects from causing scanning to be re-enabled */
+ 	hdev->scanning_paused = true;
+ 
+ 	/* Soft disconnect everything (power off) */
+ 	err = hci_disconnect_all_sync(hdev, HCI_ERROR_REMOTE_POWER_OFF);
+ 	if (err) {
+ 		/* Set state to BT_RUNNING so resume doesn't notify */
+ 		hdev->suspend_state = BT_RUNNING;
+ 		hci_resume_sync(hdev);
+ 		return err;
+ 	}
+ 
+ 	/* Only configure accept list if disconnect succeeded and wake
+ 	 * isn't being prevented.
+ 	 */
+ 	if (!hdev->wakeup || !hdev->wakeup(hdev)) {
+ 		hdev->suspend_state = BT_SUSPEND_DISCONNECT;
+ 		return 0;
+ 	}
+ 
+ 	/* Unpause to take care of updating scanning params */
+ 	hdev->scanning_paused = false;
+ 
+ 	/* Update event mask so only the allowed event can wakeup the host */
+ 	hci_set_event_mask_sync(hdev);
+ 
+ 	/* Enable event filter for paired devices */
+ 	hci_update_event_filter_sync(hdev);
+ 
+ 	/* Update LE passive scan if enabled */
+ 	hci_update_passive_scan_sync(hdev);
+ 
+ 	/* Pause scan changes again. */
+ 	hdev->scanning_paused = true;
+ 
+ 	hdev->suspend_state = BT_SUSPEND_CONFIGURE_WAKE;
+ 
+ 	return 0;
+ }
+ 
+ /* This function resumes discovery */
+ static int hci_resume_discovery_sync(struct hci_dev *hdev)
+ {
+ 	int err;
+ 
+ 	/* If discovery not paused there nothing to do */
+ 	if (!hdev->discovery_paused)
+ 		return 0;
+ 
+ 	hdev->discovery_paused = false;
+ 
+ 	hci_discovery_set_state(hdev, DISCOVERY_STARTING);
+ 
+ 	err = hci_start_discovery_sync(hdev);
+ 
+ 	hci_discovery_set_state(hdev, err ? DISCOVERY_STOPPED :
+ 				DISCOVERY_FINDING);
+ 
+ 	return err;
+ }
+ 
+ static void hci_resume_monitor_sync(struct hci_dev *hdev)
+ {
+ 	switch (hci_get_adv_monitor_offload_ext(hdev)) {
+ 	case HCI_ADV_MONITOR_EXT_MSFT:
+ 		msft_resume_sync(hdev);
+ 		break;
+ 	default:
+ 		return;
+ 	}
+ }
+ 
+ /* This function performs the HCI suspend procedures in the follow order:
+  *
+  * Restore event mask
+  * Clear event filter
+  * Update passive scanning (normal duty cycle)
+  * Resume Directed Advertising/Advertising
+  * Resume discovery (active scanning/inquiry)
+  */
+ int hci_resume_sync(struct hci_dev *hdev)
+ {
+ 	/* If not marked as suspended there nothing to do */
+ 	if (!hdev->suspended)
+ 		return 0;
+ 
+ 	hdev->suspended = false;
+ 	hdev->scanning_paused = false;
+ 
+ 	/* Restore event mask */
+ 	hci_set_event_mask_sync(hdev);
+ 
+ 	/* Clear any event filters and restore scan state */
+ 	hci_clear_event_filter_sync(hdev);
+ 	hci_update_scan_sync(hdev);
+ 
+ 	/* Reset passive scanning to normal */
+ 	hci_update_passive_scan_sync(hdev);
+ 
+ 	/* Resume monitor filters */
+ 	hci_resume_monitor_sync(hdev);
+ 
+ 	/* Resume other advertisements */
+ 	hci_resume_advertising_sync(hdev);
+ 
+ 	/* Resume discovery */
+ 	hci_resume_discovery_sync(hdev);
+ 
+ 	return 0;
+ }
+ 
+ static bool conn_use_rpa(struct hci_conn *conn)
+ {
+ 	struct hci_dev *hdev = conn->hdev;
+ 
+ 	return hci_dev_test_flag(hdev, HCI_PRIVACY);
+ }
+ 
+ static int hci_le_ext_directed_advertising_sync(struct hci_dev *hdev,
+ 						struct hci_conn *conn)
+ {
+ 	struct hci_cp_le_set_ext_adv_params cp;
+ 	int err;
+ 	bdaddr_t random_addr;
+ 	u8 own_addr_type;
+ 
+ 	err = hci_update_random_address_sync(hdev, false, conn_use_rpa(conn),
+ 					     &own_addr_type);
+ 	if (err)
+ 		return err;
+ 
+ 	/* Set require_privacy to false so that the remote device has a
+ 	 * chance of identifying us.
+ 	 */
+ 	err = hci_get_random_address(hdev, false, conn_use_rpa(conn), NULL,
+ 				     &own_addr_type, &random_addr);
+ 	if (err)
+ 		return err;
+ 
+ 	memset(&cp, 0, sizeof(cp));
+ 
+ 	cp.evt_properties = cpu_to_le16(LE_LEGACY_ADV_DIRECT_IND);
+ 	cp.own_addr_type = own_addr_type;
+ 	cp.channel_map = hdev->le_adv_channel_map;
+ 	cp.tx_power = HCI_TX_POWER_INVALID;
+ 	cp.primary_phy = HCI_ADV_PHY_1M;
+ 	cp.secondary_phy = HCI_ADV_PHY_1M;
+ 	cp.handle = 0x00; /* Use instance 0 for directed adv */
+ 	cp.own_addr_type = own_addr_type;
+ 	cp.peer_addr_type = conn->dst_type;
+ 	bacpy(&cp.peer_addr, &conn->dst);
+ 
+ 	/* As per Core Spec 5.2 Vol 2, PART E, Sec 7.8.53, for
+ 	 * advertising_event_property LE_LEGACY_ADV_DIRECT_IND
+ 	 * does not supports advertising data when the advertising set already
+ 	 * contains some, the controller shall return erroc code 'Invalid
+ 	 * HCI Command Parameters(0x12).
+ 	 * So it is required to remove adv set for handle 0x00. since we use
+ 	 * instance 0 for directed adv.
+ 	 */
+ 	err = hci_remove_ext_adv_instance_sync(hdev, cp.handle, NULL);
+ 	if (err)
+ 		return err;
+ 
+ 	err = __hci_cmd_sync_status(hdev, HCI_OP_LE_SET_EXT_ADV_PARAMS,
+ 				    sizeof(cp), &cp, HCI_CMD_TIMEOUT);
+ 	if (err)
+ 		return err;
+ 
+ 	/* Check if random address need to be updated */
+ 	if (own_addr_type == ADDR_LE_DEV_RANDOM &&
+ 	    bacmp(&random_addr, BDADDR_ANY) &&
+ 	    bacmp(&random_addr, &hdev->random_addr)) {
+ 		err = hci_set_adv_set_random_addr_sync(hdev, 0x00,
+ 						       &random_addr);
+ 		if (err)
+ 			return err;
+ 	}
+ 
+ 	return hci_enable_ext_advertising_sync(hdev, 0x00);
+ }
+ 
+ static int hci_le_directed_advertising_sync(struct hci_dev *hdev,
+ 					    struct hci_conn *conn)
+ {
+ 	struct hci_cp_le_set_adv_param cp;
+ 	u8 status;
+ 	u8 own_addr_type;
+ 	u8 enable;
+ 
+ 	if (ext_adv_capable(hdev))
+ 		return hci_le_ext_directed_advertising_sync(hdev, conn);
+ 
+ 	/* Clear the HCI_LE_ADV bit temporarily so that the
+ 	 * hci_update_random_address knows that it's safe to go ahead
+ 	 * and write a new random address. The flag will be set back on
+ 	 * as soon as the SET_ADV_ENABLE HCI command completes.
+ 	 */
+ 	hci_dev_clear_flag(hdev, HCI_LE_ADV);
+ 
+ 	/* Set require_privacy to false so that the remote device has a
+ 	 * chance of identifying us.
+ 	 */
+ 	status = hci_update_random_address_sync(hdev, false, conn_use_rpa(conn),
+ 						&own_addr_type);
+ 	if (status)
+ 		return status;
+ 
+ 	memset(&cp, 0, sizeof(cp));
+ 
+ 	/* Some controllers might reject command if intervals are not
+ 	 * within range for undirected advertising.
+ 	 * BCM20702A0 is known to be affected by this.
+ 	 */
+ 	cp.min_interval = cpu_to_le16(0x0020);
+ 	cp.max_interval = cpu_to_le16(0x0020);
+ 
+ 	cp.type = LE_ADV_DIRECT_IND;
+ 	cp.own_address_type = own_addr_type;
+ 	cp.direct_addr_type = conn->dst_type;
+ 	bacpy(&cp.direct_addr, &conn->dst);
+ 	cp.channel_map = hdev->le_adv_channel_map;
+ 
+ 	status = __hci_cmd_sync_status(hdev, HCI_OP_LE_SET_ADV_PARAM,
+ 				       sizeof(cp), &cp, HCI_CMD_TIMEOUT);
+ 	if (status)
+ 		return status;
+ 
+ 	enable = 0x01;
+ 
+ 	return __hci_cmd_sync_status(hdev, HCI_OP_LE_SET_ADV_ENABLE,
+ 				     sizeof(enable), &enable, HCI_CMD_TIMEOUT);
+ }
+ 
+ static void set_ext_conn_params(struct hci_conn *conn,
+ 				struct hci_cp_le_ext_conn_param *p)
+ {
+ 	struct hci_dev *hdev = conn->hdev;
+ 
+ 	memset(p, 0, sizeof(*p));
+ 
+ 	p->scan_interval = cpu_to_le16(hdev->le_scan_int_connect);
+ 	p->scan_window = cpu_to_le16(hdev->le_scan_window_connect);
+ 	p->conn_interval_min = cpu_to_le16(conn->le_conn_min_interval);
+ 	p->conn_interval_max = cpu_to_le16(conn->le_conn_max_interval);
+ 	p->conn_latency = cpu_to_le16(conn->le_conn_latency);
+ 	p->supervision_timeout = cpu_to_le16(conn->le_supv_timeout);
+ 	p->min_ce_len = cpu_to_le16(0x0000);
+ 	p->max_ce_len = cpu_to_le16(0x0000);
+ }
+ 
+ int hci_le_ext_create_conn_sync(struct hci_dev *hdev, struct hci_conn *conn,
+ 				u8 own_addr_type)
+ {
+ 	struct hci_cp_le_ext_create_conn *cp;
+ 	struct hci_cp_le_ext_conn_param *p;
+ 	u8 data[sizeof(*cp) + sizeof(*p) * 3];
+ 	u32 plen;
+ 
+ 	cp = (void *)data;
+ 	p = (void *)cp->data;
+ 
+ 	memset(cp, 0, sizeof(*cp));
+ 
+ 	bacpy(&cp->peer_addr, &conn->dst);
+ 	cp->peer_addr_type = conn->dst_type;
+ 	cp->own_addr_type = own_addr_type;
+ 
+ 	plen = sizeof(*cp);
+ 
+ 	if (scan_1m(hdev)) {
+ 		cp->phys |= LE_SCAN_PHY_1M;
+ 		set_ext_conn_params(conn, p);
+ 
+ 		p++;
+ 		plen += sizeof(*p);
+ 	}
+ 
+ 	if (scan_2m(hdev)) {
+ 		cp->phys |= LE_SCAN_PHY_2M;
+ 		set_ext_conn_params(conn, p);
+ 
+ 		p++;
+ 		plen += sizeof(*p);
+ 	}
+ 
+ 	if (scan_coded(hdev)) {
+ 		cp->phys |= LE_SCAN_PHY_CODED;
+ 		set_ext_conn_params(conn, p);
+ 
+ 		plen += sizeof(*p);
+ 	}
+ 
+ 	return __hci_cmd_sync_status_sk(hdev, HCI_OP_LE_EXT_CREATE_CONN,
+ 					plen, data,
+ 					HCI_EV_LE_ENHANCED_CONN_COMPLETE,
+ 					HCI_CMD_TIMEOUT, NULL);
+ }
+ 
+ int hci_le_create_conn_sync(struct hci_dev *hdev, struct hci_conn *conn)
+ {
+ 	struct hci_cp_le_create_conn cp;
+ 	struct hci_conn_params *params;
+ 	u8 own_addr_type;
+ 	int err;
+ 
+ 	/* If requested to connect as peripheral use directed advertising */
+ 	if (conn->role == HCI_ROLE_SLAVE) {
+ 		/* If we're active scanning and the controller doesn't support
+ 		 * simultaneous roles simply reject the attempt.
+ 		 */
+ 		if (hci_dev_test_flag(hdev, HCI_LE_SCAN) &&
+ 		    hdev->le_scan_type == LE_SCAN_ACTIVE &&
+ 		    !hci_dev_le_state_simultaneous(hdev)) {
+ 			hci_conn_del(conn);
+ 			return -EBUSY;
+ 		}
+ 
+ 		/* Pause advertising while doing directed advertising. */
+ 		hci_pause_advertising_sync(hdev);
+ 
+ 		err = hci_le_directed_advertising_sync(hdev, conn);
+ 		goto done;
+ 	}
+ 
+ 	/* Disable advertising if simultaneous roles is not supported. */
+ 	if (!hci_dev_le_state_simultaneous(hdev))
+ 		hci_pause_advertising_sync(hdev);
+ 
+ 	params = hci_conn_params_lookup(hdev, &conn->dst, conn->dst_type);
+ 	if (params) {
+ 		conn->le_conn_min_interval = params->conn_min_interval;
+ 		conn->le_conn_max_interval = params->conn_max_interval;
+ 		conn->le_conn_latency = params->conn_latency;
+ 		conn->le_supv_timeout = params->supervision_timeout;
+ 	} else {
+ 		conn->le_conn_min_interval = hdev->le_conn_min_interval;
+ 		conn->le_conn_max_interval = hdev->le_conn_max_interval;
+ 		conn->le_conn_latency = hdev->le_conn_latency;
+ 		conn->le_supv_timeout = hdev->le_supv_timeout;
+ 	}
+ 
+ 	/* If controller is scanning, we stop it since some controllers are
+ 	 * not able to scan and connect at the same time. Also set the
+ 	 * HCI_LE_SCAN_INTERRUPTED flag so that the command complete
+ 	 * handler for scan disabling knows to set the correct discovery
+ 	 * state.
+ 	 */
+ 	if (hci_dev_test_flag(hdev, HCI_LE_SCAN)) {
+ 		hci_scan_disable_sync(hdev);
+ 		hci_dev_set_flag(hdev, HCI_LE_SCAN_INTERRUPTED);
+ 	}
+ 
+ 	/* Update random address, but set require_privacy to false so
+ 	 * that we never connect with an non-resolvable address.
+ 	 */
+ 	err = hci_update_random_address_sync(hdev, false, conn_use_rpa(conn),
+ 					     &own_addr_type);
+ 	if (err)
+ 		goto done;
+ 
+ 	if (use_ext_conn(hdev)) {
+ 		err = hci_le_ext_create_conn_sync(hdev, conn, own_addr_type);
+ 		goto done;
+ 	}
+ 
+ 	memset(&cp, 0, sizeof(cp));
+ 
+ 	cp.scan_interval = cpu_to_le16(hdev->le_scan_int_connect);
+ 	cp.scan_window = cpu_to_le16(hdev->le_scan_window_connect);
+ 
+ 	bacpy(&cp.peer_addr, &conn->dst);
+ 	cp.peer_addr_type = conn->dst_type;
+ 	cp.own_address_type = own_addr_type;
+ 	cp.conn_interval_min = cpu_to_le16(conn->le_conn_min_interval);
+ 	cp.conn_interval_max = cpu_to_le16(conn->le_conn_max_interval);
+ 	cp.conn_latency = cpu_to_le16(conn->le_conn_latency);
+ 	cp.supervision_timeout = cpu_to_le16(conn->le_supv_timeout);
+ 	cp.min_ce_len = cpu_to_le16(0x0000);
+ 	cp.max_ce_len = cpu_to_le16(0x0000);
+ 
+ 	err = __hci_cmd_sync_status_sk(hdev, HCI_OP_LE_CREATE_CONN,
+ 				       sizeof(cp), &cp, HCI_EV_LE_CONN_COMPLETE,
+ 				       HCI_CMD_TIMEOUT, NULL);
+ 
+ done:
+ 	/* Re-enable advertising after the connection attempt is finished. */
+ 	hci_resume_advertising_sync(hdev);
+ 	return err;
+ }
++>>>>>>> 4fc9857ab8c6 (Bluetooth: hci_sync: Add check simultaneous roles support)
diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 6a9c6abdef9e..a49ca490f143 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -790,6 +790,12 @@ extern struct mutex hci_cb_list_lock;
 		hci_dev_clear_flag(hdev, HCI_QUALITY_REPORT);	\
 	} while (0)
 
+#define hci_dev_le_state_simultaneous(hdev) \
+	(test_bit(HCI_QUIRK_VALID_LE_STATES, &hdev->quirks) && \
+	 (hdev->le_states[4] & 0x08) &&	/* Central */ \
+	 (hdev->le_states[4] & 0x40) &&	/* Peripheral */ \
+	 (hdev->le_states[3] & 0x10))	/* Simultaneous */
+
 /* ----- HCI interface to upper protocols ----- */
 int l2cap_connect_ind(struct hci_dev *hdev, bdaddr_t *bdaddr);
 int l2cap_disconn_ind(struct hci_conn *hcon);
* Unmerged path net/bluetooth/hci_sync.c
diff --git a/net/bluetooth/mgmt.c b/net/bluetooth/mgmt.c
index 20135c1a1973..39ef5d6270a1 100644
--- a/net/bluetooth/mgmt.c
+++ b/net/bluetooth/mgmt.c
@@ -3917,10 +3917,7 @@ static int read_exp_features_info(struct sock *sk, struct hci_dev *hdev,
 #endif
 
 	if (hdev) {
-		if (test_bit(HCI_QUIRK_VALID_LE_STATES, &hdev->quirks) &&
-		    (hdev->le_states[4] & 0x08) &&	/* Central */
-		    (hdev->le_states[4] & 0x40) &&	/* Peripheral */
-		    (hdev->le_states[3] & 0x10))	/* Simultaneous */
+		if (hci_dev_le_state_simultaneous(hdev))
 			flags = BIT(0);
 		else
 			flags = 0;
