tty: n_gsm: fix reset fifo race condition

jira LE-1907
cve CVE-2023-6546
Rebuild_History Non-Buildable kernel-4.18.0-541.el8
commit-author Daniel Starke <daniel.starke@siemens.com>
commit 73029a4d7161f8b6c0934553145ef574d2d0c645
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-541.el8/73029a4d.failed

gsmtty_write() and gsm_dlci_data_output() properly guard the fifo access.
However, gsm_dlci_close() and gsmtty_flush_buffer() modifies the fifo but
do not guard this.
Add a guard here to prevent race conditions on parallel writes to the fifo.

Fixes: e1eaea46bb40 ("tty: n_gsm line discipline")
	Cc: stable@vger.kernel.org
	Signed-off-by: Daniel Starke <daniel.starke@siemens.com>
Link: https://lore.kernel.org/r/20220414094225.4527-17-daniel.starke@siemens.com
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 73029a4d7161f8b6c0934553145ef574d2d0c645)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/tty/n_gsm.c
diff --cc drivers/tty/n_gsm.c
index e37c003da9b1,15be4a235783..000000000000
--- a/drivers/tty/n_gsm.c
+++ b/drivers/tty/n_gsm.c
@@@ -1446,7 -1450,12 +1448,16 @@@ static void gsm_dlci_close(struct gsm_d
  	dlci->state = DLCI_CLOSED;
  	if (dlci->addr != 0) {
  		tty_port_tty_hangup(&dlci->port, false);
++<<<<<<< HEAD
 +		kfifo_reset(dlci->fifo);
++=======
+ 		spin_lock_irqsave(&dlci->lock, flags);
+ 		kfifo_reset(&dlci->fifo);
+ 		spin_unlock_irqrestore(&dlci->lock, flags);
+ 		/* Ensure that gsmtty_open() can return. */
+ 		tty_port_set_initialized(&dlci->port, 0);
+ 		wake_up_interruptible(&dlci->port.open_wait);
++>>>>>>> 73029a4d7161 (tty: n_gsm: fix reset fifo race condition)
  	} else
  		dlci->gsm->dead = true;
  	/* Unregister gsmtty driver,report gsmtty dev remove uevent for user */
@@@ -3150,7 -3160,9 +3163,13 @@@ static void gsmtty_flush_buffer(struct 
  	   then the data being transmitted can't simply be junked once
  	   it has first hit the stack. Until then we can just blow it
  	   away */
++<<<<<<< HEAD
 +	kfifo_reset(dlci->fifo);
++=======
+ 	spin_lock_irqsave(&dlci->lock, flags);
+ 	kfifo_reset(&dlci->fifo);
+ 	spin_unlock_irqrestore(&dlci->lock, flags);
++>>>>>>> 73029a4d7161 (tty: n_gsm: fix reset fifo race condition)
  	/* Need to unhook this DLCI from the transmit queue logic */
  }
  
* Unmerged path drivers/tty/n_gsm.c
