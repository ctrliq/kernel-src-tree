tty: n_gsm: replace use of gsm_read_ea() with gsm_read_ea_val()

jira LE-1907
cve CVE-2023-6546
Rebuild_History Non-Buildable kernel-4.18.0-541.el8
commit-author Daniel Starke <daniel.starke@siemens.com>
commit 669609cea1d294f43efdd8d57ab65927df90e6df
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-541.el8/669609ce.failed

Replace the use of gsm_read_ea() with gsm_read_ea_val() where applicable to
improve code readability and avoid errors like in the past. See first link
below for reference.

Link: https://lore.kernel.org/all/20220504081733.3494-1-daniel.starke@siemens.com/
Link: https://lore.kernel.org/all/202208222147.WfFRmf1r-lkp@intel.com/
	Reported-by: kernel test robot <lkp@intel.com>
	Signed-off-by: Daniel Starke <daniel.starke@siemens.com>
Link: https://lore.kernel.org/r/20220831073800.7459-3-daniel.starke@siemens.com
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 669609cea1d294f43efdd8d57ab65927df90e6df)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/tty/n_gsm.c
diff --cc drivers/tty/n_gsm.c
index 6376ba42b27e,c5445d397261..000000000000
--- a/drivers/tty/n_gsm.c
+++ b/drivers/tty/n_gsm.c
@@@ -1811,10 -1937,13 +1804,17 @@@ static void gsm_dlci_data(struct gsm_dl
  			tty_wakeup(tty);
  			tty_kref_put(tty);
  		}
++<<<<<<< HEAD
 +		/* Fall through */
++=======
+ 		/* Skip processed modem data */
+ 		data += len;
+ 		clen -= len;
+ 		fallthrough;
++>>>>>>> 669609cea1d2 (tty: n_gsm: replace use of gsm_read_ea() with gsm_read_ea_val())
  	case 1:		/* Line state will go via DLCI 0 controls only */
  	default:
- 		tty_insert_flip_string(port, data, len);
+ 		tty_insert_flip_string(port, data, clen);
  		tty_flip_buffer_push(port);
  	}
  }
@@@ -1835,26 -1964,52 +1835,29 @@@ static void gsm_dlci_command(struct gsm
  {
  	/* See what command is involved */
  	unsigned int command = 0;
- 	while (len-- > 0) {
- 		if (gsm_read_ea(&command, *data++) == 1) {
- 			int clen = *data++;
- 			len--;
- 			/* FIXME: this is properly an EA */
- 			clen >>= 1;
- 			/* Malformed command ? */
- 			if (clen > len)
- 				return;
- 			if (command & 1)
- 				gsm_control_message(dlci->gsm, command,
- 								data, clen);
- 			else
- 				gsm_control_response(dlci->gsm, command,
- 								data, clen);
- 			return;
- 		}
- 	}
+ 	unsigned int clen = 0;
+ 	unsigned int dlen;
+ 
+ 	/* read the command */
+ 	dlen = gsm_read_ea_val(&command, data, len);
+ 	len -= dlen;
+ 	data += dlen;
+ 
+ 	/* read any control data */
+ 	dlen = gsm_read_ea_val(&clen, data, len);
+ 	len -= dlen;
+ 	data += dlen;
+ 
+ 	/* Malformed command? */
+ 	if (clen > len)
+ 		return;
+ 
+ 	if (command & 1)
+ 		gsm_control_message(dlci->gsm, command, data, clen);
+ 	else
+ 		gsm_control_response(dlci->gsm, command, data, clen);
  }
  
 -/**
 - *	gsm_kick_timeout	-	transmit if possible
 - *	@work: work contained in our gsm object
 - *
 - *	Transmit data from DLCIs if the queue is empty. We can't rely on
 - *	a tty wakeup except when we filled the pipe so we need to fire off
 - *	new data ourselves in other cases.
 - */
 -static void gsm_kick_timeout(struct work_struct *work)
 -{
 -	struct gsm_mux *gsm = container_of(work, struct gsm_mux, kick_timeout.work);
 -	int sent = 0;
 -
 -	mutex_lock(&gsm->tx_mutex);
 -	/* If we have nothing running then we need to fire up */
 -	if (gsm->tx_bytes < TX_THRESH_LO)
 -		sent = gsm_dlci_data_sweep(gsm);
 -	mutex_unlock(&gsm->tx_mutex);
 -
 -	if (sent && debug & 4)
 -		pr_info("%s TX queue stalled\n", __func__);
 -}
 -
  /*
   *	Allocate/Free DLCI channels
   */
* Unmerged path drivers/tty/n_gsm.c
