Bluetooth: Introduce HCI_CONN_FLAG_DEVICE_PRIVACY device flag

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-541.el8
commit-author Luiz Augusto von Dentz <luiz.von.dentz@intel.com>
commit 6126ffabba6b415bd6bf3e1b091ef074e86765c6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-541.el8/6126ffab.failed

This introduces HCI_CONN_FLAG_DEVICE_PRIVACY which can be used by
userspace to indicate to the controller to use Device Privacy Mode to a
specific device.

	Signed-off-by: Luiz Augusto von Dentz <luiz.von.dentz@intel.com>
	Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
(cherry picked from commit 6126ffabba6b415bd6bf3e1b091ef074e86765c6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/bluetooth/hci_core.h
diff --cc include/net/bluetooth/hci_core.h
index c24a8da7cd2c,cf24af649c7f..000000000000
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@@ -152,6 -152,16 +152,19 @@@ struct bdaddr_list_with_irk 
  	u8 local_irk[16];
  };
  
++<<<<<<< HEAD
++=======
+ enum hci_conn_flags {
+ 	HCI_CONN_FLAG_REMOTE_WAKEUP,
+ 	HCI_CONN_FLAG_DEVICE_PRIVACY,
+ 
+ 	__HCI_CONN_NUM_FLAGS,
+ };
+ 
+ /* Make sure number of flags doesn't exceed sizeof(current_flags) */
+ static_assert(__HCI_CONN_NUM_FLAGS < 32);
+ 
++>>>>>>> 6126ffabba6b (Bluetooth: Introduce HCI_CONN_FLAG_DEVICE_PRIVACY device flag)
  struct bdaddr_list_with_flags {
  	struct list_head list;
  	bdaddr_t bdaddr;
* Unmerged path include/net/bluetooth/hci_core.h
diff --git a/net/bluetooth/mgmt.c b/net/bluetooth/mgmt.c
index 036ea352710a..1d6af311720d 100644
--- a/net/bluetooth/mgmt.c
+++ b/net/bluetooth/mgmt.c
@@ -3979,6 +3979,11 @@ static int exp_ll_privacy_feature_changed(bool enabled, struct hci_dev *hdev,
 	memcpy(ev.uuid, rpa_resolution_uuid, 16);
 	ev.flags = cpu_to_le32((enabled ? BIT(0) : 0) | BIT(1));
 
+	if (enabled && privacy_mode_capable(hdev))
+		set_bit(HCI_CONN_FLAG_DEVICE_PRIVACY, hdev->conn_flags);
+	else
+		clear_bit(HCI_CONN_FLAG_DEVICE_PRIVACY, hdev->conn_flags);
+
 	return mgmt_limited_event(MGMT_EV_EXP_FEATURE_CHANGED, hdev,
 				  &ev, sizeof(ev),
 				  HCI_MGMT_EXP_FEATURE_EVENTS, skip);
@@ -4456,6 +4461,13 @@ static int set_device_flags(struct sock *sk, struct hci_dev *hdev, void *data,
 		if (params) {
 			params->current_flags = current_flags;
 			status = MGMT_STATUS_SUCCESS;
+
+			/* Update passive scan if HCI_CONN_FLAG_DEVICE_PRIVACY
+			 * has been set.
+			 */
+			if (test_bit(HCI_CONN_FLAG_DEVICE_PRIVACY,
+				     params->flags))
+				hci_update_passive_scan(hdev);
 		} else {
 			bt_dev_warn(hdev, "No such LE device %pMR (0x%x)",
 				    &cp->addr.bdaddr,
