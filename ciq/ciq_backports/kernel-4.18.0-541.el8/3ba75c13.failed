efi: libstub: declare DXE services table

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-541.el8
commit-author Baskov Evgeniy <baskov@ispras.ru>
commit 3ba75c1316390b2bc39c19cb8f0f85922ab3f9ed
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-541.el8/3ba75c13.failed

UEFI DXE services are not yet used in kernel code
but are required to manipulate page table memory
protection flags.

Add required declarations to use DXE services functions.

	Signed-off-by: Baskov Evgeniy <baskov@ispras.ru>
Link: https://lore.kernel.org/r/20220303142120.1975-2-baskov@ispras.ru
[ardb: ignore absent DXE table but warn if the signature check fails]
	Signed-off-by: Ard Biesheuvel <ardb@kernel.org>
(cherry picked from commit 3ba75c1316390b2bc39c19cb8f0f85922ab3f9ed)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/boot/compressed/eboot.c
#	arch/x86/include/asm/efi.h
#	drivers/firmware/efi/libstub/efistub.h
diff --cc arch/x86/boot/compressed/eboot.c
index 839950619e70,cda60aba2f12..000000000000
--- a/arch/x86/boot/compressed/eboot.c
+++ b/arch/x86/boot/compressed/eboot.c
@@@ -17,37 -16,15 +17,44 @@@
  #include <asm/desc.h>
  #include <asm/boot.h>
  
 -#include "efistub.h"
 +#include "../string.h"
 +#include "eboot.h"
 +
 +static efi_system_table_t *sys_table;
 +
++<<<<<<< HEAD:arch/x86/boot/compressed/eboot.c
 +static struct efi_config *efi_early;
 +
 +__pure const struct efi_config *__efi_early(void)
 +{
 +	return efi_early;
 +}
  
 -/* Maximum physical address for 64-bit kernel with 4-level paging */
 -#define MAXMEM_X86_64_4LEVEL (1ull << 46)
 +#define BOOT_SERVICES(bits)						\
 +static void setup_boot_services##bits(struct efi_config *c)		\
 +{									\
 +	efi_system_table_##bits##_t *table;				\
 +									\
 +	table = (typeof(table))sys_table;				\
 +									\
 +	c->runtime_services	= table->runtime;			\
 +	c->boot_services	= table->boottime;			\
 +	c->text_output		= table->con_out;			\
 +}
 +BOOT_SERVICES(32);
 +BOOT_SERVICES(64);
  
 +void efi_char16_printk(efi_system_table_t *table, efi_char16_t *str)
 +{
 +	efi_call_proto(efi_simple_text_output_protocol, output_string,
 +		       efi_early->text_output, str);
 +}
++=======
+ const efi_system_table_t *efi_system_table;
+ const efi_dxe_services_table_t *efi_dxe_table;
+ extern u32 image_offset;
+ static efi_loaded_image_t *image = NULL;
++>>>>>>> 3ba75c131639 (efi: libstub: declare DXE services table):drivers/firmware/efi/libstub/x86-stub.c
  
  static efi_status_t
  preserve_pci_rom_image(efi_pci_io_protocol_t *pci, struct pci_setup_rom **__rom)
@@@ -741,47 -663,122 +748,58 @@@ static efi_status_t exit_boot(struct bo
  }
  
  /*
 - * On success, we return the address of startup_32, which has potentially been
 - * relocated by efi_relocate_kernel.
 - * On failure, we exit to the firmware via efi_exit instead of returning.
 + * On success we return a pointer to a boot_params structure, and NULL
 + * on failure.
   */
 -unsigned long efi_main(efi_handle_t handle,
 -			     efi_system_table_t *sys_table_arg,
 -			     struct boot_params *boot_params)
 +struct boot_params *
 +efi_main(struct efi_config *c, struct boot_params *boot_params)
  {
 -	unsigned long bzimage_addr = (unsigned long)startup_32;
 -	unsigned long buffer_start, buffer_end;
 +	struct desc_ptr *gdt = NULL;
 +	efi_loaded_image_t *image;
  	struct setup_header *hdr = &boot_params->hdr;
 -	unsigned long addr, size;
  	efi_status_t status;
 +	struct desc_struct *desc;
 +	void *handle;
 +	efi_system_table_t *_table;
 +	bool is64;
 +	unsigned long cmdline_paddr;
  
++<<<<<<< HEAD:arch/x86/boot/compressed/eboot.c
 +	efi_early = c;
 +
 +	_table = (efi_system_table_t *)(unsigned long)efi_early->table;
 +	handle = (void *)(unsigned long)efi_early->image_handle;
 +	is64 = efi_early->is64;
 +
 +	sys_table = _table;
 +
++=======
+ 	efi_system_table = sys_table_arg;
++>>>>>>> 3ba75c131639 (efi: libstub: declare DXE services table):drivers/firmware/efi/libstub/x86-stub.c
  	/* Check if we were booted by the EFI firmware */
 -	if (efi_system_table->hdr.signature != EFI_SYSTEM_TABLE_SIGNATURE)
 -		efi_exit(handle, EFI_INVALID_PARAMETER);
 +	if (sys_table->hdr.signature != EFI_SYSTEM_TABLE_SIGNATURE)
 +		goto fail;
 +
 +	if (is64)
 +		setup_boot_services64(efi_early);
 +	else
 +		setup_boot_services32(efi_early);
  
+ 	efi_dxe_table = get_efi_config_table(EFI_DXE_SERVICES_TABLE_GUID);
+ 	if (efi_dxe_table &&
+ 	    efi_dxe_table->hdr.signature != EFI_DXE_SERVICES_TABLE_SIGNATURE) {
+ 		efi_warn("Ignoring DXE services table: invalid signature\n");
+ 		efi_dxe_table = NULL;
+ 	}
+ 
  	/*
 -	 * If the kernel isn't already loaded at a suitable address,
 -	 * relocate it.
 -	 *
 -	 * It must be loaded above LOAD_PHYSICAL_ADDR.
 -	 *
 -	 * The maximum address for 64-bit is 1 << 46 for 4-level paging. This
 -	 * is defined as the macro MAXMEM, but unfortunately that is not a
 -	 * compile-time constant if 5-level paging is configured, so we instead
 -	 * define our own macro for use here.
 -	 *
 -	 * For 32-bit, the maximum address is complicated to figure out, for
 -	 * now use KERNEL_IMAGE_SIZE, which will be 512MiB, the same as what
 -	 * KASLR uses.
 -	 *
 -	 * Also relocate it if image_offset is zero, i.e. the kernel wasn't
 -	 * loaded by LoadImage, but rather by a bootloader that called the
 -	 * handover entry. The reason we must always relocate in this case is
 -	 * to handle the case of systemd-boot booting a unified kernel image,
 -	 * which is a PE executable that contains the bzImage and an initrd as
 -	 * COFF sections. The initrd section is placed after the bzImage
 -	 * without ensuring that there are at least init_size bytes available
 -	 * for the bzImage, and thus the compressed kernel's startup code may
 -	 * overwrite the initrd unless it is moved out of the way.
 -	 */
 -
 -	buffer_start = ALIGN(bzimage_addr - image_offset,
 -			     hdr->kernel_alignment);
 -	buffer_end = buffer_start + hdr->init_size;
 -
 -	if ((buffer_start < LOAD_PHYSICAL_ADDR)				     ||
 -	    (IS_ENABLED(CONFIG_X86_32) && buffer_end > KERNEL_IMAGE_SIZE)    ||
 -	    (IS_ENABLED(CONFIG_X86_64) && buffer_end > MAXMEM_X86_64_4LEVEL) ||
 -	    (image_offset == 0)) {
 -		extern char _bss[];
 -
 -		status = efi_relocate_kernel(&bzimage_addr,
 -					     (unsigned long)_bss - bzimage_addr,
 -					     hdr->init_size,
 -					     hdr->pref_address,
 -					     hdr->kernel_alignment,
 -					     LOAD_PHYSICAL_ADDR);
 -		if (status != EFI_SUCCESS) {
 -			efi_err("efi_relocate_kernel() failed!\n");
 -			goto fail;
 -		}
 -		/*
 -		 * Now that we've copied the kernel elsewhere, we no longer
 -		 * have a set up block before startup_32(), so reset image_offset
 -		 * to zero in case it was set earlier.
 -		 */
 -		image_offset = 0;
 -	}
 -
 -#ifdef CONFIG_CMDLINE_BOOL
 -	status = efi_parse_options(CONFIG_CMDLINE);
 -	if (status != EFI_SUCCESS) {
 -		efi_err("Failed to parse options\n");
 -		goto fail;
 -	}
 -#endif
 -	if (!IS_ENABLED(CONFIG_CMDLINE_OVERRIDE)) {
 -		unsigned long cmdline_paddr = ((u64)hdr->cmd_line_ptr |
 -					       ((u64)boot_params->ext_cmd_line_ptr << 32));
 -		status = efi_parse_options((char *)cmdline_paddr);
 -		if (status != EFI_SUCCESS) {
 -			efi_err("Failed to parse options\n");
 -			goto fail;
 -		}
 -	}
 -
 -	/*
 -	 * At this point, an initrd may already have been loaded by the
 -	 * bootloader and passed via bootparams. We permit an initrd loaded
 -	 * from the LINUX_EFI_INITRD_MEDIA_GUID device path to supersede it.
 -	 *
 -	 * If the device path is not present, any command-line initrd=
 -	 * arguments will be processed only if image is not NULL, which will be
 -	 * the case only if we were loaded via the PE entry point.
 +	 * make_boot_params() may have been called before efi_main(), in which
 +	 * case this is the second time we parse the cmdline. This is ok,
 +	 * parsing the cmdline multiple times does not have side-effects.
  	 */
 -	status = efi_load_initrd(image, &addr, &size, hdr->initrd_addr_max,
 -				 ULONG_MAX);
 -	if (status != EFI_SUCCESS)
 -		goto fail;
 -	if (size > 0) {
 -		efi_set_u64_split(addr, &hdr->ramdisk_image,
 -				  &boot_params->ext_ramdisk_image);
 -		efi_set_u64_split(size, &hdr->ramdisk_size,
 -				  &boot_params->ext_ramdisk_size);
 -	}
 +	cmdline_paddr = ((u64)hdr->cmd_line_ptr |
 +			 ((u64)boot_params->ext_cmd_line_ptr << 32));
 +	efi_parse_options((char *)cmdline_paddr);
  
  	/*
  	 * If the boot loader gave us a value for secure_boot then we use that,
diff --cc arch/x86/include/asm/efi.h
index ab1bdbd9d144,bed74a0f2932..000000000000
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@@ -209,31 -234,142 +209,139 @@@ static inline bool efi_is_native(void
  		__builtin_types_compatible_p(u32, __typeof__(attr)),	\
  			(unsigned long)(attr), (attr))
  
 -#define efi_table_attr(inst, attr)					\
 -	(efi_is_native()						\
 -		? inst->attr						\
 -		: (__typeof__(inst->attr))				\
 -			efi_mixed_mode_cast(inst->mixed_mode.attr))
 -
 -/*
 - * The following macros allow translating arguments if necessary from native to
 - * mixed mode. The use case for this is to initialize the upper 32 bits of
 - * output parameters, and where the 32-bit method requires a 64-bit argument,
 - * which must be split up into two arguments to be thunked properly.
 - *
 - * As examples, the AllocatePool boot service returns the address of the
 - * allocation, but it will not set the high 32 bits of the address. To ensure
 - * that the full 64-bit address is initialized, we zero-init the address before
 - * calling the thunk.
 - *
 - * The FreePages boot service takes a 64-bit physical address even in 32-bit
 - * mode. For the thunk to work correctly, a native 64-bit call of
 - * 	free_pages(addr, size)
 - * must be translated to
 - * 	efi64_thunk(free_pages, addr & U32_MAX, addr >> 32, size)
 - * so that the two 32-bit halves of addr get pushed onto the stack separately.
 - */
 -
 -static inline void *efi64_zero_upper(void *p)
 -{
 -	((u32 *)p)[1] = 0;
 -	return p;
 -}
 +#define efi_table_attr(table, attr, instance) ({			\
 +	__typeof__(((table##_t *)0)->attr) __ret;			\
 +	if (efi_is_native()) {						\
 +		__ret = ((table##_t *)(unsigned long)instance)->attr;	\
 +	} else {							\
 +		__ret = (__typeof__(__ret))efi_mixed_mode_cast(		\
 +		((table##_t *)(unsigned long)instance)->mixed_mode.attr);\
 +	}								\
 +	__ret;								\
 +})
  
 +#define efi_call_proto(protocol, f, instance, ...)			\
 +	__efi_early()->call((unsigned long)				\
 +				efi_table_attr(protocol, f, instance),	\
 +		instance, ##__VA_ARGS__)
 +
 +#define efi_call_early(f, ...)						\
 +	__efi_early()->call((unsigned long)				\
 +				efi_table_attr(efi_boot_services, f,	\
 +		__efi_early()->boot_services), __VA_ARGS__)
 +
++<<<<<<< HEAD
 +#define efi_call_runtime(f, ...)					\
 +	__efi_early()->call((unsigned long)				\
 +				efi_table_attr(efi_runtime_services, f,	\
 +		__efi_early()->runtime_services), __VA_ARGS__)
++=======
+ static inline u32 efi64_convert_status(efi_status_t status)
+ {
+ 	return (u32)(status | (u64)status >> 32);
+ }
+ 
+ #define __efi64_argmap_free_pages(addr, size)				\
+ 	((addr), 0, (size))
+ 
+ #define __efi64_argmap_get_memory_map(mm_size, mm, key, size, ver)	\
+ 	((mm_size), (mm), efi64_zero_upper(key), efi64_zero_upper(size), (ver))
+ 
+ #define __efi64_argmap_allocate_pool(type, size, buffer)		\
+ 	((type), (size), efi64_zero_upper(buffer))
+ 
+ #define __efi64_argmap_create_event(type, tpl, f, c, event)		\
+ 	((type), (tpl), (f), (c), efi64_zero_upper(event))
+ 
+ #define __efi64_argmap_set_timer(event, type, time)			\
+ 	((event), (type), lower_32_bits(time), upper_32_bits(time))
+ 
+ #define __efi64_argmap_wait_for_event(num, event, index)		\
+ 	((num), (event), efi64_zero_upper(index))
+ 
+ #define __efi64_argmap_handle_protocol(handle, protocol, interface)	\
+ 	((handle), (protocol), efi64_zero_upper(interface))
+ 
+ #define __efi64_argmap_locate_protocol(protocol, reg, interface)	\
+ 	((protocol), (reg), efi64_zero_upper(interface))
+ 
+ #define __efi64_argmap_locate_device_path(protocol, path, handle)	\
+ 	((protocol), (path), efi64_zero_upper(handle))
+ 
+ #define __efi64_argmap_exit(handle, status, size, data)			\
+ 	((handle), efi64_convert_status(status), (size), (data))
+ 
+ /* PCI I/O */
+ #define __efi64_argmap_get_location(protocol, seg, bus, dev, func)	\
+ 	((protocol), efi64_zero_upper(seg), efi64_zero_upper(bus),	\
+ 	 efi64_zero_upper(dev), efi64_zero_upper(func))
+ 
+ /* LoadFile */
+ #define __efi64_argmap_load_file(protocol, path, policy, bufsize, buf)	\
+ 	((protocol), (path), (policy), efi64_zero_upper(bufsize), (buf))
+ 
+ /* Graphics Output Protocol */
+ #define __efi64_argmap_query_mode(gop, mode, size, info)		\
+ 	((gop), (mode), efi64_zero_upper(size), efi64_zero_upper(info))
+ 
+ /* TCG2 protocol */
+ #define __efi64_argmap_hash_log_extend_event(prot, fl, addr, size, ev)	\
+ 	((prot), (fl), 0ULL, (u64)(addr), 0ULL, (u64)(size), 0ULL, ev)
+ 
+ /*
+  * The macros below handle the plumbing for the argument mapping. To add a
+  * mapping for a specific EFI method, simply define a macro
+  * __efi64_argmap_<method name>, following the examples above.
+  */
+ 
+ #define __efi64_thunk_map(inst, func, ...)				\
+ 	efi64_thunk(inst->mixed_mode.func,				\
+ 		__efi64_argmap(__efi64_argmap_ ## func(__VA_ARGS__),	\
+ 			       (__VA_ARGS__)))
+ 
+ #define __efi64_argmap(mapped, args)					\
+ 	__PASTE(__efi64_argmap__, __efi_nargs(__efi_eat mapped))(mapped, args)
+ #define __efi64_argmap__0(mapped, args) __efi_eval mapped
+ #define __efi64_argmap__1(mapped, args) __efi_eval args
+ 
+ #define __efi_eat(...)
+ #define __efi_eval(...) __VA_ARGS__
+ 
+ /* The three macros below handle dispatching via the thunk if needed */
+ 
+ #define efi_call_proto(inst, func, ...)					\
+ 	(efi_is_native()						\
+ 		? inst->func(inst, ##__VA_ARGS__)			\
+ 		: __efi64_thunk_map(inst, func, inst, ##__VA_ARGS__))
+ 
+ #define efi_bs_call(func, ...)						\
+ 	(efi_is_native()						\
+ 		? efi_system_table->boottime->func(__VA_ARGS__)		\
+ 		: __efi64_thunk_map(efi_table_attr(efi_system_table,	\
+ 						   boottime),		\
+ 				    func, __VA_ARGS__))
+ 
+ #define efi_rt_call(func, ...)						\
+ 	(efi_is_native()						\
+ 		? efi_system_table->runtime->func(__VA_ARGS__)		\
+ 		: __efi64_thunk_map(efi_table_attr(efi_system_table,	\
+ 						   runtime),		\
+ 				    func, __VA_ARGS__))
+ 
+ #define efi_dxe_call(func, ...)						\
+ 	(efi_is_native()						\
+ 		? efi_dxe_table->func(__VA_ARGS__)			\
+ 		: __efi64_thunk_map(efi_dxe_table, func, __VA_ARGS__))
+ 
+ #else /* CONFIG_EFI_MIXED */
+ 
+ static inline bool efi_is_64bit(void)
+ {
+ 	return IS_ENABLED(CONFIG_X86_64);
+ }
+ 
+ #endif /* CONFIG_EFI_MIXED */
++>>>>>>> 3ba75c131639 (efi: libstub: declare DXE services table)
  
  extern bool efi_reboot_required(void);
  extern bool efi_is_table_address(unsigned long phys_addr);
diff --cc drivers/firmware/efi/libstub/efistub.h
index 6dd28f42f779,2dc24776899a..000000000000
--- a/drivers/firmware/efi/libstub/efistub.h
+++ b/drivers/firmware/efi/libstub/efistub.h
@@@ -25,25 -29,827 +25,841 @@@
  #define EFI_ALLOC_ALIGN		EFI_PAGE_SIZE
  #endif
  
 -extern bool efi_nochunk;
 -extern bool efi_nokaslr;
 -extern int efi_loglevel;
 -extern bool efi_novamap;
 +extern int __pure nokaslr(void);
 +extern int __pure is_quiet(void);
  
 -extern const efi_system_table_t *efi_system_table;
 +extern void set_nokaslr(int val);
  
++<<<<<<< HEAD
 +#define pr_efi(sys_table, msg)		do {				\
 +	if (!is_quiet()) efi_printk(sys_table, "EFI stub: "msg);	\
 +} while (0)
++=======
+ typedef union efi_dxe_services_table efi_dxe_services_table_t;
+ extern const efi_dxe_services_table_t *efi_dxe_table;
+ 
+ efi_status_t __efiapi efi_pe_entry(efi_handle_t handle,
+ 				   efi_system_table_t *sys_table_arg);
++>>>>>>> 3ba75c131639 (efi: libstub: declare DXE services table)
  
 -#ifndef ARCH_HAS_EFISTUB_WRAPPERS
 +#define pr_efi_err(sys_table, msg) efi_printk(sys_table, "EFI stub: ERROR: "msg)
  
++<<<<<<< HEAD
 +void efi_char16_printk(efi_system_table_t *, efi_char16_t *);
++=======
+ #define efi_is_native()		(true)
+ #define efi_bs_call(func, ...)	efi_system_table->boottime->func(__VA_ARGS__)
+ #define efi_rt_call(func, ...)	efi_system_table->runtime->func(__VA_ARGS__)
+ #define efi_dxe_call(func, ...)	efi_dxe_table->func(__VA_ARGS__)
+ #define efi_table_attr(inst, attr)	(inst->attr)
+ #define efi_call_proto(inst, func, ...) inst->func(inst, ##__VA_ARGS__)
++>>>>>>> 3ba75c131639 (efi: libstub: declare DXE services table)
  
 -#endif
 +unsigned long get_dram_base(efi_system_table_t *sys_table_arg);
  
++<<<<<<< HEAD
 +efi_status_t allocate_new_fdt_and_exit_boot(efi_system_table_t *sys_table,
 +					    void *handle,
++=======
+ #define efi_info(fmt, ...) \
+ 	efi_printk(KERN_INFO fmt, ##__VA_ARGS__)
+ #define efi_warn(fmt, ...) \
+ 	efi_printk(KERN_WARNING "WARNING: " fmt, ##__VA_ARGS__)
+ #define efi_err(fmt, ...) \
+ 	efi_printk(KERN_ERR "ERROR: " fmt, ##__VA_ARGS__)
+ #define efi_debug(fmt, ...) \
+ 	efi_printk(KERN_DEBUG "DEBUG: " fmt, ##__VA_ARGS__)
+ 
+ #define efi_printk_once(fmt, ...) 		\
+ ({						\
+ 	static bool __print_once;		\
+ 	bool __ret_print_once = !__print_once;	\
+ 						\
+ 	if (!__print_once) {			\
+ 		__print_once = true;		\
+ 		efi_printk(fmt, ##__VA_ARGS__);	\
+ 	}					\
+ 	__ret_print_once;			\
+ })
+ 
+ #define efi_info_once(fmt, ...) \
+ 	efi_printk_once(KERN_INFO fmt, ##__VA_ARGS__)
+ #define efi_warn_once(fmt, ...) \
+ 	efi_printk_once(KERN_WARNING "WARNING: " fmt, ##__VA_ARGS__)
+ #define efi_err_once(fmt, ...) \
+ 	efi_printk_once(KERN_ERR "ERROR: " fmt, ##__VA_ARGS__)
+ #define efi_debug_once(fmt, ...) \
+ 	efi_printk_once(KERN_DEBUG "DEBUG: " fmt, ##__VA_ARGS__)
+ 
+ /* Helper macros for the usual case of using simple C variables: */
+ #ifndef fdt_setprop_inplace_var
+ #define fdt_setprop_inplace_var(fdt, node_offset, name, var) \
+ 	fdt_setprop_inplace((fdt), (node_offset), (name), &(var), sizeof(var))
+ #endif
+ 
+ #ifndef fdt_setprop_var
+ #define fdt_setprop_var(fdt, node_offset, name, var) \
+ 	fdt_setprop((fdt), (node_offset), (name), &(var), sizeof(var))
+ #endif
+ 
+ #define get_efi_var(name, vendor, ...)				\
+ 	efi_rt_call(get_variable, (efi_char16_t *)(name),	\
+ 		    (efi_guid_t *)(vendor), __VA_ARGS__)
+ 
+ #define set_efi_var(name, vendor, ...)				\
+ 	efi_rt_call(set_variable, (efi_char16_t *)(name),	\
+ 		    (efi_guid_t *)(vendor), __VA_ARGS__)
+ 
+ #define efi_get_handle_at(array, idx)					\
+ 	(efi_is_native() ? (array)[idx] 				\
+ 		: (efi_handle_t)(unsigned long)((u32 *)(array))[idx])
+ 
+ #define efi_get_handle_num(size)					\
+ 	((size) / (efi_is_native() ? sizeof(efi_handle_t) : sizeof(u32)))
+ 
+ #define for_each_efi_handle(handle, array, size, i)			\
+ 	for (i = 0;							\
+ 	     i < efi_get_handle_num(size) &&				\
+ 		((handle = efi_get_handle_at((array), i)) || true);	\
+ 	     i++)
+ 
+ static inline
+ void efi_set_u64_split(u64 data, u32 *lo, u32 *hi)
+ {
+ 	*lo = lower_32_bits(data);
+ 	*hi = upper_32_bits(data);
+ }
+ 
+ /*
+  * Allocation types for calls to boottime->allocate_pages.
+  */
+ #define EFI_ALLOCATE_ANY_PAGES		0
+ #define EFI_ALLOCATE_MAX_ADDRESS	1
+ #define EFI_ALLOCATE_ADDRESS		2
+ #define EFI_MAX_ALLOCATE_TYPE		3
+ 
+ /*
+  * The type of search to perform when calling boottime->locate_handle
+  */
+ #define EFI_LOCATE_ALL_HANDLES			0
+ #define EFI_LOCATE_BY_REGISTER_NOTIFY		1
+ #define EFI_LOCATE_BY_PROTOCOL			2
+ 
+ /*
+  * boottime->stall takes the time period in microseconds
+  */
+ #define EFI_USEC_PER_SEC		1000000
+ 
+ /*
+  * boottime->set_timer takes the time in 100ns units
+  */
+ #define EFI_100NSEC_PER_USEC	((u64)10)
+ 
+ /*
+  * An efi_boot_memmap is used by efi_get_memory_map() to return the
+  * EFI memory map in a dynamically allocated buffer.
+  *
+  * The buffer allocated for the EFI memory map includes extra room for
+  * a minimum of EFI_MMAP_NR_SLACK_SLOTS additional EFI memory descriptors.
+  * This facilitates the reuse of the EFI memory map buffer when a second
+  * call to ExitBootServices() is needed because of intervening changes to
+  * the EFI memory map. Other related structures, e.g. x86 e820ext, need
+  * to factor in this headroom requirement as well.
+  */
+ #define EFI_MMAP_NR_SLACK_SLOTS	8
+ 
+ struct efi_boot_memmap {
+ 	efi_memory_desc_t	**map;
+ 	unsigned long		*map_size;
+ 	unsigned long		*desc_size;
+ 	u32			*desc_ver;
+ 	unsigned long		*key_ptr;
+ 	unsigned long		*buff_size;
+ };
+ 
+ typedef struct efi_generic_dev_path efi_device_path_protocol_t;
+ 
+ typedef void *efi_event_t;
+ /* Note that notifications won't work in mixed mode */
+ typedef void (__efiapi *efi_event_notify_t)(efi_event_t, void *);
+ 
+ #define EFI_EVT_TIMER		0x80000000U
+ #define EFI_EVT_RUNTIME		0x40000000U
+ #define EFI_EVT_NOTIFY_WAIT	0x00000100U
+ #define EFI_EVT_NOTIFY_SIGNAL	0x00000200U
+ 
+ /**
+  * efi_set_event_at() - add event to events array
+  *
+  * @events:	array of UEFI events
+  * @ids:	index where to put the event in the array
+  * @event:	event to add to the aray
+  *
+  * boottime->wait_for_event() takes an array of events as input.
+  * Provide a helper to set it up correctly for mixed mode.
+  */
+ static inline
+ void efi_set_event_at(efi_event_t *events, size_t idx, efi_event_t event)
+ {
+ 	if (efi_is_native())
+ 		events[idx] = event;
+ 	else
+ 		((u32 *)events)[idx] = (u32)(unsigned long)event;
+ }
+ 
+ #define EFI_TPL_APPLICATION	4
+ #define EFI_TPL_CALLBACK	8
+ #define EFI_TPL_NOTIFY		16
+ #define EFI_TPL_HIGH_LEVEL	31
+ 
+ typedef enum {
+ 	EfiTimerCancel,
+ 	EfiTimerPeriodic,
+ 	EfiTimerRelative
+ } EFI_TIMER_DELAY;
+ 
+ /*
+  * EFI Boot Services table
+  */
+ union efi_boot_services {
+ 	struct {
+ 		efi_table_hdr_t hdr;
+ 		void *raise_tpl;
+ 		void *restore_tpl;
+ 		efi_status_t (__efiapi *allocate_pages)(int, int, unsigned long,
+ 							efi_physical_addr_t *);
+ 		efi_status_t (__efiapi *free_pages)(efi_physical_addr_t,
+ 						    unsigned long);
+ 		efi_status_t (__efiapi *get_memory_map)(unsigned long *, void *,
+ 							unsigned long *,
+ 							unsigned long *, u32 *);
+ 		efi_status_t (__efiapi *allocate_pool)(int, unsigned long,
+ 						       void **);
+ 		efi_status_t (__efiapi *free_pool)(void *);
+ 		efi_status_t (__efiapi *create_event)(u32, unsigned long,
+ 						      efi_event_notify_t, void *,
+ 						      efi_event_t *);
+ 		efi_status_t (__efiapi *set_timer)(efi_event_t,
+ 						  EFI_TIMER_DELAY, u64);
+ 		efi_status_t (__efiapi *wait_for_event)(unsigned long,
+ 							efi_event_t *,
+ 							unsigned long *);
+ 		void *signal_event;
+ 		efi_status_t (__efiapi *close_event)(efi_event_t);
+ 		void *check_event;
+ 		void *install_protocol_interface;
+ 		void *reinstall_protocol_interface;
+ 		void *uninstall_protocol_interface;
+ 		efi_status_t (__efiapi *handle_protocol)(efi_handle_t,
+ 							 efi_guid_t *, void **);
+ 		void *__reserved;
+ 		void *register_protocol_notify;
+ 		efi_status_t (__efiapi *locate_handle)(int, efi_guid_t *,
+ 						       void *, unsigned long *,
+ 						       efi_handle_t *);
+ 		efi_status_t (__efiapi *locate_device_path)(efi_guid_t *,
+ 							    efi_device_path_protocol_t **,
+ 							    efi_handle_t *);
+ 		efi_status_t (__efiapi *install_configuration_table)(efi_guid_t *,
+ 								     void *);
+ 		void *load_image;
+ 		void *start_image;
+ 		efi_status_t __noreturn (__efiapi *exit)(efi_handle_t,
+ 							 efi_status_t,
+ 							 unsigned long,
+ 							 efi_char16_t *);
+ 		void *unload_image;
+ 		efi_status_t (__efiapi *exit_boot_services)(efi_handle_t,
+ 							    unsigned long);
+ 		void *get_next_monotonic_count;
+ 		efi_status_t (__efiapi *stall)(unsigned long);
+ 		void *set_watchdog_timer;
+ 		void *connect_controller;
+ 		efi_status_t (__efiapi *disconnect_controller)(efi_handle_t,
+ 							       efi_handle_t,
+ 							       efi_handle_t);
+ 		void *open_protocol;
+ 		void *close_protocol;
+ 		void *open_protocol_information;
+ 		void *protocols_per_handle;
+ 		void *locate_handle_buffer;
+ 		efi_status_t (__efiapi *locate_protocol)(efi_guid_t *, void *,
+ 							 void **);
+ 		void *install_multiple_protocol_interfaces;
+ 		void *uninstall_multiple_protocol_interfaces;
+ 		void *calculate_crc32;
+ 		void *copy_mem;
+ 		void *set_mem;
+ 		void *create_event_ex;
+ 	};
+ 	struct {
+ 		efi_table_hdr_t hdr;
+ 		u32 raise_tpl;
+ 		u32 restore_tpl;
+ 		u32 allocate_pages;
+ 		u32 free_pages;
+ 		u32 get_memory_map;
+ 		u32 allocate_pool;
+ 		u32 free_pool;
+ 		u32 create_event;
+ 		u32 set_timer;
+ 		u32 wait_for_event;
+ 		u32 signal_event;
+ 		u32 close_event;
+ 		u32 check_event;
+ 		u32 install_protocol_interface;
+ 		u32 reinstall_protocol_interface;
+ 		u32 uninstall_protocol_interface;
+ 		u32 handle_protocol;
+ 		u32 __reserved;
+ 		u32 register_protocol_notify;
+ 		u32 locate_handle;
+ 		u32 locate_device_path;
+ 		u32 install_configuration_table;
+ 		u32 load_image;
+ 		u32 start_image;
+ 		u32 exit;
+ 		u32 unload_image;
+ 		u32 exit_boot_services;
+ 		u32 get_next_monotonic_count;
+ 		u32 stall;
+ 		u32 set_watchdog_timer;
+ 		u32 connect_controller;
+ 		u32 disconnect_controller;
+ 		u32 open_protocol;
+ 		u32 close_protocol;
+ 		u32 open_protocol_information;
+ 		u32 protocols_per_handle;
+ 		u32 locate_handle_buffer;
+ 		u32 locate_protocol;
+ 		u32 install_multiple_protocol_interfaces;
+ 		u32 uninstall_multiple_protocol_interfaces;
+ 		u32 calculate_crc32;
+ 		u32 copy_mem;
+ 		u32 set_mem;
+ 		u32 create_event_ex;
+ 	} mixed_mode;
+ };
+ 
+ typedef enum {
+ 	EfiGcdMemoryTypeNonExistent,
+ 	EfiGcdMemoryTypeReserved,
+ 	EfiGcdMemoryTypeSystemMemory,
+ 	EfiGcdMemoryTypeMemoryMappedIo,
+ 	EfiGcdMemoryTypePersistent,
+ 	EfiGcdMemoryTypeMoreReliable,
+ 	EfiGcdMemoryTypeMaximum
+ } efi_gcd_memory_type_t;
+ 
+ typedef struct {
+ 	efi_physical_addr_t base_address;
+ 	u64 length;
+ 	u64 capabilities;
+ 	u64 attributes;
+ 	efi_gcd_memory_type_t gcd_memory_type;
+ 	void *image_handle;
+ 	void *device_handle;
+ } efi_gcd_memory_space_desc_t;
+ 
+ /*
+  * EFI DXE Services table
+  */
+ union efi_dxe_services_table {
+ 	struct {
+ 		efi_table_hdr_t hdr;
+ 		void *add_memory_space;
+ 		void *allocate_memory_space;
+ 		void *free_memory_space;
+ 		void *remove_memory_space;
+ 		efi_status_t (__efiapi *get_memory_space_descriptor)(efi_physical_addr_t,
+ 								     efi_gcd_memory_space_desc_t *);
+ 		efi_status_t (__efiapi *set_memory_space_attributes)(efi_physical_addr_t,
+ 								     u64, u64);
+ 		void *get_memory_space_map;
+ 		void *add_io_space;
+ 		void *allocate_io_space;
+ 		void *free_io_space;
+ 		void *remove_io_space;
+ 		void *get_io_space_descriptor;
+ 		void *get_io_space_map;
+ 		void *dispatch;
+ 		void *schedule;
+ 		void *trust;
+ 		void *process_firmware_volume;
+ 		void *set_memory_space_capabilities;
+ 	};
+ 	struct {
+ 		efi_table_hdr_t hdr;
+ 		u32 add_memory_space;
+ 		u32 allocate_memory_space;
+ 		u32 free_memory_space;
+ 		u32 remove_memory_space;
+ 		u32 get_memory_space_descriptor;
+ 		u32 set_memory_space_attributes;
+ 		u32 get_memory_space_map;
+ 		u32 add_io_space;
+ 		u32 allocate_io_space;
+ 		u32 free_io_space;
+ 		u32 remove_io_space;
+ 		u32 get_io_space_descriptor;
+ 		u32 get_io_space_map;
+ 		u32 dispatch;
+ 		u32 schedule;
+ 		u32 trust;
+ 		u32 process_firmware_volume;
+ 		u32 set_memory_space_capabilities;
+ 	} mixed_mode;
+ };
+ 
+ typedef union efi_uga_draw_protocol efi_uga_draw_protocol_t;
+ 
+ union efi_uga_draw_protocol {
+ 	struct {
+ 		efi_status_t (__efiapi *get_mode)(efi_uga_draw_protocol_t *,
+ 						  u32*, u32*, u32*, u32*);
+ 		void *set_mode;
+ 		void *blt;
+ 	};
+ 	struct {
+ 		u32 get_mode;
+ 		u32 set_mode;
+ 		u32 blt;
+ 	} mixed_mode;
+ };
+ 
+ typedef struct {
+ 	u16 scan_code;
+ 	efi_char16_t unicode_char;
+ } efi_input_key_t;
+ 
+ union efi_simple_text_input_protocol {
+ 	struct {
+ 		void *reset;
+ 		efi_status_t (__efiapi *read_keystroke)(efi_simple_text_input_protocol_t *,
+ 							efi_input_key_t *);
+ 		efi_event_t wait_for_key;
+ 	};
+ 	struct {
+ 		u32 reset;
+ 		u32 read_keystroke;
+ 		u32 wait_for_key;
+ 	} mixed_mode;
+ };
+ 
+ efi_status_t efi_wait_for_key(unsigned long usec, efi_input_key_t *key);
+ 
+ union efi_simple_text_output_protocol {
+ 	struct {
+ 		void *reset;
+ 		efi_status_t (__efiapi *output_string)(efi_simple_text_output_protocol_t *,
+ 						       efi_char16_t *);
+ 		void *test_string;
+ 	};
+ 	struct {
+ 		u32 reset;
+ 		u32 output_string;
+ 		u32 test_string;
+ 	} mixed_mode;
+ };
+ 
+ #define PIXEL_RGB_RESERVED_8BIT_PER_COLOR		0
+ #define PIXEL_BGR_RESERVED_8BIT_PER_COLOR		1
+ #define PIXEL_BIT_MASK					2
+ #define PIXEL_BLT_ONLY					3
+ #define PIXEL_FORMAT_MAX				4
+ 
+ typedef struct {
+ 	u32 red_mask;
+ 	u32 green_mask;
+ 	u32 blue_mask;
+ 	u32 reserved_mask;
+ } efi_pixel_bitmask_t;
+ 
+ typedef struct {
+ 	u32 version;
+ 	u32 horizontal_resolution;
+ 	u32 vertical_resolution;
+ 	int pixel_format;
+ 	efi_pixel_bitmask_t pixel_information;
+ 	u32 pixels_per_scan_line;
+ } efi_graphics_output_mode_info_t;
+ 
+ typedef union efi_graphics_output_protocol_mode efi_graphics_output_protocol_mode_t;
+ 
+ union efi_graphics_output_protocol_mode {
+ 	struct {
+ 		u32 max_mode;
+ 		u32 mode;
+ 		efi_graphics_output_mode_info_t *info;
+ 		unsigned long size_of_info;
+ 		efi_physical_addr_t frame_buffer_base;
+ 		unsigned long frame_buffer_size;
+ 	};
+ 	struct {
+ 		u32 max_mode;
+ 		u32 mode;
+ 		u32 info;
+ 		u32 size_of_info;
+ 		u64 frame_buffer_base;
+ 		u32 frame_buffer_size;
+ 	} mixed_mode;
+ };
+ 
+ typedef union efi_graphics_output_protocol efi_graphics_output_protocol_t;
+ 
+ union efi_graphics_output_protocol {
+ 	struct {
+ 		efi_status_t (__efiapi *query_mode)(efi_graphics_output_protocol_t *,
+ 						    u32, unsigned long *,
+ 						    efi_graphics_output_mode_info_t **);
+ 		efi_status_t (__efiapi *set_mode)  (efi_graphics_output_protocol_t *, u32);
+ 		void *blt;
+ 		efi_graphics_output_protocol_mode_t *mode;
+ 	};
+ 	struct {
+ 		u32 query_mode;
+ 		u32 set_mode;
+ 		u32 blt;
+ 		u32 mode;
+ 	} mixed_mode;
+ };
+ 
+ typedef union {
+ 	struct {
+ 		u32			revision;
+ 		efi_handle_t		parent_handle;
+ 		efi_system_table_t	*system_table;
+ 		efi_handle_t		device_handle;
+ 		void			*file_path;
+ 		void			*reserved;
+ 		u32			load_options_size;
+ 		void			*load_options;
+ 		void			*image_base;
+ 		__aligned_u64		image_size;
+ 		unsigned int		image_code_type;
+ 		unsigned int		image_data_type;
+ 		efi_status_t		(__efiapi *unload)(efi_handle_t image_handle);
+ 	};
+ 	struct {
+ 		u32		revision;
+ 		u32		parent_handle;
+ 		u32		system_table;
+ 		u32		device_handle;
+ 		u32		file_path;
+ 		u32		reserved;
+ 		u32		load_options_size;
+ 		u32		load_options;
+ 		u32		image_base;
+ 		__aligned_u64	image_size;
+ 		u32		image_code_type;
+ 		u32		image_data_type;
+ 		u32		unload;
+ 	} mixed_mode;
+ } efi_loaded_image_t;
+ 
+ typedef struct {
+ 	u64			size;
+ 	u64			file_size;
+ 	u64			phys_size;
+ 	efi_time_t		create_time;
+ 	efi_time_t		last_access_time;
+ 	efi_time_t		modification_time;
+ 	__aligned_u64		attribute;
+ 	efi_char16_t		filename[];
+ } efi_file_info_t;
+ 
+ typedef struct efi_file_protocol efi_file_protocol_t;
+ 
+ struct efi_file_protocol {
+ 	u64		revision;
+ 	efi_status_t	(__efiapi *open)	(efi_file_protocol_t *,
+ 						 efi_file_protocol_t **,
+ 						 efi_char16_t *, u64, u64);
+ 	efi_status_t	(__efiapi *close)	(efi_file_protocol_t *);
+ 	efi_status_t	(__efiapi *delete)	(efi_file_protocol_t *);
+ 	efi_status_t	(__efiapi *read)	(efi_file_protocol_t *,
+ 						 unsigned long *, void *);
+ 	efi_status_t	(__efiapi *write)	(efi_file_protocol_t *,
+ 						 unsigned long, void *);
+ 	efi_status_t	(__efiapi *get_position)(efi_file_protocol_t *, u64 *);
+ 	efi_status_t	(__efiapi *set_position)(efi_file_protocol_t *, u64);
+ 	efi_status_t	(__efiapi *get_info)	(efi_file_protocol_t *,
+ 						 efi_guid_t *, unsigned long *,
+ 						 void *);
+ 	efi_status_t	(__efiapi *set_info)	(efi_file_protocol_t *,
+ 						 efi_guid_t *, unsigned long,
+ 						 void *);
+ 	efi_status_t	(__efiapi *flush)	(efi_file_protocol_t *);
+ };
+ 
+ typedef struct efi_simple_file_system_protocol efi_simple_file_system_protocol_t;
+ 
+ struct efi_simple_file_system_protocol {
+ 	u64	revision;
+ 	int	(__efiapi *open_volume)(efi_simple_file_system_protocol_t *,
+ 					efi_file_protocol_t **);
+ };
+ 
+ #define EFI_FILE_MODE_READ	0x0000000000000001
+ #define EFI_FILE_MODE_WRITE	0x0000000000000002
+ #define EFI_FILE_MODE_CREATE	0x8000000000000000
+ 
+ typedef enum {
+ 	EfiPciIoWidthUint8,
+ 	EfiPciIoWidthUint16,
+ 	EfiPciIoWidthUint32,
+ 	EfiPciIoWidthUint64,
+ 	EfiPciIoWidthFifoUint8,
+ 	EfiPciIoWidthFifoUint16,
+ 	EfiPciIoWidthFifoUint32,
+ 	EfiPciIoWidthFifoUint64,
+ 	EfiPciIoWidthFillUint8,
+ 	EfiPciIoWidthFillUint16,
+ 	EfiPciIoWidthFillUint32,
+ 	EfiPciIoWidthFillUint64,
+ 	EfiPciIoWidthMaximum
+ } EFI_PCI_IO_PROTOCOL_WIDTH;
+ 
+ typedef enum {
+ 	EfiPciIoAttributeOperationGet,
+ 	EfiPciIoAttributeOperationSet,
+ 	EfiPciIoAttributeOperationEnable,
+ 	EfiPciIoAttributeOperationDisable,
+ 	EfiPciIoAttributeOperationSupported,
+     EfiPciIoAttributeOperationMaximum
+ } EFI_PCI_IO_PROTOCOL_ATTRIBUTE_OPERATION;
+ 
+ typedef struct {
+ 	u32 read;
+ 	u32 write;
+ } efi_pci_io_protocol_access_32_t;
+ 
+ typedef union efi_pci_io_protocol efi_pci_io_protocol_t;
+ 
+ typedef
+ efi_status_t (__efiapi *efi_pci_io_protocol_cfg_t)(efi_pci_io_protocol_t *,
+ 						   EFI_PCI_IO_PROTOCOL_WIDTH,
+ 						   u32 offset,
+ 						   unsigned long count,
+ 						   void *buffer);
+ 
+ typedef struct {
+ 	void *read;
+ 	void *write;
+ } efi_pci_io_protocol_access_t;
+ 
+ typedef struct {
+ 	efi_pci_io_protocol_cfg_t read;
+ 	efi_pci_io_protocol_cfg_t write;
+ } efi_pci_io_protocol_config_access_t;
+ 
+ union efi_pci_io_protocol {
+ 	struct {
+ 		void *poll_mem;
+ 		void *poll_io;
+ 		efi_pci_io_protocol_access_t mem;
+ 		efi_pci_io_protocol_access_t io;
+ 		efi_pci_io_protocol_config_access_t pci;
+ 		void *copy_mem;
+ 		void *map;
+ 		void *unmap;
+ 		void *allocate_buffer;
+ 		void *free_buffer;
+ 		void *flush;
+ 		efi_status_t (__efiapi *get_location)(efi_pci_io_protocol_t *,
+ 						      unsigned long *segment_nr,
+ 						      unsigned long *bus_nr,
+ 						      unsigned long *device_nr,
+ 						      unsigned long *func_nr);
+ 		void *attributes;
+ 		void *get_bar_attributes;
+ 		void *set_bar_attributes;
+ 		uint64_t romsize;
+ 		void *romimage;
+ 	};
+ 	struct {
+ 		u32 poll_mem;
+ 		u32 poll_io;
+ 		efi_pci_io_protocol_access_32_t mem;
+ 		efi_pci_io_protocol_access_32_t io;
+ 		efi_pci_io_protocol_access_32_t pci;
+ 		u32 copy_mem;
+ 		u32 map;
+ 		u32 unmap;
+ 		u32 allocate_buffer;
+ 		u32 free_buffer;
+ 		u32 flush;
+ 		u32 get_location;
+ 		u32 attributes;
+ 		u32 get_bar_attributes;
+ 		u32 set_bar_attributes;
+ 		u64 romsize;
+ 		u32 romimage;
+ 	} mixed_mode;
+ };
+ 
+ #define EFI_PCI_IO_ATTRIBUTE_ISA_MOTHERBOARD_IO 0x0001
+ #define EFI_PCI_IO_ATTRIBUTE_ISA_IO 0x0002
+ #define EFI_PCI_IO_ATTRIBUTE_VGA_PALETTE_IO 0x0004
+ #define EFI_PCI_IO_ATTRIBUTE_VGA_MEMORY 0x0008
+ #define EFI_PCI_IO_ATTRIBUTE_VGA_IO 0x0010
+ #define EFI_PCI_IO_ATTRIBUTE_IDE_PRIMARY_IO 0x0020
+ #define EFI_PCI_IO_ATTRIBUTE_IDE_SECONDARY_IO 0x0040
+ #define EFI_PCI_IO_ATTRIBUTE_MEMORY_WRITE_COMBINE 0x0080
+ #define EFI_PCI_IO_ATTRIBUTE_IO 0x0100
+ #define EFI_PCI_IO_ATTRIBUTE_MEMORY 0x0200
+ #define EFI_PCI_IO_ATTRIBUTE_BUS_MASTER 0x0400
+ #define EFI_PCI_IO_ATTRIBUTE_MEMORY_CACHED 0x0800
+ #define EFI_PCI_IO_ATTRIBUTE_MEMORY_DISABLE 0x1000
+ #define EFI_PCI_IO_ATTRIBUTE_EMBEDDED_DEVICE 0x2000
+ #define EFI_PCI_IO_ATTRIBUTE_EMBEDDED_ROM 0x4000
+ #define EFI_PCI_IO_ATTRIBUTE_DUAL_ADDRESS_CYCLE 0x8000
+ #define EFI_PCI_IO_ATTRIBUTE_ISA_IO_16 0x10000
+ #define EFI_PCI_IO_ATTRIBUTE_VGA_PALETTE_IO_16 0x20000
+ #define EFI_PCI_IO_ATTRIBUTE_VGA_IO_16 0x40000
+ 
+ struct efi_dev_path;
+ 
+ typedef union apple_properties_protocol apple_properties_protocol_t;
+ 
+ union apple_properties_protocol {
+ 	struct {
+ 		unsigned long version;
+ 		efi_status_t (__efiapi *get)(apple_properties_protocol_t *,
+ 					     struct efi_dev_path *,
+ 					     efi_char16_t *, void *, u32 *);
+ 		efi_status_t (__efiapi *set)(apple_properties_protocol_t *,
+ 					     struct efi_dev_path *,
+ 					     efi_char16_t *, void *, u32);
+ 		efi_status_t (__efiapi *del)(apple_properties_protocol_t *,
+ 					     struct efi_dev_path *,
+ 					     efi_char16_t *);
+ 		efi_status_t (__efiapi *get_all)(apple_properties_protocol_t *,
+ 						 void *buffer, u32 *);
+ 	};
+ 	struct {
+ 		u32 version;
+ 		u32 get;
+ 		u32 set;
+ 		u32 del;
+ 		u32 get_all;
+ 	} mixed_mode;
+ };
+ 
+ typedef u32 efi_tcg2_event_log_format;
+ 
+ #define INITRD_EVENT_TAG_ID 0x8F3B22ECU
+ #define EV_EVENT_TAG 0x00000006U
+ #define EFI_TCG2_EVENT_HEADER_VERSION	0x1
+ 
+ struct efi_tcg2_event {
+ 	u32		event_size;
+ 	struct {
+ 		u32	header_size;
+ 		u16	header_version;
+ 		u32	pcr_index;
+ 		u32	event_type;
+ 	} __packed event_header;
+ 	/* u8[] event follows here */
+ } __packed;
+ 
+ struct efi_tcg2_tagged_event {
+ 	u32 tagged_event_id;
+ 	u32 tagged_event_data_size;
+ 	/* u8  tagged event data follows here */
+ } __packed;
+ 
+ typedef struct efi_tcg2_event efi_tcg2_event_t;
+ typedef struct efi_tcg2_tagged_event efi_tcg2_tagged_event_t;
+ typedef union efi_tcg2_protocol efi_tcg2_protocol_t;
+ 
+ union efi_tcg2_protocol {
+ 	struct {
+ 		void *get_capability;
+ 		efi_status_t (__efiapi *get_event_log)(efi_tcg2_protocol_t *,
+ 						       efi_tcg2_event_log_format,
+ 						       efi_physical_addr_t *,
+ 						       efi_physical_addr_t *,
+ 						       efi_bool_t *);
+ 		efi_status_t (__efiapi *hash_log_extend_event)(efi_tcg2_protocol_t *,
+ 							       u64,
+ 							       efi_physical_addr_t,
+ 							       u64,
+ 							       const efi_tcg2_event_t *);
+ 		void *submit_command;
+ 		void *get_active_pcr_banks;
+ 		void *set_active_pcr_banks;
+ 		void *get_result_of_set_active_pcr_banks;
+ 	};
+ 	struct {
+ 		u32 get_capability;
+ 		u32 get_event_log;
+ 		u32 hash_log_extend_event;
+ 		u32 submit_command;
+ 		u32 get_active_pcr_banks;
+ 		u32 set_active_pcr_banks;
+ 		u32 get_result_of_set_active_pcr_banks;
+ 	} mixed_mode;
+ };
+ 
+ typedef union efi_load_file_protocol efi_load_file_protocol_t;
+ typedef union efi_load_file_protocol efi_load_file2_protocol_t;
+ 
+ union efi_load_file_protocol {
+ 	struct {
+ 		efi_status_t (__efiapi *load_file)(efi_load_file_protocol_t *,
+ 						   efi_device_path_protocol_t *,
+ 						   bool, unsigned long *, void *);
+ 	};
+ 	struct {
+ 		u32 load_file;
+ 	} mixed_mode;
+ };
+ 
+ typedef struct {
+ 	u32 attributes;
+ 	u16 file_path_list_length;
+ 	u8 variable_data[];
+ 	// efi_char16_t description[];
+ 	// efi_device_path_protocol_t file_path_list[];
+ 	// u8 optional_data[];
+ } __packed efi_load_option_t;
+ 
+ #define EFI_LOAD_OPTION_ACTIVE		0x0001U
+ #define EFI_LOAD_OPTION_FORCE_RECONNECT	0x0002U
+ #define EFI_LOAD_OPTION_HIDDEN		0x0008U
+ #define EFI_LOAD_OPTION_CATEGORY	0x1f00U
+ #define   EFI_LOAD_OPTION_CATEGORY_BOOT	0x0000U
+ #define   EFI_LOAD_OPTION_CATEGORY_APP	0x0100U
+ 
+ #define EFI_LOAD_OPTION_BOOT_MASK \
+ 	(EFI_LOAD_OPTION_ACTIVE|EFI_LOAD_OPTION_HIDDEN|EFI_LOAD_OPTION_CATEGORY)
+ #define EFI_LOAD_OPTION_MASK (EFI_LOAD_OPTION_FORCE_RECONNECT|EFI_LOAD_OPTION_BOOT_MASK)
+ 
+ typedef struct {
+ 	u32 attributes;
+ 	u16 file_path_list_length;
+ 	const efi_char16_t *description;
+ 	const efi_device_path_protocol_t *file_path_list;
+ 	size_t optional_data_size;
+ 	const void *optional_data;
+ } efi_load_option_unpacked_t;
+ 
+ void efi_pci_disable_bridge_busmaster(void);
+ 
+ typedef efi_status_t (*efi_exit_boot_map_processing)(
+ 	struct efi_boot_memmap *map,
+ 	void *priv);
+ 
+ efi_status_t efi_exit_boot_services(void *handle,
+ 				    struct efi_boot_memmap *map,
+ 				    void *priv,
+ 				    efi_exit_boot_map_processing priv_func);
+ 
+ efi_status_t allocate_new_fdt_and_exit_boot(void *handle,
++>>>>>>> 3ba75c131639 (efi: libstub: declare DXE services table)
  					    unsigned long *new_fdt_addr,
 +					    unsigned long max_addr,
  					    u64 initrd_addr, u64 initrd_size,
  					    char *cmdline_ptr,
  					    unsigned long fdt_addr,
* Unmerged path arch/x86/boot/compressed/eboot.c
* Unmerged path arch/x86/include/asm/efi.h
* Unmerged path drivers/firmware/efi/libstub/efistub.h
diff --git a/include/linux/efi.h b/include/linux/efi.h
index cf1b0b8af326..a62d232417cc 100644
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@ -834,6 +834,7 @@ void efi_native_runtime_setup(void);
 #define APPLE_PROPERTIES_PROTOCOL_GUID		EFI_GUID(0x91bd12fe, 0xf6c3, 0x44fb,  0xa5, 0xb7, 0x51, 0x22, 0xab, 0x30, 0x3a, 0xe0)
 #define EFI_TCG2_PROTOCOL_GUID			EFI_GUID(0x607f766c, 0x7455, 0x42be,  0x93, 0x0b, 0xe4, 0xd7, 0x6d, 0xb2, 0x72, 0x0f)
 #define EFI_RT_PROPERTIES_TABLE_GUID		EFI_GUID(0xeb66918a, 0x7eef, 0x402a,  0x84, 0x2e, 0x93, 0x1d, 0x21, 0xc3, 0x8a, 0xe9)
+#define EFI_DXE_SERVICES_TABLE_GUID		EFI_GUID(0x05ad34ba, 0x6f02, 0x4214,  0x95, 0x2e, 0x4d, 0xa0, 0x39, 0x8e, 0x2b, 0xb9)
 
 #define EFI_IMAGE_SECURITY_DATABASE_GUID	EFI_GUID(0xd719b2cb, 0x3d3a, 0x4596,  0xa3, 0xbc, 0xda, 0xd0, 0x0e, 0x67, 0x65, 0x6f)
 #define EFI_SHIM_LOCK_GUID			EFI_GUID(0x605dab50, 0xe046, 0x4300,  0xab, 0xb6, 0x3d, 0xd8, 0x10, 0xdd, 0x8b, 0x23)
@@ -885,6 +886,7 @@ typedef struct {
 } efi_config_table_type_t;
 
 #define EFI_SYSTEM_TABLE_SIGNATURE ((u64)0x5453595320494249ULL)
+#define EFI_DXE_SERVICES_TABLE_SIGNATURE ((u64)0x565245535f455844ULL)
 
 #define EFI_2_30_SYSTEM_TABLE_REVISION  ((2 << 16) | (30))
 #define EFI_2_20_SYSTEM_TABLE_REVISION  ((2 << 16) | (20))
