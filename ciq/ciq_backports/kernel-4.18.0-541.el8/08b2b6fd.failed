cgroup: fix spelling mistakes

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-541.el8
commit-author Zhen Lei <thunder.leizhen@huawei.com>
commit 08b2b6fdf6b26032f025084ce2893924a0cdb4a2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-541.el8/08b2b6fd.failed

Fix some spelling mistakes in comments:
hierarhcy ==> hierarchy
automtically ==> automatically
overriden ==> overridden
In absense of .. or ==> In absence of .. and
assocaited ==> associated
taget ==> target
initate ==> initiate
succeded ==> succeeded
curremt ==> current
udpated ==> updated

	Signed-off-by: Zhen Lei <thunder.leizhen@huawei.com>
	Signed-off-by: Tejun Heo <tj@kernel.org>
(cherry picked from commit 08b2b6fdf6b26032f025084ce2893924a0cdb4a2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/cgroup-defs.h
#	kernel/cgroup/cgroup.c
diff --cc include/linux/cgroup-defs.h
index dcd51ba95429,fb8f6d2cd104..000000000000
--- a/include/linux/cgroup-defs.h
+++ b/include/linux/cgroup-defs.h
@@@ -721,10 -668,7 +721,14 @@@ struct cgroup_subsys 
  	 */
  	bool threaded:1;
  
++<<<<<<< HEAD
 +	RH_KABI_DEPRECATE(bool, broken_hierarchy:1)
 +	RH_KABI_DEPRECATE(bool, warned_broken_hierarchy:1)
 +
 +	/* the following two fields are initialized automtically during boot */
++=======
+ 	/* the following two fields are initialized automatically during boot */
++>>>>>>> 08b2b6fdf6b2 (cgroup: fix spelling mistakes)
  	int id;
  	const char *name;
  
@@@ -804,20 -748,30 +808,40 @@@ static inline void cgroup_threadgroup_c
   * sock_cgroup_data is embedded at sock->sk_cgrp_data and contains
   * per-socket cgroup information except for memcg association.
   *
 - * On legacy hierarchies, net_prio and net_cls controllers directly set
 - * attributes on each sock which can then be tested by the network layer.
 - * On the default hierarchy, each sock is associated with the cgroup it was
 - * created in and the networking layer can match the cgroup directly.
 + * On legacy hierarchies, net_prio and net_cls controllers directly
 + * set attributes on each sock which can then be tested by the network
 + * layer. On the default hierarchy, each sock is associated with the
 + * cgroup it was created in and the networking layer can match the
 + * cgroup directly.
   *
++<<<<<<< HEAD
 + * RHEL8 Note: RH_KABI_BROKEN_REPLACE() is used here because the size of
 + * sock_cgroup_data structure has been increased from 8 bytes to 16 bytes.
 + * As a result, the sk_cgrp_data field of struct sock in include/net/sock.h
 + * has to be relocated to RH_KABI_RESERVE() area with the old location
 + * deprecated.
++=======
+  * To avoid carrying all three cgroup related fields separately in sock,
+  * sock_cgroup_data overloads (prioidx, classid) and the cgroup pointer.
+  * On boot, sock_cgroup_data records the cgroup that the sock was created
+  * in so that cgroup2 matches can be made; however, once either net_prio or
+  * net_cls starts being used, the area is overridden to carry prioidx and/or
+  * classid.  The two modes are distinguished by whether the lowest bit is
+  * set.  Clear bit indicates cgroup pointer while set bit prioidx and
+  * classid.
+  *
+  * While userland may start using net_prio or net_cls at any time, once
+  * either is used, cgroup2 matching no longer works.  There is no reason to
+  * mix the two and this is in line with how legacy and v2 compatibility is
+  * handled.  On mode switch, cgroup references which are already being
+  * pointed to by socks may be leaked.  While this can be remedied by adding
+  * synchronization around sock_cgroup_data, given that the number of leaked
+  * cgroups is bound and highly unlikely to be high, this seems to be the
+  * better trade-off.
++>>>>>>> 08b2b6fdf6b2 (cgroup: fix spelling mistakes)
   */
  struct sock_cgroup_data {
 +	RH_KABI_BROKEN_REPLACE(
  	union {
  #ifdef __LITTLE_ENDIAN
  		struct {
diff --cc kernel/cgroup/cgroup.c
index 6927e89b31a5,21ecc6ee6a6d..000000000000
--- a/kernel/cgroup/cgroup.c
+++ b/kernel/cgroup/cgroup.c
@@@ -6139,14 -6047,16 +6139,27 @@@ out_revert
  }
  
  /**
++<<<<<<< HEAD
 +  * cgroup_cancel_fork - called if a fork failed after cgroup_can_fork()
 +  * @child: the child process
 +  *
 +  * This calls the cancel_fork() callbacks if a fork failed *after*
 +  * cgroup_can_fork() succeded.
 +  */
 +void cgroup_cancel_fork(struct task_struct *child)
 +	__releases(&cgroup_threadgroup_rwsem)
++=======
+  * cgroup_cancel_fork - called if a fork failed after cgroup_can_fork()
+  * @child: the child process
+  * @kargs: the arguments passed to create the child process
+  *
+  * This calls the cancel_fork() callbacks if a fork failed *after*
+  * cgroup_can_fork() succeeded and cleans up references we took to
+  * prepare a new css_set for the child process in cgroup_can_fork().
+  */
+ void cgroup_cancel_fork(struct task_struct *child,
+ 			struct kernel_clone_args *kargs)
++>>>>>>> 08b2b6fdf6b2 (cgroup: fix spelling mistakes)
  {
  	struct cgroup_subsys *ss;
  	int i;
* Unmerged path include/linux/cgroup-defs.h
diff --git a/include/linux/cgroup.h b/include/linux/cgroup.h
index 73910ca79ae3..881adac611ea 100644
--- a/include/linux/cgroup.h
+++ b/include/linux/cgroup.h
@@ -30,7 +30,7 @@
 #ifdef CONFIG_CGROUPS
 
 /*
- * All weight knobs on the default hierarhcy should use the following min,
+ * All weight knobs on the default hierarchy should use the following min,
  * default and max values.  The default value is the logarithmic center of
  * MIN and MAX and allows 100x to be expressed in both directions.
  */
diff --git a/kernel/cgroup/cgroup-v1.c b/kernel/cgroup/cgroup-v1.c
index 5eb20205b59e..c8a22cbe892b 100644
--- a/kernel/cgroup/cgroup-v1.c
+++ b/kernel/cgroup/cgroup-v1.c
@@ -1008,7 +1008,7 @@ static int check_cgroupfs_options(struct fs_context *fc)
 	ctx->subsys_mask &= enabled;
 
 	/*
-	 * In absense of 'none', 'name=' or subsystem name options,
+	 * In absence of 'none', 'name=' and subsystem name options,
 	 * let's default to 'all'.
 	 */
 	if (!ctx->subsys_mask && !ctx->none && !ctx->name)
* Unmerged path kernel/cgroup/cgroup.c
diff --git a/kernel/cgroup/cpuset.c b/kernel/cgroup/cpuset.c
index 9668469d70c4..b84222204c07 100644
--- a/kernel/cgroup/cpuset.c
+++ b/kernel/cgroup/cpuset.c
@@ -3866,7 +3866,7 @@ nodemask_t cpuset_mems_allowed(struct task_struct *tsk)
 }
 
 /**
- * cpuset_nodemask_valid_mems_allowed - check nodemask vs. curremt mems_allowed
+ * cpuset_nodemask_valid_mems_allowed - check nodemask vs. current mems_allowed
  * @nodemask: the nodemask to be checked
  *
  * Are any of the nodes in the nodemask allowed in current->mems_allowed?
diff --git a/kernel/cgroup/rdma.c b/kernel/cgroup/rdma.c
index 1d75ae7f1cb7..64ccb5f216d8 100644
--- a/kernel/cgroup/rdma.c
+++ b/kernel/cgroup/rdma.c
@@ -247,7 +247,7 @@ EXPORT_SYMBOL(rdmacg_uncharge);
  * This function follows charging resource in hierarchical way.
  * It will fail if the charge would cause the new value to exceed the
  * hierarchical limit.
- * Returns 0 if the charge succeded, otherwise -EAGAIN, -ENOMEM or -EINVAL.
+ * Returns 0 if the charge succeeded, otherwise -EAGAIN, -ENOMEM or -EINVAL.
  * Returns pointer to rdmacg for this resource when charging is successful.
  *
  * Charger needs to account resources on two criteria.
diff --git a/kernel/cgroup/rstat.c b/kernel/cgroup/rstat.c
index 0fbf31a37e51..776ab1538f86 100644
--- a/kernel/cgroup/rstat.c
+++ b/kernel/cgroup/rstat.c
@@ -74,7 +74,7 @@ void cgroup_rstat_updated(struct cgroup *cgrp, int cpu)
  * @root: root of the tree to traversal
  * @cpu: target cpu
  *
- * Walks the udpated rstat_cpu tree on @cpu from @root.  %NULL @pos starts
+ * Walks the updated rstat_cpu tree on @cpu from @root.  %NULL @pos starts
  * the traversal and %NULL return indicates the end.  During traversal,
  * each returned cgroup is unlinked from the tree.  Must be called with the
  * matching cgroup_rstat_cpu_lock held.
