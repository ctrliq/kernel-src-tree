Bluetooth: hci_sync: Convert MGMT_OP_SET_CONNECTABLE to use cmd_sync

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-541.el8
commit-author Luiz Augusto von Dentz <luiz.von.dentz@intel.com>
commit f056a65783cce9c1279c1635d92768ce5962e4d6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-541.el8/f056a657.failed

This makes MGMT_OP_SET_CONNEABLE use hci_cmd_sync_queue instead of
use a dedicated connetable_update work.

	Signed-off-by: Luiz Augusto von Dentz <luiz.von.dentz@intel.com>
	Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
(cherry picked from commit f056a65783cce9c1279c1635d92768ce5962e4d6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/bluetooth/hci_core.h
#	include/net/bluetooth/hci_sync.h
#	net/bluetooth/hci_request.c
#	net/bluetooth/hci_sync.c
diff --cc include/net/bluetooth/hci_core.h
index 4e3d44f98eeb,acb46ae27b5a..000000000000
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@@ -498,8 -495,6 +498,11 @@@ struct hci_dev 
  	struct work_struct	discov_update;
  	struct work_struct	bg_scan_update;
  	struct work_struct	scan_update;
++<<<<<<< HEAD
 +	struct work_struct	connectable_update;
 +	struct work_struct	discoverable_update;
++=======
++>>>>>>> f056a65783cc (Bluetooth: hci_sync: Convert MGMT_OP_SET_CONNECTABLE to use cmd_sync)
  	struct delayed_work	le_scan_disable;
  	struct delayed_work	le_scan_restart;
  
@@@ -1832,8 -1825,6 +1835,11 @@@ void mgmt_new_conn_param(struct hci_de
  			 u16 max_interval, u16 latency, u16 timeout);
  void mgmt_smp_complete(struct hci_conn *conn, bool complete);
  bool mgmt_get_connectable(struct hci_dev *hdev);
++<<<<<<< HEAD
 +void mgmt_set_connectable_complete(struct hci_dev *hdev, u8 status);
 +void mgmt_set_discoverable_complete(struct hci_dev *hdev, u8 status);
++=======
++>>>>>>> f056a65783cc (Bluetooth: hci_sync: Convert MGMT_OP_SET_CONNECTABLE to use cmd_sync)
  u8 mgmt_get_adv_discov_flags(struct hci_dev *hdev);
  void mgmt_advertising_added(struct sock *sk, struct hci_dev *hdev,
  			    u8 instance);
diff --cc include/net/bluetooth/hci_sync.h
index db96546d40c8,0336c1bc5d25..000000000000
--- a/include/net/bluetooth/hci_sync.h
+++ b/include/net/bluetooth/hci_sync.h
@@@ -89,5 -90,13 +89,13 @@@ int hci_dev_close_sync(struct hci_dev *
  int hci_powered_update_sync(struct hci_dev *hdev);
  int hci_set_powered_sync(struct hci_dev *hdev, u8 val);
  
++<<<<<<< HEAD
++=======
+ int hci_update_discoverable_sync(struct hci_dev *hdev);
+ int hci_update_discoverable(struct hci_dev *hdev);
+ 
+ int hci_update_connectable_sync(struct hci_dev *hdev);
+ 
++>>>>>>> f056a65783cc (Bluetooth: hci_sync: Convert MGMT_OP_SET_CONNECTABLE to use cmd_sync)
  int hci_start_discovery_sync(struct hci_dev *hdev);
  int hci_stop_discovery_sync(struct hci_dev *hdev);
 -
 -int hci_suspend_sync(struct hci_dev *hdev);
 -int hci_resume_sync(struct hci_dev *hdev);
diff --cc net/bluetooth/hci_request.c
index 46fa9c3bdb3e,98bf425eaf1b..000000000000
--- a/net/bluetooth/hci_request.c
+++ b/net/bluetooth/hci_request.c
@@@ -3088,8 -2800,6 +3047,11 @@@ void hci_request_setup(struct hci_dev *
  	INIT_WORK(&hdev->discov_update, discov_update);
  	INIT_WORK(&hdev->bg_scan_update, bg_scan_update);
  	INIT_WORK(&hdev->scan_update, scan_update_work);
++<<<<<<< HEAD
 +	INIT_WORK(&hdev->connectable_update, connectable_update_work);
 +	INIT_WORK(&hdev->discoverable_update, discoverable_update_work);
++=======
++>>>>>>> f056a65783cc (Bluetooth: hci_sync: Convert MGMT_OP_SET_CONNECTABLE to use cmd_sync)
  	INIT_DELAYED_WORK(&hdev->discov_off, discov_off);
  	INIT_DELAYED_WORK(&hdev->le_scan_disable, le_scan_disable_work);
  	INIT_DELAYED_WORK(&hdev->le_scan_restart, le_scan_restart_work);
@@@ -3104,8 -2814,6 +3066,11 @@@ void hci_request_cancel_all(struct hci_
  	cancel_work_sync(&hdev->discov_update);
  	cancel_work_sync(&hdev->bg_scan_update);
  	cancel_work_sync(&hdev->scan_update);
++<<<<<<< HEAD
 +	cancel_work_sync(&hdev->connectable_update);
 +	cancel_work_sync(&hdev->discoverable_update);
++=======
++>>>>>>> f056a65783cc (Bluetooth: hci_sync: Convert MGMT_OP_SET_CONNECTABLE to use cmd_sync)
  	cancel_delayed_work_sync(&hdev->discov_off);
  	cancel_delayed_work_sync(&hdev->le_scan_disable);
  	cancel_delayed_work_sync(&hdev->le_scan_restart);
diff --cc net/bluetooth/hci_sync.c
index 621a0df9da94,ad86caf41f91..000000000000
--- a/net/bluetooth/hci_sync.c
+++ b/net/bluetooth/hci_sync.c
@@@ -2694,6 -4391,126 +2694,129 @@@ int hci_set_powered_sync(struct hci_de
  	return hci_power_off_sync(hdev);
  }
  
++<<<<<<< HEAD
++=======
+ static int hci_write_iac_sync(struct hci_dev *hdev)
+ {
+ 	struct hci_cp_write_current_iac_lap cp;
+ 
+ 	if (!hci_dev_test_flag(hdev, HCI_DISCOVERABLE))
+ 		return 0;
+ 
+ 	memset(&cp, 0, sizeof(cp));
+ 
+ 	if (hci_dev_test_flag(hdev, HCI_LIMITED_DISCOVERABLE)) {
+ 		/* Limited discoverable mode */
+ 		cp.num_iac = min_t(u8, hdev->num_iac, 2);
+ 		cp.iac_lap[0] = 0x00;	/* LIAC */
+ 		cp.iac_lap[1] = 0x8b;
+ 		cp.iac_lap[2] = 0x9e;
+ 		cp.iac_lap[3] = 0x33;	/* GIAC */
+ 		cp.iac_lap[4] = 0x8b;
+ 		cp.iac_lap[5] = 0x9e;
+ 	} else {
+ 		/* General discoverable mode */
+ 		cp.num_iac = 1;
+ 		cp.iac_lap[0] = 0x33;	/* GIAC */
+ 		cp.iac_lap[1] = 0x8b;
+ 		cp.iac_lap[2] = 0x9e;
+ 	}
+ 
+ 	return __hci_cmd_sync_status(hdev, HCI_OP_WRITE_CURRENT_IAC_LAP,
+ 				     (cp.num_iac * 3) + 1, &cp,
+ 				     HCI_CMD_TIMEOUT);
+ }
+ 
+ int hci_update_discoverable_sync(struct hci_dev *hdev)
+ {
+ 	int err = 0;
+ 
+ 	if (hci_dev_test_flag(hdev, HCI_BREDR_ENABLED)) {
+ 		err = hci_write_iac_sync(hdev);
+ 		if (err)
+ 			return err;
+ 
+ 		err = hci_update_scan_sync(hdev);
+ 		if (err)
+ 			return err;
+ 
+ 		err = hci_update_class_sync(hdev);
+ 		if (err)
+ 			return err;
+ 	}
+ 
+ 	/* Advertising instances don't use the global discoverable setting, so
+ 	 * only update AD if advertising was enabled using Set Advertising.
+ 	 */
+ 	if (hci_dev_test_flag(hdev, HCI_ADVERTISING)) {
+ 		err = hci_update_adv_data_sync(hdev, 0x00);
+ 		if (err)
+ 			return err;
+ 
+ 		/* Discoverable mode affects the local advertising
+ 		 * address in limited privacy mode.
+ 		 */
+ 		if (hci_dev_test_flag(hdev, HCI_LIMITED_PRIVACY)) {
+ 			if (ext_adv_capable(hdev))
+ 				err = hci_start_ext_adv_sync(hdev, 0x00);
+ 			else
+ 				err = hci_enable_advertising_sync(hdev);
+ 		}
+ 	}
+ 
+ 	return err;
+ }
+ 
+ static int update_discoverable_sync(struct hci_dev *hdev, void *data)
+ {
+ 	return hci_update_discoverable_sync(hdev);
+ }
+ 
+ int hci_update_discoverable(struct hci_dev *hdev)
+ {
+ 	/* Only queue if it would have any effect */
+ 	if (hdev_is_powered(hdev) &&
+ 	    hci_dev_test_flag(hdev, HCI_ADVERTISING) &&
+ 	    hci_dev_test_flag(hdev, HCI_DISCOVERABLE) &&
+ 	    hci_dev_test_flag(hdev, HCI_LIMITED_PRIVACY))
+ 		return hci_cmd_sync_queue(hdev, update_discoverable_sync, NULL,
+ 					  NULL);
+ 
+ 	return 0;
+ }
+ 
+ int hci_update_connectable_sync(struct hci_dev *hdev)
+ {
+ 	int err;
+ 
+ 	err = hci_update_scan_sync(hdev);
+ 	if (err)
+ 		return err;
+ 
+ 	/* If BR/EDR is not enabled and we disable advertising as a
+ 	 * by-product of disabling connectable, we need to update the
+ 	 * advertising flags.
+ 	 */
+ 	if (!hci_dev_test_flag(hdev, HCI_BREDR_ENABLED))
+ 		err = hci_update_adv_data_sync(hdev, hdev->cur_adv_instance);
+ 
+ 	/* Update the advertising parameters if necessary */
+ 	if (hci_dev_test_flag(hdev, HCI_ADVERTISING) ||
+ 	    !list_empty(&hdev->adv_instances)) {
+ 		if (ext_adv_capable(hdev))
+ 			err = hci_start_ext_adv_sync(hdev,
+ 						     hdev->cur_adv_instance);
+ 		else
+ 			err = hci_enable_advertising_sync(hdev);
+ 
+ 		if (err)
+ 			return err;
+ 	}
+ 
+ 	return hci_update_passive_scan_sync(hdev);
+ }
+ 
++>>>>>>> f056a65783cc (Bluetooth: hci_sync: Convert MGMT_OP_SET_CONNECTABLE to use cmd_sync)
  static int hci_inquiry_sync(struct hci_dev *hdev, u8 length)
  {
  	const u8 giac[3] = { 0x33, 0x8b, 0x9e };
* Unmerged path include/net/bluetooth/hci_core.h
* Unmerged path include/net/bluetooth/hci_sync.h
* Unmerged path net/bluetooth/hci_request.c
* Unmerged path net/bluetooth/hci_sync.c
diff --git a/net/bluetooth/mgmt.c b/net/bluetooth/mgmt.c
index e69bfcb60f82..f1e18d5651b6 100644
--- a/net/bluetooth/mgmt.c
+++ b/net/bluetooth/mgmt.c
@@ -1535,31 +1535,26 @@ static int set_discoverable(struct sock *sk, struct hci_dev *hdev, void *data,
 	return err;
 }
 
-void mgmt_set_connectable_complete(struct hci_dev *hdev, u8 status)
+static void mgmt_set_connectable_complete(struct hci_dev *hdev, void *data,
+					  int err)
 {
-	struct mgmt_pending_cmd *cmd;
+	struct mgmt_pending_cmd *cmd = data;
 
-	bt_dev_dbg(hdev, "status 0x%02x", status);
+	bt_dev_dbg(hdev, "err %d", err);
 
 	hci_dev_lock(hdev);
 
-	cmd = pending_find(MGMT_OP_SET_CONNECTABLE, hdev);
-	if (!cmd)
-		goto unlock;
-
-	if (status) {
-		u8 mgmt_err = mgmt_status(status);
+	if (err) {
+		u8 mgmt_err = mgmt_status(err);
 		mgmt_cmd_status(cmd->sk, cmd->index, cmd->opcode, mgmt_err);
-		goto remove_cmd;
+		goto done;
 	}
 
 	send_settings_rsp(cmd->sk, MGMT_OP_SET_CONNECTABLE, hdev);
 	new_settings(hdev, cmd->sk);
 
-remove_cmd:
-	mgmt_pending_remove(cmd);
-
-unlock:
+done:
+	mgmt_pending_free(cmd);
 	hci_dev_unlock(hdev);
 }
 
@@ -1592,6 +1587,13 @@ static int set_connectable_update_settings(struct hci_dev *hdev,
 	return 0;
 }
 
+static int set_connectable_sync(struct hci_dev *hdev, void *data)
+{
+	BT_DBG("%s", hdev->name);
+
+	return hci_update_connectable_sync(hdev);
+}
+
 static int set_connectable(struct sock *sk, struct hci_dev *hdev, void *data,
 			   u16 len)
 {
@@ -1624,7 +1626,7 @@ static int set_connectable(struct sock *sk, struct hci_dev *hdev, void *data,
 		goto failed;
 	}
 
-	cmd = mgmt_pending_add(sk, MGMT_OP_SET_CONNECTABLE, hdev, data, len);
+	cmd = mgmt_pending_new(sk, MGMT_OP_SET_CONNECTABLE, hdev, data, len);
 	if (!cmd) {
 		err = -ENOMEM;
 		goto failed;
@@ -1641,8 +1643,8 @@ static int set_connectable(struct sock *sk, struct hci_dev *hdev, void *data,
 		hci_dev_clear_flag(hdev, HCI_CONNECTABLE);
 	}
 
-	queue_work(hdev->req_workqueue, &hdev->connectable_update);
-	err = 0;
+	err = hci_cmd_sync_queue(hdev, set_connectable_sync, cmd,
+				 mgmt_set_connectable_complete);
 
 failed:
 	hci_dev_unlock(hdev);
