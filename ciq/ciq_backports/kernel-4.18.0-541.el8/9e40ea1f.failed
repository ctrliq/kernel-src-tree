mxser: extract port ISR

jira LE-1907
cve CVE-2023-6546
Rebuild_History Non-Buildable kernel-4.18.0-541.el8
commit-author Jiri Slaby <jslaby@suse.cz>
commit 9e40ea1f785292356cfb39aafff7d346b46d8b4f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-541.el8/9e40ea1f.failed

The ISR is terrible mix of letters. Let's extract the proper per-port
handling to a separate function called mxser_port_isr. This way, we can
actually see what both mxser_interrupt and mxser_port_isr do now.

	Signed-off-by: Jiri Slaby <jslaby@suse.cz>
Link: https://lore.kernel.org/r/20210618061516.662-14-jslaby@suse.cz
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 9e40ea1f785292356cfb39aafff7d346b46d8b4f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/tty/mxser.c
diff --cc drivers/tty/mxser.c
index 399fb247a605,555b9b37b52f..000000000000
--- a/drivers/tty/mxser.c
+++ b/drivers/tty/mxser.c
@@@ -2362,59 -2293,8 +2422,61 @@@ static irqreturn_t mxser_interrupt(int 
  			int_cnt = 0;
  			spin_lock(&port->slock);
  			do {
- 				iir = inb(port->ioaddr + UART_IIR);
- 				if (iir & UART_IIR_NO_INT)
+ 				if (mxser_port_isr(port))
  					break;
++<<<<<<< HEAD
 +				iir &= MOXA_MUST_IIR_MASK;
 +				tty = tty_port_tty_get(&port->port);
 +				if (!tty || port->closing ||
 +				    !tty_port_initialized(&port->port)) {
 +					status = inb(port->ioaddr + UART_LSR);
 +					outb(0x27, port->ioaddr + UART_FCR);
 +					inb(port->ioaddr + UART_MSR);
 +					tty_kref_put(tty);
 +					break;
 +				}
 +
 +				status = inb(port->ioaddr + UART_LSR);
 +
 +				if (status & UART_LSR_PE)
 +					port->err_shadow |= NPPI_NOTIFY_PARITY;
 +				if (status & UART_LSR_FE)
 +					port->err_shadow |= NPPI_NOTIFY_FRAMING;
 +				if (status & UART_LSR_OE)
 +					port->err_shadow |=
 +						NPPI_NOTIFY_HW_OVERRUN;
 +				if (status & UART_LSR_BI)
 +					port->err_shadow |= NPPI_NOTIFY_BREAK;
 +
 +				if (port->board->chip_flag) {
 +					if (iir == MOXA_MUST_IIR_GDA ||
 +					    iir == MOXA_MUST_IIR_RDA ||
 +					    iir == MOXA_MUST_IIR_RTO ||
 +					    iir == MOXA_MUST_IIR_LSR)
 +						mxser_receive_chars(tty, port,
 +								&status);
 +
 +				} else {
 +					status &= port->read_status_mask;
 +					if (status & UART_LSR_DR)
 +						mxser_receive_chars(tty, port,
 +								&status);
 +				}
 +				msr = inb(port->ioaddr + UART_MSR);
 +				if (msr & UART_MSR_ANY_DELTA)
 +					mxser_check_modem_status(tty, port, msr);
 +
 +				if (port->board->chip_flag) {
 +					if (iir == 0x02 && (status &
 +								UART_LSR_THRE))
 +						mxser_transmit_chars(tty, port);
 +				} else {
 +					if (status & UART_LSR_THRE)
 +						mxser_transmit_chars(tty, port);
 +				}
 +				tty_kref_put(tty);
++=======
++>>>>>>> 9e40ea1f7852 (mxser: extract port ISR)
  			} while (int_cnt++ < MXSER_ISR_PASS_LIMIT);
  			spin_unlock(&port->slock);
  		}
* Unmerged path drivers/tty/mxser.c
