efi: libstub: ensure allocated memory to be executable

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-541.el8
commit-author Baskov Evgeniy <baskov@ispras.ru>
commit 82e0d6d76a2a74bd6a31141d555d53b4cc22c2a3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-541.el8/82e0d6d7.failed

There are UEFI versions that restrict execution of memory regions,
preventing the kernel from booting. Parts that needs to be executable
are:

* Area used for trampoline placement.
* All memory regions that the kernel may be relocated before
  and during extraction.

Use DXE services to ensure aforementioned address ranges
to be executable. Only modify attributes that does not
have appropriate attributes.

	Signed-off-by: Baskov Evgeniy <baskov@ispras.ru>
Link: https://lore.kernel.org/r/20220303142120.1975-3-baskov@ispras.ru
	Signed-off-by: Ard Biesheuvel <ardb@kernel.org>
(cherry picked from commit 82e0d6d76a2a74bd6a31141d555d53b4cc22c2a3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/boot/compressed/eboot.c
diff --cc arch/x86/boot/compressed/eboot.c
index 839950619e70,b14e88ccefca..000000000000
--- a/arch/x86/boot/compressed/eboot.c
+++ b/arch/x86/boot/compressed/eboot.c
@@@ -240,12 -212,113 +240,113 @@@ static void retrieve_apple_device_prope
  	}
  }
  
+ static void
+ adjust_memory_range_protection(unsigned long start, unsigned long size)
+ {
+ 	efi_status_t status;
+ 	efi_gcd_memory_space_desc_t desc;
+ 	unsigned long end, next;
+ 	unsigned long rounded_start, rounded_end;
+ 	unsigned long unprotect_start, unprotect_size;
+ 	int has_system_memory = 0;
+ 
+ 	if (efi_dxe_table == NULL)
+ 		return;
+ 
+ 	rounded_start = rounddown(start, EFI_PAGE_SIZE);
+ 	rounded_end = roundup(start + size, EFI_PAGE_SIZE);
+ 
+ 	/*
+ 	 * Don't modify memory region attributes, they are
+ 	 * already suitable, to lower the possibility to
+ 	 * encounter firmware bugs.
+ 	 */
+ 
+ 	for (end = start + size; start < end; start = next) {
+ 
+ 		status = efi_dxe_call(get_memory_space_descriptor, start, &desc);
+ 
+ 		if (status != EFI_SUCCESS)
+ 			return;
+ 
+ 		next = desc.base_address + desc.length;
+ 
+ 		/*
+ 		 * Only system memory is suitable for trampoline/kernel image placement,
+ 		 * so only this type of memory needs its attributes to be modified.
+ 		 */
+ 
+ 		if (desc.gcd_memory_type != EfiGcdMemoryTypeSystemMemory ||
+ 		    (desc.attributes & (EFI_MEMORY_RO | EFI_MEMORY_XP)) == 0)
+ 			continue;
+ 
+ 		unprotect_start = max(rounded_start, (unsigned long)desc.base_address);
+ 		unprotect_size = min(rounded_end, next) - unprotect_start;
+ 
+ 		status = efi_dxe_call(set_memory_space_attributes,
+ 				      unprotect_start, unprotect_size,
+ 				      EFI_MEMORY_WB);
+ 
+ 		if (status != EFI_SUCCESS) {
+ 			efi_warn("Unable to unprotect memory range [%08lx,%08lx]: %d\n",
+ 				 unprotect_start,
+ 				 unprotect_start + unprotect_size,
+ 				 (int)status);
+ 		}
+ 	}
+ }
+ 
+ /*
+  * Trampoline takes 2 pages and can be loaded in first megabyte of memory
+  * with its end placed between 128k and 640k where BIOS might start.
+  * (see arch/x86/boot/compressed/pgtable_64.c)
+  *
+  * We cannot find exact trampoline placement since memory map
+  * can be modified by UEFI, and it can alter the computed address.
+  */
+ 
+ #define TRAMPOLINE_PLACEMENT_BASE ((128 - 8)*1024)
+ #define TRAMPOLINE_PLACEMENT_SIZE (640*1024 - (128 - 8)*1024)
+ 
+ void startup_32(struct boot_params *boot_params);
+ 
+ static void
+ setup_memory_protection(unsigned long image_base, unsigned long image_size)
+ {
+ 	/*
+ 	 * Allow execution of possible trampoline used
+ 	 * for switching between 4- and 5-level page tables
+ 	 * and relocated kernel image.
+ 	 */
+ 
+ 	adjust_memory_range_protection(TRAMPOLINE_PLACEMENT_BASE,
+ 				       TRAMPOLINE_PLACEMENT_SIZE);
+ 
+ #ifdef CONFIG_64BIT
+ 	if (image_base != (unsigned long)startup_32)
+ 		adjust_memory_range_protection(image_base, image_size);
+ #else
+ 	/*
+ 	 * Clear protection flags on a whole range of possible
+ 	 * addresses used for KASLR. We don't need to do that
+ 	 * on x86_64, since KASLR/extraction is performed after
+ 	 * dedicated identity page tables are built and we only
+ 	 * need to remove possible protection on relocated image
+ 	 * itself disregarding further relocations.
+ 	 */
+ 	adjust_memory_range_protection(LOAD_PHYSICAL_ADDR,
+ 				       KERNEL_IMAGE_SIZE - LOAD_PHYSICAL_ADDR);
+ #endif
+ }
+ 
  static const efi_char16_t apple[] = L"Apple";
  
- static void setup_quirks(struct boot_params *boot_params)
+ static void setup_quirks(struct boot_params *boot_params,
+ 			 unsigned long image_base,
+ 			 unsigned long image_size)
  {
  	efi_char16_t *fw_vendor = (efi_char16_t *)(unsigned long)
 -		efi_table_attr(efi_system_table, fw_vendor);
 +		efi_table_attr(efi_system_table, fw_vendor, sys_table);
  
  	if (!memcmp(fw_vendor, apple, sizeof(apple))) {
  		if (IS_ENABLED(CONFIG_APPLE_PROPERTIES))
@@@ -365,6 -438,18 +469,21 @@@ void setup_graphics(struct boot_params 
  	}
  }
  
++<<<<<<< HEAD:arch/x86/boot/compressed/eboot.c
++=======
+ 
+ static void __noreturn efi_exit(efi_handle_t handle, efi_status_t status)
+ {
+ 	efi_bs_call(exit, handle, status, 0, NULL);
+ 	for(;;)
+ 		asm("hlt");
+ }
+ 
+ void __noreturn efi_stub_entry(efi_handle_t handle,
+ 			       efi_system_table_t *sys_table_arg,
+ 			       struct boot_params *boot_params);
+ 
++>>>>>>> 82e0d6d76a2a (efi: libstub: ensure allocated memory to be executable):drivers/firmware/efi/libstub/x86-stub.c
  /*
   * Because the x86 boot code expects to be passed a boot_params we
   * need to create one ourselves (usually the bootloader would create
@@@ -798,12 -900,11 +917,12 @@@ efi_main(struct efi_config *c, struct b
  
  	setup_efi_pci(boot_params);
  
- 	setup_quirks(boot_params);
+ 	setup_quirks(boot_params, bzimage_addr, buffer_end - buffer_start);
  
 -	status = exit_boot(boot_params, handle);
 +	status = efi_call_early(allocate_pool, EFI_LOADER_DATA,
 +				sizeof(*gdt), (void **)&gdt);
  	if (status != EFI_SUCCESS) {
 -		efi_err("exit_boot() failed!\n");
 +		efi_printk(sys_table, "Failed to allocate memory for 'gdt' structure\n");
  		goto fail;
  	}
  
* Unmerged path arch/x86/boot/compressed/eboot.c
diff --git a/drivers/firmware/efi/Kconfig b/drivers/firmware/efi/Kconfig
index 0d870f135ef5..99c8f167c0e1 100644
--- a/drivers/firmware/efi/Kconfig
+++ b/drivers/firmware/efi/Kconfig
@@ -95,6 +95,18 @@ config EFI_SOFT_RESERVE
 
 	  If unsure, say Y.
 
+config EFI_DXE_MEM_ATTRIBUTES
+	bool "Adjust memory attributes in EFISTUB"
+	depends on EFI && EFI_STUB && X86
+	default y
+	help
+	  UEFI specification does not guarantee all memory to be
+	  accessible for both write and execute as the kernel expects
+	  it to be.
+	  Use DXE services to check and alter memory protection
+	  attributes during boot via EFISTUB to ensure that memory
+	  ranges used by the kernel are writable and executable.
+
 config EFI_PARAMS_FROM_FDT
 	bool
 	help
