EDAC/ghes: Fix NULL pointer dereference in ghes_edac_register()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-541.el8
commit-author Shiju Jose <shiju.jose@huawei.com>
commit b972fdba8665d75109ade0357739f46af6415d2a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-541.el8/b972fdba.failed

After

  b9cae27728d1 ("EDAC/ghes: Scan the system once on driver init")

and with CONFIG_DEBUG_TEST_DRIVER_REMOVE enabled, ghes_hw.dimms becomes
a NULL pointer after the second ->probe() (aka ghes_edac_register())
which the config option causes to be called.

This happens because the static variable which holds down whether
the system has been scanned already, doesn't get reset in
ghes_edac_unregister(). Then, on the second probe, ghes_scan_system()
doesn't get to enumerate the DIMMs, leading to ghes_hw.dimms remaining
NULL.

Clear the variable and rename it to something more descriptive so that a
second probe succeeds.

 [ bp: Rewrite commit message. ]

Fixes: b9cae27728d1 ("EDAC/ghes: Scan the system once on driver init")
	Suggested-by: Borislav Petkov <bp@suse.de>
	Signed-off-by: Shiju Jose <shiju.jose@huawei.com>
	Signed-off-by: Borislav Petkov <bp@suse.de>
Link: https://lkml.kernel.org/r/20200827140450.1620-1-shiju.jose@huawei.com
(cherry picked from commit b972fdba8665d75109ade0357739f46af6415d2a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/edac/ghes_edac.c
diff --cc drivers/edac/ghes_edac.c
index 0365a010a90d,54ebc8afc6b1..000000000000
--- a/drivers/edac/ghes_edac.c
+++ b/drivers/edac/ghes_edac.c
@@@ -75,142 -83,156 +77,162 @@@ struct memdev_dmi_entry 
  	u16 conf_mem_clk_speed;
  } __attribute__((__packed__));
  
 -static struct dimm_info *find_dimm_by_handle(struct mem_ctl_info *mci, u16 handle)
 -{
 -	struct dimm_info *dimm;
 +struct ghes_edac_dimm_fill {
 +	struct mem_ctl_info *mci;
 +	unsigned count;
 +};
  
 -	mci_for_each_dimm(mci, dimm) {
 -		if (dimm->smbios_handle == handle)
 -			return dimm;
 -	}
 +static void ghes_edac_count_dimms(const struct dmi_header *dh, void *arg)
 +{
 +	int *num_dimm = arg;
  
 -	return NULL;
 +	if (dh->type == DMI_ENTRY_MEM_DEVICE)
 +		(*num_dimm)++;
  }
  
 -static void dimm_setup_label(struct dimm_info *dimm, u16 handle)
 +static int get_dimm_smbios_index(struct mem_ctl_info *mci, u16 handle)
  {
 -	const char *bank = NULL, *device = NULL;
 -
 -	dmi_memdev_name(handle, &bank, &device);
 +	int i;
  
 -	/* both strings must be non-zero */
 -	if (bank && *bank && device && *device)
 -		snprintf(dimm->label, sizeof(dimm->label), "%s %s", bank, device);
 +	for (i = 0; i < mci->tot_dimms; i++) {
 +		if (mci->dimms[i]->smbios_handle == handle)
 +			return i;
 +	}
 +	return -1;
  }
  
 -static void assign_dmi_dimm_info(struct dimm_info *dimm, struct memdev_dmi_entry *entry)
 +static void dimm_setup_label(struct dimm_info *dimm, u16 handle)
  {
 -	u16 rdr_mask = BIT(7) | BIT(13);
 -
 -	if (entry->size == 0xffff) {
 -		pr_info("Can't get DIMM%i size\n", dimm->idx);
 -		dimm->nr_pages = MiB_TO_PAGES(32);/* Unknown */
 -	} else if (entry->size == 0x7fff) {
 -		dimm->nr_pages = MiB_TO_PAGES(entry->extended_size);
 -	} else {
 -		if (entry->size & BIT(15))
 -			dimm->nr_pages = MiB_TO_PAGES((entry->size & 0x7fff) << 10);
 -		else
 -			dimm->nr_pages = MiB_TO_PAGES(entry->size);
 -	}
 +	const char *bank = NULL, *device = NULL;
  
 -	switch (entry->memory_type) {
 -	case 0x12:
 -		if (entry->type_detail & BIT(13))
 -			dimm->mtype = MEM_RDDR;
 -		else
 -			dimm->mtype = MEM_DDR;
 -		break;
 -	case 0x13:
 -		if (entry->type_detail & BIT(13))
 -			dimm->mtype = MEM_RDDR2;
 -		else
 -			dimm->mtype = MEM_DDR2;
 -		break;
 -	case 0x14:
 -		dimm->mtype = MEM_FB_DDR2;
 -		break;
 -	case 0x18:
 -		if (entry->type_detail & BIT(12))
 -			dimm->mtype = MEM_NVDIMM;
 -		else if (entry->type_detail & BIT(13))
 -			dimm->mtype = MEM_RDDR3;
 -		else
 -			dimm->mtype = MEM_DDR3;
 -		break;
 -	case 0x1a:
 -		if (entry->type_detail & BIT(12))
 -			dimm->mtype = MEM_NVDIMM;
 -		else if (entry->type_detail & BIT(13))
 -			dimm->mtype = MEM_RDDR4;
 -		else
 -			dimm->mtype = MEM_DDR4;
 -		break;
 -	default:
 -		if (entry->type_detail & BIT(6))
 -			dimm->mtype = MEM_RMBS;
 -		else if ((entry->type_detail & rdr_mask) == rdr_mask)
 -			dimm->mtype = MEM_RDR;
 -		else if (entry->type_detail & BIT(7))
 -			dimm->mtype = MEM_SDR;
 -		else if (entry->type_detail & BIT(9))
 -			dimm->mtype = MEM_EDO;
 -		else
 -			dimm->mtype = MEM_UNKNOWN;
 -	}
 +	dmi_memdev_name(handle, &bank, &device);
  
  	/*
 -	 * Actually, we can only detect if the memory has bits for
 -	 * checksum or not
 +	 * Set to a NULL string when both bank and device are zero. In this case,
 +	 * the label assigned by default will be preserved.
  	 */
 -	if (entry->total_width == entry->data_width)
 -		dimm->edac_mode = EDAC_NONE;
 -	else
 -		dimm->edac_mode = EDAC_SECDED;
 -
 -	dimm->dtype = DEV_UNKNOWN;
 -	dimm->grain = 128;		/* Likely, worse case */
 -
 -	dimm_setup_label(dimm, entry->handle);
 -
 -	if (dimm->nr_pages) {
 -		edac_dbg(1, "DIMM%i: %s size = %d MB%s\n",
 -			dimm->idx, edac_mem_types[dimm->mtype],
 -			PAGES_TO_MiB(dimm->nr_pages),
 -			(dimm->edac_mode != EDAC_NONE) ? "(ECC)" : "");
 -		edac_dbg(2, "\ttype %d, detail 0x%02x, width %d(total %d)\n",
 -			entry->memory_type, entry->type_detail,
 -			entry->total_width, entry->data_width);
 -	}
 -
 -	dimm->smbios_handle = entry->handle;
 +	snprintf(dimm->label, sizeof(dimm->label), "%s%s%s",
 +		 (bank && *bank) ? bank : "",
 +		 (bank && *bank && device && *device) ? " " : "",
 +		 (device && *device) ? device : "");
  }
  
 -static void enumerate_dimms(const struct dmi_header *dh, void *arg)
 +static void ghes_edac_dmidecode(const struct dmi_header *dh, void *arg)
  {
 -	struct memdev_dmi_entry *entry = (struct memdev_dmi_entry *)dh;
 -	struct ghes_hw_desc *hw = (struct ghes_hw_desc *)arg;
 -	struct dimm_info *d;
 +	struct ghes_edac_dimm_fill *dimm_fill = arg;
 +	struct mem_ctl_info *mci = dimm_fill->mci;
 +
 +	if (dh->type == DMI_ENTRY_MEM_DEVICE) {
 +		struct memdev_dmi_entry *entry = (struct memdev_dmi_entry *)dh;
 +		struct dimm_info *dimm = edac_get_dimm(mci, dimm_fill->count, 0, 0);
 +		u16 rdr_mask = BIT(7) | BIT(13);
 +
 +		if (entry->size == 0xffff) {
 +			pr_info("Can't get DIMM%i size\n",
 +				dimm_fill->count);
 +			dimm->nr_pages = MiB_TO_PAGES(32);/* Unknown */
 +		} else if (entry->size == 0x7fff) {
 +			dimm->nr_pages = MiB_TO_PAGES(entry->extended_size);
 +		} else {
 +			if (entry->size & BIT(15))
 +				dimm->nr_pages = MiB_TO_PAGES((entry->size & 0x7fff) << 10);
 +			else
 +				dimm->nr_pages = MiB_TO_PAGES(entry->size);
 +		}
  
 -	if (dh->type != DMI_ENTRY_MEM_DEVICE)
 -		return;
 +		switch (entry->memory_type) {
 +		case 0x12:
 +			if (entry->type_detail & BIT(13))
 +				dimm->mtype = MEM_RDDR;
 +			else
 +				dimm->mtype = MEM_DDR;
 +			break;
 +		case 0x13:
 +			if (entry->type_detail & BIT(13))
 +				dimm->mtype = MEM_RDDR2;
 +			else
 +				dimm->mtype = MEM_DDR2;
 +			break;
 +		case 0x14:
 +			dimm->mtype = MEM_FB_DDR2;
 +			break;
 +		case 0x18:
 +			if (entry->type_detail & BIT(12))
 +				dimm->mtype = MEM_NVDIMM;
 +			else if (entry->type_detail & BIT(13))
 +				dimm->mtype = MEM_RDDR3;
 +			else
 +				dimm->mtype = MEM_DDR3;
 +			break;
 +		case 0x1a:
 +			if (entry->type_detail & BIT(12))
 +				dimm->mtype = MEM_NVDIMM;
 +			else if (entry->type_detail & BIT(13))
 +				dimm->mtype = MEM_RDDR4;
 +			else
 +				dimm->mtype = MEM_DDR4;
 +			break;
 +		default:
 +			if (entry->type_detail & BIT(6))
 +				dimm->mtype = MEM_RMBS;
 +			else if ((entry->type_detail & rdr_mask) == rdr_mask)
 +				dimm->mtype = MEM_RDR;
 +			else if (entry->type_detail & BIT(7))
 +				dimm->mtype = MEM_SDR;
 +			else if (entry->type_detail & BIT(9))
 +				dimm->mtype = MEM_EDO;
 +			else
 +				dimm->mtype = MEM_UNKNOWN;
 +		}
  
 -	/* Enlarge the array with additional 16 */
 -	if (!hw->num_dimms || !(hw->num_dimms % 16)) {
 -		struct dimm_info *new;
 +		/*
 +		 * Actually, we can only detect if the memory has bits for
 +		 * checksum or not
 +		 */
 +		if (entry->total_width == entry->data_width)
 +			dimm->edac_mode = EDAC_NONE;
 +		else
 +			dimm->edac_mode = EDAC_SECDED;
  
 -		new = krealloc(hw->dimms, (hw->num_dimms + 16) * sizeof(struct dimm_info),
 -			        GFP_KERNEL);
 -		if (!new) {
 -			WARN_ON_ONCE(1);
 -			return;
 +		dimm->dtype = DEV_UNKNOWN;
 +		dimm->grain = 128;		/* Likely, worse case */
 +
 +		dimm_setup_label(dimm, entry->handle);
 +
 +		if (dimm->nr_pages) {
 +			edac_dbg(1, "DIMM%i: %s size = %d MB%s\n",
 +				dimm_fill->count, edac_mem_types[dimm->mtype],
 +				PAGES_TO_MiB(dimm->nr_pages),
 +				(dimm->edac_mode != EDAC_NONE) ? "(ECC)" : "");
 +			edac_dbg(2, "\ttype %d, detail 0x%02x, width %d(total %d)\n",
 +				entry->memory_type, entry->type_detail,
 +				entry->total_width, entry->data_width);
  		}
  
 -		hw->dimms = new;
 +		dimm->smbios_handle = entry->handle;
 +
 +		dimm_fill->count++;
  	}
++<<<<<<< HEAD
++=======
+ 
+ 	d = &hw->dimms[hw->num_dimms];
+ 	d->idx = hw->num_dimms;
+ 
+ 	assign_dmi_dimm_info(d, entry);
+ 
+ 	hw->num_dimms++;
+ }
+ 
+ static void ghes_scan_system(void)
+ {
+ 	if (system_scanned)
+ 		return;
+ 
+ 	dmi_walk(enumerate_dimms, &ghes_hw);
+ 
+ 	system_scanned = true;
++>>>>>>> b972fdba8665 (EDAC/ghes: Fix NULL pointer dereference in ghes_edac_register())
  }
  
  void ghes_edac_report_mem_error(int sev, struct cper_sec_mem_err *mem_err)
* Unmerged path drivers/edac/ghes_edac.c
