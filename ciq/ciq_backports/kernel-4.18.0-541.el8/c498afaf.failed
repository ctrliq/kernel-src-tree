EDAC: Introduce an mci_for_each_dimm() iterator

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-541.el8
commit-author Robert Richter <rrichter@marvell.com>
commit c498afaf7df87f44e7cb383c135baec52b5259be
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-541.el8/c498afaf.failed

Introduce an mci_for_each_dimm() iterator. It returns a pointer to
a struct dimm_info. This makes the declaration and use of an index
obsolete and avoids access to internal data of struct mci (direct array
access etc).

 [ bp: push the struct dimm_info *dimm; declaration into the
   CONFIG_EDAC_DEBUG block. ]

	Signed-off-by: Robert Richter <rrichter@marvell.com>
	Signed-off-by: Borislav Petkov <bp@suse.de>
	Reviewed-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
	Cc: "linux-edac@vger.kernel.org" <linux-edac@vger.kernel.org>
	Cc: James Morse <james.morse@arm.com>
	Cc: Tony Luck <tony.luck@intel.com>
Link: https://lkml.kernel.org/r/20191106093239.25517-4-rrichter@marvell.com
(cherry picked from commit c498afaf7df87f44e7cb383c135baec52b5259be)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/edac/edac_mc_sysfs.c
#	drivers/edac/i5100_edac.c
diff --cc drivers/edac/edac_mc_sysfs.c
index 0d28c5e31b29,0367554e7437..000000000000
--- a/drivers/edac/edac_mc_sysfs.c
+++ b/drivers/edac/edac_mc_sysfs.c
@@@ -964,22 -945,9 +963,27 @@@ int edac_create_sysfs_mci_device(struc
  		if (!dimm->nr_pages)
  			continue;
  
++<<<<<<< HEAD
 +#ifdef CONFIG_EDAC_DEBUG
 +		edac_dbg(1, "creating dimm%d, located at ", i);
 +		if (edac_debug_level >= 1) {
 +			int lay;
 +			for (lay = 0; lay < mci->n_layers; lay++)
 +				printk(KERN_CONT "%s %d ",
 +					edac_layer_name[mci->layers[lay].type],
 +					dimm->location[lay]);
 +			printk(KERN_CONT "\n");
 +		}
 +#endif
 +		err = edac_create_dimm_object(mci, dimm, i);
 +		if (err) {
 +			edac_dbg(1, "failure: create dimm %d obj\n", i);
++=======
+ 		err = edac_create_dimm_object(mci, dimm);
+ 		if (err)
++>>>>>>> c498afaf7df8 (EDAC: Introduce an mci_for_each_dimm() iterator)
  			goto fail_unregister_dimm;
 +		}
  	}
  
  #ifdef CONFIG_EDAC_LEGACY_SYSFS
@@@ -1021,11 -985,10 +1022,10 @@@ void edac_remove_sysfs_mci_device(struc
  	edac_delete_csrow_objects(mci);
  #endif
  
- 	for (i = 0; i < mci->tot_dimms; i++) {
- 		struct dimm_info *dimm = mci->dimms[i];
+ 	mci_for_each_dimm(mci, dimm) {
  		if (dimm->nr_pages == 0)
  			continue;
 -		edac_dbg(1, "unregistering device %s\n", dev_name(&dimm->dev));
 +		edac_dbg(0, "removing device %s\n", dev_name(&dimm->dev));
  		device_unregister(&dimm->dev);
  	}
  }
diff --cc drivers/edac/i5100_edac.c
index 39ba7f2414ae,0ddc41e47a96..000000000000
--- a/drivers/edac/i5100_edac.c
+++ b/drivers/edac/i5100_edac.c
@@@ -846,14 -846,13 +846,21 @@@ static void i5100_init_interleaving(str
  
  static void i5100_init_csrows(struct mem_ctl_info *mci)
  {
- 	int i;
  	struct i5100_priv *priv = mci->pvt_info;
+ 	struct dimm_info *dimm;
  
++<<<<<<< HEAD
 +	for (i = 0; i < mci->tot_dimms; i++) {
 +		struct dimm_info *dimm;
 +		const unsigned long npages = i5100_npages(mci, i);
 +		const unsigned chan = i5100_csrow_to_chan(mci, i);
 +		const unsigned rank = i5100_csrow_to_rank(mci, i);
++=======
+ 	mci_for_each_dimm(mci, dimm) {
+ 		const unsigned long npages = i5100_npages(mci, dimm->idx);
+ 		const unsigned int chan = i5100_csrow_to_chan(mci, dimm->idx);
+ 		const unsigned int rank = i5100_csrow_to_rank(mci, dimm->idx);
++>>>>>>> c498afaf7df8 (EDAC: Introduce an mci_for_each_dimm() iterator)
  
  		if (!npages)
  			continue;
diff --git a/drivers/edac/edac_mc.c b/drivers/edac/edac_mc.c
index 1b23eafb85e3..c88a61ef5e93 100644
--- a/drivers/edac/edac_mc.c
+++ b/drivers/edac/edac_mc.c
@@ -145,15 +145,18 @@ static void edac_mc_dump_channel(struct rank_info *chan)
 	edac_dbg(4, "    channel->dimm = %p\n", chan->dimm);
 }
 
-static void edac_mc_dump_dimm(struct dimm_info *dimm, int number)
+static void edac_mc_dump_dimm(struct dimm_info *dimm)
 {
 	char location[80];
 
+	if (!dimm->nr_pages)
+		return;
+
 	edac_dimm_info_location(dimm, location, sizeof(location));
 
 	edac_dbg(4, "%s%i: %smapped as virtual row %d, chan %d\n",
 		 dimm->mci->csbased ? "rank" : "dimm",
-		 number, location, dimm->csrow, dimm->cschannel);
+		 dimm->idx, location, dimm->csrow, dimm->cschannel);
 	edac_dbg(4, "  dimm = %p\n", dimm);
 	edac_dbg(4, "  dimm->label = '%s'\n", dimm->label);
 	edac_dbg(4, "  dimm->nr_pages = 0x%x\n", dimm->nr_pages);
@@ -726,6 +729,7 @@ int edac_mc_add_mc_with_groups(struct mem_ctl_info *mci,
 		edac_mc_dump_mci(mci);
 
 	if (edac_debug_level >= 4) {
+		struct dimm_info *dimm;
 		int i;
 
 		for (i = 0; i < mci->nr_csrows; i++) {
@@ -742,9 +746,9 @@ int edac_mc_add_mc_with_groups(struct mem_ctl_info *mci,
 				if (csrow->channels[j]->dimm->nr_pages)
 					edac_mc_dump_channel(csrow->channels[j]);
 		}
-		for (i = 0; i < mci->tot_dimms; i++)
-			if (mci->dimms[i]->nr_pages)
-				edac_mc_dump_dimm(mci->dimms[i], i);
+
+		mci_for_each_dimm(mci, dimm)
+			edac_mc_dump_dimm(dimm);
 	}
 #endif
 	mutex_lock(&mem_ctls_mutex);
@@ -1102,6 +1106,7 @@ void edac_mc_handle_error(const enum hw_event_mc_err_type type,
 			  const char *msg,
 			  const char *other_detail)
 {
+	struct dimm_info *dimm;
 	char *p;
 	int row = -1, chan = -1;
 	int pos[EDAC_MAX_LAYERS] = { top_layer, mid_layer, low_layer };
@@ -1162,9 +1167,7 @@ void edac_mc_handle_error(const enum hw_event_mc_err_type type,
 	p = e->label;
 	*p = '\0';
 
-	for (i = 0; i < mci->tot_dimms; i++) {
-		struct dimm_info *dimm = mci->dimms[i];
-
+	mci_for_each_dimm(mci, dimm) {
 		if (top_layer >= 0 && top_layer != dimm->location[0])
 			continue;
 		if (mid_layer >= 0 && mid_layer != dimm->location[1])
* Unmerged path drivers/edac/edac_mc_sysfs.c
diff --git a/drivers/edac/ghes_edac.c b/drivers/edac/ghes_edac.c
index 0731ed80366b..a3db6e1cdb38 100644
--- a/drivers/edac/ghes_edac.c
+++ b/drivers/edac/ghes_edac.c
@@ -92,12 +92,13 @@ static void ghes_edac_count_dimms(const struct dmi_header *dh, void *arg)
 
 static int get_dimm_smbios_index(struct mem_ctl_info *mci, u16 handle)
 {
-	int i;
+	struct dimm_info *dimm;
 
-	for (i = 0; i < mci->tot_dimms; i++) {
-		if (mci->dimms[i]->smbios_handle == handle)
-			return i;
+	mci_for_each_dimm(mci, dimm) {
+		if (dimm->smbios_handle == handle)
+			return dimm->idx;
 	}
+
 	return -1;
 }
 
* Unmerged path drivers/edac/i5100_edac.c
diff --git a/include/linux/edac.h b/include/linux/edac.h
index 7b38fd8dd823..19c2fc1ad9b3 100644
--- a/include/linux/edac.h
+++ b/include/linux/edac.h
@@ -660,6 +660,13 @@ struct mem_ctl_info {
 	u16 fake_inject_count;
 };
 
+#define mci_for_each_dimm(mci, dimm)				\
+	for ((dimm) = (mci)->dimms[0];				\
+	     (dimm);						\
+	     (dimm) = (dimm)->idx + 1 < (mci)->tot_dimms	\
+		     ? (mci)->dimms[(dimm)->idx + 1]		\
+		     : NULL)
+
 /**
  * edac_get_dimm_by_index - Get DIMM info at @index from a memory
  * 			    controller
