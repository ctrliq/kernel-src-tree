mxser: remove MOXA_ASPP_MON and friends

jira LE-1907
cve CVE-2023-6546
Rebuild_History Non-Buildable kernel-4.18.0-541.el8
commit-author Jiri Slaby <jslaby@suse.cz>
commit 644c55d229537d6770615b01f074537776973a5b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-541.el8/644c55d2.failed

1) MOXA_ASPP_MON_EXT is broken at least since commit ecbbfd44a08f (TTY:
   move tty buffers to tty_port) in 2012.
2) The ioctl definitions were never exposed to userspace, so noone should
   actually be reliably using them.
3) They're not even mentioned in any of the mxser utilities.

So remove all these mxser-special ioctls: MOXA_ASPP_MON,
MOXA_ASPP_MON_EXT, and MOXA_SDS_RSTICOUNTER.

	Signed-off-by: Jiri Slaby <jslaby@suse.cz>
Link: https://lore.kernel.org/r/20210618061516.662-25-jslaby@suse.cz
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 644c55d229537d6770615b01f074537776973a5b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/tty/mxser.c
diff --cc drivers/tty/mxser.c
index e63665b0a8d7,68c2f2346dcf..000000000000
--- a/drivers/tty/mxser.c
+++ b/drivers/tty/mxser.c
@@@ -1679,93 -1492,6 +1627,96 @@@ static int mxser_ioctl_special(unsigne
  			}
  		return 0;
  	}
++<<<<<<< HEAD
 +	case MOXA_ASPP_MON_EXT: {
 +		struct mxser_mon_ext *me; /* it's 2k, stack unfriendly */
 +		unsigned int cflag, iflag, p;
 +		u8 opmode;
 +
 +		me = kzalloc(sizeof(*me), GFP_KERNEL);
 +		if (!me)
 +			return -ENOMEM;
 +
 +		for (i = 0, p = 0; i < MXSER_BOARDS; i++) {
 +			for (j = 0; j < MXSER_PORTS_PER_BOARD; j++, p++) {
 +				if (p >= ARRAY_SIZE(me->rx_cnt)) {
 +					i = MXSER_BOARDS;
 +					break;
 +				}
 +				ip = &mxser_boards[i].ports[j];
 +				port = &ip->port;
 +
 +				mutex_lock(&port->mutex);
 +				if (!ip->ioaddr) {
 +					mutex_unlock(&port->mutex);
 +					continue;
 +				}
 +
 +				spin_lock_irq(&ip->slock);
 +				status = mxser_get_msr(ip->ioaddr, 0, p);
 +
 +				if (status & UART_MSR_TERI)
 +					ip->icount.rng++;
 +				if (status & UART_MSR_DDSR)
 +					ip->icount.dsr++;
 +				if (status & UART_MSR_DDCD)
 +					ip->icount.dcd++;
 +				if (status & UART_MSR_DCTS)
 +					ip->icount.cts++;
 +
 +				ip->mon_data.modem_status = status;
 +				me->rx_cnt[p] = ip->mon_data.rxcnt;
 +				me->tx_cnt[p] = ip->mon_data.txcnt;
 +				me->up_rxcnt[p] = ip->mon_data.up_rxcnt;
 +				me->up_txcnt[p] = ip->mon_data.up_txcnt;
 +				me->modem_status[p] =
 +					ip->mon_data.modem_status;
 +				spin_unlock_irq(&ip->slock);
 +
 +				tty = tty_port_tty_get(&ip->port);
 +
 +				if (!tty) {
 +					cflag = ip->normal_termios.c_cflag;
 +					iflag = ip->normal_termios.c_iflag;
 +					me->baudrate[p] = tty_termios_baud_rate(&ip->normal_termios);
 +				} else {
 +					cflag = tty->termios.c_cflag;
 +					iflag = tty->termios.c_iflag;
 +					me->baudrate[p] = tty_get_baud_rate(tty);
 +				}
 +				tty_kref_put(tty);
 +
 +				me->databits[p] = cflag & CSIZE;
 +				me->stopbits[p] = cflag & CSTOPB;
 +				me->parity[p] = cflag & (PARENB | PARODD |
 +						CMSPAR);
 +
 +				if (cflag & CRTSCTS)
 +					me->flowctrl[p] |= 0x03;
 +
 +				if (iflag & (IXON | IXOFF))
 +					me->flowctrl[p] |= 0x0C;
 +
 +				if (ip->type == PORT_16550A)
 +					me->fifo[p] = 1;
 +
 +				if (ip->board->chip_flag == MOXA_MUST_MU860_HWID) {
 +					opmode = inb(ip->opmode_ioaddr)>>((p % 4) * 2);
 +					opmode &= OP_MODE_MASK;
 +				} else {
 +					opmode = RS232_MODE;
 +				}
 +				me->iftype[p] = opmode;
 +				mutex_unlock(&port->mutex);
 +			}
 +		}
 +		if (copy_to_user(argp, me, sizeof(*me)))
 +			ret = -EFAULT;
 +		kfree(me);
 +		return ret;
 +	}
++=======
++>>>>>>> 644c55d22953 (mxser: remove MOXA_ASPP_MON and friends)
  	default:
  		return -ENOIOCTLCMD;
  	}
@@@ -2248,18 -1937,31 +2161,16 @@@ intr_old
  
  		}
  
 -		if (hwid)
 +		if (port->board->chip_flag)
  			break;
  
 -		status = inb(port->ioaddr + UART_LSR);
 -	} while (status & UART_LSR_DR);
 -
 -	return status;
 -}
 -
 -static u8 mxser_receive_chars(struct tty_struct *tty,
 -		struct mxser_port *port, u8 status)
 -{
 -	int cnt = 0;
 -
 -	if (tty->receive_room == 0 && !port->ldisc_stop_rx)
 -		mxser_stoprx(tty);
 -
 -	if (!mxser_receive_chars_new(tty, port, status, &cnt))
 -		status = mxser_receive_chars_old(tty, port, status, &cnt);
 +		*status = inb(port->ioaddr + UART_LSR);
 +	} while (*status & UART_LSR_DR);
  
 +end_intr:
  	mxvar_log.rxcnt[tty->index] += cnt;
- 	port->mon_data.rxcnt += cnt;
- 	port->mon_data.up_rxcnt += cnt;
  
  	tty_flip_buffer_push(&port->port);
 -
 -	return status;
  }
  
  static void mxser_transmit_chars(struct tty_struct *tty, struct mxser_port *port)
* Unmerged path drivers/tty/mxser.c
