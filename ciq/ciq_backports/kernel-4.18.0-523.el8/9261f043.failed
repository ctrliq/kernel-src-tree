s390/vfio-ap: use work struct to verify queue reset

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-523.el8
commit-author Tony Krowiak <akrowiak@linux.ibm.com>
commit 9261f0438835a97254590046e1be83733cca440f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-523.el8/9261f043.failed

Instead of waiting to verify that a queue is reset in the
vfio_ap_mdev_reset_queue function, let's use a wait queue to check the
the state of the reset. This way, when resetting all of the queues assigned
to a matrix mdev, we don't have to wait for each queue to be reset before
initiating a reset on the next queue to be reset.

	Signed-off-by: Tony Krowiak <akrowiak@linux.ibm.com>
	Reviewed-by: Jason J. Herne <jjherne@linux.ibm.com>
	Suggested-by: Halil Pasic <pasic@linux.ibm.com>
	Acked-by: Janosch Frank <frankja@linux.ibm.com>
	Tested-by: Viktor Mihajlovski <mihajlov@linux.ibm.com>
Link: https://lore.kernel.org/r/20230815184333.6554-8-akrowiak@linux.ibm.com
	Signed-off-by: Heiko Carstens <hca@linux.ibm.com>
(cherry picked from commit 9261f0438835a97254590046e1be83733cca440f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/s390/crypto/vfio_ap_ops.c
#	drivers/s390/crypto/vfio_ap_private.h
diff --cc drivers/s390/crypto/vfio_ap_ops.c
index ef0d06898296,3a59f1c5390f..000000000000
--- a/drivers/s390/crypto/vfio_ap_ops.c
+++ b/drivers/s390/crypto/vfio_ap_ops.c
@@@ -33,7 -34,8 +33,12 @@@
  
  static int vfio_ap_mdev_reset_queues(struct ap_queue_table *qtable);
  static struct vfio_ap_queue *vfio_ap_find_queue(int apqn);
++<<<<<<< HEAD
 +static int vfio_ap_mdev_reset_queue(struct vfio_ap_queue *q, unsigned int retry);
++=======
+ static const struct vfio_device_ops vfio_ap_matrix_dev_ops;
+ static void vfio_ap_mdev_reset_queue(struct vfio_ap_queue *q);
++>>>>>>> 9261f0438835 (s390/vfio-ap: use work struct to verify queue reset)
  
  /**
   * get_update_locks_for_kvm: Acquire the locks required to dynamically update a
@@@ -1560,137 -1621,141 +1565,220 @@@ static int apq_status_check(int apqn, s
  	}
  }
  
++<<<<<<< HEAD
 +static int apq_reset_check(struct vfio_ap_queue *q)
++=======
+ #define WAIT_MSG "Waited %dms for reset of queue %02x.%04x (%u, %u, %u)"
+ 
+ static void apq_reset_check(struct work_struct *reset_work)
++>>>>>>> 9261f0438835 (s390/vfio-ap: use work struct to verify queue reset)
  {
 -	int ret = -EBUSY, elapsed = 0;
 +	int ret;
 +	int iters = MAX_RESET_CHECK_WAIT / AP_RESET_INTERVAL;
  	struct ap_queue_status status;
+ 	struct vfio_ap_queue *q;
  
++<<<<<<< HEAD
 +	for (; iters > 0; iters--) {
++=======
+ 	q = container_of(reset_work, struct vfio_ap_queue, reset_work);
+ 	memcpy(&status, &q->reset_status, sizeof(status));
+ 	while (true) {
++>>>>>>> 9261f0438835 (s390/vfio-ap: use work struct to verify queue reset)
  		msleep(AP_RESET_INTERVAL);
 -		elapsed += AP_RESET_INTERVAL;
  		status = ap_tapq(q->apqn, NULL);
  		ret = apq_status_check(q->apqn, &status);
++<<<<<<< HEAD
 +		if (ret != -EBUSY)
 +			return ret;
 +	}
 +	WARN_ONCE(iters <= 0,
 +		  "timeout verifying reset of queue %02x.%04x (%u, %u, %u)",
 +		  AP_QID_CARD(q->apqn), AP_QID_QUEUE(q->apqn),
 +		  status.queue_empty, status.irq_enabled, status.response_code);
 +	return ret;
 +}
 +
 +static int vfio_ap_mdev_reset_queue(struct vfio_ap_queue *q,
 +				    unsigned int retry)
 +{
 +	struct ap_queue_status status;
 +	int ret;
 +
 +	if (!q)
 +		return 0;
 +retry_zapq:
++=======
+ 		if (ret == -EIO)
+ 			return;
+ 		if (ret == -EBUSY) {
+ 			pr_notice_ratelimited(WAIT_MSG, elapsed,
+ 					      AP_QID_CARD(q->apqn),
+ 					      AP_QID_QUEUE(q->apqn),
+ 					      status.response_code,
+ 					      status.queue_empty,
+ 					      status.irq_enabled);
+ 		} else {
+ 			if (q->reset_status.response_code == AP_RESPONSE_RESET_IN_PROGRESS ||
+ 			    q->reset_status.response_code == AP_RESPONSE_BUSY) {
+ 				status = ap_zapq(q->apqn, 0);
+ 				memcpy(&q->reset_status, &status, sizeof(status));
+ 				continue;
+ 			}
+ 			/*
+ 			 * When an AP adapter is deconfigured, the
+ 			 * associated queues are reset, so let's set the
+ 			 * status response code to 0 so the queue may be
+ 			 * passed through (i.e., not filtered)
+ 			 */
+ 			if (status.response_code == AP_RESPONSE_DECONFIGURED)
+ 				q->reset_status.response_code = 0;
+ 			if (q->saved_isc != VFIO_AP_ISC_INVALID)
+ 				vfio_ap_free_aqic_resources(q);
+ 			break;
+ 		}
+ 	}
+ }
+ 
+ static void vfio_ap_mdev_reset_queue(struct vfio_ap_queue *q)
+ {
+ 	struct ap_queue_status status;
+ 
+ 	if (!q)
+ 		return;
++>>>>>>> 9261f0438835 (s390/vfio-ap: use work struct to verify queue reset)
  	status = ap_zapq(q->apqn, 0);
 -	memcpy(&q->reset_status, &status, sizeof(status));
 +	q->reset_rc = status.response_code;
  	switch (status.response_code) {
  	case AP_RESPONSE_NORMAL:
++<<<<<<< HEAD
 +		ret = 0;
 +		/* if the reset has not completed, wait for it to take effect */
 +		if (!status.queue_empty || status.irq_enabled)
 +			ret = apq_reset_check(q);
++=======
+ 	case AP_RESPONSE_RESET_IN_PROGRESS:
+ 	case AP_RESPONSE_BUSY:
+ 		/*
+ 		 * Let's verify whether the ZAPQ completed successfully on a work queue.
+ 		 */
+ 		queue_work(system_long_wq, &q->reset_work);
+ 		break;
+ 	case AP_RESPONSE_DECONFIGURED:
+ 		/*
+ 		 * When an AP adapter is deconfigured, the associated
+ 		 * queues are reset, so let's set the status response code to 0
+ 		 * so the queue may be passed through (i.e., not filtered).
+ 		 */
+ 		q->reset_status.response_code = 0;
+ 		vfio_ap_free_aqic_resources(q);
++>>>>>>> 9261f0438835 (s390/vfio-ap: use work struct to verify queue reset)
  		break;
 +	case AP_RESPONSE_RESET_IN_PROGRESS:
 +		if (retry--) {
 +			msleep(20);
 +			goto retry_zapq;
 +		}
 +		ret = -EBUSY;
 +		break;
 +	case AP_RESPONSE_Q_NOT_AVAIL:
 +	case AP_RESPONSE_DECONFIGURED:
 +	case AP_RESPONSE_CHECKSTOPPED:
 +		WARN_ONCE(status.irq_enabled,
 +			  "PQAP/ZAPQ for %02x.%04x failed with rc=%u while IRQ enabled",
 +			  AP_QID_CARD(q->apqn), AP_QID_QUEUE(q->apqn),
 +			  status.response_code);
 +		ret = -EBUSY;
 +		goto free_resources;
  	default:
 +		/* things are really broken, give up */
  		WARN(true,
  		     "PQAP/ZAPQ for %02x.%04x failed with invalid rc=%u\n",
  		     AP_QID_CARD(q->apqn), AP_QID_QUEUE(q->apqn),
  		     status.response_code);
- 		return -EIO;
  	}
++<<<<<<< HEAD
 +
 +free_resources:
 +	vfio_ap_free_aqic_resources(q);
 +
 +	return ret;
++=======
++>>>>>>> 9261f0438835 (s390/vfio-ap: use work struct to verify queue reset)
  }
  
  static int vfio_ap_mdev_reset_queues(struct ap_queue_table *qtable)
  {
- 	int ret, loop_cursor, rc = 0;
+ 	int ret = 0, loop_cursor;
  	struct vfio_ap_queue *q;
  
+ 	hash_for_each(qtable->queues, loop_cursor, q, mdev_qnode)
+ 		vfio_ap_mdev_reset_queue(q);
+ 
  	hash_for_each(qtable->queues, loop_cursor, q, mdev_qnode) {
++<<<<<<< HEAD
 +		ret = vfio_ap_mdev_reset_queue(q, 1);
 +		/*
 +		 * Regardless whether a queue turns out to be busy, or
 +		 * is not operational, we need to continue resetting
 +		 * the remaining queues.
 +		 */
 +		if (ret)
 +			rc = ret;
++=======
+ 		flush_work(&q->reset_work);
+ 
+ 		if (q->reset_status.response_code)
+ 			ret = -EIO;
++>>>>>>> 9261f0438835 (s390/vfio-ap: use work struct to verify queue reset)
  	}
  
- 	return rc;
+ 	return ret;
  }
  
 -static int vfio_ap_mdev_open_device(struct vfio_device *vdev)
 +static int vfio_ap_mdev_open(struct mdev_device *mdev)
  {
 -	struct ap_matrix_mdev *matrix_mdev =
 -		container_of(vdev, struct ap_matrix_mdev, vdev);
 +	struct ap_matrix_mdev *matrix_mdev = mdev_get_drvdata(mdev);
 +	unsigned long events;
 +	int ret;
  
 -	if (!vdev->kvm)
 -		return -EINVAL;
  
 -	return vfio_ap_mdev_set_kvm(matrix_mdev, vdev->kvm);
 -}
 +	if (!try_module_get(THIS_MODULE))
 +		return -ENODEV;
  
 -static void vfio_ap_mdev_close_device(struct vfio_device *vdev)
 -{
 -	struct ap_matrix_mdev *matrix_mdev =
 -		container_of(vdev, struct ap_matrix_mdev, vdev);
 +	matrix_mdev->group_notifier.notifier_call = vfio_ap_mdev_group_notifier;
 +	events = VFIO_GROUP_NOTIFY_SET_KVM;
  
 -	vfio_ap_mdev_unset_kvm(matrix_mdev);
 -}
 +	ret = vfio_register_notifier(mdev_dev(mdev), VFIO_GROUP_NOTIFY,
 +				     &events, &matrix_mdev->group_notifier);
 +	if (ret) {
 +		module_put(THIS_MODULE);
 +		return ret;
 +	}
  
 -static void vfio_ap_mdev_request(struct vfio_device *vdev, unsigned int count)
 -{
 -	struct device *dev = vdev->dev;
 -	struct ap_matrix_mdev *matrix_mdev;
 +	matrix_mdev->iommu_notifier.notifier_call = vfio_ap_mdev_iommu_notifier;
 +	events = VFIO_IOMMU_NOTIFY_DMA_UNMAP;
 +	ret = vfio_register_notifier(mdev_dev(mdev), VFIO_IOMMU_NOTIFY,
 +				     &events, &matrix_mdev->iommu_notifier);
 +	if (!ret)
 +		return ret;
  
 -	matrix_mdev = container_of(vdev, struct ap_matrix_mdev, vdev);
 +	vfio_unregister_notifier(mdev_dev(mdev), VFIO_GROUP_NOTIFY,
 +				 &matrix_mdev->group_notifier);
 +	module_put(THIS_MODULE);
 +	return ret;
 +}
  
 -	if (matrix_mdev->req_trigger) {
 -		if (!(count % 10))
 -			dev_notice_ratelimited(dev,
 -					       "Relaying device request to user (#%u)\n",
 -					       count);
 +static void vfio_ap_mdev_release(struct mdev_device *mdev)
 +{
 +	struct ap_matrix_mdev *matrix_mdev = mdev_get_drvdata(mdev);
  
 -		eventfd_signal(matrix_mdev->req_trigger, 1);
 -	} else if (count == 0) {
 -		dev_notice(dev,
 -			   "No device request registered, blocked until released by user\n");
 -	}
 +	vfio_unregister_notifier(mdev_dev(mdev), VFIO_IOMMU_NOTIFY,
 +				 &matrix_mdev->iommu_notifier);
 +	vfio_unregister_notifier(mdev_dev(mdev), VFIO_GROUP_NOTIFY,
 +				 &matrix_mdev->group_notifier);
 +	vfio_ap_mdev_unset_kvm(matrix_mdev);
 +	module_put(THIS_MODULE);
  }
  
  static int vfio_ap_mdev_get_device_info(unsigned long arg)
@@@ -1839,6 -2040,8 +1927,11 @@@ int vfio_ap_mdev_probe_queue(struct ap_
  
  	q->apqn = to_ap_queue(&apdev->device)->qid;
  	q->saved_isc = VFIO_AP_ISC_INVALID;
++<<<<<<< HEAD
++=======
+ 	memset(&q->reset_status, 0, sizeof(q->reset_status));
+ 	INIT_WORK(&q->reset_work, apq_reset_check);
++>>>>>>> 9261f0438835 (s390/vfio-ap: use work struct to verify queue reset)
  	matrix_mdev = get_update_locks_by_apqn(q->apqn);
  
  	if (matrix_mdev) {
@@@ -1887,7 -2090,8 +1980,12 @@@ void vfio_ap_mdev_remove_queue(struct a
  		}
  	}
  
++<<<<<<< HEAD
 +	vfio_ap_mdev_reset_queue(q, 1);
++=======
+ 	vfio_ap_mdev_reset_queue(q);
+ 	flush_work(&q->reset_work);
++>>>>>>> 9261f0438835 (s390/vfio-ap: use work struct to verify queue reset)
  	dev_set_drvdata(&apdev->device, NULL);
  	kfree(q);
  	release_update_locks_for_mdev(matrix_mdev);
diff --cc drivers/s390/crypto/vfio_ap_private.h
index 69446da9e20a,88aff8b81f2f..000000000000
--- a/drivers/s390/crypto/vfio_ap_private.h
+++ b/drivers/s390/crypto/vfio_ap_private.h
@@@ -134,7 -133,8 +134,12 @@@ struct ap_matrix_mdev 
   * @apqn: the APQN of the AP queue device
   * @saved_isc: the guest ISC registered with the GIB interface
   * @mdev_qnode: allows the vfio_ap_queue struct to be added to a hashtable
++<<<<<<< HEAD
 + * @reset_rc: the status response code from the last reset of the queue
++=======
+  * @reset_status: the status from the last reset of the queue
+  * @reset_work: work to wait for queue reset to complete
++>>>>>>> 9261f0438835 (s390/vfio-ap: use work struct to verify queue reset)
   */
  struct vfio_ap_queue {
  	struct ap_matrix_mdev *matrix_mdev;
@@@ -143,7 -143,8 +148,12 @@@
  #define VFIO_AP_ISC_INVALID 0xff
  	unsigned char saved_isc;
  	struct hlist_node mdev_qnode;
++<<<<<<< HEAD
 +	unsigned int reset_rc;
++=======
+ 	struct ap_queue_status reset_status;
+ 	struct work_struct reset_work;
++>>>>>>> 9261f0438835 (s390/vfio-ap: use work struct to verify queue reset)
  };
  
  int vfio_ap_mdev_register(void);
* Unmerged path drivers/s390/crypto/vfio_ap_ops.c
* Unmerged path drivers/s390/crypto/vfio_ap_private.h
