s390/uv: UV feature check utility

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-523.el8
commit-author Steffen Eiden <seiden@linux.ibm.com>
commit 59a881402cc89788652fa2c2ce7421d14f131c34
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-523.el8/59a88140.failed

Introduces a function to check the existence of an UV feature.
Refactor feature bit checks to use the new function.

	Signed-off-by: Steffen Eiden <seiden@linux.ibm.com>
	Reviewed-by: Claudio Imbrenda <imbrenda@linux.ibm.com>
	Reviewed-by: Janosch Frank <frankja@linux.ibm.com>
	Signed-off-by: Janosch Frank <frankja@linux.ibm.com>
	Reviewed-by: Michael Mueller <mimu@linux.ibm.com>
Link: https://lore.kernel.org/r/20230815151415.379760-3-seiden@linux.ibm.com
Message-Id: <20230815151415.379760-3-seiden@linux.ibm.com>
(cherry picked from commit 59a881402cc89788652fa2c2ce7421d14f131c34)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/s390/kernel/uv.c
diff --cc arch/s390/kernel/uv.c
index 06c37e1605b2,fc07bc39e698..000000000000
--- a/arch/s390/kernel/uv.c
+++ b/arch/s390/kernel/uv.c
@@@ -264,6 -232,39 +264,42 @@@ static int make_secure_pte(pte_t *ptep
  	return uvcb->rc == 0x10a ? -ENXIO : -EINVAL;
  }
  
++<<<<<<< HEAD
++=======
+ /**
+  * should_export_before_import - Determine whether an export is needed
+  * before an import-like operation
+  * @uvcb: the Ultravisor control block of the UVC to be performed
+  * @mm: the mm of the process
+  *
+  * Returns whether an export is needed before every import-like operation.
+  * This is needed for shared pages, which don't trigger a secure storage
+  * exception when accessed from a different guest.
+  *
+  * Although considered as one, the Unpin Page UVC is not an actual import,
+  * so it is not affected.
+  *
+  * No export is needed also when there is only one protected VM, because the
+  * page cannot belong to the wrong VM in that case (there is no "other VM"
+  * it can belong to).
+  *
+  * Return: true if an export is needed before every import, otherwise false.
+  */
+ static bool should_export_before_import(struct uv_cb_header *uvcb, struct mm_struct *mm)
+ {
+ 	/*
+ 	 * The misc feature indicates, among other things, that importing a
+ 	 * shared page from a different protected VM will automatically also
+ 	 * transfer its ownership.
+ 	 */
+ 	if (uv_has_feature(BIT_UV_FEAT_MISC))
+ 		return false;
+ 	if (uvcb->cmd == UVC_CMD_UNPIN_PAGE_SHARED)
+ 		return false;
+ 	return atomic_read(&mm->context.protected_count) > 1;
+ }
+ 
++>>>>>>> 59a881402cc8 (s390/uv: UV feature check utility)
  /*
   * Requests the Ultravisor to make a page accessible to a guest.
   * If it's brought in the first time, it will be cleared. If
diff --git a/arch/s390/include/asm/uv.h b/arch/s390/include/asm/uv.h
index 39a4f27fd83d..deb1e5eaaafa 100644
--- a/arch/s390/include/asm/uv.h
+++ b/arch/s390/include/asm/uv.h
@@ -387,6 +387,13 @@ struct uv_info {
 
 extern struct uv_info uv_info;
 
+static inline bool uv_has_feature(u8 feature_bit)
+{
+	if (feature_bit >= sizeof(uv_info.uv_feature_indications) * 8)
+		return false;
+	return test_bit_inv(feature_bit, &uv_info.uv_feature_indications);
+}
+
 #ifdef CONFIG_PROTECTED_VIRTUALIZATION_GUEST
 extern int prot_virt_guest;
 
* Unmerged path arch/s390/kernel/uv.c
diff --git a/arch/s390/kvm/kvm-s390.c b/arch/s390/kvm/kvm-s390.c
index 9b1966faa220..67821bb85270 100644
--- a/arch/s390/kvm/kvm-s390.c
+++ b/arch/s390/kvm/kvm-s390.c
@@ -2377,7 +2377,7 @@ static int kvm_s390_cpus_to_pv(struct kvm *kvm, u16 *rc, u16 *rrc)
 	struct kvm_vcpu *vcpu;
 
 	/* Disable the GISA if the ultravisor does not support AIV. */
-	if (!test_bit_inv(BIT_UV_FEAT_AIV, &uv_info.uv_feature_indications))
+	if (!uv_has_feature(BIT_UV_FEAT_AIV))
 		kvm_s390_gisa_disable(kvm);
 
 	kvm_for_each_vcpu(i, vcpu, kvm) {
diff --git a/arch/s390/mm/fault.c b/arch/s390/mm/fault.c
index f4c580686dab..cf9923d1cd2f 100644
--- a/arch/s390/mm/fault.c
+++ b/arch/s390/mm/fault.c
@@ -859,7 +859,7 @@ void do_secure_storage_access(struct pt_regs *regs)
 	 * reliable without the misc UV feature so we need to check
 	 * for that as well.
 	 */
-	if (test_bit_inv(BIT_UV_FEAT_MISC, &uv_info.uv_feature_indications) &&
+	if (uv_has_feature(BIT_UV_FEAT_MISC) &&
 	    !test_bit_inv(61, &regs->int_parm_long)) {
 		/*
 		 * When this happens, userspace did something that it
