can: af_can: fix NULL pointer dereference in can_rcv_filter

jira LE-1907
cve CVE-2023-2166
Rebuild_History Non-Buildable kernel-4.18.0-523.el8
commit-author Oliver Hartkopp <socketcan@hartkopp.net>
commit 0acc442309a0a1b01bcdaa135e56e6398a49439c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-523.el8/0acc4423.failed

Analogue to commit 8aa59e355949 ("can: af_can: fix NULL pointer
dereference in can_rx_register()") we need to check for a missing
initialization of ml_priv in the receive path of CAN frames.

Since commit 4e096a18867a ("net: introduce CAN specific pointer in the
struct net_device") the check for dev->type to be ARPHRD_CAN is not
sufficient anymore since bonding or tun netdevices claim to be CAN
devices but do not initialize ml_priv accordingly.

Fixes: 4e096a18867a ("net: introduce CAN specific pointer in the struct net_device")
	Reported-by: syzbot+2d7f58292cb5b29eb5ad@syzkaller.appspotmail.com
	Reported-by: Wei Chen <harperchen1110@gmail.com>
	Signed-off-by: Oliver Hartkopp <socketcan@hartkopp.net>
Link: https://lore.kernel.org/all/20221206201259.3028-1-socketcan@hartkopp.net
	Cc: stable@vger.kernel.org
	Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>
(cherry picked from commit 0acc442309a0a1b01bcdaa135e56e6398a49439c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/can/af_can.c
diff --cc net/can/af_can.c
index 5338bdc1b8f1,c69168f11e44..000000000000
--- a/net/can/af_can.c
+++ b/net/can/af_can.c
@@@ -719,19 -677,12 +719,23 @@@ static void can_receive(struct sk_buff 
  static int can_rcv(struct sk_buff *skb, struct net_device *dev,
  		   struct packet_type *pt, struct net_device *orig_dev)
  {
++<<<<<<< HEAD
 +	struct canfd_frame *cfd = (struct canfd_frame *)skb->data;
 +
 +	if (unlikely(dev->type != ARPHRD_CAN || skb->len != CAN_MTU)) {
++=======
+ 	if (unlikely(dev->type != ARPHRD_CAN || !can_get_ml_priv(dev) || !can_is_can_skb(skb))) {
++>>>>>>> 0acc442309a0 (can: af_can: fix NULL pointer dereference in can_rcv_filter)
  		pr_warn_once("PF_CAN: dropped non conform CAN skbuff: dev type %d, len %d\n",
  			     dev->type, skb->len);
 +		goto free_skb;
 +	}
  
 -		kfree_skb(skb);
 -		return NET_RX_DROP;
 +	/* This check is made separately since cfd->len would be uninitialized if skb->len = 0. */
 +	if (unlikely(cfd->len > CAN_MAX_DLEN)) {
 +		pr_warn_once("PF_CAN: dropped non conform CAN skbuff: dev type %d, len %d, datalen %d\n",
 +			     dev->type, skb->len, cfd->len);
 +		goto free_skb;
  	}
  
  	can_receive(skb, dev);
@@@ -743,34 -690,36 +747,57 @@@ free_skb
  }
  
  static int canfd_rcv(struct sk_buff *skb, struct net_device *dev,
 -		     struct packet_type *pt, struct net_device *orig_dev)
 +		   struct packet_type *pt, struct net_device *orig_dev)
  {
++<<<<<<< HEAD
 +	struct canfd_frame *cfd = (struct canfd_frame *)skb->data;
 +
 +	if (unlikely(dev->type != ARPHRD_CAN || skb->len != CANFD_MTU)) {
++=======
+ 	if (unlikely(dev->type != ARPHRD_CAN || !can_get_ml_priv(dev) || !can_is_canfd_skb(skb))) {
++>>>>>>> 0acc442309a0 (can: af_can: fix NULL pointer dereference in can_rcv_filter)
  		pr_warn_once("PF_CAN: dropped non conform CAN FD skbuff: dev type %d, len %d\n",
  			     dev->type, skb->len);
 +		goto free_skb;
 +	}
  
 -		kfree_skb(skb);
 -		return NET_RX_DROP;
 +	/* This check is made separately since cfd->len would be uninitialized if skb->len = 0. */
 +	if (unlikely(cfd->len > CANFD_MAX_DLEN)) {
 +		pr_warn_once("PF_CAN: dropped non conform CAN FD skbuff: dev type %d, len %d, datalen %d\n",
 +			     dev->type, skb->len, cfd->len);
 +		goto free_skb;
  	}
  
  	can_receive(skb, dev);
  	return NET_RX_SUCCESS;
 +
 +free_skb:
 +	kfree_skb(skb);
 +	return NET_RX_DROP;
  }
  
++<<<<<<< HEAD
 +/*
 + * af_can protocol functions
 + */
++=======
+ static int canxl_rcv(struct sk_buff *skb, struct net_device *dev,
+ 		     struct packet_type *pt, struct net_device *orig_dev)
+ {
+ 	if (unlikely(dev->type != ARPHRD_CAN || !can_get_ml_priv(dev) || !can_is_canxl_skb(skb))) {
+ 		pr_warn_once("PF_CAN: dropped non conform CAN XL skbuff: dev type %d, len %d\n",
+ 			     dev->type, skb->len);
+ 
+ 		kfree_skb(skb);
+ 		return NET_RX_DROP;
+ 	}
+ 
+ 	can_receive(skb, dev);
+ 	return NET_RX_SUCCESS;
+ }
+ 
+ /* af_can protocol functions */
++>>>>>>> 0acc442309a0 (can: af_can: fix NULL pointer dereference in can_rcv_filter)
  
  /**
   * can_proto_register - register CAN transport protocol
* Unmerged path net/can/af_can.c
