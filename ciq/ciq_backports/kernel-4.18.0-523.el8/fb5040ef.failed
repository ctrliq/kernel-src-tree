KVM: s390: export kvm_s390_pv*_is_protected functions

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-523.el8
commit-author Tony Krowiak <akrowiak@linux.ibm.com>
commit fb5040ef7f707525d0681cf6bfe424ccd1aadab7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-523.el8/fb5040ef.failed

Export the kvm_s390_pv_is_protected and kvm_s390_pv_cpu_is_protected
functions so that they can be called from other modules that carry a
GPL-compatible license.

	Signed-off-by: Janosch Frank <frankja@linux.ibm.com>
	Signed-off-by: Tony Krowiak <akrowiak@linux.ibm.com>
	Tested-by: Viktor Mihajlovski <mihajlov@linux.ibm.com>
Link: https://lore.kernel.org/r/20230815184333.6554-12-akrowiak@linux.ibm.com
	Signed-off-by: Heiko Carstens <hca@linux.ibm.com>
(cherry picked from commit fb5040ef7f707525d0681cf6bfe424ccd1aadab7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/s390/kvm/pv.c
diff --cc arch/s390/kvm/pv.c
index c1c4e6259d93,856140e9942e..000000000000
--- a/arch/s390/kvm/pv.c
+++ b/arch/s390/kvm/pv.c
@@@ -14,8 -13,56 +14,56 @@@
  #include <asm/gmap.h>
  #include <asm/uv.h>
  #include <asm/mman.h>
 -#include <linux/pagewalk.h>
 -#include <linux/sched/mm.h>
 -#include <linux/mmu_notifier.h>
  #include "kvm-s390.h"
  
++<<<<<<< HEAD
++=======
+ bool kvm_s390_pv_is_protected(struct kvm *kvm)
+ {
+ 	lockdep_assert_held(&kvm->lock);
+ 	return !!kvm_s390_pv_get_handle(kvm);
+ }
+ EXPORT_SYMBOL_GPL(kvm_s390_pv_is_protected);
+ 
+ bool kvm_s390_pv_cpu_is_protected(struct kvm_vcpu *vcpu)
+ {
+ 	lockdep_assert_held(&vcpu->mutex);
+ 	return !!kvm_s390_pv_cpu_get_handle(vcpu);
+ }
+ EXPORT_SYMBOL_GPL(kvm_s390_pv_cpu_is_protected);
+ 
+ /**
+  * struct pv_vm_to_be_destroyed - Represents a protected VM that needs to
+  * be destroyed
+  *
+  * @list: list head for the list of leftover VMs
+  * @old_gmap_table: the gmap table of the leftover protected VM
+  * @handle: the handle of the leftover protected VM
+  * @stor_var: pointer to the variable storage of the leftover protected VM
+  * @stor_base: address of the base storage of the leftover protected VM
+  *
+  * Represents a protected VM that is still registered with the Ultravisor,
+  * but which does not correspond any longer to an active KVM VM. It should
+  * be destroyed at some point later, either asynchronously or when the
+  * process terminates.
+  */
+ struct pv_vm_to_be_destroyed {
+ 	struct list_head list;
+ 	unsigned long old_gmap_table;
+ 	u64 handle;
+ 	void *stor_var;
+ 	unsigned long stor_base;
+ };
+ 
+ static void kvm_s390_clear_pv_state(struct kvm *kvm)
+ {
+ 	kvm->arch.pv.handle = 0;
+ 	kvm->arch.pv.guest_len = 0;
+ 	kvm->arch.pv.stor_base = 0;
+ 	kvm->arch.pv.stor_var = NULL;
+ }
+ 
++>>>>>>> fb5040ef7f70 (KVM: s390: export kvm_s390_pv*_is_protected functions)
  int kvm_s390_pv_destroy_cpu(struct kvm_vcpu *vcpu, u16 *rc, u16 *rrc)
  {
  	int cc;
diff --git a/arch/s390/include/asm/kvm_host.h b/arch/s390/include/asm/kvm_host.h
index 8652cab44eb5..f3406de4aa03 100644
--- a/arch/s390/include/asm/kvm_host.h
+++ b/arch/s390/include/asm/kvm_host.h
@@ -1018,6 +1018,9 @@ void kvm_arch_crypto_set_masks(struct kvm *kvm, unsigned long *apm,
 extern int sie64a(struct kvm_s390_sie_block *, u64 *);
 extern char sie_exit;
 
+bool kvm_s390_pv_is_protected(struct kvm *kvm);
+bool kvm_s390_pv_cpu_is_protected(struct kvm_vcpu *vcpu);
+
 extern int kvm_s390_gisc_register(struct kvm *kvm, u32 gisc);
 extern int kvm_s390_gisc_unregister(struct kvm *kvm, u32 gisc);
 
diff --git a/arch/s390/kvm/kvm-s390.h b/arch/s390/kvm/kvm-s390.h
index 00b658353cad..14cbeaaeaaef 100644
--- a/arch/s390/kvm/kvm-s390.h
+++ b/arch/s390/kvm/kvm-s390.h
@@ -267,18 +267,6 @@ static inline u64 kvm_s390_pv_cpu_get_handle(struct kvm_vcpu *vcpu)
 	return vcpu->arch.pv.handle;
 }
 
-static inline bool kvm_s390_pv_is_protected(struct kvm *kvm)
-{
-	lockdep_assert_held(&kvm->lock);
-	return !!kvm_s390_pv_get_handle(kvm);
-}
-
-static inline bool kvm_s390_pv_cpu_is_protected(struct kvm_vcpu *vcpu)
-{
-	lockdep_assert_held(&vcpu->mutex);
-	return !!kvm_s390_pv_cpu_get_handle(vcpu);
-}
-
 /* implemented in interrupt.c */
 int kvm_s390_handle_wait(struct kvm_vcpu *vcpu);
 void kvm_s390_vcpu_wakeup(struct kvm_vcpu *vcpu);
* Unmerged path arch/s390/kvm/pv.c
