s390/vfio-ap: clean up irq resources if possible

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-523.el8
commit-author Tony Krowiak <akrowiak@linux.ibm.com>
commit 7aa7b2a80cb70d528785f06a54d6c8148826006d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-523.el8/7aa7b2a8.failed

The architecture does not specify whether interrupts are disabled as part
of the asynchronous reset or upon return from the PQAP/ZAPQ instruction.
If, however, PQAP/ZAPQ completes with APQSW response code 0 and the
interrupt bit in the status word is also 0, we know the interrupts are
disabled and we can go ahead and clean up the corresponding resources;
otherwise, we must wait until the asynchronous reset has completed.

	Signed-off-by: Tony Krowiak <akrowiak@linux.ibm.com>
	Suggested-by: Halil Pasic <pasic@linux.ibm.com>
	Reviewed-by: Jason J. Herne <jjherne@linux.ibm.com>
	Acked-by: Halil Pasic <pasic@linux.ibm.com>
	Acked-by: Janosch Frank <frankja@linux.ibm.com>
	Tested-by: Viktor Mihajlovski <mihajlov@linux.ibm.com>
Link: https://lore.kernel.org/r/20230815184333.6554-3-akrowiak@linux.ibm.com
	Signed-off-by: Heiko Carstens <hca@linux.ibm.com>
(cherry picked from commit 7aa7b2a80cb70d528785f06a54d6c8148826006d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/s390/crypto/vfio_ap_ops.c
diff --cc drivers/s390/crypto/vfio_ap_ops.c
index ef0d06898296,be92ba45226d..000000000000
--- a/drivers/s390/crypto/vfio_ap_ops.c
+++ b/drivers/s390/crypto/vfio_ap_ops.c
@@@ -1594,28 -1654,34 +1594,52 @@@ retry_zapq
  	switch (status.response_code) {
  	case AP_RESPONSE_NORMAL:
  		ret = 0;
- 		/* if the reset has not completed, wait for it to take effect */
- 		if (!status.queue_empty || status.irq_enabled)
+ 		if (!status.irq_enabled)
+ 			vfio_ap_free_aqic_resources(q);
+ 		if (!status.queue_empty || status.irq_enabled) {
  			ret = apq_reset_check(q);
+ 			if (status.irq_enabled && ret == 0)
+ 				vfio_ap_free_aqic_resources(q);
+ 		}
  		break;
  	case AP_RESPONSE_RESET_IN_PROGRESS:
++<<<<<<< HEAD
 +		if (retry--) {
 +			msleep(20);
 +			goto retry_zapq;
 +		}
 +		ret = -EBUSY;
++=======
+ 		/*
+ 		 * There is a reset issued by another process in progress. Let's wait
+ 		 * for that to complete. Since we have no idea whether it was a RAPQ or
+ 		 * ZAPQ, then if it completes successfully, let's issue the ZAPQ.
+ 		 */
+ 		ret = apq_reset_check(q);
+ 		if (ret)
+ 			break;
+ 		goto retry_zapq;
+ 	case AP_RESPONSE_DECONFIGURED:
+ 		/*
+ 		 * When an AP adapter is deconfigured, the associated
+ 		 * queues are reset, so let's return a value indicating the reset
+ 		 * completed successfully.
+ 		 */
+ 		ret = 0;
+ 		vfio_ap_free_aqic_resources(q);
++>>>>>>> 7aa7b2a80cb7 (s390/vfio-ap: clean up irq resources if possible)
  		break;
 +	case AP_RESPONSE_Q_NOT_AVAIL:
 +	case AP_RESPONSE_DECONFIGURED:
 +	case AP_RESPONSE_CHECKSTOPPED:
 +		WARN_ONCE(status.irq_enabled,
 +			  "PQAP/ZAPQ for %02x.%04x failed with rc=%u while IRQ enabled",
 +			  AP_QID_CARD(q->apqn), AP_QID_QUEUE(q->apqn),
 +			  status.response_code);
 +		ret = -EBUSY;
 +		goto free_resources;
  	default:
 +		/* things are really broken, give up */
  		WARN(true,
  		     "PQAP/ZAPQ for %02x.%04x failed with invalid rc=%u\n",
  		     AP_QID_CARD(q->apqn), AP_QID_QUEUE(q->apqn),
@@@ -1623,9 -1689,6 +1647,12 @@@
  		return -EIO;
  	}
  
++<<<<<<< HEAD
 +free_resources:
 +	vfio_ap_free_aqic_resources(q);
 +
++=======
++>>>>>>> 7aa7b2a80cb7 (s390/vfio-ap: clean up irq resources if possible)
  	return ret;
  }
  
* Unmerged path drivers/s390/crypto/vfio_ap_ops.c
