s390/vfio-ap: check for TAPQ response codes 0x35 and 0x36

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-523.el8
commit-author Tony Krowiak <akrowiak@linux.ibm.com>
commit 7847a19b5b6265f11e71c8499a3b608edac7f398
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-523.el8/7847a19b.failed

Check for response codes 0x35 and 0x36 which are asynchronous return codes
indicating a failure of the guest to associate a secret with a queue. Since
there can be no interaction with this queue from the guest (i.e., the vcpus
are out of SIE for hot unplug, the guest is being shut down or an emulated
subsystem reset of the guest is taking place), let's go ahead and re-issue
the ZAPQ to reset and zeroize the queue.

	Signed-off-by: Tony Krowiak <akrowiak@linux.ibm.com>
	Reviewed-by: Jason J. Herne <jjherne@linux.ibm.com>
	Reviewed-by: Halil Pasic <pasic@linux.ibm.com>
	Tested-by: Viktor Mihajlovski <mihajlov@linux.ibm.com>
Link: https://lore.kernel.org/r/20230815184333.6554-10-akrowiak@linux.ibm.com
	Signed-off-by: Heiko Carstens <hca@linux.ibm.com>
(cherry picked from commit 7847a19b5b6265f11e71c8499a3b608edac7f398)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/s390/crypto/vfio_ap_ops.c
diff --cc drivers/s390/crypto/vfio_ap_ops.c
index ef0d06898296,8bda52c46df0..000000000000
--- a/drivers/s390/crypto/vfio_ap_ops.c
+++ b/drivers/s390/crypto/vfio_ap_ops.c
@@@ -1550,7 -1610,18 +1550,17 @@@ static int apq_status_check(int apqn, s
  	case AP_RESPONSE_DECONFIGURED:
  		return 0;
  	case AP_RESPONSE_RESET_IN_PROGRESS:
 -	case AP_RESPONSE_BUSY:
  		return -EBUSY;
+ 	case AP_RESPONSE_ASSOC_SECRET_NOT_UNIQUE:
+ 	case AP_RESPONSE_ASSOC_FAILED:
+ 		/*
+ 		 * These asynchronous response codes indicate a PQAP(AAPQ)
+ 		 * instruction to associate a secret with the guest failed. All
+ 		 * subsequent AP instructions will end with the asynchronous
+ 		 * response code until the AP queue is reset; so, let's return
+ 		 * a value indicating a reset needs to be performed again.
+ 		 */
+ 		return -EAGAIN;
  	default:
  		WARN(true,
  		     "failed to verify reset of queue %02x.%04x: TAPQ rc=%u\n",
@@@ -1560,62 -1631,82 +1570,95 @@@
  	}
  }
  
 -#define WAIT_MSG "Waited %dms for reset of queue %02x.%04x (%u, %u, %u)"
 -
 -static void apq_reset_check(struct work_struct *reset_work)
 +static int apq_reset_check(struct vfio_ap_queue *q)
  {
 -	int ret = -EBUSY, elapsed = 0;
 +	int ret;
 +	int iters = MAX_RESET_CHECK_WAIT / AP_RESET_INTERVAL;
  	struct ap_queue_status status;
 -	struct vfio_ap_queue *q;
  
 -	q = container_of(reset_work, struct vfio_ap_queue, reset_work);
 -	memcpy(&status, &q->reset_status, sizeof(status));
 -	while (true) {
 +	for (; iters > 0; iters--) {
  		msleep(AP_RESET_INTERVAL);
 -		elapsed += AP_RESET_INTERVAL;
  		status = ap_tapq(q->apqn, NULL);
  		ret = apq_status_check(q->apqn, &status);
++<<<<<<< HEAD
 +		if (ret != -EBUSY)
 +			return ret;
++=======
+ 		if (ret == -EIO)
+ 			return;
+ 		if (ret == -EBUSY) {
+ 			pr_notice_ratelimited(WAIT_MSG, elapsed,
+ 					      AP_QID_CARD(q->apqn),
+ 					      AP_QID_QUEUE(q->apqn),
+ 					      status.response_code,
+ 					      status.queue_empty,
+ 					      status.irq_enabled);
+ 		} else {
+ 			if (q->reset_status.response_code == AP_RESPONSE_RESET_IN_PROGRESS ||
+ 			    q->reset_status.response_code == AP_RESPONSE_BUSY ||
+ 			    q->reset_status.response_code == AP_RESPONSE_STATE_CHANGE_IN_PROGRESS ||
+ 			    ret == -EAGAIN) {
+ 				status = ap_zapq(q->apqn, 0);
+ 				memcpy(&q->reset_status, &status, sizeof(status));
+ 				continue;
+ 			}
+ 			/*
+ 			 * When an AP adapter is deconfigured, the
+ 			 * associated queues are reset, so let's set the
+ 			 * status response code to 0 so the queue may be
+ 			 * passed through (i.e., not filtered)
+ 			 */
+ 			if (status.response_code == AP_RESPONSE_DECONFIGURED)
+ 				q->reset_status.response_code = 0;
+ 			if (q->saved_isc != VFIO_AP_ISC_INVALID)
+ 				vfio_ap_free_aqic_resources(q);
+ 			break;
+ 		}
++>>>>>>> 7847a19b5b62 (s390/vfio-ap: check for TAPQ response codes 0x35 and 0x36)
  	}
 +	WARN_ONCE(iters <= 0,
 +		  "timeout verifying reset of queue %02x.%04x (%u, %u, %u)",
 +		  AP_QID_CARD(q->apqn), AP_QID_QUEUE(q->apqn),
 +		  status.queue_empty, status.irq_enabled, status.response_code);
 +	return ret;
  }
  
 -static void vfio_ap_mdev_reset_queue(struct vfio_ap_queue *q)
 +static int vfio_ap_mdev_reset_queue(struct vfio_ap_queue *q,
 +				    unsigned int retry)
  {
  	struct ap_queue_status status;
 +	int ret;
  
  	if (!q)
 -		return;
 +		return 0;
 +retry_zapq:
  	status = ap_zapq(q->apqn, 0);
 -	memcpy(&q->reset_status, &status, sizeof(status));
 +	q->reset_rc = status.response_code;
  	switch (status.response_code) {
  	case AP_RESPONSE_NORMAL:
 +		ret = 0;
 +		/* if the reset has not completed, wait for it to take effect */
 +		if (!status.queue_empty || status.irq_enabled)
 +			ret = apq_reset_check(q);
 +		break;
  	case AP_RESPONSE_RESET_IN_PROGRESS:
 -	case AP_RESPONSE_BUSY:
 -	case AP_RESPONSE_STATE_CHANGE_IN_PROGRESS:
 -		/*
 -		 * Let's verify whether the ZAPQ completed successfully on a work queue.
 -		 */
 -		queue_work(system_long_wq, &q->reset_work);
 +		if (retry--) {
 +			msleep(20);
 +			goto retry_zapq;
 +		}
 +		ret = -EBUSY;
  		break;
 +	case AP_RESPONSE_Q_NOT_AVAIL:
  	case AP_RESPONSE_DECONFIGURED:
 -		/*
 -		 * When an AP adapter is deconfigured, the associated
 -		 * queues are reset, so let's set the status response code to 0
 -		 * so the queue may be passed through (i.e., not filtered).
 -		 */
 -		q->reset_status.response_code = 0;
 -		vfio_ap_free_aqic_resources(q);
 -		break;
 +	case AP_RESPONSE_CHECKSTOPPED:
 +		WARN_ONCE(status.irq_enabled,
 +			  "PQAP/ZAPQ for %02x.%04x failed with rc=%u while IRQ enabled",
 +			  AP_QID_CARD(q->apqn), AP_QID_QUEUE(q->apqn),
 +			  status.response_code);
 +		ret = -EBUSY;
 +		goto free_resources;
  	default:
 +		/* things are really broken, give up */
  		WARN(true,
  		     "PQAP/ZAPQ for %02x.%04x failed with invalid rc=%u\n",
  		     AP_QID_CARD(q->apqn), AP_QID_QUEUE(q->apqn),
* Unmerged path drivers/s390/crypto/vfio_ap_ops.c
