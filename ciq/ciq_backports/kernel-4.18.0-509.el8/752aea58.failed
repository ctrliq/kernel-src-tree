Bluetooth: mt7921s: fix bus hang with wrong privilege

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-509.el8
commit-author Mark Chen <mark-yw.chen@mediatek.com>
commit 752aea58489fd42f5c54dc50cb098d19e486ae61
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-509.el8/752aea58.failed

According to chip hw flow, mt7921s need to re-acquire privilege
again before normal running. Otherwise, the bus may be stuck in
an abnormal status.

Fixes: c603bf1f94d0 ("Bluetooth: btmtksdio: add MT7921s Bluetooth support")
Co-developed-by: Sean Wang <sean.wang@mediatek.com>
	Signed-off-by: Sean Wang <sean.wang@mediatek.com>
	Signed-off-by: Mark Chen <mark-yw.chen@mediatek.com>
	Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
(cherry picked from commit 752aea58489fd42f5c54dc50cb098d19e486ae61)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/bluetooth/btmtksdio.c
diff --cc drivers/bluetooth/btmtksdio.c
index 9d69b7207cf2,0951bb10d117..000000000000
--- a/drivers/bluetooth/btmtksdio.c
+++ b/drivers/bluetooth/btmtksdio.c
@@@ -892,6 -805,187 +892,190 @@@ ignore_func_on
  	}
  	kfree_skb(skb);
  
++<<<<<<< HEAD
++=======
+ 	return 0;
+ }
+ 
+ static int mt79xx_setup(struct hci_dev *hdev, const char *fwname)
+ {
+ 	struct btmtk_hci_wmt_params wmt_params;
+ 	u8 param = 0x1;
+ 	int err;
+ 
+ 	err = btmtk_setup_firmware_79xx(hdev, fwname, mtk_hci_wmt_sync);
+ 	if (err < 0) {
+ 		bt_dev_err(hdev, "Failed to setup 79xx firmware (%d)", err);
+ 		return err;
+ 	}
+ 
+ 	/* Enable Bluetooth protocol */
+ 	wmt_params.op = BTMTK_WMT_FUNC_CTRL;
+ 	wmt_params.flag = 0;
+ 	wmt_params.dlen = sizeof(param);
+ 	wmt_params.data = &param;
+ 	wmt_params.status = NULL;
+ 
+ 	err = mtk_hci_wmt_sync(hdev, &wmt_params);
+ 	if (err < 0) {
+ 		bt_dev_err(hdev, "Failed to send wmt func ctrl (%d)", err);
+ 		return err;
+ 	}
+ 
+ 	hci_set_msft_opcode(hdev, 0xFD30);
+ 	hci_set_aosp_capable(hdev);
+ 
+ 	return err;
+ }
+ 
+ static int btmtksdio_mtk_reg_read(struct hci_dev *hdev, u32 reg, u32 *val)
+ {
+ 	struct btmtk_hci_wmt_params wmt_params;
+ 	struct reg_read_cmd reg_read = {
+ 		.type = 1,
+ 		.num = 1,
+ 	};
+ 	u32 status;
+ 	int err;
+ 
+ 	reg_read.addr = cpu_to_le32(reg);
+ 	wmt_params.op = BTMTK_WMT_REGISTER;
+ 	wmt_params.flag = BTMTK_WMT_REG_READ;
+ 	wmt_params.dlen = sizeof(reg_read);
+ 	wmt_params.data = &reg_read;
+ 	wmt_params.status = &status;
+ 
+ 	err = mtk_hci_wmt_sync(hdev, &wmt_params);
+ 	if (err < 0) {
+ 		bt_dev_err(hdev, "Failed to read reg (%d)", err);
+ 		return err;
+ 	}
+ 
+ 	*val = status;
+ 
+ 	return err;
+ }
+ 
+ static int btmtksdio_mtk_reg_write(struct hci_dev *hdev, u32 reg, u32 val, u32 mask)
+ {
+ 	struct btmtk_hci_wmt_params wmt_params;
+ 	const struct reg_write_cmd reg_write = {
+ 		.type = 1,
+ 		.num = 1,
+ 		.addr = cpu_to_le32(reg),
+ 		.data = cpu_to_le32(val),
+ 		.mask = cpu_to_le32(mask),
+ 	};
+ 	int err, status;
+ 
+ 	wmt_params.op = BTMTK_WMT_REGISTER;
+ 	wmt_params.flag = BTMTK_WMT_REG_WRITE;
+ 	wmt_params.dlen = sizeof(reg_write);
+ 	wmt_params.data = &reg_write;
+ 	wmt_params.status = &status;
+ 
+ 	err = mtk_hci_wmt_sync(hdev, &wmt_params);
+ 	if (err < 0)
+ 		bt_dev_err(hdev, "Failed to write reg (%d)", err);
+ 
+ 	return err;
+ }
+ 
+ static int btmtksdio_sco_setting(struct hci_dev *hdev)
+ {
+ 	const struct btmtk_sco sco_setting = {
+ 		.clock_config = 0x49,
+ 		.channel_format_config = 0x80,
+ 	};
+ 	struct sk_buff *skb;
+ 	u32 val;
+ 	int err;
+ 
+ 	/* Enable SCO over I2S/PCM for MediaTek chipset */
+ 	skb =  __hci_cmd_sync(hdev, 0xfc72, sizeof(sco_setting),
+ 			      &sco_setting, HCI_CMD_TIMEOUT);
+ 	if (IS_ERR(skb))
+ 		return PTR_ERR(skb);
+ 
+ 	kfree_skb(skb);
+ 
+ 	err = btmtksdio_mtk_reg_read(hdev, MT7921_PINMUX_0, &val);
+ 	if (err < 0)
+ 		return err;
+ 
+ 	val |= 0x11000000;
+ 	err = btmtksdio_mtk_reg_write(hdev, MT7921_PINMUX_0, val, ~0);
+ 	if (err < 0)
+ 		return err;
+ 
+ 	err = btmtksdio_mtk_reg_read(hdev, MT7921_PINMUX_1, &val);
+ 	if (err < 0)
+ 		return err;
+ 
+ 	val |= 0x00000101;
+ 	return btmtksdio_mtk_reg_write(hdev, MT7921_PINMUX_1, val, ~0);
+ }
+ 
+ static int btmtksdio_setup(struct hci_dev *hdev)
+ {
+ 	struct btmtksdio_dev *bdev = hci_get_drvdata(hdev);
+ 	ktime_t calltime, delta, rettime;
+ 	unsigned long long duration;
+ 	char fwname[64];
+ 	int err, dev_id;
+ 	u32 fw_version = 0;
+ 
+ 	calltime = ktime_get();
+ 	set_bit(BTMTKSDIO_HW_TX_READY, &bdev->tx_state);
+ 
+ 	switch (bdev->data->chipid) {
+ 	case 0x7921:
+ 		err = btmtksdio_mtk_reg_read(hdev, 0x70010200, &dev_id);
+ 		if (err < 0) {
+ 			bt_dev_err(hdev, "Failed to get device id (%d)", err);
+ 			return err;
+ 		}
+ 
+ 		err = btmtksdio_mtk_reg_read(hdev, 0x80021004, &fw_version);
+ 		if (err < 0) {
+ 			bt_dev_err(hdev, "Failed to get fw version (%d)", err);
+ 			return err;
+ 		}
+ 
+ 		snprintf(fwname, sizeof(fwname),
+ 			 "mediatek/BT_RAM_CODE_MT%04x_1_%x_hdr.bin",
+ 			 dev_id & 0xffff, (fw_version & 0xff) + 1);
+ 		err = mt79xx_setup(hdev, fwname);
+ 		if (err < 0)
+ 			return err;
+ 
+ 		err = btmtksdio_fw_pmctrl(bdev);
+ 		if (err < 0)
+ 			return err;
+ 
+ 		err = btmtksdio_drv_pmctrl(bdev);
+ 		if (err < 0)
+ 			return err;
+ 
+ 		/* Enable SCO over I2S/PCM */
+ 		err = btmtksdio_sco_setting(hdev);
+ 		if (err < 0) {
+ 			bt_dev_err(hdev, "Failed to enable SCO setting (%d)", err);
+ 			return err;
+ 		}
+ 
+ 		break;
+ 	case 0x7663:
+ 	case 0x7668:
+ 		err = mt76xx_setup(hdev, bdev->data->fwname);
+ 		if (err < 0)
+ 			return err;
+ 		break;
+ 	default:
+ 		return -ENODEV;
+ 	}
+ 
++>>>>>>> 752aea58489f (Bluetooth: mt7921s: fix bus hang with wrong privilege)
  	rettime = ktime_get();
  	delta = ktime_sub(rettime, calltime);
  	duration = (unsigned long long)ktime_to_ns(delta) >> 10;
* Unmerged path drivers/bluetooth/btmtksdio.c
