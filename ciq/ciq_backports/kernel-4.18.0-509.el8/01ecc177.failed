Bluetooth: mt7921s: fix btmtksdio_[drv|fw]_pmctrl()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-509.el8
commit-author Mark Chen <mark-yw.chen@mediatek.com>
commit 01ecc177b7d7ba055b79645e60e89385736ef2fc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-509.el8/01ecc177.failed

According to the firmware behavior (even the oldest one in linux-firmware)

If the firmware is downloaded, MT7921S must rely on the additional mailbox
mechanism that resides in firmware to check if the device is the right
state for btmtksdio_mcu_[drv|fw]_pmctrl(). Otherwise, we still apply the
old way for that.

That is a necessary patch before we enable runtime pm for mt7921s as
default.

Fixes: c603bf1f94d0 ("Bluetooth: btmtksdio: add MT7921s Bluetooth support")
Co-developed-by: Sean Wang <sean.wang@mediatek.com>
	Signed-off-by: Sean Wang <sean.wang@mediatek.com>
	Signed-off-by: Mark Chen <mark-yw.chen@mediatek.com>
	Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
(cherry picked from commit 01ecc177b7d7ba055b79645e60e89385736ef2fc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/bluetooth/btmtksdio.c
diff --cc drivers/bluetooth/btmtksdio.c
index 9d69b7207cf2,b0aae4143037..000000000000
--- a/drivers/bluetooth/btmtksdio.c
+++ b/drivers/bluetooth/btmtksdio.c
@@@ -40,14 -37,26 +40,35 @@@ static bool enable_autosuspend
  
  struct btmtksdio_data {
  	const char *fwname;
++<<<<<<< HEAD
++=======
+ 	u16 chipid;
+ 	bool lp_mbox_supported;
++>>>>>>> 01ecc177b7d7 (Bluetooth: mt7921s: fix btmtksdio_[drv|fw]_pmctrl())
  };
  
  static const struct btmtksdio_data mt7663_data = {
  	.fwname = FIRMWARE_MT7663,
++<<<<<<< HEAD
++=======
+ 	.chipid = 0x7663,
+ 	.lp_mbox_supported = false,
++>>>>>>> 01ecc177b7d7 (Bluetooth: mt7921s: fix btmtksdio_[drv|fw]_pmctrl())
  };
  
  static const struct btmtksdio_data mt7668_data = {
  	.fwname = FIRMWARE_MT7668,
++<<<<<<< HEAD
++=======
+ 	.chipid = 0x7668,
+ 	.lp_mbox_supported = false,
+ };
+ 
+ static const struct btmtksdio_data mt7921_data = {
+ 	.fwname = FIRMWARE_MT7961,
+ 	.chipid = 0x7921,
+ 	.lp_mbox_supported = true,
++>>>>>>> 01ecc177b7d7 (Bluetooth: mt7921s: fix btmtksdio_[drv|fw]_pmctrl())
  };
  
  static const struct sdio_device_id btmtksdio_table[] = {
@@@ -95,25 -110,9 +120,31 @@@ MODULE_DEVICE_TABLE(sdio, btmtksdio_tab
  #define MTK_SDIO_BLOCK_SIZE	256
  
  #define BTMTKSDIO_TX_WAIT_VND_EVT	1
++<<<<<<< HEAD
 +
 +enum {
 +	MTK_WMT_PATCH_DWNLD = 0x1,
 +	MTK_WMT_TEST = 0x2,
 +	MTK_WMT_WAKEUP = 0x3,
 +	MTK_WMT_HIF = 0x4,
 +	MTK_WMT_FUNC_CTRL = 0x6,
 +	MTK_WMT_RST = 0x7,
 +	MTK_WMT_SEMAPHORE = 0x17,
 +};
 +
 +enum {
 +	BTMTK_WMT_INVALID,
 +	BTMTK_WMT_PATCH_UNDONE,
 +	BTMTK_WMT_PATCH_DONE,
 +	BTMTK_WMT_ON_UNDONE,
 +	BTMTK_WMT_ON_DONE,
 +	BTMTK_WMT_ON_PROGRESS,
 +};
++=======
+ #define BTMTKSDIO_HW_TX_READY		2
+ #define BTMTKSDIO_FUNC_ENABLED		3
+ #define BTMTKSDIO_PATCH_ENABLED		4
++>>>>>>> 01ecc177b7d7 (Bluetooth: mt7921s: fix btmtksdio_[drv|fw]_pmctrl())
  
  struct mtkbtsdio_hdr {
  	__le16	len;
@@@ -309,6 -291,78 +340,81 @@@ static u32 btmtksdio_drv_own_query(stru
  	return sdio_readl(bdev->func, MTK_REG_CHLPCR, NULL);
  }
  
++<<<<<<< HEAD
++=======
+ static u32 btmtksdio_drv_own_query_79xx(struct btmtksdio_dev *bdev)
+ {
+ 	return sdio_readl(bdev->func, MTK_REG_PD2HRM0R, NULL);
+ }
+ 
+ static int btmtksdio_fw_pmctrl(struct btmtksdio_dev *bdev)
+ {
+ 	u32 status;
+ 	int err;
+ 
+ 	sdio_claim_host(bdev->func);
+ 
+ 	if (bdev->data->lp_mbox_supported &&
+ 	    test_bit(BTMTKSDIO_PATCH_ENABLED, &bdev->tx_state)) {
+ 		sdio_writel(bdev->func, CSICR_CLR_MBOX_ACK, MTK_REG_CSICR,
+ 			    &err);
+ 		err = readx_poll_timeout(btmtksdio_drv_own_query_79xx, bdev,
+ 					 status, !(status & PD2HRM0R_DRV_OWN),
+ 					 2000, 1000000);
+ 		if (err < 0) {
+ 			bt_dev_err(bdev->hdev, "mailbox ACK not cleared");
+ 			goto out;
+ 		}
+ 	}
+ 
+ 	/* Return ownership to the device */
+ 	sdio_writel(bdev->func, C_FW_OWN_REQ_SET, MTK_REG_CHLPCR, &err);
+ 	if (err < 0)
+ 		goto out;
+ 
+ 	err = readx_poll_timeout(btmtksdio_drv_own_query, bdev, status,
+ 				 !(status & C_COM_DRV_OWN), 2000, 1000000);
+ 
+ out:
+ 	sdio_release_host(bdev->func);
+ 
+ 	if (err < 0)
+ 		bt_dev_err(bdev->hdev, "Cannot return ownership to device");
+ 
+ 	return err;
+ }
+ 
+ static int btmtksdio_drv_pmctrl(struct btmtksdio_dev *bdev)
+ {
+ 	u32 status;
+ 	int err;
+ 
+ 	sdio_claim_host(bdev->func);
+ 
+ 	/* Get ownership from the device */
+ 	sdio_writel(bdev->func, C_FW_OWN_REQ_CLR, MTK_REG_CHLPCR, &err);
+ 	if (err < 0)
+ 		goto out;
+ 
+ 	err = readx_poll_timeout(btmtksdio_drv_own_query, bdev, status,
+ 				 status & C_COM_DRV_OWN, 2000, 1000000);
+ 
+ 	if (!err && bdev->data->lp_mbox_supported &&
+ 	    test_bit(BTMTKSDIO_PATCH_ENABLED, &bdev->tx_state))
+ 		err = readx_poll_timeout(btmtksdio_drv_own_query_79xx, bdev,
+ 					 status, status & PD2HRM0R_DRV_OWN,
+ 					 2000, 1000000);
+ 
+ out:
+ 	sdio_release_host(bdev->func);
+ 
+ 	if (err < 0)
+ 		bt_dev_err(bdev->hdev, "Cannot get ownership from device");
+ 
+ 	return err;
+ }
+ 
++>>>>>>> 01ecc177b7d7 (Bluetooth: mt7921s: fix btmtksdio_[drv|fw]_pmctrl())
  static int btmtksdio_recv_event(struct hci_dev *hdev, struct sk_buff *skb)
  {
  	struct btmtksdio_dev *bdev = hci_get_drvdata(hdev);
@@@ -717,97 -759,7 +823,98 @@@ static int btmtksdio_func_query(struct 
  	return status;
  }
  
 -static int mt76xx_setup(struct hci_dev *hdev, const char *fwname)
 +static int mtk_setup_firmware(struct hci_dev *hdev, const char *fwname)
 +{
++	struct btmtksdio_dev *bdev = hci_get_drvdata(hdev);
 +	struct btmtk_hci_wmt_params wmt_params;
 +	const struct firmware *fw;
 +	const u8 *fw_ptr;
 +	size_t fw_size;
 +	int err, dlen;
 +	u8 flag, param;
 +
 +	err = request_firmware(&fw, fwname, &hdev->dev);
 +	if (err < 0) {
 +		bt_dev_err(hdev, "Failed to load firmware file (%d)", err);
 +		return err;
 +	}
 +
 +	/* Power on data RAM the firmware relies on. */
 +	param = 1;
 +	wmt_params.op = MTK_WMT_FUNC_CTRL;
 +	wmt_params.flag = 3;
 +	wmt_params.dlen = sizeof(param);
 +	wmt_params.data = &param;
 +	wmt_params.status = NULL;
 +
 +	err = mtk_hci_wmt_sync(hdev, &wmt_params);
 +	if (err < 0) {
 +		bt_dev_err(hdev, "Failed to power on data RAM (%d)", err);
 +		goto free_fw;
 +	}
 +
 +	fw_ptr = fw->data;
 +	fw_size = fw->size;
 +
 +	/* The size of patch header is 30 bytes, should be skip */
 +	if (fw_size < 30) {
 +		err = -EINVAL;
 +		goto free_fw;
 +	}
 +
 +	fw_size -= 30;
 +	fw_ptr += 30;
 +	flag = 1;
 +
 +	wmt_params.op = MTK_WMT_PATCH_DWNLD;
 +	wmt_params.status = NULL;
 +
 +	while (fw_size > 0) {
 +		dlen = min_t(int, 250, fw_size);
 +
 +		/* Tell device the position in sequence */
 +		if (fw_size - dlen <= 0)
 +			flag = 3;
 +		else if (fw_size < fw->size - 30)
 +			flag = 2;
 +
 +		wmt_params.flag = flag;
 +		wmt_params.dlen = dlen;
 +		wmt_params.data = fw_ptr;
 +
 +		err = mtk_hci_wmt_sync(hdev, &wmt_params);
 +		if (err < 0) {
 +			bt_dev_err(hdev, "Failed to send wmt patch dwnld (%d)",
 +				   err);
 +			goto free_fw;
 +		}
 +
 +		fw_size -= dlen;
 +		fw_ptr += dlen;
 +	}
 +
 +	wmt_params.op = MTK_WMT_RST;
 +	wmt_params.flag = 4;
 +	wmt_params.dlen = 0;
 +	wmt_params.data = NULL;
 +	wmt_params.status = NULL;
 +
 +	/* Activate funciton the firmware providing to */
 +	err = mtk_hci_wmt_sync(hdev, &wmt_params);
 +	if (err < 0) {
 +		bt_dev_err(hdev, "Failed to send wmt rst (%d)", err);
 +		goto free_fw;
 +	}
 +
 +	/* Wait a few moments for firmware activation done */
 +	usleep_range(10000, 12000);
 +
 +free_fw:
 +	release_firmware(fw);
 +	return err;
 +}
 +
 +static int btmtksdio_setup(struct hci_dev *hdev)
  {
  	struct btmtksdio_dev *bdev = hci_get_drvdata(hdev);
  	struct btmtk_hci_wmt_params wmt_params;
@@@ -892,6 -841,189 +1001,192 @@@ ignore_func_on
  	}
  	kfree_skb(skb);
  
++<<<<<<< HEAD
++=======
+ 	return 0;
+ }
+ 
+ static int mt79xx_setup(struct hci_dev *hdev, const char *fwname)
+ {
+ 	struct btmtksdio_dev *bdev = hci_get_drvdata(hdev);
+ 	struct btmtk_hci_wmt_params wmt_params;
+ 	u8 param = 0x1;
+ 	int err;
+ 
+ 	err = btmtk_setup_firmware_79xx(hdev, fwname, mtk_hci_wmt_sync);
+ 	if (err < 0) {
+ 		bt_dev_err(hdev, "Failed to setup 79xx firmware (%d)", err);
+ 		return err;
+ 	}
+ 
+ 	/* Enable Bluetooth protocol */
+ 	wmt_params.op = BTMTK_WMT_FUNC_CTRL;
+ 	wmt_params.flag = 0;
+ 	wmt_params.dlen = sizeof(param);
+ 	wmt_params.data = &param;
+ 	wmt_params.status = NULL;
+ 
+ 	err = mtk_hci_wmt_sync(hdev, &wmt_params);
+ 	if (err < 0) {
+ 		bt_dev_err(hdev, "Failed to send wmt func ctrl (%d)", err);
+ 		return err;
+ 	}
+ 
+ 	hci_set_msft_opcode(hdev, 0xFD30);
+ 	hci_set_aosp_capable(hdev);
+ 	set_bit(BTMTKSDIO_PATCH_ENABLED, &bdev->tx_state);
+ 
+ 	return err;
+ }
+ 
+ static int btmtksdio_mtk_reg_read(struct hci_dev *hdev, u32 reg, u32 *val)
+ {
+ 	struct btmtk_hci_wmt_params wmt_params;
+ 	struct reg_read_cmd reg_read = {
+ 		.type = 1,
+ 		.num = 1,
+ 	};
+ 	u32 status;
+ 	int err;
+ 
+ 	reg_read.addr = cpu_to_le32(reg);
+ 	wmt_params.op = BTMTK_WMT_REGISTER;
+ 	wmt_params.flag = BTMTK_WMT_REG_READ;
+ 	wmt_params.dlen = sizeof(reg_read);
+ 	wmt_params.data = &reg_read;
+ 	wmt_params.status = &status;
+ 
+ 	err = mtk_hci_wmt_sync(hdev, &wmt_params);
+ 	if (err < 0) {
+ 		bt_dev_err(hdev, "Failed to read reg (%d)", err);
+ 		return err;
+ 	}
+ 
+ 	*val = status;
+ 
+ 	return err;
+ }
+ 
+ static int btmtksdio_mtk_reg_write(struct hci_dev *hdev, u32 reg, u32 val, u32 mask)
+ {
+ 	struct btmtk_hci_wmt_params wmt_params;
+ 	const struct reg_write_cmd reg_write = {
+ 		.type = 1,
+ 		.num = 1,
+ 		.addr = cpu_to_le32(reg),
+ 		.data = cpu_to_le32(val),
+ 		.mask = cpu_to_le32(mask),
+ 	};
+ 	int err, status;
+ 
+ 	wmt_params.op = BTMTK_WMT_REGISTER;
+ 	wmt_params.flag = BTMTK_WMT_REG_WRITE;
+ 	wmt_params.dlen = sizeof(reg_write);
+ 	wmt_params.data = &reg_write;
+ 	wmt_params.status = &status;
+ 
+ 	err = mtk_hci_wmt_sync(hdev, &wmt_params);
+ 	if (err < 0)
+ 		bt_dev_err(hdev, "Failed to write reg (%d)", err);
+ 
+ 	return err;
+ }
+ 
+ static int btmtksdio_sco_setting(struct hci_dev *hdev)
+ {
+ 	const struct btmtk_sco sco_setting = {
+ 		.clock_config = 0x49,
+ 		.channel_format_config = 0x80,
+ 	};
+ 	struct sk_buff *skb;
+ 	u32 val;
+ 	int err;
+ 
+ 	/* Enable SCO over I2S/PCM for MediaTek chipset */
+ 	skb =  __hci_cmd_sync(hdev, 0xfc72, sizeof(sco_setting),
+ 			      &sco_setting, HCI_CMD_TIMEOUT);
+ 	if (IS_ERR(skb))
+ 		return PTR_ERR(skb);
+ 
+ 	kfree_skb(skb);
+ 
+ 	err = btmtksdio_mtk_reg_read(hdev, MT7921_PINMUX_0, &val);
+ 	if (err < 0)
+ 		return err;
+ 
+ 	val |= 0x11000000;
+ 	err = btmtksdio_mtk_reg_write(hdev, MT7921_PINMUX_0, val, ~0);
+ 	if (err < 0)
+ 		return err;
+ 
+ 	err = btmtksdio_mtk_reg_read(hdev, MT7921_PINMUX_1, &val);
+ 	if (err < 0)
+ 		return err;
+ 
+ 	val |= 0x00000101;
+ 	return btmtksdio_mtk_reg_write(hdev, MT7921_PINMUX_1, val, ~0);
+ }
+ 
+ static int btmtksdio_setup(struct hci_dev *hdev)
+ {
+ 	struct btmtksdio_dev *bdev = hci_get_drvdata(hdev);
+ 	ktime_t calltime, delta, rettime;
+ 	unsigned long long duration;
+ 	char fwname[64];
+ 	int err, dev_id;
+ 	u32 fw_version = 0;
+ 
+ 	calltime = ktime_get();
+ 	set_bit(BTMTKSDIO_HW_TX_READY, &bdev->tx_state);
+ 
+ 	switch (bdev->data->chipid) {
+ 	case 0x7921:
+ 		err = btmtksdio_mtk_reg_read(hdev, 0x70010200, &dev_id);
+ 		if (err < 0) {
+ 			bt_dev_err(hdev, "Failed to get device id (%d)", err);
+ 			return err;
+ 		}
+ 
+ 		err = btmtksdio_mtk_reg_read(hdev, 0x80021004, &fw_version);
+ 		if (err < 0) {
+ 			bt_dev_err(hdev, "Failed to get fw version (%d)", err);
+ 			return err;
+ 		}
+ 
+ 		snprintf(fwname, sizeof(fwname),
+ 			 "mediatek/BT_RAM_CODE_MT%04x_1_%x_hdr.bin",
+ 			 dev_id & 0xffff, (fw_version & 0xff) + 1);
+ 		err = mt79xx_setup(hdev, fwname);
+ 		if (err < 0)
+ 			return err;
+ 
+ 		err = btmtksdio_fw_pmctrl(bdev);
+ 		if (err < 0)
+ 			return err;
+ 
+ 		err = btmtksdio_drv_pmctrl(bdev);
+ 		if (err < 0)
+ 			return err;
+ 
+ 		/* Enable SCO over I2S/PCM */
+ 		err = btmtksdio_sco_setting(hdev);
+ 		if (err < 0) {
+ 			bt_dev_err(hdev, "Failed to enable SCO setting (%d)", err);
+ 			return err;
+ 		}
+ 
+ 		break;
+ 	case 0x7663:
+ 	case 0x7668:
+ 		err = mt76xx_setup(hdev, bdev->data->fwname);
+ 		if (err < 0)
+ 			return err;
+ 		break;
+ 	default:
+ 		return -ENODEV;
+ 	}
+ 
++>>>>>>> 01ecc177b7d7 (Bluetooth: mt7921s: fix btmtksdio_[drv|fw]_pmctrl())
  	rettime = ktime_get();
  	delta = ktime_sub(rettime, calltime);
  	duration = (unsigned long long)ktime_to_ns(delta) >> 10;
* Unmerged path drivers/bluetooth/btmtksdio.c
