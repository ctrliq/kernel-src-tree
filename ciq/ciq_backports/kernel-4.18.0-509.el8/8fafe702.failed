Bluetooth: mt7921s: support bluetooth reset mechanism

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-509.el8
commit-author Chih-Ying Chiang <chih-yin.chiang@mediatek.com>
commit 8fafe702253d50bf90daf324ae86b5ad5ac8a5e1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-509.el8/8fafe702.failed

Implement .cmd_timeout to reset the MT7921s device via a dedicated GPIO
pin when the firmware hang or the command has no response.

Co-developed-by: Mark Chen <mark-yw.chen@mediatek.com>
	Signed-off-by: Mark Chen <mark-yw.chen@mediatek.com>
Co-developed-by: Sean Wang <sean.wang@mediatek.com>
	Signed-off-by: Sean Wang <sean.wang@mediatek.com>
	Signed-off-by: Chih-Ying Chiang <chih-yin.chiang@mediatek.com>
	Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
(cherry picked from commit 8fafe702253d50bf90daf324ae86b5ad5ac8a5e1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/bluetooth/btmtk.h
#	drivers/bluetooth/btmtksdio.c
diff --cc drivers/bluetooth/btmtksdio.c
index 9d69b7207cf2,8e200e80d2f6..000000000000
--- a/drivers/bluetooth/btmtksdio.c
+++ b/drivers/bluetooth/btmtksdio.c
@@@ -12,7 -12,7 +12,11 @@@
  
  #include <asm/unaligned.h>
  #include <linux/atomic.h>
++<<<<<<< HEAD
 +#include <linux/firmware.h>
++=======
+ #include <linux/gpio/consumer.h>
++>>>>>>> 8fafe702253d (Bluetooth: mt7921s: support bluetooth reset mechanism)
  #include <linux/init.h>
  #include <linux/iopoll.h>
  #include <linux/kernel.h>
@@@ -95,25 -114,10 +101,32 @@@ MODULE_DEVICE_TABLE(sdio, btmtksdio_tab
  #define MTK_SDIO_BLOCK_SIZE	256
  
  #define BTMTKSDIO_TX_WAIT_VND_EVT	1
++<<<<<<< HEAD
 +
 +enum {
 +	MTK_WMT_PATCH_DWNLD = 0x1,
 +	MTK_WMT_TEST = 0x2,
 +	MTK_WMT_WAKEUP = 0x3,
 +	MTK_WMT_HIF = 0x4,
 +	MTK_WMT_FUNC_CTRL = 0x6,
 +	MTK_WMT_RST = 0x7,
 +	MTK_WMT_SEMAPHORE = 0x17,
 +};
 +
 +enum {
 +	BTMTK_WMT_INVALID,
 +	BTMTK_WMT_PATCH_UNDONE,
 +	BTMTK_WMT_PATCH_DONE,
 +	BTMTK_WMT_ON_UNDONE,
 +	BTMTK_WMT_ON_DONE,
 +	BTMTK_WMT_ON_PROGRESS,
 +};
++=======
+ #define BTMTKSDIO_HW_TX_READY		2
+ #define BTMTKSDIO_FUNC_ENABLED		3
+ #define BTMTKSDIO_PATCH_ENABLED		4
+ #define BTMTKSDIO_HW_RESET_ACTIVE	5
++>>>>>>> 8fafe702253d (Bluetooth: mt7921s: support bluetooth reset mechanism)
  
  struct mtkbtsdio_hdr {
  	__le16	len;
@@@ -309,6 -298,83 +324,86 @@@ static u32 btmtksdio_drv_own_query(stru
  	return sdio_readl(bdev->func, MTK_REG_CHLPCR, NULL);
  }
  
++<<<<<<< HEAD
++=======
+ static u32 btmtksdio_drv_own_query_79xx(struct btmtksdio_dev *bdev)
+ {
+ 	return sdio_readl(bdev->func, MTK_REG_PD2HRM0R, NULL);
+ }
+ 
+ static u32 btmtksdio_chcr_query(struct btmtksdio_dev *bdev)
+ {
+ 	return sdio_readl(bdev->func, MTK_REG_CHCR, NULL);
+ }
+ 
+ static int btmtksdio_fw_pmctrl(struct btmtksdio_dev *bdev)
+ {
+ 	u32 status;
+ 	int err;
+ 
+ 	sdio_claim_host(bdev->func);
+ 
+ 	if (bdev->data->lp_mbox_supported &&
+ 	    test_bit(BTMTKSDIO_PATCH_ENABLED, &bdev->tx_state)) {
+ 		sdio_writel(bdev->func, CSICR_CLR_MBOX_ACK, MTK_REG_CSICR,
+ 			    &err);
+ 		err = readx_poll_timeout(btmtksdio_drv_own_query_79xx, bdev,
+ 					 status, !(status & PD2HRM0R_DRV_OWN),
+ 					 2000, 1000000);
+ 		if (err < 0) {
+ 			bt_dev_err(bdev->hdev, "mailbox ACK not cleared");
+ 			goto out;
+ 		}
+ 	}
+ 
+ 	/* Return ownership to the device */
+ 	sdio_writel(bdev->func, C_FW_OWN_REQ_SET, MTK_REG_CHLPCR, &err);
+ 	if (err < 0)
+ 		goto out;
+ 
+ 	err = readx_poll_timeout(btmtksdio_drv_own_query, bdev, status,
+ 				 !(status & C_COM_DRV_OWN), 2000, 1000000);
+ 
+ out:
+ 	sdio_release_host(bdev->func);
+ 
+ 	if (err < 0)
+ 		bt_dev_err(bdev->hdev, "Cannot return ownership to device");
+ 
+ 	return err;
+ }
+ 
+ static int btmtksdio_drv_pmctrl(struct btmtksdio_dev *bdev)
+ {
+ 	u32 status;
+ 	int err;
+ 
+ 	sdio_claim_host(bdev->func);
+ 
+ 	/* Get ownership from the device */
+ 	sdio_writel(bdev->func, C_FW_OWN_REQ_CLR, MTK_REG_CHLPCR, &err);
+ 	if (err < 0)
+ 		goto out;
+ 
+ 	err = readx_poll_timeout(btmtksdio_drv_own_query, bdev, status,
+ 				 status & C_COM_DRV_OWN, 2000, 1000000);
+ 
+ 	if (!err && bdev->data->lp_mbox_supported &&
+ 	    test_bit(BTMTKSDIO_PATCH_ENABLED, &bdev->tx_state))
+ 		err = readx_poll_timeout(btmtksdio_drv_own_query_79xx, bdev,
+ 					 status, status & PD2HRM0R_DRV_OWN,
+ 					 2000, 1000000);
+ 
+ out:
+ 	sdio_release_host(bdev->func);
+ 
+ 	if (err < 0)
+ 		bt_dev_err(bdev->hdev, "Cannot get ownership from device");
+ 
+ 	return err;
+ }
+ 
++>>>>>>> 8fafe702253d (Bluetooth: mt7921s: support bluetooth reset mechanism)
  static int btmtksdio_recv_event(struct hci_dev *hdev, struct sk_buff *skb)
  {
  	struct btmtksdio_dev *bdev = hci_get_drvdata(hdev);
@@@ -892,6 -854,240 +987,243 @@@ ignore_func_on
  	}
  	kfree_skb(skb);
  
++<<<<<<< HEAD
++=======
+ 	return 0;
+ }
+ 
+ static int mt79xx_setup(struct hci_dev *hdev, const char *fwname)
+ {
+ 	struct btmtksdio_dev *bdev = hci_get_drvdata(hdev);
+ 	struct btmtk_hci_wmt_params wmt_params;
+ 	u8 param = 0x1;
+ 	int err;
+ 
+ 	err = btmtk_setup_firmware_79xx(hdev, fwname, mtk_hci_wmt_sync);
+ 	if (err < 0) {
+ 		bt_dev_err(hdev, "Failed to setup 79xx firmware (%d)", err);
+ 		return err;
+ 	}
+ 
+ 	/* Enable Bluetooth protocol */
+ 	wmt_params.op = BTMTK_WMT_FUNC_CTRL;
+ 	wmt_params.flag = 0;
+ 	wmt_params.dlen = sizeof(param);
+ 	wmt_params.data = &param;
+ 	wmt_params.status = NULL;
+ 
+ 	err = mtk_hci_wmt_sync(hdev, &wmt_params);
+ 	if (err < 0) {
+ 		bt_dev_err(hdev, "Failed to send wmt func ctrl (%d)", err);
+ 		return err;
+ 	}
+ 
+ 	hci_set_msft_opcode(hdev, 0xFD30);
+ 	hci_set_aosp_capable(hdev);
+ 	set_bit(BTMTKSDIO_PATCH_ENABLED, &bdev->tx_state);
+ 
+ 	return err;
+ }
+ 
+ static int btmtksdio_mtk_reg_read(struct hci_dev *hdev, u32 reg, u32 *val)
+ {
+ 	struct btmtk_hci_wmt_params wmt_params;
+ 	struct reg_read_cmd reg_read = {
+ 		.type = 1,
+ 		.num = 1,
+ 	};
+ 	u32 status;
+ 	int err;
+ 
+ 	reg_read.addr = cpu_to_le32(reg);
+ 	wmt_params.op = BTMTK_WMT_REGISTER;
+ 	wmt_params.flag = BTMTK_WMT_REG_READ;
+ 	wmt_params.dlen = sizeof(reg_read);
+ 	wmt_params.data = &reg_read;
+ 	wmt_params.status = &status;
+ 
+ 	err = mtk_hci_wmt_sync(hdev, &wmt_params);
+ 	if (err < 0) {
+ 		bt_dev_err(hdev, "Failed to read reg (%d)", err);
+ 		return err;
+ 	}
+ 
+ 	*val = status;
+ 
+ 	return err;
+ }
+ 
+ static int btmtksdio_mtk_reg_write(struct hci_dev *hdev, u32 reg, u32 val, u32 mask)
+ {
+ 	struct btmtk_hci_wmt_params wmt_params;
+ 	const struct reg_write_cmd reg_write = {
+ 		.type = 1,
+ 		.num = 1,
+ 		.addr = cpu_to_le32(reg),
+ 		.data = cpu_to_le32(val),
+ 		.mask = cpu_to_le32(mask),
+ 	};
+ 	int err, status;
+ 
+ 	wmt_params.op = BTMTK_WMT_REGISTER;
+ 	wmt_params.flag = BTMTK_WMT_REG_WRITE;
+ 	wmt_params.dlen = sizeof(reg_write);
+ 	wmt_params.data = &reg_write;
+ 	wmt_params.status = &status;
+ 
+ 	err = mtk_hci_wmt_sync(hdev, &wmt_params);
+ 	if (err < 0)
+ 		bt_dev_err(hdev, "Failed to write reg (%d)", err);
+ 
+ 	return err;
+ }
+ 
+ static int btmtksdio_sco_setting(struct hci_dev *hdev)
+ {
+ 	const struct btmtk_sco sco_setting = {
+ 		.clock_config = 0x49,
+ 		.channel_format_config = 0x80,
+ 	};
+ 	struct sk_buff *skb;
+ 	u32 val;
+ 	int err;
+ 
+ 	/* Enable SCO over I2S/PCM for MediaTek chipset */
+ 	skb =  __hci_cmd_sync(hdev, 0xfc72, sizeof(sco_setting),
+ 			      &sco_setting, HCI_CMD_TIMEOUT);
+ 	if (IS_ERR(skb))
+ 		return PTR_ERR(skb);
+ 
+ 	kfree_skb(skb);
+ 
+ 	err = btmtksdio_mtk_reg_read(hdev, MT7921_PINMUX_0, &val);
+ 	if (err < 0)
+ 		return err;
+ 
+ 	val |= 0x11000000;
+ 	err = btmtksdio_mtk_reg_write(hdev, MT7921_PINMUX_0, val, ~0);
+ 	if (err < 0)
+ 		return err;
+ 
+ 	err = btmtksdio_mtk_reg_read(hdev, MT7921_PINMUX_1, &val);
+ 	if (err < 0)
+ 		return err;
+ 
+ 	val |= 0x00000101;
+ 	return btmtksdio_mtk_reg_write(hdev, MT7921_PINMUX_1, val, ~0);
+ }
+ 
+ static int btmtksdio_reset_setting(struct hci_dev *hdev)
+ {
+ 	int err;
+ 	u32 val;
+ 
+ 	err = btmtksdio_mtk_reg_read(hdev, MT7921_PINMUX_1, &val);
+ 	if (err < 0)
+ 		return err;
+ 
+ 	val |= 0x20; /* set the pin (bit field 11:8) work as GPIO mode */
+ 	err = btmtksdio_mtk_reg_write(hdev, MT7921_PINMUX_1, val, ~0);
+ 	if (err < 0)
+ 		return err;
+ 
+ 	err = btmtksdio_mtk_reg_read(hdev, MT7921_BTSYS_RST, &val);
+ 	if (err < 0)
+ 		return err;
+ 
+ 	val |= MT7921_BTSYS_RST_WITH_GPIO;
+ 	return btmtksdio_mtk_reg_write(hdev, MT7921_BTSYS_RST, val, ~0);
+ }
+ 
+ static int btmtksdio_setup(struct hci_dev *hdev)
+ {
+ 	struct btmtksdio_dev *bdev = hci_get_drvdata(hdev);
+ 	ktime_t calltime, delta, rettime;
+ 	unsigned long long duration;
+ 	char fwname[64];
+ 	int err, dev_id;
+ 	u32 fw_version = 0, val;
+ 
+ 	calltime = ktime_get();
+ 	set_bit(BTMTKSDIO_HW_TX_READY, &bdev->tx_state);
+ 
+ 	switch (bdev->data->chipid) {
+ 	case 0x7921:
+ 		if (test_bit(BTMTKSDIO_HW_RESET_ACTIVE, &bdev->tx_state)) {
+ 			err = btmtksdio_mtk_reg_read(hdev, MT7921_DLSTATUS,
+ 						     &val);
+ 			if (err < 0)
+ 				return err;
+ 
+ 			val &= ~BT_DL_STATE;
+ 			err = btmtksdio_mtk_reg_write(hdev, MT7921_DLSTATUS,
+ 						      val, ~0);
+ 			if (err < 0)
+ 				return err;
+ 
+ 			btmtksdio_fw_pmctrl(bdev);
+ 			msleep(20);
+ 			btmtksdio_drv_pmctrl(bdev);
+ 
+ 			clear_bit(BTMTKSDIO_HW_RESET_ACTIVE, &bdev->tx_state);
+ 		}
+ 
+ 		err = btmtksdio_mtk_reg_read(hdev, 0x70010200, &dev_id);
+ 		if (err < 0) {
+ 			bt_dev_err(hdev, "Failed to get device id (%d)", err);
+ 			return err;
+ 		}
+ 
+ 		err = btmtksdio_mtk_reg_read(hdev, 0x80021004, &fw_version);
+ 		if (err < 0) {
+ 			bt_dev_err(hdev, "Failed to get fw version (%d)", err);
+ 			return err;
+ 		}
+ 
+ 		snprintf(fwname, sizeof(fwname),
+ 			 "mediatek/BT_RAM_CODE_MT%04x_1_%x_hdr.bin",
+ 			 dev_id & 0xffff, (fw_version & 0xff) + 1);
+ 		err = mt79xx_setup(hdev, fwname);
+ 		if (err < 0)
+ 			return err;
+ 
+ 		err = btmtksdio_fw_pmctrl(bdev);
+ 		if (err < 0)
+ 			return err;
+ 
+ 		err = btmtksdio_drv_pmctrl(bdev);
+ 		if (err < 0)
+ 			return err;
+ 
+ 		/* Enable SCO over I2S/PCM */
+ 		err = btmtksdio_sco_setting(hdev);
+ 		if (err < 0) {
+ 			bt_dev_err(hdev, "Failed to enable SCO setting (%d)", err);
+ 			return err;
+ 		}
+ 
+ 		/* Enable GPIO reset mechanism */
+ 		if (bdev->reset) {
+ 			err = btmtksdio_reset_setting(hdev);
+ 			if (err < 0) {
+ 				bt_dev_err(hdev, "Failed to enable Reset setting (%d)", err);
+ 				devm_gpiod_put(bdev->dev, bdev->reset);
+ 				bdev->reset = NULL;
+ 			}
+ 		}
+ 
+ 		break;
+ 	case 0x7663:
+ 	case 0x7668:
+ 		err = mt76xx_setup(hdev, bdev->data->fwname);
+ 		if (err < 0)
+ 			return err;
+ 		break;
+ 	default:
+ 		return -ENODEV;
+ 	}
+ 
++>>>>>>> 8fafe702253d (Bluetooth: mt7921s: support bluetooth reset mechanism)
  	rettime = ktime_get();
  	delta = ktime_sub(rettime, calltime);
  	duration = (unsigned long long)ktime_to_ns(delta) >> 10;
@@@ -977,6 -1173,73 +1309,76 @@@ static int btmtksdio_send_frame(struct 
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static void btmtksdio_cmd_timeout(struct hci_dev *hdev)
+ {
+ 	struct btmtksdio_dev *bdev = hci_get_drvdata(hdev);
+ 	u32 status;
+ 	int err;
+ 
+ 	if (!bdev->reset || bdev->data->chipid != 0x7921)
+ 		return;
+ 
+ 	pm_runtime_get_sync(bdev->dev);
+ 
+ 	if (test_and_set_bit(BTMTKSDIO_HW_RESET_ACTIVE, &bdev->tx_state))
+ 		return;
+ 
+ 	sdio_claim_host(bdev->func);
+ 
+ 	sdio_writel(bdev->func, C_INT_EN_CLR, MTK_REG_CHLPCR, NULL);
+ 	skb_queue_purge(&bdev->txq);
+ 	cancel_work_sync(&bdev->txrx_work);
+ 
+ 	gpiod_set_value_cansleep(bdev->reset, 1);
+ 	msleep(100);
+ 	gpiod_set_value_cansleep(bdev->reset, 0);
+ 
+ 	err = readx_poll_timeout(btmtksdio_chcr_query, bdev, status,
+ 				 status & BT_RST_DONE, 100000, 2000000);
+ 	if (err < 0) {
+ 		bt_dev_err(hdev, "Failed to reset (%d)", err);
+ 		goto err;
+ 	}
+ 
+ 	clear_bit(BTMTKSDIO_PATCH_ENABLED, &bdev->tx_state);
+ err:
+ 	sdio_release_host(bdev->func);
+ 
+ 	pm_runtime_put_noidle(bdev->dev);
+ 	pm_runtime_disable(bdev->dev);
+ 
+ 	hci_reset_dev(hdev);
+ }
+ 
+ static bool btmtksdio_sdio_wakeup(struct hci_dev *hdev)
+ {
+ 	struct btmtksdio_dev *bdev = hci_get_drvdata(hdev);
+ 	bool may_wakeup = device_may_wakeup(bdev->dev);
+ 	const struct btmtk_wakeon bt_awake = {
+ 		.mode = 0x1,
+ 		.gpo = 0,
+ 		.active_high = 0x1,
+ 		.enable_delay = cpu_to_le16(0xc80),
+ 		.wakeup_delay = cpu_to_le16(0x20),
+ 	};
+ 
+ 	if (may_wakeup && bdev->data->chipid == 0x7921) {
+ 		struct sk_buff *skb;
+ 
+ 		skb =  __hci_cmd_sync(hdev, 0xfc27, sizeof(bt_awake),
+ 				      &bt_awake, HCI_CMD_TIMEOUT);
+ 		if (IS_ERR(skb))
+ 			may_wakeup = false;
+ 
+ 		kfree_skb(skb);
+ 	}
+ 
+ 	return may_wakeup;
+ }
+ 
++>>>>>>> 8fafe702253d (Bluetooth: mt7921s: support bluetooth reset mechanism)
  static int btmtksdio_probe(struct sdio_func *func,
  			   const struct sdio_device_id *id)
  {
@@@ -1051,7 -1316,18 +1454,22 @@@
  	 */
  	pm_runtime_put_noidle(bdev->dev);
  
++<<<<<<< HEAD
 +	return 0;
++=======
+ 	err = device_init_wakeup(bdev->dev, true);
+ 	if (err)
+ 		bt_dev_err(hdev, "failed to initialize device wakeup");
+ 
+ 	bdev->dev->of_node = of_find_compatible_node(NULL, NULL,
+ 						     "mediatek,mt7921s-bluetooth");
+ 	bdev->reset = devm_gpiod_get_optional(bdev->dev, "reset",
+ 					      GPIOD_OUT_LOW);
+ 	if (IS_ERR(bdev->reset))
+ 		err = PTR_ERR(bdev->reset);
+ 
+ 	return err;
++>>>>>>> 8fafe702253d (Bluetooth: mt7921s: support bluetooth reset mechanism)
  }
  
  static void btmtksdio_remove(struct sdio_func *func)
* Unmerged path drivers/bluetooth/btmtk.h
* Unmerged path drivers/bluetooth/btmtk.h
* Unmerged path drivers/bluetooth/btmtksdio.c
