Bluetooth: btmtksdio: add MT7921s Bluetooth support

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-509.el8
commit-author Sean Wang <sean.wang@mediatek.com>
commit c603bf1f94d0ef8ce3ef081112eae13cd744ef17
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-509.el8/c603bf1f.failed

add MT7921s Bluetooth support

Co-developed-by: Mark-yw Chen <mark-yw.chen@mediatek.com>
	Signed-off-by: Mark-yw Chen <mark-yw.chen@mediatek.com>
	Signed-off-by: Sean Wang <sean.wang@mediatek.com>
	Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
(cherry picked from commit c603bf1f94d0ef8ce3ef081112eae13cd744ef17)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/bluetooth/btmtk.h
#	drivers/bluetooth/btmtksdio.c
diff --cc drivers/bluetooth/btmtksdio.c
index 1db43f893c2d,ce6a6c00ff98..000000000000
--- a/drivers/bluetooth/btmtksdio.c
+++ b/drivers/bluetooth/btmtksdio.c
@@@ -51,10 -56,12 +59,12 @@@ static const struct btmtksdio_data mt79
  };
  
  static const struct sdio_device_id btmtksdio_table[] = {
 -	{SDIO_DEVICE(SDIO_VENDOR_ID_MEDIATEK, SDIO_DEVICE_ID_MEDIATEK_MT7663),
 +	{SDIO_DEVICE(SDIO_VENDOR_ID_MEDIATEK, 0x7663),
  	 .driver_data = (kernel_ulong_t)&mt7663_data },
 -	{SDIO_DEVICE(SDIO_VENDOR_ID_MEDIATEK, SDIO_DEVICE_ID_MEDIATEK_MT7668),
 +	{SDIO_DEVICE(SDIO_VENDOR_ID_MEDIATEK, 0x7668),
  	 .driver_data = (kernel_ulong_t)&mt7668_data },
+ 	{SDIO_DEVICE(SDIO_VENDOR_ID_MEDIATEK, SDIO_DEVICE_ID_MEDIATEK_MT7961),
+ 	 .driver_data = (kernel_ulong_t)&mt7921_data },
  	{ }	/* Terminating entry */
  };
  MODULE_DEVICE_TABLE(sdio, btmtksdio_table);
@@@ -175,12 -125,14 +185,13 @@@ static int mtk_hci_wmt_sync(struct hci_
  {
  	struct btmtksdio_dev *bdev = hci_get_drvdata(hdev);
  	struct btmtk_hci_wmt_evt_funcc *wmt_evt_funcc;
+ 	struct btmtk_hci_wmt_evt_reg *wmt_evt_reg;
  	u32 hlen, status = BTMTK_WMT_INVALID;
  	struct btmtk_hci_wmt_evt *wmt_evt;
 -	struct btmtk_hci_wmt_cmd *wc;
 -	struct btmtk_wmt_hdr *hdr;
 +	struct mtk_hci_wmt_cmd wc;
 +	struct mtk_wmt_hdr *hdr;
  	int err;
  
 -	/* Send the WMT command and wait until the WMT event returns */
  	hlen = sizeof(*hdr) + wmt_params->dlen;
  	if (hlen > 255)
  		return -EINVAL;
@@@ -686,112 -658,16 +710,110 @@@ static int btmtksdio_func_query(struct 
  	return status;
  }
  
++<<<<<<< HEAD
 +static int mtk_setup_firmware(struct hci_dev *hdev, const char *fwname)
 +{
 +	struct btmtk_hci_wmt_params wmt_params;
 +	const struct firmware *fw;
 +	const u8 *fw_ptr;
 +	size_t fw_size;
 +	int err, dlen;
 +	u8 flag, param;
 +
 +	err = request_firmware(&fw, fwname, &hdev->dev);
 +	if (err < 0) {
 +		bt_dev_err(hdev, "Failed to load firmware file (%d)", err);
 +		return err;
 +	}
 +
 +	/* Power on data RAM the firmware relies on. */
 +	param = 1;
 +	wmt_params.op = MTK_WMT_FUNC_CTRL;
 +	wmt_params.flag = 3;
 +	wmt_params.dlen = sizeof(param);
 +	wmt_params.data = &param;
 +	wmt_params.status = NULL;
 +
 +	err = mtk_hci_wmt_sync(hdev, &wmt_params);
 +	if (err < 0) {
 +		bt_dev_err(hdev, "Failed to power on data RAM (%d)", err);
 +		goto free_fw;
 +	}
 +
 +	fw_ptr = fw->data;
 +	fw_size = fw->size;
 +
 +	/* The size of patch header is 30 bytes, should be skip */
 +	if (fw_size < 30) {
 +		err = -EINVAL;
 +		goto free_fw;
 +	}
 +
 +	fw_size -= 30;
 +	fw_ptr += 30;
 +	flag = 1;
 +
 +	wmt_params.op = MTK_WMT_PATCH_DWNLD;
 +	wmt_params.status = NULL;
 +
 +	while (fw_size > 0) {
 +		dlen = min_t(int, 250, fw_size);
 +
 +		/* Tell device the position in sequence */
 +		if (fw_size - dlen <= 0)
 +			flag = 3;
 +		else if (fw_size < fw->size - 30)
 +			flag = 2;
 +
 +		wmt_params.flag = flag;
 +		wmt_params.dlen = dlen;
 +		wmt_params.data = fw_ptr;
 +
 +		err = mtk_hci_wmt_sync(hdev, &wmt_params);
 +		if (err < 0) {
 +			bt_dev_err(hdev, "Failed to send wmt patch dwnld (%d)",
 +				   err);
 +			goto free_fw;
 +		}
 +
 +		fw_size -= dlen;
 +		fw_ptr += dlen;
 +	}
 +
 +	wmt_params.op = MTK_WMT_RST;
 +	wmt_params.flag = 4;
 +	wmt_params.dlen = 0;
 +	wmt_params.data = NULL;
 +	wmt_params.status = NULL;
 +
 +	/* Activate funciton the firmware providing to */
 +	err = mtk_hci_wmt_sync(hdev, &wmt_params);
 +	if (err < 0) {
 +		bt_dev_err(hdev, "Failed to send wmt rst (%d)", err);
 +		goto free_fw;
 +	}
 +
 +	/* Wait a few moments for firmware activation done */
 +	usleep_range(10000, 12000);
 +
 +free_fw:
 +	release_firmware(fw);
 +	return err;
 +}
 +
 +static int btmtksdio_setup(struct hci_dev *hdev)
++=======
+ static int mt76xx_setup(struct hci_dev *hdev, const char *fwname)
++>>>>>>> c603bf1f94d0 (Bluetooth: btmtksdio: add MT7921s Bluetooth support)
  {
- 	struct btmtksdio_dev *bdev = hci_get_drvdata(hdev);
  	struct btmtk_hci_wmt_params wmt_params;
- 	ktime_t calltime, delta, rettime;
  	struct btmtk_tci_sleep tci_sleep;
- 	unsigned long long duration;
  	struct sk_buff *skb;
  	int err, status;
  	u8 param = 0x1;
  
- 	calltime = ktime_get();
- 	bdev->hw_tx_ready = true;
- 
  	/* Query whether the firmware is already download */
 -	wmt_params.op = BTMTK_WMT_SEMAPHORE;
 +	wmt_params.op = MTK_WMT_SEMAPHORE;
  	wmt_params.flag = 1;
  	wmt_params.dlen = 0;
  	wmt_params.data = NULL;
@@@ -809,7 -685,7 +831,11 @@@
  	}
  
  	/* Setup a firmware which the device definitely requires */
++<<<<<<< HEAD
 +	err = mtk_setup_firmware(hdev, bdev->data->fwname);
++=======
+ 	err = btmtk_setup_firmware(hdev, fwname, mtk_hci_wmt_sync);
++>>>>>>> c603bf1f94d0 (Bluetooth: btmtksdio: add MT7921s Bluetooth support)
  	if (err < 0)
  		return err;
  
* Unmerged path drivers/bluetooth/btmtk.h
* Unmerged path drivers/bluetooth/btmtk.h
* Unmerged path drivers/bluetooth/btmtksdio.c
