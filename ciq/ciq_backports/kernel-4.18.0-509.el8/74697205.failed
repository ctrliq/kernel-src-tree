Bluetooth: btmtksdio: fix possible FW initialization failure

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-509.el8
commit-author Sean Wang <sean.wang@mediatek.com>
commit 7469720563e01f479ec5afe06bd6f440f965d523
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-509.el8/74697205.failed

According to FW advised sequence, mt7921s need to re-acquire privilege
immediately after the firmware download is complete before normal running.
Otherwise, it is still possible the bus may be stuck in an abnormal status
that causes FW initialization failure in the current driver.

Fixes: 752aea58489f ("Bluetooth: mt7921s: fix bus hang with wrong privilege")
Co-developed-by: Yake Yang <yake.yang@mediatek.com>
	Signed-off-by: Yake Yang <yake.yang@mediatek.com>
	Signed-off-by: Sean Wang <sean.wang@mediatek.com>
	Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
(cherry picked from commit 7469720563e01f479ec5afe06bd6f440f965d523)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/bluetooth/btmtksdio.c
diff --cc drivers/bluetooth/btmtksdio.c
index 6020fa3485e6,5d13c1f61bd3..000000000000
--- a/drivers/bluetooth/btmtksdio.c
+++ b/drivers/bluetooth/btmtksdio.c
@@@ -894,6 -848,309 +894,312 @@@ ignore_func_on
  	}
  	kfree_skb(skb);
  
++<<<<<<< HEAD
++=======
+ 	return 0;
+ }
+ 
+ static int mt79xx_setup(struct hci_dev *hdev, const char *fwname)
+ {
+ 	struct btmtksdio_dev *bdev = hci_get_drvdata(hdev);
+ 	struct btmtk_hci_wmt_params wmt_params;
+ 	u8 param = 0x1;
+ 	int err;
+ 
+ 	err = btmtk_setup_firmware_79xx(hdev, fwname, mtk_hci_wmt_sync);
+ 	if (err < 0) {
+ 		bt_dev_err(hdev, "Failed to setup 79xx firmware (%d)", err);
+ 		return err;
+ 	}
+ 
+ 	err = btmtksdio_fw_pmctrl(bdev);
+ 	if (err < 0)
+ 		return err;
+ 
+ 	err = btmtksdio_drv_pmctrl(bdev);
+ 	if (err < 0)
+ 		return err;
+ 
+ 	/* Enable Bluetooth protocol */
+ 	wmt_params.op = BTMTK_WMT_FUNC_CTRL;
+ 	wmt_params.flag = 0;
+ 	wmt_params.dlen = sizeof(param);
+ 	wmt_params.data = &param;
+ 	wmt_params.status = NULL;
+ 
+ 	err = mtk_hci_wmt_sync(hdev, &wmt_params);
+ 	if (err < 0) {
+ 		bt_dev_err(hdev, "Failed to send wmt func ctrl (%d)", err);
+ 		return err;
+ 	}
+ 
+ 	hci_set_msft_opcode(hdev, 0xFD30);
+ 	hci_set_aosp_capable(hdev);
+ 	set_bit(BTMTKSDIO_PATCH_ENABLED, &bdev->tx_state);
+ 
+ 	return err;
+ }
+ 
+ static int btmtksdio_mtk_reg_read(struct hci_dev *hdev, u32 reg, u32 *val)
+ {
+ 	struct btmtk_hci_wmt_params wmt_params;
+ 	struct reg_read_cmd reg_read = {
+ 		.type = 1,
+ 		.num = 1,
+ 	};
+ 	u32 status;
+ 	int err;
+ 
+ 	reg_read.addr = cpu_to_le32(reg);
+ 	wmt_params.op = BTMTK_WMT_REGISTER;
+ 	wmt_params.flag = BTMTK_WMT_REG_READ;
+ 	wmt_params.dlen = sizeof(reg_read);
+ 	wmt_params.data = &reg_read;
+ 	wmt_params.status = &status;
+ 
+ 	err = mtk_hci_wmt_sync(hdev, &wmt_params);
+ 	if (err < 0) {
+ 		bt_dev_err(hdev, "Failed to read reg (%d)", err);
+ 		return err;
+ 	}
+ 
+ 	*val = status;
+ 
+ 	return err;
+ }
+ 
+ static int btmtksdio_mtk_reg_write(struct hci_dev *hdev, u32 reg, u32 val, u32 mask)
+ {
+ 	struct btmtk_hci_wmt_params wmt_params;
+ 	const struct reg_write_cmd reg_write = {
+ 		.type = 1,
+ 		.num = 1,
+ 		.addr = cpu_to_le32(reg),
+ 		.data = cpu_to_le32(val),
+ 		.mask = cpu_to_le32(mask),
+ 	};
+ 	int err, status;
+ 
+ 	wmt_params.op = BTMTK_WMT_REGISTER;
+ 	wmt_params.flag = BTMTK_WMT_REG_WRITE;
+ 	wmt_params.dlen = sizeof(reg_write);
+ 	wmt_params.data = &reg_write;
+ 	wmt_params.status = &status;
+ 
+ 	err = mtk_hci_wmt_sync(hdev, &wmt_params);
+ 	if (err < 0)
+ 		bt_dev_err(hdev, "Failed to write reg (%d)", err);
+ 
+ 	return err;
+ }
+ 
+ static int btmtksdio_get_data_path_id(struct hci_dev *hdev, __u8 *data_path_id)
+ {
+ 	/* uses 1 as data path id for all the usecases */
+ 	*data_path_id = 1;
+ 	return 0;
+ }
+ 
+ static int btmtksdio_get_codec_config_data(struct hci_dev *hdev,
+ 					   __u8 link, struct bt_codec *codec,
+ 					   __u8 *ven_len, __u8 **ven_data)
+ {
+ 	int err = 0;
+ 
+ 	if (!ven_data || !ven_len)
+ 		return -EINVAL;
+ 
+ 	*ven_len = 0;
+ 	*ven_data = NULL;
+ 
+ 	if (link != ESCO_LINK) {
+ 		bt_dev_err(hdev, "Invalid link type(%u)", link);
+ 		return -EINVAL;
+ 	}
+ 
+ 	*ven_data = kmalloc(sizeof(__u8), GFP_KERNEL);
+ 	if (!*ven_data) {
+ 		err = -ENOMEM;
+ 		goto error;
+ 	}
+ 
+ 	/* supports only CVSD and mSBC offload codecs */
+ 	switch (codec->id) {
+ 	case 0x02:
+ 		**ven_data = 0x00;
+ 		break;
+ 	case 0x05:
+ 		**ven_data = 0x01;
+ 		break;
+ 	default:
+ 		err = -EINVAL;
+ 		bt_dev_err(hdev, "Invalid codec id(%u)", codec->id);
+ 		goto error;
+ 	}
+ 	/* codec and its capabilities are pre-defined to ids
+ 	 * preset id = 0x00 represents CVSD codec with sampling rate 8K
+ 	 * preset id = 0x01 represents mSBC codec with sampling rate 16K
+ 	 */
+ 	*ven_len = sizeof(__u8);
+ 	return err;
+ 
+ error:
+ 	kfree(*ven_data);
+ 	*ven_data = NULL;
+ 	return err;
+ }
+ 
+ static int btmtksdio_sco_setting(struct hci_dev *hdev)
+ {
+ 	const struct btmtk_sco sco_setting = {
+ 		.clock_config = 0x49,
+ 		.channel_format_config = 0x80,
+ 	};
+ 	struct sk_buff *skb;
+ 	u32 val;
+ 	int err;
+ 
+ 	/* Enable SCO over I2S/PCM for MediaTek chipset */
+ 	skb =  __hci_cmd_sync(hdev, 0xfc72, sizeof(sco_setting),
+ 			      &sco_setting, HCI_CMD_TIMEOUT);
+ 	if (IS_ERR(skb))
+ 		return PTR_ERR(skb);
+ 
+ 	kfree_skb(skb);
+ 
+ 	err = btmtksdio_mtk_reg_read(hdev, MT7921_PINMUX_0, &val);
+ 	if (err < 0)
+ 		return err;
+ 
+ 	val |= 0x11000000;
+ 	err = btmtksdio_mtk_reg_write(hdev, MT7921_PINMUX_0, val, ~0);
+ 	if (err < 0)
+ 		return err;
+ 
+ 	err = btmtksdio_mtk_reg_read(hdev, MT7921_PINMUX_1, &val);
+ 	if (err < 0)
+ 		return err;
+ 
+ 	val |= 0x00000101;
+ 	err =  btmtksdio_mtk_reg_write(hdev, MT7921_PINMUX_1, val, ~0);
+ 	if (err < 0)
+ 		return err;
+ 
+ 	hdev->get_data_path_id = btmtksdio_get_data_path_id;
+ 	hdev->get_codec_config_data = btmtksdio_get_codec_config_data;
+ 
+ 	return err;
+ }
+ 
+ static int btmtksdio_reset_setting(struct hci_dev *hdev)
+ {
+ 	int err;
+ 	u32 val;
+ 
+ 	err = btmtksdio_mtk_reg_read(hdev, MT7921_PINMUX_1, &val);
+ 	if (err < 0)
+ 		return err;
+ 
+ 	val |= 0x20; /* set the pin (bit field 11:8) work as GPIO mode */
+ 	err = btmtksdio_mtk_reg_write(hdev, MT7921_PINMUX_1, val, ~0);
+ 	if (err < 0)
+ 		return err;
+ 
+ 	err = btmtksdio_mtk_reg_read(hdev, MT7921_BTSYS_RST, &val);
+ 	if (err < 0)
+ 		return err;
+ 
+ 	val |= MT7921_BTSYS_RST_WITH_GPIO;
+ 	return btmtksdio_mtk_reg_write(hdev, MT7921_BTSYS_RST, val, ~0);
+ }
+ 
+ static int btmtksdio_setup(struct hci_dev *hdev)
+ {
+ 	struct btmtksdio_dev *bdev = hci_get_drvdata(hdev);
+ 	ktime_t calltime, delta, rettime;
+ 	unsigned long long duration;
+ 	char fwname[64];
+ 	int err, dev_id;
+ 	u32 fw_version = 0, val;
+ 
+ 	calltime = ktime_get();
+ 	set_bit(BTMTKSDIO_HW_TX_READY, &bdev->tx_state);
+ 
+ 	switch (bdev->data->chipid) {
+ 	case 0x7921:
+ 		if (test_bit(BTMTKSDIO_HW_RESET_ACTIVE, &bdev->tx_state)) {
+ 			err = btmtksdio_mtk_reg_read(hdev, MT7921_DLSTATUS,
+ 						     &val);
+ 			if (err < 0)
+ 				return err;
+ 
+ 			val &= ~BT_DL_STATE;
+ 			err = btmtksdio_mtk_reg_write(hdev, MT7921_DLSTATUS,
+ 						      val, ~0);
+ 			if (err < 0)
+ 				return err;
+ 
+ 			btmtksdio_fw_pmctrl(bdev);
+ 			msleep(20);
+ 			btmtksdio_drv_pmctrl(bdev);
+ 
+ 			clear_bit(BTMTKSDIO_HW_RESET_ACTIVE, &bdev->tx_state);
+ 		}
+ 
+ 		err = btmtksdio_mtk_reg_read(hdev, 0x70010200, &dev_id);
+ 		if (err < 0) {
+ 			bt_dev_err(hdev, "Failed to get device id (%d)", err);
+ 			return err;
+ 		}
+ 
+ 		err = btmtksdio_mtk_reg_read(hdev, 0x80021004, &fw_version);
+ 		if (err < 0) {
+ 			bt_dev_err(hdev, "Failed to get fw version (%d)", err);
+ 			return err;
+ 		}
+ 
+ 		snprintf(fwname, sizeof(fwname),
+ 			 "mediatek/BT_RAM_CODE_MT%04x_1_%x_hdr.bin",
+ 			 dev_id & 0xffff, (fw_version & 0xff) + 1);
+ 		err = mt79xx_setup(hdev, fwname);
+ 		if (err < 0)
+ 			return err;
+ 
+ 		/* Enable SCO over I2S/PCM */
+ 		err = btmtksdio_sco_setting(hdev);
+ 		if (err < 0) {
+ 			bt_dev_err(hdev, "Failed to enable SCO setting (%d)", err);
+ 			return err;
+ 		}
+ 
+ 		/* Enable WBS with mSBC codec */
+ 		set_bit(HCI_QUIRK_WIDEBAND_SPEECH_SUPPORTED, &hdev->quirks);
+ 
+ 		/* Enable GPIO reset mechanism */
+ 		if (bdev->reset) {
+ 			err = btmtksdio_reset_setting(hdev);
+ 			if (err < 0) {
+ 				bt_dev_err(hdev, "Failed to enable Reset setting (%d)", err);
+ 				devm_gpiod_put(bdev->dev, bdev->reset);
+ 				bdev->reset = NULL;
+ 			}
+ 		}
+ 
+ 		/* Valid LE States quirk for MediaTek 7921 */
+ 		set_bit(HCI_QUIRK_VALID_LE_STATES, &hdev->quirks);
+ 
+ 		break;
+ 	case 0x7663:
+ 	case 0x7668:
+ 		err = mt76xx_setup(hdev, bdev->data->fwname);
+ 		if (err < 0)
+ 			return err;
+ 		break;
+ 	default:
+ 		return -ENODEV;
+ 	}
+ 
++>>>>>>> 7469720563e0 (Bluetooth: btmtksdio: fix possible FW initialization failure)
  	rettime = ktime_get();
  	delta = ktime_sub(rettime, calltime);
  	duration = (unsigned long long)ktime_to_ns(delta) >> 10;
* Unmerged path drivers/bluetooth/btmtksdio.c
