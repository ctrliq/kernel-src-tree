Bluetooth: btmtksdio: enable msft opcode

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-509.el8
commit-author Łukasz Bartosik <lb@semihalf.com>
commit 630491ffd53cd2237445bd058e8d95662666947b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-509.el8/630491ff.failed

Enable msft opcode for mt7921 chip.

	Signed-off-by: Łukasz Bartosik <lb@semihalf.com>
	Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
(cherry picked from commit 630491ffd53cd2237445bd058e8d95662666947b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/bluetooth/btmtksdio.c
diff --cc drivers/bluetooth/btmtksdio.c
index 9bc3e3bd14e8,3a12ea0cf285..000000000000
--- a/drivers/bluetooth/btmtksdio.c
+++ b/drivers/bluetooth/btmtksdio.c
@@@ -882,6 -763,115 +882,118 @@@ ignore_func_on
  	}
  	kfree_skb(skb);
  
++<<<<<<< HEAD
++=======
+ 	return 0;
+ }
+ 
+ static int mt79xx_setup(struct hci_dev *hdev, const char *fwname)
+ {
+ 	struct btmtk_hci_wmt_params wmt_params;
+ 	u8 param = 0x1;
+ 	int err;
+ 
+ 	err = btmtk_setup_firmware_79xx(hdev, fwname, mtk_hci_wmt_sync);
+ 	if (err < 0) {
+ 		bt_dev_err(hdev, "Failed to setup 79xx firmware (%d)", err);
+ 		return err;
+ 	}
+ 
+ 	/* Enable Bluetooth protocol */
+ 	wmt_params.op = BTMTK_WMT_FUNC_CTRL;
+ 	wmt_params.flag = 0;
+ 	wmt_params.dlen = sizeof(param);
+ 	wmt_params.data = &param;
+ 	wmt_params.status = NULL;
+ 
+ 	err = mtk_hci_wmt_sync(hdev, &wmt_params);
+ 	if (err < 0) {
+ 		bt_dev_err(hdev, "Failed to send wmt func ctrl (%d)", err);
+ 		return err;
+ 	}
+ 
+ 	hci_set_msft_opcode(hdev, 0xFD30);
+ 
+ 	return err;
+ }
+ 
+ static int btsdio_mtk_reg_read(struct hci_dev *hdev, u32 reg, u32 *val)
+ {
+ 	struct btmtk_hci_wmt_params wmt_params;
+ 	struct reg_read_cmd {
+ 		u8 type;
+ 		u8 rsv;
+ 		u8 num;
+ 		__le32 addr;
+ 	} __packed reg_read = {
+ 		.type = 1,
+ 		.num = 1,
+ 	};
+ 	u32 status;
+ 	int err;
+ 
+ 	reg_read.addr = cpu_to_le32(reg);
+ 	wmt_params.op = BTMTK_WMT_REGISTER;
+ 	wmt_params.flag = BTMTK_WMT_REG_READ;
+ 	wmt_params.dlen = sizeof(reg_read);
+ 	wmt_params.data = &reg_read;
+ 	wmt_params.status = &status;
+ 
+ 	err = mtk_hci_wmt_sync(hdev, &wmt_params);
+ 	if (err < 0) {
+ 		bt_dev_err(hdev, "Failed to read reg(%d)", err);
+ 		return err;
+ 	}
+ 
+ 	*val = status;
+ 
+ 	return err;
+ }
+ 
+ static int btmtksdio_setup(struct hci_dev *hdev)
+ {
+ 	struct btmtksdio_dev *bdev = hci_get_drvdata(hdev);
+ 	ktime_t calltime, delta, rettime;
+ 	unsigned long long duration;
+ 	char fwname[64];
+ 	int err, dev_id;
+ 	u32 fw_version = 0;
+ 
+ 	calltime = ktime_get();
+ 	set_bit(BTMTKSDIO_HW_TX_READY, &bdev->tx_state);
+ 
+ 	switch (bdev->data->chipid) {
+ 	case 0x7921:
+ 		err = btsdio_mtk_reg_read(hdev, 0x70010200, &dev_id);
+ 		if (err < 0) {
+ 			bt_dev_err(hdev, "Failed to get device id (%d)", err);
+ 			return err;
+ 		}
+ 
+ 		err = btsdio_mtk_reg_read(hdev, 0x80021004, &fw_version);
+ 		if (err < 0) {
+ 			bt_dev_err(hdev, "Failed to get fw version (%d)", err);
+ 			return err;
+ 		}
+ 
+ 		snprintf(fwname, sizeof(fwname),
+ 			 "mediatek/BT_RAM_CODE_MT%04x_1_%x_hdr.bin",
+ 			 dev_id & 0xffff, (fw_version & 0xff) + 1);
+ 		err = mt79xx_setup(hdev, fwname);
+ 		if (err < 0)
+ 			return err;
+ 		break;
+ 	case 0x7663:
+ 	case 0x7668:
+ 		err = mt76xx_setup(hdev, bdev->data->fwname);
+ 		if (err < 0)
+ 			return err;
+ 		break;
+ 	default:
+ 		return -ENODEV;
+ 	}
+ 
++>>>>>>> 630491ffd53c (Bluetooth: btmtksdio: enable msft opcode)
  	rettime = ktime_get();
  	delta = ktime_sub(rettime, calltime);
  	duration = (unsigned long long)ktime_to_ns(delta) >> 10;
* Unmerged path drivers/bluetooth/btmtksdio.c
