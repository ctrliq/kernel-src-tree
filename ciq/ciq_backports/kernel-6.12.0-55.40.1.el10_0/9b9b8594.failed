scsi: fnic: Add and improve logs in FDMI and FDMI ABTS paths

jira LE-4569
Rebuild_History Non-Buildable kernel-6.12.0-55.40.1.el10_0
commit-author Karan Tilak Kumar <kartilak@cisco.com>
commit 9b9b8594654a79e3d4166356fd86cd5397477b24
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-6.12.0-55.40.1.el10_0/9b9b8594.failed

Add logs in FDMI and FDMI ABTS paths.

Modify log text in these paths.

	Reviewed-by: Sesidhar Baddela <sebaddel@cisco.com>
	Reviewed-by: Arulprabhu Ponnusamy <arulponn@cisco.com>
	Reviewed-by: Gian Carlo Boffa <gcboffa@cisco.com>
	Reviewed-by: Arun Easi <aeasi@cisco.com>
	Reviewed-by: John Meneghini <jmeneghi@redhat.com>
	Signed-off-by: Karan Tilak Kumar <kartilak@cisco.com>
Link: https://lore.kernel.org/r/20250618003431.6314-3-kartilak@cisco.com
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 9b9b8594654a79e3d4166356fd86cd5397477b24)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/fnic/fdls_disc.c
diff --cc drivers/scsi/fnic/fdls_disc.c
index a9ffa7b63730,ae37f85f618b..000000000000
--- a/drivers/scsi/fnic/fdls_disc.c
+++ b/drivers/scsi/fnic/fdls_disc.c
@@@ -785,21 -782,55 +785,73 @@@ static void fdls_send_fdmi_abts(struct 
  	fdls_init_fabric_abts_frame(frame, iport);
  
  	hton24(d_id, FC_FID_MGMT_SERV);
++<<<<<<< HEAD
 +	FNIC_STD_SET_D_ID(*pfabric_abts, d_id);
 +
 +	if (iport->fabric.fdmi_pending & FDLS_FDMI_PLOGI_PENDING) {
 +		oxid = iport->active_oxid_fdmi_plogi;
 +		FNIC_STD_SET_OX_ID(*pfabric_abts, oxid);
 +		fnic_send_fcoe_frame(iport, frame, frame_size);
 +	} else {
 +		if (iport->fabric.fdmi_pending & FDLS_FDMI_REG_HBA_PENDING) {
 +			oxid = iport->active_oxid_fdmi_rhba;
 +			FNIC_STD_SET_OX_ID(*pfabric_abts, oxid);
 +			fnic_send_fcoe_frame(iport, frame, frame_size);
 +		}
 +		if (iport->fabric.fdmi_pending & FDLS_FDMI_RPA_PENDING) {
 +			oxid = iport->active_oxid_fdmi_rpa;
 +			FNIC_STD_SET_OX_ID(*pfabric_abts, oxid);
++=======
+ 	FNIC_STD_SET_D_ID(*pfdmi_abts, d_id);
+ 	FNIC_STD_SET_OX_ID(*pfdmi_abts, oxid);
+ 
+ 	return frame;
+ }
+ 
+ static void fdls_send_fdmi_abts(struct fnic_iport_s *iport)
+ {
+ 	uint8_t *frame;
+ 	struct fnic *fnic = iport->fnic;
+ 	unsigned long fdmi_tov;
+ 	uint16_t frame_size = FNIC_ETH_FCOE_HDRS_OFFSET +
+ 			sizeof(struct fc_frame_header);
+ 
+ 	if (iport->fabric.fdmi_pending & FDLS_FDMI_PLOGI_PENDING) {
+ 		frame = fdls_alloc_init_fdmi_abts_frame(iport,
+ 						iport->active_oxid_fdmi_plogi);
+ 		if (frame == NULL)
+ 			return;
+ 
+ 		FNIC_FCS_DBG(KERN_INFO, fnic->host, fnic->fnic_num,
+ 			 "0x%x: FDLS send FDMI PLOGI abts. iport->fabric.state: %d oxid: 0x%x",
+ 			 iport->fcid, iport->fabric.state, iport->active_oxid_fdmi_plogi);
+ 		fnic_send_fcoe_frame(iport, frame, frame_size);
+ 	} else {
+ 		if (iport->fabric.fdmi_pending & FDLS_FDMI_REG_HBA_PENDING) {
+ 			frame = fdls_alloc_init_fdmi_abts_frame(iport,
+ 						iport->active_oxid_fdmi_rhba);
+ 			if (frame == NULL)
+ 				return;
+ 
+ 			FNIC_FCS_DBG(KERN_INFO, fnic->host, fnic->fnic_num,
+ 				 "0x%x: FDLS send FDMI RHBA abts. iport->fabric.state: %d oxid: 0x%x",
+ 				 iport->fcid, iport->fabric.state, iport->active_oxid_fdmi_rhba);
+ 			fnic_send_fcoe_frame(iport, frame, frame_size);
+ 		}
+ 		if (iport->fabric.fdmi_pending & FDLS_FDMI_RPA_PENDING) {
+ 			frame = fdls_alloc_init_fdmi_abts_frame(iport,
+ 						iport->active_oxid_fdmi_rpa);
+ 			if (frame == NULL) {
+ 				if (iport->fabric.fdmi_pending & FDLS_FDMI_REG_HBA_PENDING)
+ 					goto arm_timer;
+ 				else
+ 					return;
+ 			}
+ 
+ 			FNIC_FCS_DBG(KERN_INFO, fnic->host, fnic->fnic_num,
+ 				 "0x%x: FDLS send FDMI RPA abts. iport->fabric.state: %d oxid: 0x%x",
+ 				 iport->fcid, iport->fabric.state, iport->active_oxid_fdmi_rpa);
++>>>>>>> 9b9b8594654a (scsi: fnic: Add and improve logs in FDMI and FDMI ABTS paths)
  			fnic_send_fcoe_frame(iport, frame, frame_size);
  		}
  	}
@@@ -2282,26 -2332,30 +2338,37 @@@ void fdls_fdmi_timer_callback(struct ti
  	 * Schedule to free the OXID after 2*r_a_tov and proceed
  	 */
  	if (iport->fabric.fdmi_pending & FDLS_FDMI_PLOGI_PENDING) {
+ 		FNIC_FCS_DBG(KERN_INFO, fnic->host, fnic->fnic_num,
+ 			"FDMI PLOGI ABTS timed out. Schedule oxid free: 0x%x\n",
+ 			iport->active_oxid_fdmi_plogi);
  		fdls_schedule_oxid_free(iport, &iport->active_oxid_fdmi_plogi);
  	} else {
- 		if (iport->fabric.fdmi_pending & FDLS_FDMI_REG_HBA_PENDING)
+ 		if (iport->fabric.fdmi_pending & FDLS_FDMI_REG_HBA_PENDING) {
+ 			FNIC_FCS_DBG(KERN_INFO, fnic->host, fnic->fnic_num,
+ 						"FDMI RHBA ABTS timed out. Schedule oxid free: 0x%x\n",
+ 						iport->active_oxid_fdmi_rhba);
  			fdls_schedule_oxid_free(iport, &iport->active_oxid_fdmi_rhba);
- 		if (iport->fabric.fdmi_pending & FDLS_FDMI_RPA_PENDING)
+ 		}
+ 		if (iport->fabric.fdmi_pending & FDLS_FDMI_RPA_PENDING) {
+ 			FNIC_FCS_DBG(KERN_INFO, fnic->host, fnic->fnic_num,
+ 						"FDMI RPA ABTS timed out. Schedule oxid free: 0x%x\n",
+ 						iport->active_oxid_fdmi_rpa);
  			fdls_schedule_oxid_free(iport, &iport->active_oxid_fdmi_rpa);
+ 		}
  	}
  	FNIC_FCS_DBG(KERN_INFO, fnic->host, fnic->fnic_num,
- 		"fdmi timer callback : 0x%x\n", iport->fabric.fdmi_pending);
+ 		"iport->fabric.fdmi_pending: 0x%x\n", iport->fabric.fdmi_pending);
  
 -	fdls_fdmi_retry_plogi(iport);
 +	iport->fabric.fdmi_pending = 0;
 +	/* If max retries not exhaused, start over from fdmi plogi */
 +	if (iport->fabric.fdmi_retry < FDLS_FDMI_MAX_RETRY) {
 +		iport->fabric.fdmi_retry++;
 +		FNIC_FCS_DBG(KERN_INFO, fnic->host, fnic->fnic_num,
 +					 "retry fdmi timer %d", iport->fabric.fdmi_retry);
 +		fdls_send_fdmi_plogi(iport);
 +	}
  	FNIC_FCS_DBG(KERN_INFO, fnic->host, fnic->fnic_num,
- 		"fdmi timer callback : 0x%x\n", iport->fabric.fdmi_pending);
+ 		"iport->fabric.fdmi_pending: 0x%x\n", iport->fabric.fdmi_pending);
  	spin_unlock_irqrestore(&fnic->fnic_lock, flags);
  }
  
@@@ -3716,13 -3770,60 +3783,68 @@@ static void fdls_process_fdmi_abts_rsp(
  
  	switch (FNIC_FRAME_TYPE(oxid)) {
  	case FNIC_FRAME_TYPE_FDMI_PLOGI:
+ 		FNIC_FCS_DBG(KERN_INFO, fnic->host, fnic->fnic_num,
+ 			"Received FDMI PLOGI ABTS rsp with oxid: 0x%x", oxid);
+ 		FNIC_FCS_DBG(KERN_INFO, fnic->host, fnic->fnic_num,
+ 			 "0x%x: iport->fabric.fdmi_pending: 0x%x",
+ 			 iport->fcid, iport->fabric.fdmi_pending);
  		fdls_free_oxid(iport, oxid, &iport->active_oxid_fdmi_plogi);
++<<<<<<< HEAD
 +		break;
 +	case FNIC_FRAME_TYPE_FDMI_RHBA:
++=======
+ 
+ 		iport->fabric.fdmi_pending &= ~FDLS_FDMI_PLOGI_PENDING;
+ 		iport->fabric.fdmi_pending &= ~FDLS_FDMI_ABORT_PENDING;
+ 		FNIC_FCS_DBG(KERN_INFO, fnic->host, fnic->fnic_num,
+ 			 "0x%x: iport->fabric.fdmi_pending: 0x%x",
+ 			 iport->fcid, iport->fabric.fdmi_pending);
+ 		break;
+ 	case FNIC_FRAME_TYPE_FDMI_RHBA:
+ 		FNIC_FCS_DBG(KERN_INFO, fnic->host, fnic->fnic_num,
+ 			"Received FDMI RHBA ABTS rsp with oxid: 0x%x", oxid);
+ 		FNIC_FCS_DBG(KERN_INFO, fnic->host, fnic->fnic_num,
+ 			 "0x%x: iport->fabric.fdmi_pending: 0x%x",
+ 			 iport->fcid, iport->fabric.fdmi_pending);
+ 
+ 		iport->fabric.fdmi_pending &= ~FDLS_FDMI_REG_HBA_PENDING;
+ 
+ 		/* If RPA is still pending, don't turn off ABORT PENDING.
+ 		 * We count on the timer to detect the ABTS timeout and take
+ 		 * corrective action.
+ 		 */
+ 		if (!(iport->fabric.fdmi_pending & FDLS_FDMI_RPA_PENDING))
+ 			iport->fabric.fdmi_pending &= ~FDLS_FDMI_ABORT_PENDING;
+ 
++>>>>>>> 9b9b8594654a (scsi: fnic: Add and improve logs in FDMI and FDMI ABTS paths)
  		fdls_free_oxid(iport, oxid, &iport->active_oxid_fdmi_rhba);
+ 		FNIC_FCS_DBG(KERN_INFO, fnic->host, fnic->fnic_num,
+ 			 "0x%x: iport->fabric.fdmi_pending: 0x%x",
+ 			 iport->fcid, iport->fabric.fdmi_pending);
  		break;
  	case FNIC_FRAME_TYPE_FDMI_RPA:
++<<<<<<< HEAD
++=======
+ 		FNIC_FCS_DBG(KERN_INFO, fnic->host, fnic->fnic_num,
+ 			"Received FDMI RPA ABTS rsp with oxid: 0x%x", oxid);
+ 		FNIC_FCS_DBG(KERN_INFO, fnic->host, fnic->fnic_num,
+ 			 "0x%x: iport->fabric.fdmi_pending: 0x%x",
+ 			 iport->fcid, iport->fabric.fdmi_pending);
+ 
+ 		iport->fabric.fdmi_pending &= ~FDLS_FDMI_RPA_PENDING;
+ 
+ 		/* If RHBA is still pending, don't turn off ABORT PENDING.
+ 		 * We count on the timer to detect the ABTS timeout and take
+ 		 * corrective action.
+ 		 */
+ 		if (!(iport->fabric.fdmi_pending & FDLS_FDMI_REG_HBA_PENDING))
+ 			iport->fabric.fdmi_pending &= ~FDLS_FDMI_ABORT_PENDING;
+ 
++>>>>>>> 9b9b8594654a (scsi: fnic: Add and improve logs in FDMI and FDMI ABTS paths)
  		fdls_free_oxid(iport, oxid, &iport->active_oxid_fdmi_rpa);
+ 		FNIC_FCS_DBG(KERN_INFO, fnic->host, fnic->fnic_num,
+ 			 "0x%x: iport->fabric.fdmi_pending: 0x%x",
+ 			 iport->fcid, iport->fabric.fdmi_pending);
  		break;
  	default:
  		FNIC_FCS_DBG(KERN_INFO, fnic->host, fnic->fnic_num,
* Unmerged path drivers/scsi/fnic/fdls_disc.c
