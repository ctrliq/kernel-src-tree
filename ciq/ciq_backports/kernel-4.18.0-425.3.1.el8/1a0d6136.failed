mptcp: local addresses fullmesh

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-425.3.1.el8
commit-author Geliang Tang <geliangtang@xiaomi.com>
commit 1a0d6136c5f0af62850b0f4a27e75e1ca4bbcdda
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-425.3.1.el8/1a0d6136.failed

In mptcp_pm_nl_add_addr_received(), fill a temporary allocate array of
all local address corresponding to the fullmesh endpoint. If such array
is empty, keep the current behavior.

Elsewhere loop on such array and create a subflow for each local address
towards the given remote address

	Suggested-by: Paolo Abeni <pabeni@redhat.com>
	Signed-off-by: Geliang Tang <geliangtang@xiaomi.com>
	Signed-off-by: Mat Martineau <mathew.j.martineau@linux.intel.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 1a0d6136c5f0af62850b0f4a27e75e1ca4bbcdda)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/mptcp/pm_netlink.c
diff --cc net/mptcp/pm_netlink.c
index f65c5d4f7f45,6e3df62a87d2..000000000000
--- a/net/mptcp/pm_netlink.c
+++ b/net/mptcp/pm_netlink.c
@@@ -539,9 -593,8 +593,12 @@@ static void mptcp_pm_nl_add_addr_receiv
  	struct sock *sk = (struct sock *)msk;
  	unsigned int add_addr_accept_max;
  	struct mptcp_addr_info remote;
- 	struct mptcp_addr_info local;
  	unsigned int subflows_max;
++<<<<<<< HEAD
 +	bool reset_port = false;
++=======
+ 	int i, nr;
++>>>>>>> 1a0d6136c5f0 (mptcp: local addresses fullmesh)
  
  	add_addr_accept_max = mptcp_pm_get_add_addr_accept_max(msk);
  	subflows_max = mptcp_pm_get_subflows_max(msk);
@@@ -550,38 -603,29 +607,54 @@@
  		 msk->pm.add_addr_accepted, add_addr_accept_max,
  		 msk->pm.remote.family);
  
 -	if (lookup_subflow_by_daddr(&msk->conn_list, &msk->pm.remote))
 +	remote = msk->pm.remote;
 +	if (lookup_subflow_by_daddr(&msk->conn_list, &remote))
  		goto add_addr_echo;
  
++<<<<<<< HEAD
 +	msk->pm.add_addr_accepted++;
 +	msk->pm.subflows++;
 +	if (msk->pm.add_addr_accepted >= add_addr_accept_max ||
 +	    msk->pm.subflows >= subflows_max)
 +		WRITE_ONCE(msk->pm.accept_addr, false);
 +
 +	/* pick id 0 port, if none is provided the remote address */
 +	if (!remote.port) {
 +		reset_port = true;
 +		remote.port = sk->sk_dport;
 +	}
 +
 +	/* connect to the specified remote address, using whatever
 +	 * local address the routing configuration will pick.
 +	 */
 +	memset(&local, 0, sizeof(local));
 +	local.family = remote.family;
++=======
+ 	/* connect to the specified remote address, using whatever
+ 	 * local address the routing configuration will pick.
+ 	 */
+ 	remote = msk->pm.remote;
+ 	if (!remote.port)
+ 		remote.port = sk->sk_dport;
+ 	nr = fill_local_addresses_vec(msk, addrs);
+ 
+ 	msk->pm.add_addr_accepted++;
+ 	if (msk->pm.add_addr_accepted >= add_addr_accept_max ||
+ 	    msk->pm.subflows >= subflows_max)
+ 		WRITE_ONCE(msk->pm.accept_addr, false);
++>>>>>>> 1a0d6136c5f0 (mptcp: local addresses fullmesh)
  
  	spin_unlock_bh(&msk->pm.lock);
- 	__mptcp_subflow_connect(sk, &local, &remote);
+ 	for (i = 0; i < nr; i++)
+ 		__mptcp_subflow_connect(sk, &addrs[i], &remote);
  	spin_lock_bh(&msk->pm.lock);
  
 +	/* be sure to echo exactly the received address */
 +	if (reset_port)
 +		remote.port = 0;
 +
  add_addr_echo:
 -	mptcp_pm_announce_addr(msk, &msk->pm.remote, true);
 +	mptcp_pm_announce_addr(msk, &remote, true);
  	mptcp_pm_nl_addr_send_ack(msk);
  }
  
* Unmerged path net/mptcp/pm_netlink.c
