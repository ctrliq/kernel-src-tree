x86/speculation/mmio: Add mitigation for Processor MMIO Stale Data

jira LE-1907
cve CVE-2022-21166
cve CVE-2022-21125
cve CVE-2022-21123
Rebuild_History Non-Buildable kernel-4.18.0-425.3.1.el8
commit-author Pawan Gupta <pawan.kumar.gupta@linux.intel.com>
commit 8cb861e9e3c9a55099ad3d08e1a3b653d29c33ca
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-425.3.1.el8/8cb861e9.failed

Processor MMIO Stale Data is a class of vulnerabilities that may
expose data after an MMIO operation. For details please refer to
Documentation/admin-guide/hw-vuln/processor_mmio_stale_data.rst.

These vulnerabilities are broadly categorized as:

Device Register Partial Write (DRPW):
  Some endpoint MMIO registers incorrectly handle writes that are
  smaller than the register size. Instead of aborting the write or only
  copying the correct subset of bytes (for example, 2 bytes for a 2-byte
  write), more bytes than specified by the write transaction may be
  written to the register. On some processors, this may expose stale
  data from the fill buffers of the core that created the write
  transaction.

Shared Buffers Data Sampling (SBDS):
  After propagators may have moved data around the uncore and copied
  stale data into client core fill buffers, processors affected by MFBDS
  can leak data from the fill buffer.

Shared Buffers Data Read (SBDR):
  It is similar to Shared Buffer Data Sampling (SBDS) except that the
  data is directly read into the architectural software-visible state.

An attacker can use these vulnerabilities to extract data from CPU fill
buffers using MDS and TAA methods. Mitigate it by clearing the CPU fill
buffers using the VERW instruction before returning to a user or a
guest.

On CPUs not affected by MDS and TAA, user application cannot sample data
from CPU fill buffers using MDS or TAA. A guest with MMIO access can
still use DRPW or SBDR to extract data architecturally. Mitigate it with
VERW instruction to clear fill buffers before VMENTER for MMIO capable
guests.

Add a kernel parameter mmio_stale_data={off|full|full,nosmt} to control
the mitigation.

	Signed-off-by: Pawan Gupta <pawan.kumar.gupta@linux.intel.com>
	Signed-off-by: Borislav Petkov <bp@suse.de>
(cherry picked from commit 8cb861e9e3c9a55099ad3d08e1a3b653d29c33ca)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/admin-guide/kernel-parameters.txt
#	arch/x86/include/asm/nospec-branch.h
#	arch/x86/kernel/cpu/bugs.c
diff --cc Documentation/admin-guide/kernel-parameters.txt
index e078ec640fa5,c4893782055b..000000000000
--- a/Documentation/admin-guide/kernel-parameters.txt
+++ b/Documentation/admin-guide/kernel-parameters.txt
@@@ -2766,9 -3102,10 +2766,13 @@@
  					       l1tf=off [X86]
  					       mds=off [X86]
  					       tsx_async_abort=off [X86]
 -					       kvm.nx_huge_pages=off [X86]
  					       no_entry_flush [PPC]
  					       no_uaccess_flush [PPC]
++<<<<<<< HEAD
 +					       kvm.nx_huge_pages=off [X86]
++=======
+ 					       mmio_stale_data=off [X86]
++>>>>>>> 8cb861e9e3c9 (x86/speculation/mmio: Add mitigation for Processor MMIO Stale Data)
  
  				Exceptions:
  					       This does not have any effect on
diff --cc arch/x86/include/asm/nospec-branch.h
index c25499f99085,da251a5645b0..000000000000
--- a/arch/x86/include/asm/nospec-branch.h
+++ b/arch/x86/include/asm/nospec-branch.h
@@@ -305,6 -267,10 +305,13 @@@ DECLARE_STATIC_KEY_FALSE(switch_mm_alwa
  DECLARE_STATIC_KEY_FALSE(mds_user_clear);
  DECLARE_STATIC_KEY_FALSE(mds_idle_clear);
  
++<<<<<<< HEAD
++=======
+ DECLARE_STATIC_KEY_FALSE(switch_mm_cond_l1d_flush);
+ 
+ DECLARE_STATIC_KEY_FALSE(mmio_stale_data_clear);
+ 
++>>>>>>> 8cb861e9e3c9 (x86/speculation/mmio: Add mitigation for Processor MMIO Stale Data)
  #include <asm/segment.h>
  
  /**
diff --cc arch/x86/kernel/cpu/bugs.c
index f6dceabb4029,7b01ba9bc701..000000000000
--- a/arch/x86/kernel/cpu/bugs.c
+++ b/arch/x86/kernel/cpu/bugs.c
@@@ -44,7 -43,9 +44,8 @@@ static void __init l1tf_select_mitigati
  static void __init mds_select_mitigation(void);
  static void __init md_clear_update_mitigation(void);
  static void __init taa_select_mitigation(void);
+ static void __init mmio_select_mitigation(void);
  static void __init srbds_select_mitigation(void);
 -static void __init l1d_flush_select_mitigation(void);
  
  /* The base value of the SPEC_CTRL MSR that always has to be preserved. */
  u64 x86_spec_ctrl_base;
@@@ -78,6 -79,17 +79,20 @@@ EXPORT_SYMBOL_GPL(mds_user_clear)
  DEFINE_STATIC_KEY_FALSE(mds_idle_clear);
  EXPORT_SYMBOL_GPL(mds_idle_clear);
  
++<<<<<<< HEAD
++=======
+ /*
+  * Controls whether l1d flush based mitigations are enabled,
+  * based on hw features and admin setting via boot parameter
+  * defaults to false
+  */
+ DEFINE_STATIC_KEY_FALSE(switch_mm_cond_l1d_flush);
+ 
+ /* Controls CPU Fill buffer clear before KVM guest MMIO accesses */
+ DEFINE_STATIC_KEY_FALSE(mmio_stale_data_clear);
+ EXPORT_SYMBOL_GPL(mmio_stale_data_clear);
+ 
++>>>>>>> 8cb861e9e3c9 (x86/speculation/mmio: Add mitigation for Processor MMIO Stale Data)
  void __init check_bugs(void)
  {
  	identify_boot_cpu();
@@@ -116,11 -124,14 +131,13 @@@
  	l1tf_select_mitigation();
  	mds_select_mitigation();
  	taa_select_mitigation();
+ 	mmio_select_mitigation();
  	srbds_select_mitigation();
 -	l1d_flush_select_mitigation();
  
  	/*
- 	 * As MDS and TAA mitigations are inter-related, update and print their
- 	 * mitigation after TAA mitigation selection is done.
+ 	 * As MDS, TAA and MMIO Stale Data mitigations are inter-related, update
+ 	 * and print their mitigation after MDS, TAA and MMIO Stale Data
+ 	 * mitigation selection is done.
  	 */
  	md_clear_update_mitigation();
  
* Unmerged path Documentation/admin-guide/kernel-parameters.txt
* Unmerged path arch/x86/include/asm/nospec-branch.h
* Unmerged path arch/x86/kernel/cpu/bugs.c
diff --git a/arch/x86/kvm/vmx/vmx.c b/arch/x86/kvm/vmx/vmx.c
index 020468feb063..be716022bf17 100644
--- a/arch/x86/kvm/vmx/vmx.c
+++ b/arch/x86/kvm/vmx/vmx.c
@@ -6774,6 +6774,9 @@ static noinstr void vmx_vcpu_enter_exit(struct kvm_vcpu *vcpu,
 		vmx_l1d_flush(vcpu);
 	else if (static_branch_unlikely(&mds_user_clear))
 		mds_clear_cpu_buffers();
+	else if (static_branch_unlikely(&mmio_stale_data_clear) &&
+		 kvm_arch_has_assigned_device(vcpu->kvm))
+		mds_clear_cpu_buffers();
 
 	if (vcpu->arch.cr2 != native_read_cr2())
 		native_write_cr2(vcpu->arch.cr2);
