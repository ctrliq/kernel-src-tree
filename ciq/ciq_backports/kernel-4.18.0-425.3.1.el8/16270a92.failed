PCI: designware-ep: Fix the Header Type check

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-425.3.1.el8
commit-author Hou Zhiqiang <Zhiqiang.Hou@nxp.com>
commit 16270a92355722e387e9ca19627c5a4d7bae1354
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-425.3.1.el8/16270a92.failed

The current check will result in the multiple function device
fails to initialize. So fix the check by masking out the
multiple function bit.

Link: https://lore.kernel.org/r/20200818092746.24366-1-Zhiqiang.Hou@nxp.com
Fixes: 0b24134f7888 ("PCI: dwc: Add validation that PCIe core is set to correct mode")
	Signed-off-by: Hou Zhiqiang <Zhiqiang.Hou@nxp.com>
	Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
	Reviewed-by: Rob Herring <robh@kernel.org>
(cherry picked from commit 16270a92355722e387e9ca19627c5a4d7bae1354)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/pci/controller/dwc/pcie-designware-ep.c
diff --cc drivers/pci/controller/dwc/pcie-designware-ep.c
index de8635af4cde,29f5c616c3bc..000000000000
--- a/drivers/pci/controller/dwc/pcie-designware-ep.c
+++ b/drivers/pci/controller/dwc/pcie-designware-ep.c
@@@ -490,6 -478,64 +490,67 @@@ void dw_pcie_ep_exit(struct dw_pcie_ep 
  	pci_epc_mem_exit(epc);
  }
  
++<<<<<<< HEAD
++=======
+ static unsigned int dw_pcie_ep_find_ext_capability(struct dw_pcie *pci, int cap)
+ {
+ 	u32 header;
+ 	int pos = PCI_CFG_SPACE_SIZE;
+ 
+ 	while (pos) {
+ 		header = dw_pcie_readl_dbi(pci, pos);
+ 		if (PCI_EXT_CAP_ID(header) == cap)
+ 			return pos;
+ 
+ 		pos = PCI_EXT_CAP_NEXT(header);
+ 		if (!pos)
+ 			break;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ int dw_pcie_ep_init_complete(struct dw_pcie_ep *ep)
+ {
+ 	struct dw_pcie *pci = to_dw_pcie_from_ep(ep);
+ 	unsigned int offset;
+ 	unsigned int nbars;
+ 	u8 hdr_type;
+ 	u32 reg;
+ 	int i;
+ 
+ 	hdr_type = dw_pcie_readb_dbi(pci, PCI_HEADER_TYPE) &
+ 		   PCI_HEADER_TYPE_MASK;
+ 	if (hdr_type != PCI_HEADER_TYPE_NORMAL) {
+ 		dev_err(pci->dev,
+ 			"PCIe controller is not set to EP mode (hdr_type:0x%x)!\n",
+ 			hdr_type);
+ 		return -EIO;
+ 	}
+ 
+ 	ep->msi_cap = dw_pcie_find_capability(pci, PCI_CAP_ID_MSI);
+ 
+ 	ep->msix_cap = dw_pcie_find_capability(pci, PCI_CAP_ID_MSIX);
+ 
+ 	offset = dw_pcie_ep_find_ext_capability(pci, PCI_EXT_CAP_ID_REBAR);
+ 	if (offset) {
+ 		reg = dw_pcie_readl_dbi(pci, offset + PCI_REBAR_CTRL);
+ 		nbars = (reg & PCI_REBAR_CTRL_NBAR_MASK) >>
+ 			PCI_REBAR_CTRL_NBAR_SHIFT;
+ 
+ 		dw_pcie_dbi_ro_wr_en(pci);
+ 		for (i = 0; i < nbars; i++, offset += PCI_REBAR_CTRL)
+ 			dw_pcie_writel_dbi(pci, offset + PCI_REBAR_CAP, 0x0);
+ 		dw_pcie_dbi_ro_wr_dis(pci);
+ 	}
+ 
+ 	dw_pcie_setup(pci);
+ 
+ 	return 0;
+ }
+ EXPORT_SYMBOL_GPL(dw_pcie_ep_init_complete);
+ 
++>>>>>>> 16270a923557 (PCI: designware-ep: Fix the Header Type check)
  int dw_pcie_ep_init(struct dw_pcie_ep *ep)
  {
  	int ret;
* Unmerged path drivers/pci/controller/dwc/pcie-designware-ep.c
diff --git a/include/uapi/linux/pci_regs.h b/include/uapi/linux/pci_regs.h
index 0900b2c3a3eb..0241ef2c5fc8 100644
--- a/include/uapi/linux/pci_regs.h
+++ b/include/uapi/linux/pci_regs.h
@@ -76,6 +76,7 @@
 #define PCI_CACHE_LINE_SIZE	0x0c	/* 8 bits */
 #define PCI_LATENCY_TIMER	0x0d	/* 8 bits */
 #define PCI_HEADER_TYPE		0x0e	/* 8 bits */
+#define  PCI_HEADER_TYPE_MASK		0x7f
 #define  PCI_HEADER_TYPE_NORMAL		0
 #define  PCI_HEADER_TYPE_BRIDGE		1
 #define  PCI_HEADER_TYPE_CARDBUS	2
