devres: fix typos in comments

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-425.3.1.el8
commit-author Julia Lawall <Julia.Lawall@inria.fr>
commit 451fd6ee1adb7ca28277023e450708cb9061edb2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-425.3.1.el8/451fd6ee.failed

Various spelling mistakes in comments.
Detected with the help of Coccinelle.

	Signed-off-by: Julia Lawall <Julia.Lawall@inria.fr>

Link: https://lore.kernel.org/r/20220314115354.144023-19-Julia.Lawall@inria.fr
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 451fd6ee1adb7ca28277023e450708cb9061edb2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/base/devres.c
diff --cc drivers/base/devres.c
index fc9d6e521cbc,864d0b3f566e..000000000000
--- a/drivers/base/devres.c
+++ b/drivers/base/devres.c
@@@ -816,6 -835,103 +816,106 @@@ void * devm_kmalloc(struct device *dev
  EXPORT_SYMBOL_GPL(devm_kmalloc);
  
  /**
++<<<<<<< HEAD
++=======
+  * devm_krealloc - Resource-managed krealloc()
+  * @dev: Device to re-allocate memory for
+  * @ptr: Pointer to the memory chunk to re-allocate
+  * @new_size: New allocation size
+  * @gfp: Allocation gfp flags
+  *
+  * Managed krealloc(). Resizes the memory chunk allocated with devm_kmalloc().
+  * Behaves similarly to regular krealloc(): if @ptr is NULL or ZERO_SIZE_PTR,
+  * it's the equivalent of devm_kmalloc(). If new_size is zero, it frees the
+  * previously allocated memory and returns ZERO_SIZE_PTR. This function doesn't
+  * change the order in which the release callback for the re-alloc'ed devres
+  * will be called (except when falling back to devm_kmalloc() or when freeing
+  * resources when new_size is zero). The contents of the memory are preserved
+  * up to the lesser of new and old sizes.
+  */
+ void *devm_krealloc(struct device *dev, void *ptr, size_t new_size, gfp_t gfp)
+ {
+ 	size_t total_new_size, total_old_size;
+ 	struct devres *old_dr, *new_dr;
+ 	unsigned long flags;
+ 
+ 	if (unlikely(!new_size)) {
+ 		devm_kfree(dev, ptr);
+ 		return ZERO_SIZE_PTR;
+ 	}
+ 
+ 	if (unlikely(ZERO_OR_NULL_PTR(ptr)))
+ 		return devm_kmalloc(dev, new_size, gfp);
+ 
+ 	if (WARN_ON(is_kernel_rodata((unsigned long)ptr)))
+ 		/*
+ 		 * We cannot reliably realloc a const string returned by
+ 		 * devm_kstrdup_const().
+ 		 */
+ 		return NULL;
+ 
+ 	if (!check_dr_size(new_size, &total_new_size))
+ 		return NULL;
+ 
+ 	total_old_size = ksize(container_of(ptr, struct devres, data));
+ 	if (total_old_size == 0) {
+ 		WARN(1, "Pointer doesn't point to dynamically allocated memory.");
+ 		return NULL;
+ 	}
+ 
+ 	/*
+ 	 * If new size is smaller or equal to the actual number of bytes
+ 	 * allocated previously - just return the same pointer.
+ 	 */
+ 	if (total_new_size <= total_old_size)
+ 		return ptr;
+ 
+ 	/*
+ 	 * Otherwise: allocate new, larger chunk. We need to allocate before
+ 	 * taking the lock as most probably the caller uses GFP_KERNEL.
+ 	 */
+ 	new_dr = alloc_dr(devm_kmalloc_release,
+ 			  total_new_size, gfp, dev_to_node(dev));
+ 	if (!new_dr)
+ 		return NULL;
+ 
+ 	/*
+ 	 * The spinlock protects the linked list against concurrent
+ 	 * modifications but not the resource itself.
+ 	 */
+ 	spin_lock_irqsave(&dev->devres_lock, flags);
+ 
+ 	old_dr = find_dr(dev, devm_kmalloc_release, devm_kmalloc_match, ptr);
+ 	if (!old_dr) {
+ 		spin_unlock_irqrestore(&dev->devres_lock, flags);
+ 		kfree(new_dr);
+ 		WARN(1, "Memory chunk not managed or managed by a different device.");
+ 		return NULL;
+ 	}
+ 
+ 	replace_dr(dev, &old_dr->node, &new_dr->node);
+ 
+ 	spin_unlock_irqrestore(&dev->devres_lock, flags);
+ 
+ 	/*
+ 	 * We can copy the memory contents after releasing the lock as we're
+ 	 * no longer modifying the list links.
+ 	 */
+ 	memcpy(new_dr->data, old_dr->data,
+ 	       total_old_size - offsetof(struct devres, data));
+ 	/*
+ 	 * Same for releasing the old devres - it's now been removed from the
+ 	 * list. This is also the reason why we must not use devm_kfree() - the
+ 	 * links are no longer valid.
+ 	 */
+ 	kfree(old_dr);
+ 
+ 	return new_dr->data;
+ }
+ EXPORT_SYMBOL_GPL(devm_krealloc);
+ 
+ /**
++>>>>>>> 451fd6ee1adb (devres: fix typos in comments)
   * devm_kstrdup - Allocate resource managed space and
   *                copy an existing string into that.
   * @dev: Device to allocate memory for
* Unmerged path drivers/base/devres.c
