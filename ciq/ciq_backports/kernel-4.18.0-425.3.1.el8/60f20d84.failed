of/fdt: Rework early_init_dt_scan_chosen() to call directly

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-425.3.1.el8
commit-author Rob Herring <robh@kernel.org>
commit 60f20d84dc813f1342771a3e4f06d89da26dc412
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-425.3.1.el8/60f20d84.failed

Use of the of_scan_flat_dt() function predates libfdt and is discouraged
as libfdt provides a nicer set of APIs. Rework
early_init_dt_scan_chosen() to be called directly and use libfdt.

	Cc: Michael Ellerman <mpe@ellerman.id.au>
	Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
	Cc: Paul Mackerras <paulus@samba.org>
	Cc: Frank Rowand <frowand.list@gmail.com>
	Cc: linuxppc-dev@lists.ozlabs.org
	Signed-off-by: Rob Herring <robh@kernel.org>
	Reviewed-by: Frank Rowand <frank.rowand@sony.com>
Link: https://lore.kernel.org/r/20211118181213.1433346-2-robh@kernel.org
(cherry picked from commit 60f20d84dc813f1342771a3e4f06d89da26dc412)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/mm/nohash/kaslr_booke.c
#	drivers/of/fdt.c
diff --cc drivers/of/fdt.c
index 5f804b7f0a7a,1f1705f76263..000000000000
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@@ -1078,24 -1124,27 +1078,32 @@@ int __init early_init_dt_scan_memory(un
  	return 0;
  }
  
- int __init early_init_dt_scan_chosen(unsigned long node, const char *uname,
- 				     int depth, void *data)
+ int __init early_init_dt_scan_chosen(char *cmdline)
  {
- 	int l;
+ 	int l, node;
  	const char *p;
++<<<<<<< HEAD
++=======
+ 	const void *rng_seed;
+ 	const void *fdt = initial_boot_params;
++>>>>>>> 60f20d84dc81 (of/fdt: Rework early_init_dt_scan_chosen() to call directly)
  
- 	pr_debug("search \"chosen\", depth: %d, uname: %s\n", depth, uname);
- 
- 	if (depth != 1 || !data ||
- 	    (strcmp(uname, "chosen") != 0 && strcmp(uname, "chosen@0") != 0))
- 		return 0;
+ 	node = fdt_path_offset(fdt, "/chosen");
+ 	if (node < 0)
+ 		node = fdt_path_offset(fdt, "/chosen@0");
+ 	if (node < 0)
+ 		return -ENOENT;
  
  	early_init_dt_check_for_initrd(node);
 -	early_init_dt_check_for_elfcorehdr(node);
 -	early_init_dt_check_for_usable_mem_range(node);
  
  	/* Retrieve command line */
  	p = of_get_flat_dt_prop(node, "bootargs", &l);
  	if (p != NULL && l > 0)
++<<<<<<< HEAD
 +		strlcpy(data, p, min((int)l, COMMAND_LINE_SIZE));
++=======
+ 		strlcpy(cmdline, p, min(l, COMMAND_LINE_SIZE));
++>>>>>>> 60f20d84dc81 (of/fdt: Rework early_init_dt_scan_chosen() to call directly)
  
  	/*
  	 * CONFIG_CMDLINE is meant to be a default in case nothing else
@@@ -1115,10 -1164,21 +1123,25 @@@
  #endif
  #endif /* CONFIG_CMDLINE */
  
++<<<<<<< HEAD
 +	pr_debug("Command line is: %s\n", (char*)data);
++=======
+ 	pr_debug("Command line is: %s\n", (char *)cmdline);
  
- 	/* break now */
- 	return 1;
+ 	rng_seed = of_get_flat_dt_prop(node, "rng-seed", &l);
+ 	if (rng_seed && l > 0) {
+ 		add_bootloader_randomness(rng_seed, l);
+ 
+ 		/* try to clear seed so it won't be found. */
+ 		fdt_nop_property(initial_boot_params, node, "rng-seed");
+ 
+ 		/* update CRC check value */
+ 		of_fdt_crc32 = crc32_be(~0, initial_boot_params,
+ 				fdt_totalsize(initial_boot_params));
+ 	}
++>>>>>>> 60f20d84dc81 (of/fdt: Rework early_init_dt_scan_chosen() to call directly)
+ 
+ 	return 0;
  }
  
  #ifndef MIN_MEMBLOCK_ADDR
@@@ -1212,14 -1260,21 +1235,26 @@@ bool __init early_init_dt_verify(void *
  
  void __init early_init_dt_scan_nodes(void)
  {
++<<<<<<< HEAD
 +	/* Retrieve various information from the /chosen node */
 +	of_scan_flat_dt(early_init_dt_scan_chosen, boot_command_line);
++=======
+ 	int rc;
++>>>>>>> 60f20d84dc81 (of/fdt: Rework early_init_dt_scan_chosen() to call directly)
  
  	/* Initialize {size,address}-cells info */
  	of_scan_flat_dt(early_init_dt_scan_root, NULL);
  
++<<<<<<< HEAD
++=======
+ 	/* Retrieve various information from the /chosen node */
+ 	rc = early_init_dt_scan_chosen(boot_command_line);
+ 	if (rc)
+ 		pr_warn("No chosen node found, continuing without\n");
+ 
++>>>>>>> 60f20d84dc81 (of/fdt: Rework early_init_dt_scan_chosen() to call directly)
  	/* Setup memory, calling early_init_dt_add_memory_arch */
  	of_scan_flat_dt(early_init_dt_scan_memory, NULL);
 -
 -	/* Handle linux,usable-memory-range property */
 -	memblock_cap_memory_range(cap_mem_addr, cap_mem_size);
  }
  
  bool __init early_init_dt_scan(void *params)
* Unmerged path arch/powerpc/mm/nohash/kaslr_booke.c
diff --git a/arch/powerpc/kernel/prom.c b/arch/powerpc/kernel/prom.c
index f52d05315e32..32a06b4c08cf 100644
--- a/arch/powerpc/kernel/prom.c
+++ b/arch/powerpc/kernel/prom.c
@@ -407,7 +407,7 @@ static int __init early_init_dt_scan_chosen_ppc(unsigned long node,
 	const unsigned long *lprop; /* All these set by kernel, so no need to convert endian */
 
 	/* Use common scan routine to determine if this is the chosen node */
-	if (early_init_dt_scan_chosen(node, uname, depth, data) == 0)
+	if (early_init_dt_scan_chosen(data) < 0)
 		return 0;
 
 #ifdef CONFIG_PPC64
* Unmerged path arch/powerpc/mm/nohash/kaslr_booke.c
* Unmerged path drivers/of/fdt.c
diff --git a/include/linux/of_fdt.h b/include/linux/of_fdt.h
index a713e5d156d8..fd2f5ca6d8a8 100644
--- a/include/linux/of_fdt.h
+++ b/include/linux/of_fdt.h
@@ -69,8 +69,7 @@ extern unsigned long of_get_flat_dt_root(void);
 extern int of_get_flat_dt_size(void);
 extern uint32_t of_get_flat_dt_phandle(unsigned long node);
 
-extern int early_init_dt_scan_chosen(unsigned long node, const char *uname,
-				     int depth, void *data);
+extern int early_init_dt_scan_chosen(char *cmdline);
 extern int early_init_dt_scan_memory(unsigned long node, const char *uname,
 				     int depth, void *data);
 extern int early_init_dt_scan_chosen_stdout(void);
