ASoC: SOF: Convert the generic IPC message injector into SOF client

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-425.3.1.el8
commit-author Peter Ujfalusi <peter.ujfalusi@linux.intel.com>
commit cac0b0887e5304bddfda91a4a7106f9328c31318
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-425.3.1.el8/cac0b088.failed

Move the IPC message injection code out from the debug file as separate
SOF client driver.

Based on the kernel configuration, the device registration for the new IPC
message injector is going to happen in the core.

	Signed-off-by: Peter Ujfalusi <peter.ujfalusi@linux.intel.com>
	Reviewed-by: Kai Vehmanen <kai.vehmanen@linux.intel.com>
	Reviewed-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
	Reviewed-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
Link: https://lore.kernel.org/r/20220210150525.30756-9-peter.ujfalusi@linux.intel.com
	Signed-off-by: Mark Brown <broonie@kernel.org>
(cherry picked from commit cac0b0887e5304bddfda91a4a7106f9328c31318)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/soc/sof/Makefile
#	sound/soc/sof/debug.c
#	sound/soc/sof/sof-client.c
diff --cc sound/soc/sof/Makefile
index 4b9fccacc2b7,a2ae79ebf756..000000000000
--- a/sound/soc/sof/Makefile
+++ b/sound/soc/sof/Makefile
@@@ -10,6 -11,9 +10,12 @@@ snd-sof-pci-objs := sof-pci-dev.
  snd-sof-acpi-objs := sof-acpi-dev.o
  snd-sof-of-objs := sof-of-dev.o
  
++<<<<<<< HEAD
++=======
+ snd-sof-ipc-flood-test-objs := sof-client-ipc-flood-test.o
+ snd-sof-ipc-msg-injector-objs := sof-client-ipc-msg-injector.o
+ 
++>>>>>>> cac0b0887e53 (ASoC: SOF: Convert the generic IPC message injector into SOF client)
  snd-sof-nocodec-objs := nocodec.o
  
  snd-sof-utils-objs := sof-utils.o
@@@ -23,6 -27,9 +29,12 @@@ obj-$(CONFIG_SND_SOC_SOF_ACPI_DEV) += s
  obj-$(CONFIG_SND_SOC_SOF_OF_DEV) += snd-sof-of.o
  obj-$(CONFIG_SND_SOC_SOF_PCI_DEV) += snd-sof-pci.o
  
++<<<<<<< HEAD
++=======
+ obj-$(CONFIG_SND_SOC_SOF_DEBUG_IPC_FLOOD_TEST) += snd-sof-ipc-flood-test.o
+ obj-$(CONFIG_SND_SOC_SOF_DEBUG_IPC_MSG_INJECTOR) += snd-sof-ipc-msg-injector.o
+ 
++>>>>>>> cac0b0887e53 (ASoC: SOF: Convert the generic IPC message injector into SOF client)
  obj-$(CONFIG_SND_SOC_SOF_INTEL_TOPLEVEL) += intel/
  obj-$(CONFIG_SND_SOC_SOF_IMX_TOPLEVEL) += imx/
  obj-$(CONFIG_SND_SOC_SOF_AMD_TOPLEVEL) += amd/
diff --cc sound/soc/sof/debug.c
index 18ed21da5aa7,937fe6e11d0d..000000000000
--- a/sound/soc/sof/debug.c
+++ b/sound/soc/sof/debug.c
@@@ -234,206 -234,6 +234,209 @@@ static int snd_sof_debugfs_probe_item(s
  }
  #endif
  
++<<<<<<< HEAD
 +#if IS_ENABLED(CONFIG_SND_SOC_SOF_DEBUG_IPC_FLOOD_TEST)
 +#define MAX_IPC_FLOOD_DURATION_MS 1000
 +#define MAX_IPC_FLOOD_COUNT 10000
 +#define IPC_FLOOD_TEST_RESULT_LEN 512
 +
 +static int sof_debug_ipc_flood_test(struct snd_sof_dev *sdev,
 +				    struct snd_sof_dfsentry *dfse,
 +				    bool flood_duration_test,
 +				    unsigned long ipc_duration_ms,
 +				    unsigned long ipc_count)
 +{
 +	struct sof_ipc_cmd_hdr hdr;
 +	struct sof_ipc_reply reply;
 +	u64 min_response_time = U64_MAX;
 +	ktime_t start, end, test_end;
 +	u64 avg_response_time = 0;
 +	u64 max_response_time = 0;
 +	u64 ipc_response_time;
 +	int i = 0;
 +	int ret;
 +
 +	/* configure test IPC */
 +	hdr.cmd = SOF_IPC_GLB_TEST_MSG | SOF_IPC_TEST_IPC_FLOOD;
 +	hdr.size = sizeof(hdr);
 +
 +	/* set test end time for duration flood test */
 +	if (flood_duration_test)
 +		test_end = ktime_get_ns() + ipc_duration_ms * NSEC_PER_MSEC;
 +
 +	/* send test IPC's */
 +	while (1) {
 +		start = ktime_get();
 +		ret = sof_ipc_tx_message(sdev->ipc, hdr.cmd, &hdr, hdr.size,
 +					 &reply, sizeof(reply));
 +		end = ktime_get();
 +
 +		if (ret < 0)
 +			break;
 +
 +		/* compute min and max response times */
 +		ipc_response_time = ktime_to_ns(ktime_sub(end, start));
 +		min_response_time = min(min_response_time, ipc_response_time);
 +		max_response_time = max(max_response_time, ipc_response_time);
 +
 +		/* sum up response times */
 +		avg_response_time += ipc_response_time;
 +		i++;
 +
 +		/* test complete? */
 +		if (flood_duration_test) {
 +			if (ktime_to_ns(end) >= test_end)
 +				break;
 +		} else {
 +			if (i == ipc_count)
 +				break;
 +		}
 +	}
 +
 +	if (ret < 0)
 +		dev_err(sdev->dev,
 +			"error: ipc flood test failed at %d iterations\n", i);
 +
 +	/* return if the first IPC fails */
 +	if (!i)
 +		return ret;
 +
 +	/* compute average response time */
 +	do_div(avg_response_time, i);
 +
 +	/* clear previous test output */
 +	memset(dfse->cache_buf, 0, IPC_FLOOD_TEST_RESULT_LEN);
 +
 +	if (flood_duration_test) {
 +		dev_dbg(sdev->dev, "IPC Flood test duration: %lums\n",
 +			ipc_duration_ms);
 +		snprintf(dfse->cache_buf, IPC_FLOOD_TEST_RESULT_LEN,
 +			 "IPC Flood test duration: %lums\n", ipc_duration_ms);
 +	}
 +
 +	dev_dbg(sdev->dev,
 +		"IPC Flood count: %d, Avg response time: %lluns\n",
 +		i, avg_response_time);
 +	dev_dbg(sdev->dev, "Max response time: %lluns\n",
 +		max_response_time);
 +	dev_dbg(sdev->dev, "Min response time: %lluns\n",
 +		min_response_time);
 +
 +	/* format output string */
 +	snprintf(dfse->cache_buf + strlen(dfse->cache_buf),
 +		 IPC_FLOOD_TEST_RESULT_LEN - strlen(dfse->cache_buf),
 +		 "IPC Flood count: %d\nAvg response time: %lluns\n",
 +		 i, avg_response_time);
 +
 +	snprintf(dfse->cache_buf + strlen(dfse->cache_buf),
 +		 IPC_FLOOD_TEST_RESULT_LEN - strlen(dfse->cache_buf),
 +		 "Max response time: %lluns\nMin response time: %lluns\n",
 +		 max_response_time, min_response_time);
 +
 +	return ret;
 +}
 +#endif
 +
 +#if IS_ENABLED(CONFIG_SND_SOC_SOF_DEBUG_IPC_MSG_INJECTOR)
 +static ssize_t msg_inject_read(struct file *file, char __user *buffer,
 +			       size_t count, loff_t *ppos)
 +{
 +	struct snd_sof_dfsentry *dfse = file->private_data;
 +	struct sof_ipc_reply *rhdr = dfse->msg_inject_rx;
 +
 +	if (!rhdr->hdr.size || !count || *ppos)
 +		return 0;
 +
 +	if (count > rhdr->hdr.size)
 +		count = rhdr->hdr.size;
 +
 +	if (copy_to_user(buffer, dfse->msg_inject_rx, count))
 +		return -EFAULT;
 +
 +	*ppos += count;
 +	return count;
 +}
 +
 +static ssize_t msg_inject_write(struct file *file, const char __user *buffer,
 +				size_t count, loff_t *ppos)
 +{
 +	struct snd_sof_dfsentry *dfse = file->private_data;
 +	struct snd_sof_dev *sdev = dfse->sdev;
 +	struct sof_ipc_cmd_hdr *hdr = dfse->msg_inject_tx;
 +	size_t size;
 +	int ret, err;
 +
 +	if (*ppos)
 +		return 0;
 +
 +	size = simple_write_to_buffer(dfse->msg_inject_tx, SOF_IPC_MSG_MAX_SIZE,
 +				      ppos, buffer, count);
 +	if (size != count)
 +		return size > 0 ? -EFAULT : size;
 +
 +	ret = pm_runtime_get_sync(sdev->dev);
 +	if (ret < 0 && ret != -EACCES) {
 +		dev_err_ratelimited(sdev->dev, "%s: DSP resume failed: %d\n",
 +				    __func__, ret);
 +		pm_runtime_put_noidle(sdev->dev);
 +		goto out;
 +	}
 +
 +	/* send the message */
 +	memset(dfse->msg_inject_rx, 0, SOF_IPC_MSG_MAX_SIZE);
 +	ret = sof_ipc_tx_message(sdev->ipc, hdr->cmd, dfse->msg_inject_tx, count,
 +				 dfse->msg_inject_rx, SOF_IPC_MSG_MAX_SIZE);
 +
 +	pm_runtime_mark_last_busy(sdev->dev);
 +	err = pm_runtime_put_autosuspend(sdev->dev);
 +	if (err < 0)
 +		dev_err_ratelimited(sdev->dev, "%s: DSP idle failed: %d\n",
 +				    __func__, err);
 +
 +	/* return size if test is successful */
 +	if (ret >= 0)
 +		ret = size;
 +
 +out:
 +	return ret;
 +}
 +
 +static const struct file_operations msg_inject_fops = {
 +	.open = simple_open,
 +	.read = msg_inject_read,
 +	.write = msg_inject_write,
 +	.llseek = default_llseek,
 +};
 +
 +static int snd_sof_debugfs_msg_inject_item(struct snd_sof_dev *sdev,
 +					   const char *name, mode_t mode,
 +					   const struct file_operations *fops)
 +{
 +	struct snd_sof_dfsentry *dfse;
 +
 +	dfse = devm_kzalloc(sdev->dev, sizeof(*dfse), GFP_KERNEL);
 +	if (!dfse)
 +		return -ENOMEM;
 +
 +	/* pre allocate the tx and rx buffers */
 +	dfse->msg_inject_tx = devm_kzalloc(sdev->dev, SOF_IPC_MSG_MAX_SIZE, GFP_KERNEL);
 +	dfse->msg_inject_rx = devm_kzalloc(sdev->dev, SOF_IPC_MSG_MAX_SIZE, GFP_KERNEL);
 +	if (!dfse->msg_inject_tx || !dfse->msg_inject_rx)
 +		return -ENOMEM;
 +
 +	dfse->type = SOF_DFSENTRY_TYPE_BUF;
 +	dfse->sdev = sdev;
 +
 +	debugfs_create_file(name, mode, sdev->debugfs_root, dfse, fops);
 +	/* add to dfsentry list */
 +	list_add(&dfse->list, &sdev->dfsentry_list);
 +
 +	return 0;
 +}
 +#endif
 +
++=======
++>>>>>>> cac0b0887e53 (ASoC: SOF: Convert the generic IPC message injector into SOF client)
  static ssize_t sof_dfsentry_write(struct file *file, const char __user *buffer,
  				  size_t count, loff_t *ppos)
  {
@@@ -903,33 -580,6 +906,36 @@@ int snd_sof_dbg_init(struct snd_sof_de
  		return err;
  #endif
  
++<<<<<<< HEAD
 +#if IS_ENABLED(CONFIG_SND_SOC_SOF_DEBUG_IPC_FLOOD_TEST)
 +	/* create read-write ipc_flood_count debugfs entry */
 +	err = snd_sof_debugfs_buf_item(sdev, NULL, 0,
 +				       "ipc_flood_count", 0666);
 +
 +	/* errors are only due to memory allocation, not debugfs */
 +	if (err < 0)
 +		return err;
 +
 +	/* create read-write ipc_flood_duration_ms debugfs entry */
 +	err = snd_sof_debugfs_buf_item(sdev, NULL, 0,
 +				       "ipc_flood_duration_ms", 0666);
 +
 +	/* errors are only due to memory allocation, not debugfs */
 +	if (err < 0)
 +		return err;
 +#endif
 +
 +#if IS_ENABLED(CONFIG_SND_SOC_SOF_DEBUG_IPC_MSG_INJECTOR)
 +	err = snd_sof_debugfs_msg_inject_item(sdev, "ipc_msg_inject", 0644,
 +					      &msg_inject_fops);
 +
 +	/* errors are only due to memory allocation, not debugfs */
 +	if (err < 0)
 +		return err;
 +#endif
 +
++=======
++>>>>>>> cac0b0887e53 (ASoC: SOF: Convert the generic IPC message injector into SOF client)
  	return 0;
  }
  EXPORT_SYMBOL_GPL(snd_sof_dbg_init);
* Unmerged path sound/soc/sof/sof-client.c
diff --git a/sound/soc/sof/Kconfig b/sound/soc/sof/Kconfig
index 1a7d6cefd3b7..be244eedc7e0 100644
--- a/sound/soc/sof/Kconfig
+++ b/sound/soc/sof/Kconfig
@@ -195,7 +195,8 @@ config SND_SOC_SOF_DEBUG_IPC_FLOOD_TEST
 	  If unsure, select "N".
 
 config SND_SOC_SOF_DEBUG_IPC_MSG_INJECTOR
-	bool "SOF enable IPC message injector"
+	tristate "SOF enable IPC message injector"
+	select SND_SOC_SOF_CLIENT
 	help
 	  This option enables the IPC message injector which can be used to send
 	  crafted IPC messages to the DSP to test its robustness.
* Unmerged path sound/soc/sof/Makefile
* Unmerged path sound/soc/sof/debug.c
diff --git a/sound/soc/sof/sof-client-ipc-msg-injector.c b/sound/soc/sof/sof-client-ipc-msg-injector.c
new file mode 100644
index 000000000000..bce103da4c49
--- /dev/null
+++ b/sound/soc/sof/sof-client-ipc-msg-injector.c
@@ -0,0 +1,192 @@
+// SPDX-License-Identifier: GPL-2.0-only
+//
+// Copyright(c) 2022 Intel Corporation. All rights reserved.
+//
+// Author: Peter Ujfalusi <peter.ujfalusi@linux.intel.com>
+//
+
+#include <linux/auxiliary_bus.h>
+#include <linux/completion.h>
+#include <linux/debugfs.h>
+#include <linux/ktime.h>
+#include <linux/mod_devicetable.h>
+#include <linux/module.h>
+#include <linux/pm_runtime.h>
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+#include <sound/sof/header.h>
+
+#include "sof-client.h"
+
+#define SOF_IPC_CLIENT_SUSPEND_DELAY_MS	3000
+
+struct sof_msg_inject_priv {
+	struct dentry *dfs_file;
+
+	void *tx_buffer;
+	void *rx_buffer;
+};
+
+static int sof_msg_inject_dfs_open(struct inode *inode, struct file *file)
+{
+	struct sof_client_dev *cdev = inode->i_private;
+	int ret;
+
+	if (sof_client_get_fw_state(cdev) == SOF_FW_CRASHED)
+		return -ENODEV;
+
+	ret = debugfs_file_get(file->f_path.dentry);
+	if (unlikely(ret))
+		return ret;
+
+	ret = simple_open(inode, file);
+	if (ret)
+		debugfs_file_put(file->f_path.dentry);
+
+	return ret;
+}
+
+static ssize_t sof_msg_inject_dfs_read(struct file *file, char __user *buffer,
+				       size_t count, loff_t *ppos)
+{
+	struct sof_client_dev *cdev = file->private_data;
+	struct sof_msg_inject_priv *priv = cdev->data;
+	struct sof_ipc_reply *rhdr = priv->rx_buffer;
+
+	if (!rhdr->hdr.size || !count || *ppos)
+		return 0;
+
+	if (count > rhdr->hdr.size)
+		count = rhdr->hdr.size;
+
+	if (copy_to_user(buffer, priv->rx_buffer, count))
+		return -EFAULT;
+
+	*ppos += count;
+	return count;
+}
+
+static ssize_t sof_msg_inject_dfs_write(struct file *file, const char __user *buffer,
+					size_t count, loff_t *ppos)
+{
+	struct sof_client_dev *cdev = file->private_data;
+	struct sof_msg_inject_priv *priv = cdev->data;
+	struct device *dev = &cdev->auxdev.dev;
+	int ret, err;
+	size_t size;
+
+	if (*ppos)
+		return 0;
+
+	size = simple_write_to_buffer(priv->tx_buffer, SOF_IPC_MSG_MAX_SIZE,
+				      ppos, buffer, count);
+	if (size != count)
+		return size > 0 ? -EFAULT : size;
+
+	ret = pm_runtime_get_sync(dev);
+	if (ret < 0 && ret != -EACCES) {
+		dev_err_ratelimited(dev, "debugfs write failed to resume %d\n", ret);
+		pm_runtime_put_noidle(dev);
+		return ret;
+	}
+
+	/* send the message */
+	memset(priv->rx_buffer, 0, SOF_IPC_MSG_MAX_SIZE);
+	ret = sof_client_ipc_tx_message(cdev, priv->tx_buffer, priv->rx_buffer,
+					SOF_IPC_MSG_MAX_SIZE);
+	pm_runtime_mark_last_busy(dev);
+	err = pm_runtime_put_autosuspend(dev);
+	if (err < 0)
+		dev_err_ratelimited(dev, "debugfs write failed to idle %d\n", err);
+
+	/* return size if test is successful */
+	if (ret >= 0)
+		ret = size;
+
+	return ret;
+};
+
+static int sof_msg_inject_dfs_release(struct inode *inode, struct file *file)
+{
+	debugfs_file_put(file->f_path.dentry);
+
+	return 0;
+}
+
+static const struct file_operations sof_msg_inject_fops = {
+	.open = sof_msg_inject_dfs_open,
+	.read = sof_msg_inject_dfs_read,
+	.write = sof_msg_inject_dfs_write,
+	.llseek = default_llseek,
+	.release = sof_msg_inject_dfs_release,
+
+	.owner = THIS_MODULE,
+};
+
+static int sof_msg_inject_probe(struct auxiliary_device *auxdev,
+				const struct auxiliary_device_id *id)
+{
+	struct sof_client_dev *cdev = auxiliary_dev_to_sof_client_dev(auxdev);
+	struct dentry *debugfs_root = sof_client_get_debugfs_root(cdev);
+	struct device *dev = &auxdev->dev;
+	struct sof_msg_inject_priv *priv;
+
+	/* allocate memory for client data */
+	priv = devm_kzalloc(&auxdev->dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	priv->tx_buffer = devm_kmalloc(dev, SOF_IPC_MSG_MAX_SIZE, GFP_KERNEL);
+	priv->rx_buffer = devm_kmalloc(dev, SOF_IPC_MSG_MAX_SIZE, GFP_KERNEL);
+	if (!priv->tx_buffer || !priv->rx_buffer)
+		return -ENOMEM;
+
+	cdev->data = priv;
+
+	priv->dfs_file = debugfs_create_file("ipc_msg_inject", 0644, debugfs_root,
+					     cdev, &sof_msg_inject_fops);
+
+	/* enable runtime PM */
+	pm_runtime_set_autosuspend_delay(dev, SOF_IPC_CLIENT_SUSPEND_DELAY_MS);
+	pm_runtime_use_autosuspend(dev);
+	pm_runtime_enable(dev);
+	pm_runtime_mark_last_busy(dev);
+	pm_runtime_idle(dev);
+
+	return 0;
+}
+
+static void sof_msg_inject_remove(struct auxiliary_device *auxdev)
+{
+	struct sof_client_dev *cdev = auxiliary_dev_to_sof_client_dev(auxdev);
+	struct sof_msg_inject_priv *priv = cdev->data;
+
+	pm_runtime_disable(&auxdev->dev);
+
+	debugfs_remove(priv->dfs_file);
+}
+
+static const struct auxiliary_device_id sof_msg_inject_client_id_table[] = {
+	{ .name = "snd_sof.msg_injector" },
+	{},
+};
+MODULE_DEVICE_TABLE(auxiliary, sof_msg_inject_client_id_table);
+
+/*
+ * No need for driver pm_ops as the generic pm callbacks in the auxiliary bus
+ * type are enough to ensure that the parent SOF device resumes to bring the DSP
+ * back to D0.
+ * Driver name will be set based on KBUILD_MODNAME.
+ */
+static struct auxiliary_driver sof_msg_inject_client_drv = {
+	.probe = sof_msg_inject_probe,
+	.remove = sof_msg_inject_remove,
+
+	.id_table = sof_msg_inject_client_id_table,
+};
+
+module_auxiliary_driver(sof_msg_inject_client_drv);
+
+MODULE_DESCRIPTION("SOF IPC Message Injector Client Driver");
+MODULE_LICENSE("GPL");
+MODULE_IMPORT_NS(SND_SOC_SOF_CLIENT);
* Unmerged path sound/soc/sof/sof-client.c
diff --git a/sound/soc/sof/sof-priv.h b/sound/soc/sof/sof-priv.h
index d19b259a3cba..0041dde42fed 100644
--- a/sound/soc/sof/sof-priv.h
+++ b/sound/soc/sof/sof-priv.h
@@ -330,10 +330,6 @@ struct snd_sof_dfsentry {
 	enum sof_debugfs_access_type access_type;
 #if ENABLE_DEBUGFS_CACHEBUF
 	char *cache_buf; /* buffer to cache the contents of debugfs memory */
-#endif
-#if IS_ENABLED(CONFIG_SND_SOC_SOF_DEBUG_IPC_MSG_INJECTOR)
-	void *msg_inject_tx;
-	void *msg_inject_rx;
 #endif
 	struct snd_sof_dev *sdev;
 	struct list_head list;  /* list in sdev dfsentry list */
