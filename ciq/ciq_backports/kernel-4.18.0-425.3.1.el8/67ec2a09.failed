ASoC: SOF: Add bytes_ext control IPC ops for IPC3

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-425.3.1.el8
commit-author Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
commit 67ec2a091630c28ea8d05db2bd7178a05b04b7e6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-425.3.1.el8/67ec2a09.failed

Define and set the get/put/volatile_get control IPC ops for byte
controls for IPC3.

	Signed-off-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
	Reviewed-by: PÃ©ter Ujfalusi <peter.ujfalusi@linux.intel.com>
	Reviewed-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
Link: https://lore.kernel.org/r/20220317175044.1752400-11-ranjani.sridharan@linux.intel.com
	Signed-off-by: Mark Brown <broonie@kernel.org>
(cherry picked from commit 67ec2a091630c28ea8d05db2bd7178a05b04b7e6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/soc/sof/control.c
#	sound/soc/sof/ipc3-control.c
diff --cc sound/soc/sof/control.c
index ef61936dad59,de1778c4002b..000000000000
--- a/sound/soc/sof/control.c
+++ b/sound/soc/sof/control.c
@@@ -45,52 -45,6 +45,55 @@@ static void update_mute_led(struct snd_
  #endif
  }
  
++<<<<<<< HEAD
 +static inline u32 mixer_to_ipc(unsigned int value, u32 *volume_map, int size)
 +{
 +	if (value >= size)
 +		return volume_map[size - 1];
 +
 +	return volume_map[value];
 +}
 +
 +static inline u32 ipc_to_mixer(u32 value, u32 *volume_map, int size)
 +{
 +	int i;
 +
 +	for (i = 0; i < size; i++) {
 +		if (volume_map[i] >= value)
 +			return i;
 +	}
 +
 +	return i - 1;
 +}
 +
 +static void snd_sof_refresh_control(struct snd_sof_control *scontrol)
 +{
 +	struct sof_ipc_ctrl_data *cdata = scontrol->control_data;
 +	struct snd_soc_component *scomp = scontrol->scomp;
 +	int ret;
 +
 +	if (!scontrol->comp_data_dirty)
 +		return;
 +
 +	if (!pm_runtime_active(scomp->dev))
 +		return;
 +
 +	/* set the ABI header values */
 +	cdata->data->magic = SOF_ABI_MAGIC;
 +	cdata->data->abi = SOF_ABI_VERSION;
 +
 +	/* refresh the component data from DSP */
 +	scontrol->comp_data_dirty = false;
 +	ret = snd_sof_ipc_set_get_comp_data(scontrol, false);
 +	if (ret < 0) {
 +		dev_err(scomp->dev, "error: failed to get control data: %d\n", ret);
 +		/* Set the flag to re-try next time to get the data */
 +		scontrol->comp_data_dirty = true;
 +	}
 +}
 +
++=======
++>>>>>>> 67ec2a091630 (ASoC: SOF: Add bytes_ext control IPC ops for IPC3)
  int snd_sof_volume_get(struct snd_kcontrol *kcontrol,
  		       struct snd_ctl_elem_value *ucontrol)
  {
@@@ -331,14 -194,11 +334,18 @@@ int snd_sof_bytes_ext_put(struct snd_kc
  			  const unsigned int __user *binary_data,
  			  unsigned int size)
  {
- 	struct soc_bytes_ext *be =
- 		(struct soc_bytes_ext *)kcontrol->private_value;
+ 	struct soc_bytes_ext *be = (struct soc_bytes_ext *)kcontrol->private_value;
  	struct snd_sof_control *scontrol = be->dobj.private;
  	struct snd_soc_component *scomp = scontrol->scomp;
++<<<<<<< HEAD
 +	struct sof_ipc_ctrl_data *cdata = scontrol->control_data;
 +	struct snd_ctl_tlv header;
 +	const struct snd_ctl_tlv __user *tlvd =
 +		(const struct snd_ctl_tlv __user *)binary_data;
++=======
+ 	struct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);
+ 	const struct sof_ipc_tplg_ops *tplg_ops = sdev->ipc->ops->tplg;
++>>>>>>> 67ec2a091630 (ASoC: SOF: Add bytes_ext control IPC ops for IPC3)
  
  	/* make sure we have at least a header */
  	if (size < sizeof(struct snd_ctl_tlv))
@@@ -409,20 -216,9 +363,26 @@@ int snd_sof_bytes_ext_volatile_get(stru
  	struct soc_bytes_ext *be = (struct soc_bytes_ext *)kcontrol->private_value;
  	struct snd_sof_control *scontrol = be->dobj.private;
  	struct snd_soc_component *scomp = scontrol->scomp;
++<<<<<<< HEAD
 +	struct sof_ipc_ctrl_data *cdata = scontrol->control_data;
 +	struct snd_ctl_tlv header;
 +	struct snd_ctl_tlv __user *tlvd = (struct snd_ctl_tlv __user *)binary_data;
 +	size_t data_size;
 +	int ret;
 +	int err;
 +
 +	/*
 +	 * Decrement the limit by ext bytes header size to
 +	 * ensure the user space buffer is not exceeded.
 +	 */
 +	if (size < sizeof(struct snd_ctl_tlv))
 +		return -ENOSPC;
 +	size -= sizeof(struct snd_ctl_tlv);
++=======
+ 	struct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);
+ 	const struct sof_ipc_tplg_ops *tplg_ops = sdev->ipc->ops->tplg;
+ 	int ret, err;
++>>>>>>> 67ec2a091630 (ASoC: SOF: Add bytes_ext control IPC ops for IPC3)
  
  	ret = pm_runtime_get_sync(scomp->dev);
  	if (ret < 0 && ret != -EACCES) {
@@@ -478,51 -242,14 +406,22 @@@ int snd_sof_bytes_ext_get(struct snd_kc
  			  unsigned int __user *binary_data,
  			  unsigned int size)
  {
- 	struct soc_bytes_ext *be =
- 		(struct soc_bytes_ext *)kcontrol->private_value;
+ 	struct soc_bytes_ext *be = (struct soc_bytes_ext *)kcontrol->private_value;
  	struct snd_sof_control *scontrol = be->dobj.private;
  	struct snd_soc_component *scomp = scontrol->scomp;
++<<<<<<< HEAD
 +	struct sof_ipc_ctrl_data *cdata = scontrol->control_data;
 +	struct snd_ctl_tlv header;
 +	struct snd_ctl_tlv __user *tlvd =
 +		(struct snd_ctl_tlv __user *)binary_data;
 +	size_t data_size;
++=======
+ 	struct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);
+ 	const struct sof_ipc_tplg_ops *tplg_ops = sdev->ipc->ops->tplg;
++>>>>>>> 67ec2a091630 (ASoC: SOF: Add bytes_ext control IPC ops for IPC3)
  
- 	snd_sof_refresh_control(scontrol);
- 
- 	/*
- 	 * Decrement the limit by ext bytes header size to
- 	 * ensure the user space buffer is not exceeded.
- 	 */
- 	if (size < sizeof(struct snd_ctl_tlv))
- 		return -ENOSPC;
- 	size -= sizeof(struct snd_ctl_tlv);
- 
- 	/* set the ABI header values */
- 	cdata->data->magic = SOF_ABI_MAGIC;
- 	cdata->data->abi = SOF_ABI_VERSION;
- 
- 	/* check data size doesn't exceed max coming from topology */
- 	if (cdata->data->size > be->max - sizeof(struct sof_abi_hdr)) {
- 		dev_err_ratelimited(scomp->dev, "error: user data size %d exceeds max size %zu.\n",
- 				    cdata->data->size,
- 				    be->max - sizeof(struct sof_abi_hdr));
- 		return -EINVAL;
- 	}
- 
- 	data_size = cdata->data->size + sizeof(struct sof_abi_hdr);
- 
- 	/* make sure we don't exceed size provided by user space for data */
- 	if (data_size > size)
- 		return -ENOSPC;
- 
- 	header.numid = cdata->cmd;
- 	header.length = data_size;
- 	if (copy_to_user(tlvd, &header, sizeof(struct snd_ctl_tlv)))
- 		return -EFAULT;
- 
- 	if (copy_to_user(tlvd->tlv, cdata->data, data_size))
- 		return -EFAULT;
+ 	if (tplg_ops->control->bytes_ext_get)
+ 		return tplg_ops->control->bytes_ext_get(scontrol, binary_data, size);
  
  	return 0;
  }
* Unmerged path sound/soc/sof/ipc3-control.c
* Unmerged path sound/soc/sof/control.c
* Unmerged path sound/soc/sof/ipc3-control.c
