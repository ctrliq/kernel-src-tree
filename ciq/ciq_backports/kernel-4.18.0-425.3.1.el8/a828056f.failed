ASoC: wm_adsp: move firmware loading to client

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-425.3.1.el8
commit-author Simon Trimmer <simont@opensource.cirrus.com>
commit a828056fa1fc044beab3cbe32f484fec5f38fe98
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-425.3.1.el8/a828056f.failed

This is preparation for moving the generic DSP support out of ASoC.
Passing the firmware as parameters into the power_up functions
simplifies the generic code that will be moved out of wm_adsp.

	Signed-off-by: Simon Trimmer <simont@opensource.cirrus.com>
Link: https://lore.kernel.org/r/20210913160057.103842-14-simont@opensource.cirrus.com
	Signed-off-by: Mark Brown <broonie@kernel.org>
(cherry picked from commit a828056fa1fc044beab3cbe32f484fec5f38fe98)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/soc/codecs/wm_adsp.c
diff --cc sound/soc/codecs/wm_adsp.c
index c1b5ea3b5718,3b5b0cce7b35..000000000000
--- a/sound/soc/codecs/wm_adsp.c
+++ b/sound/soc/codecs/wm_adsp.c
@@@ -1761,10 -1798,64 +1762,71 @@@ static unsigned int wm_adsp1_parse_size
  	return pos + sizeof(*adsp1_sizes);
  }
  
++<<<<<<< HEAD
 +static unsigned int wm_adsp2_parse_sizes(struct wm_adsp *dsp,
 +					 const char * const file,
 +					 unsigned int pos,
 +					 const struct firmware *firmware)
++=======
+ static void wm_adsp_release_firmware_files(struct wm_adsp *dsp,
+ 					   const struct firmware *wmfw_firmware,
+ 					   char *wmfw_filename,
+ 					   const struct firmware *coeff_firmware,
+ 					   char *coeff_filename)
+ {
+ 	if (wmfw_firmware)
+ 		release_firmware(wmfw_firmware);
+ 	kfree(wmfw_filename);
+ 
+ 	if (coeff_firmware)
+ 		release_firmware(coeff_firmware);
+ 	kfree(coeff_filename);
+ }
+ 
+ static int wm_adsp_request_firmware_file(struct wm_adsp *dsp,
+ 					 const struct firmware **firmware,
+ 					 char **filename,
+ 					 char *suffix)
+ {
+ 	int ret = 0;
+ 
+ 	*filename = kasprintf(GFP_KERNEL, "%s-%s-%s.%s", dsp->part, dsp->fwf_name,
+ 			      wm_adsp_fw[dsp->fw].file, suffix);
+ 	if (*filename == NULL)
+ 		return -ENOMEM;
+ 
+ 	ret = request_firmware(firmware, *filename, dsp->dev);
+ 	if (ret != 0) {
+ 		adsp_err(dsp, "Failed to request '%s'\n", *filename);
+ 		kfree(*filename);
+ 		*filename = NULL;
+ 	}
+ 
+ 	return ret;
+ }
+ 
+ static int wm_adsp_request_firmware_files(struct wm_adsp *dsp,
+ 					  const struct firmware **wmfw_firmware,
+ 					  char **wmfw_filename,
+ 					  const struct firmware **coeff_firmware,
+ 					  char **coeff_filename)
+ {
+ 	int ret = 0;
+ 
+ 	ret = wm_adsp_request_firmware_file(dsp, wmfw_firmware, wmfw_filename, "wmfw");
+ 	if (ret != 0)
+ 		return ret;
+ 
+ 	wm_adsp_request_firmware_file(dsp, coeff_firmware, coeff_filename, "bin");
+ 
+ 	return 0;
+ }
+ 
+ static unsigned int cs_dsp_adsp2_parse_sizes(struct wm_adsp *dsp,
+ 					     const char * const file,
+ 					     unsigned int pos,
+ 					     const struct firmware *firmware)
++>>>>>>> a828056fa1fc (ASoC: wm_adsp: move firmware loading to client)
  {
  	const struct wmfw_adsp2_sizes *adsp2_sizes;
  
@@@ -1801,37 -1892,24 +1863,49 @@@ static bool wm_halo_validate_version(st
  	}
  }
  
++<<<<<<< HEAD
 +static int wm_adsp_load(struct wm_adsp *dsp)
++=======
+ static int cs_dsp_load(struct wm_adsp *dsp, const struct firmware *firmware,
+ 		       const char *file)
++>>>>>>> a828056fa1fc (ASoC: wm_adsp: move firmware loading to client)
  {
  	LIST_HEAD(buf_list);
- 	const struct firmware *firmware;
  	struct regmap *regmap = dsp->regmap;
  	unsigned int pos = 0;
  	const struct wmfw_header *header;
  	const struct wmfw_adsp1_sizes *adsp1_sizes;
  	const struct wmfw_footer *footer;
  	const struct wmfw_region *region;
 -	const struct cs_dsp_region *mem;
 +	const struct wm_adsp_region *mem;
  	const char *region_name;
++<<<<<<< HEAD
 +	char *file, *text = NULL;
 +	struct wm_adsp_buf *buf;
++=======
+ 	char *text = NULL;
+ 	struct cs_dsp_buf *buf;
++>>>>>>> a828056fa1fc (ASoC: wm_adsp: move firmware loading to client)
  	unsigned int reg;
  	int regions = 0;
  	int ret, offset, type;
  
++<<<<<<< HEAD
 +	file = kzalloc(PAGE_SIZE, GFP_KERNEL);
 +	if (file == NULL)
 +		return -ENOMEM;
 +
 +	snprintf(file, PAGE_SIZE, "%s-%s-%s.wmfw", dsp->part, dsp->fwf_name,
 +		 wm_adsp_fw[dsp->fw].file);
 +	file[PAGE_SIZE - 1] = '\0';
 +
 +	ret = request_firmware(&firmware, file, dsp->dev);
 +	if (ret != 0) {
 +		adsp_err(dsp, "Failed to request '%s'\n", file);
 +		goto out;
 +	}
++=======
++>>>>>>> a828056fa1fc (ASoC: wm_adsp: move firmware loading to client)
  	ret = -EINVAL;
  
  	pos = sizeof(*header) + sizeof(*adsp1_sizes) + sizeof(*footer);
@@@ -1994,11 -2072,8 +2068,13 @@@
  
  out_fw:
  	regmap_async_complete(regmap);
++<<<<<<< HEAD
 +	wm_adsp_buf_free(&buf_list);
 +	release_firmware(firmware);
++=======
+ 	cs_dsp_buf_free(&buf_list);
++>>>>>>> a828056fa1fc (ASoC: wm_adsp: move firmware loading to client)
  	kfree(text);
- out:
- 	kfree(file);
  
  	return ret;
  }
@@@ -2544,45 -2621,33 +2620,69 @@@ out
  	return ret;
  }
  
++<<<<<<< HEAD
 +static int wm_adsp_load_coeff(struct wm_adsp *dsp)
++=======
+ static int cs_dsp_load_coeff(struct wm_adsp *dsp, const struct firmware *firmware,
+ 			     const char *file)
++>>>>>>> a828056fa1fc (ASoC: wm_adsp: move firmware loading to client)
  {
  	LIST_HEAD(buf_list);
  	struct regmap *regmap = dsp->regmap;
  	struct wmfw_coeff_hdr *hdr;
  	struct wmfw_coeff_item *blk;
++<<<<<<< HEAD
 +	const struct firmware *firmware;
 +	const struct wm_adsp_region *mem;
 +	struct wm_adsp_alg_region *alg_region;
 +	const char *region_name;
 +	int ret, pos, blocks, type, offset, reg;
 +	char *file;
 +	struct wm_adsp_buf *buf;
++=======
+ 	const struct cs_dsp_region *mem;
+ 	struct cs_dsp_alg_region *alg_region;
+ 	const char *region_name;
+ 	int ret, pos, blocks, type, offset, reg;
+ 	struct cs_dsp_buf *buf;
++>>>>>>> a828056fa1fc (ASoC: wm_adsp: move firmware loading to client)
  
- 	file = kzalloc(PAGE_SIZE, GFP_KERNEL);
- 	if (file == NULL)
- 		return -ENOMEM;
+ 	if (!firmware)
+ 		return 0;
  
++<<<<<<< HEAD
 +	snprintf(file, PAGE_SIZE, "%s-%s-%s.bin", dsp->part, dsp->fwf_name,
 +		 wm_adsp_fw[dsp->fw].file);
 +	file[PAGE_SIZE - 1] = '\0';
 +
 +	ret = request_firmware(&firmware, file, dsp->dev);
 +	if (ret != 0) {
 +		adsp_warn(dsp, "Failed to request '%s'\n", file);
 +		ret = 0;
 +		goto out;
 +	}
 +	ret = -EINVAL;
 +
 +	if (sizeof(*hdr) >= firmware->size) {
 +		adsp_err(dsp, "%s: file too short, %zu bytes\n",
 +			file, firmware->size);
++=======
+ 	ret = -EINVAL;
+ 
+ 	if (sizeof(*hdr) >= firmware->size) {
+ 		cs_dsp_err(dsp, "%s: coefficient file too short, %zu bytes\n",
+ 			   file, firmware->size);
++>>>>>>> a828056fa1fc (ASoC: wm_adsp: move firmware loading to client)
  		goto out_fw;
  	}
  
  	hdr = (void *)&firmware->data[0];
  	if (memcmp(hdr->magic, "WMDR", 4) != 0) {
++<<<<<<< HEAD
 +		adsp_err(dsp, "%s: invalid magic\n", file);
++=======
+ 		cs_dsp_err(dsp, "%s: invalid coefficient magic\n", file);
++>>>>>>> a828056fa1fc (ASoC: wm_adsp: move firmware loading to client)
  		goto out_fw;
  	}
  
@@@ -2731,10 -2796,7 +2831,14 @@@
  
  out_fw:
  	regmap_async_complete(regmap);
++<<<<<<< HEAD
 +	release_firmware(firmware);
 +	wm_adsp_buf_free(&buf_list);
 +out:
 +	kfree(file);
++=======
+ 	cs_dsp_buf_free(&buf_list);
++>>>>>>> a828056fa1fc (ASoC: wm_adsp: move firmware loading to client)
  	return ret;
  }
  
@@@ -2788,107 -2861,74 +2892,148 @@@ int wm_adsp1_init(struct wm_adsp *dsp
  }
  EXPORT_SYMBOL_GPL(wm_adsp1_init);
  
++<<<<<<< HEAD
 +int wm_adsp1_event(struct snd_soc_dapm_widget *w,
 +		   struct snd_kcontrol *kcontrol,
 +		   int event)
++=======
+ static int cs_dsp_adsp1_power_up(struct wm_adsp *dsp,
+ 				 const struct firmware *wmfw_firmware, char *wmfw_filename,
+ 				 const struct firmware *coeff_firmware, char *coeff_filename,
+ 				 const char *fw_name)
++>>>>>>> a828056fa1fc (ASoC: wm_adsp: move firmware loading to client)
  {
 -	unsigned int val;
 +	struct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);
 +	struct wm_adsp *dsps = snd_soc_component_get_drvdata(component);
 +	struct wm_adsp *dsp = &dsps[w->shift];
 +	struct wm_coeff_ctl *ctl;
  	int ret;
 +	unsigned int val;
 +
 +	dsp->component = component;
  
  	mutex_lock(&dsp->pwr_lock);
  
 -	dsp->fw_name = fw_name;
 +	switch (event) {
 +	case SND_SOC_DAPM_POST_PMU:
 +		regmap_update_bits(dsp->regmap, dsp->base + ADSP1_CONTROL_30,
 +				   ADSP1_SYS_ENA, ADSP1_SYS_ENA);
  
 -	regmap_update_bits(dsp->regmap, dsp->base + ADSP1_CONTROL_30,
 -			   ADSP1_SYS_ENA, ADSP1_SYS_ENA);
 +		/*
 +		 * For simplicity set the DSP clock rate to be the
 +		 * SYSCLK rate rather than making it configurable.
 +		 */
 +		if (dsp->sysclk_reg) {
 +			ret = regmap_read(dsp->regmap, dsp->sysclk_reg, &val);
 +			if (ret != 0) {
 +				adsp_err(dsp, "Failed to read SYSCLK state: %d\n",
 +				ret);
 +				goto err_mutex;
 +			}
  
 -	/*
 -	 * For simplicity set the DSP clock rate to be the
 -	 * SYSCLK rate rather than making it configurable.
 -	 */
 -	if (dsp->sysclk_reg) {
 -		ret = regmap_read(dsp->regmap, dsp->sysclk_reg, &val);
 -		if (ret != 0) {
 -			cs_dsp_err(dsp, "Failed to read SYSCLK state: %d\n", ret);
 -			goto err_mutex;
 +			val = (val & dsp->sysclk_mask) >> dsp->sysclk_shift;
 +
 +			ret = regmap_update_bits(dsp->regmap,
 +						 dsp->base + ADSP1_CONTROL_31,
 +						 ADSP1_CLK_SEL_MASK, val);
 +			if (ret != 0) {
 +				adsp_err(dsp, "Failed to set clock rate: %d\n",
 +					 ret);
 +				goto err_mutex;
 +			}
  		}
  
 -		val = (val & dsp->sysclk_mask) >> dsp->sysclk_shift;
 +		ret = wm_adsp_load(dsp);
 +		if (ret != 0)
 +			goto err_ena;
  
 -		ret = regmap_update_bits(dsp->regmap,
 -					 dsp->base + ADSP1_CONTROL_31,
 -					 ADSP1_CLK_SEL_MASK, val);
 -		if (ret != 0) {
 -			cs_dsp_err(dsp, "Failed to set clock rate: %d\n", ret);
 -			goto err_mutex;
 -		}
 +		ret = wm_adsp1_setup_algs(dsp);
 +		if (ret != 0)
 +			goto err_ena;
 +
 +		ret = wm_adsp_load_coeff(dsp);
 +		if (ret != 0)
 +			goto err_ena;
 +
 +		/* Initialize caches for enabled and unset controls */
 +		ret = wm_coeff_init_control_caches(dsp);
 +		if (ret != 0)
 +			goto err_ena;
 +
 +		/* Sync set controls */
 +		ret = wm_coeff_sync_controls(dsp);
 +		if (ret != 0)
 +			goto err_ena;
 +
 +		dsp->booted = true;
 +
 +		/* Start the core running */
 +		regmap_update_bits(dsp->regmap, dsp->base + ADSP1_CONTROL_30,
 +				   ADSP1_CORE_ENA | ADSP1_START,
 +				   ADSP1_CORE_ENA | ADSP1_START);
 +
 +		dsp->running = true;
 +		break;
 +
 +	case SND_SOC_DAPM_PRE_PMD:
 +		dsp->running = false;
 +		dsp->booted = false;
 +
 +		/* Halt the core */
 +		regmap_update_bits(dsp->regmap, dsp->base + ADSP1_CONTROL_30,
 +				   ADSP1_CORE_ENA | ADSP1_START, 0);
 +
 +		regmap_update_bits(dsp->regmap, dsp->base + ADSP1_CONTROL_19,
 +				   ADSP1_WDMA_BUFFER_LENGTH_MASK, 0);
 +
 +		regmap_update_bits(dsp->regmap, dsp->base + ADSP1_CONTROL_30,
 +				   ADSP1_SYS_ENA, 0);
 +
 +		list_for_each_entry(ctl, &dsp->ctl_list, list)
 +			ctl->enabled = 0;
 +
 +
 +		wm_adsp_free_alg_regions(dsp);
 +		break;
 +
 +	default:
 +		break;
  	}
  
++<<<<<<< HEAD
++=======
+ 	ret = cs_dsp_load(dsp, wmfw_firmware, wmfw_filename);
+ 	if (ret != 0)
+ 		goto err_ena;
+ 
+ 	ret = cs_dsp_adsp1_setup_algs(dsp);
+ 	if (ret != 0)
+ 		goto err_ena;
+ 
+ 	ret = cs_dsp_load_coeff(dsp, coeff_firmware, coeff_filename);
+ 	if (ret != 0)
+ 		goto err_ena;
+ 
+ 	/* Initialize caches for enabled and unset controls */
+ 	ret = cs_dsp_coeff_init_control_caches(dsp);
+ 	if (ret != 0)
+ 		goto err_ena;
+ 
+ 	/* Sync set controls */
+ 	ret = cs_dsp_coeff_sync_controls(dsp);
+ 	if (ret != 0)
+ 		goto err_ena;
+ 
+ 	dsp->booted = true;
+ 
+ 	/* Start the core running */
+ 	regmap_update_bits(dsp->regmap, dsp->base + ADSP1_CONTROL_30,
+ 			   ADSP1_CORE_ENA | ADSP1_START,
+ 			   ADSP1_CORE_ENA | ADSP1_START);
+ 
+ 	dsp->running = true;
+ 
++>>>>>>> a828056fa1fc (ASoC: wm_adsp: move firmware loading to client)
  	mutex_unlock(&dsp->pwr_lock);
  
  	return 0;
@@@ -2898,6 -2938,74 +3043,77 @@@ err_ena
  			   ADSP1_SYS_ENA, 0);
  err_mutex:
  	mutex_unlock(&dsp->pwr_lock);
++<<<<<<< HEAD
++=======
+ 	return ret;
+ }
+ 
+ static void cs_dsp_adsp1_power_down(struct wm_adsp *dsp)
+ {
+ 	struct cs_dsp_coeff_ctl *ctl;
+ 
+ 	mutex_lock(&dsp->pwr_lock);
+ 
+ 	dsp->running = false;
+ 	dsp->booted = false;
+ 
+ 	/* Halt the core */
+ 	regmap_update_bits(dsp->regmap, dsp->base + ADSP1_CONTROL_30,
+ 			   ADSP1_CORE_ENA | ADSP1_START, 0);
+ 
+ 	regmap_update_bits(dsp->regmap, dsp->base + ADSP1_CONTROL_19,
+ 			   ADSP1_WDMA_BUFFER_LENGTH_MASK, 0);
+ 
+ 	regmap_update_bits(dsp->regmap, dsp->base + ADSP1_CONTROL_30,
+ 			   ADSP1_SYS_ENA, 0);
+ 
+ 	list_for_each_entry(ctl, &dsp->ctl_list, list)
+ 		ctl->enabled = 0;
+ 
+ 	cs_dsp_free_alg_regions(dsp);
+ 
+ 	mutex_unlock(&dsp->pwr_lock);
+ }
+ 
+ int wm_adsp1_event(struct snd_soc_dapm_widget *w,
+ 		   struct snd_kcontrol *kcontrol,
+ 		   int event)
+ {
+ 	struct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);
+ 	struct wm_adsp *dsps = snd_soc_component_get_drvdata(component);
+ 	struct wm_adsp *dsp = &dsps[w->shift];
+ 	int ret = 0;
+ 	char *wmfw_filename = NULL;
+ 	const struct firmware *wmfw_firmware = NULL;
+ 	char *coeff_filename = NULL;
+ 	const struct firmware *coeff_firmware = NULL;
+ 
+ 	dsp->component = component;
+ 
+ 	switch (event) {
+ 	case SND_SOC_DAPM_POST_PMU:
+ 		ret = wm_adsp_request_firmware_files(dsp,
+ 						     &wmfw_firmware, &wmfw_filename,
+ 						     &coeff_firmware, &coeff_filename);
+ 		if (ret)
+ 			break;
+ 
+ 		ret = cs_dsp_adsp1_power_up(dsp,
+ 					    wmfw_firmware, wmfw_filename,
+ 					    coeff_firmware, coeff_filename,
+ 					    wm_adsp_fw_text[dsp->fw]);
+ 
+ 		wm_adsp_release_firmware_files(dsp,
+ 					       wmfw_firmware, wmfw_filename,
+ 					       coeff_firmware, coeff_filename);
+ 		break;
+ 	case SND_SOC_DAPM_PRE_PMD:
+ 		cs_dsp_adsp1_power_down(dsp);
+ 		break;
+ 	default:
+ 		break;
+ 	}
++>>>>>>> a828056fa1fc (ASoC: wm_adsp: move firmware loading to client)
  
  	return ret;
  }
@@@ -3161,6 -3218,119 +3377,122 @@@ static void wm_halo_stop_watchdog(struc
  			   HALO_WDT_EN_MASK, 0);
  }
  
++<<<<<<< HEAD
++=======
+ static int cs_dsp_power_up(struct wm_adsp *dsp,
+ 			   const struct firmware *wmfw_firmware, char *wmfw_filename,
+ 			   const struct firmware *coeff_firmware, char *coeff_filename,
+ 			   const char *fw_name)
+ {
+ 	int ret;
+ 
+ 	mutex_lock(&dsp->pwr_lock);
+ 
+ 	dsp->fw_name = fw_name;
+ 
+ 	if (dsp->ops->enable_memory) {
+ 		ret = dsp->ops->enable_memory(dsp);
+ 		if (ret != 0)
+ 			goto err_mutex;
+ 	}
+ 
+ 	if (dsp->ops->enable_core) {
+ 		ret = dsp->ops->enable_core(dsp);
+ 		if (ret != 0)
+ 			goto err_mem;
+ 	}
+ 
+ 	ret = cs_dsp_load(dsp, wmfw_firmware, wmfw_filename);
+ 	if (ret != 0)
+ 		goto err_ena;
+ 
+ 	ret = dsp->ops->setup_algs(dsp);
+ 	if (ret != 0)
+ 		goto err_ena;
+ 
+ 	ret = cs_dsp_load_coeff(dsp, coeff_firmware, coeff_filename);
+ 	if (ret != 0)
+ 		goto err_ena;
+ 
+ 	/* Initialize caches for enabled and unset controls */
+ 	ret = cs_dsp_coeff_init_control_caches(dsp);
+ 	if (ret != 0)
+ 		goto err_ena;
+ 
+ 	if (dsp->ops->disable_core)
+ 		dsp->ops->disable_core(dsp);
+ 
+ 	dsp->booted = true;
+ 
+ 	mutex_unlock(&dsp->pwr_lock);
+ 
+ 	return 0;
+ err_ena:
+ 	if (dsp->ops->disable_core)
+ 		dsp->ops->disable_core(dsp);
+ err_mem:
+ 	if (dsp->ops->disable_memory)
+ 		dsp->ops->disable_memory(dsp);
+ err_mutex:
+ 	mutex_unlock(&dsp->pwr_lock);
+ 
+ 	return ret;
+ }
+ 
+ static void cs_dsp_power_down(struct wm_adsp *dsp)
+ {
+ 	struct cs_dsp_coeff_ctl *ctl;
+ 
+ 	mutex_lock(&dsp->pwr_lock);
+ 
+ 	cs_dsp_debugfs_clear(dsp);
+ 
+ 	dsp->fw_id = 0;
+ 	dsp->fw_id_version = 0;
+ 
+ 	dsp->booted = false;
+ 
+ 	if (dsp->ops->disable_memory)
+ 		dsp->ops->disable_memory(dsp);
+ 
+ 	list_for_each_entry(ctl, &dsp->ctl_list, list)
+ 		ctl->enabled = 0;
+ 
+ 	cs_dsp_free_alg_regions(dsp);
+ 
+ 	mutex_unlock(&dsp->pwr_lock);
+ 
+ 	cs_dsp_dbg(dsp, "Shutdown complete\n");
+ }
+ 
+ static void wm_adsp_boot_work(struct work_struct *work)
+ {
+ 	struct wm_adsp *dsp = container_of(work,
+ 					   struct wm_adsp,
+ 					   boot_work);
+ 	int ret = 0;
+ 	char *wmfw_filename = NULL;
+ 	const struct firmware *wmfw_firmware = NULL;
+ 	char *coeff_filename = NULL;
+ 	const struct firmware *coeff_firmware = NULL;
+ 
+ 	ret = wm_adsp_request_firmware_files(dsp,
+ 					     &wmfw_firmware, &wmfw_filename,
+ 					     &coeff_firmware, &coeff_filename);
+ 	if (ret)
+ 		return;
+ 
+ 	cs_dsp_power_up(dsp,
+ 			wmfw_firmware, wmfw_filename,
+ 			coeff_firmware, coeff_filename,
+ 			wm_adsp_fw_text[dsp->fw]);
+ 
+ 	wm_adsp_release_firmware_files(dsp,
+ 				       wmfw_firmware, wmfw_filename,
+ 				       coeff_firmware, coeff_filename);
+ }
+ 
++>>>>>>> a828056fa1fc (ASoC: wm_adsp: move firmware loading to client)
  int wm_adsp_early_event(struct snd_soc_dapm_widget *w,
  			struct snd_kcontrol *kcontrol, int event)
  {
* Unmerged path sound/soc/codecs/wm_adsp.c
