SUNRPC: Don't call connect() more than once on a TCP socket

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-425.3.1.el8
commit-author Trond Myklebust <trond.myklebust@hammerspace.com>
commit 89f42494f92f448747bd8a7ab1ae8b5d5520577d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-425.3.1.el8/89f42494.failed

Avoid socket state races due to repeated calls to ->connect() using the
same socket. If connect() returns 0 due to the connection having
completed, but we are in fact in a closing state, then we may leave the
XPRT_CONNECTING flag set on the transport.

	Reported-by: Enrico Scholz <enrico.scholz@sigma-chemnitz.de>
Fixes: 3be232f11a3c ("SUNRPC: Prevent immediate close+reconnect")
	Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>
(cherry picked from commit 89f42494f92f448747bd8a7ab1ae8b5d5520577d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sunrpc/xprtsock.c
diff --cc net/sunrpc/xprtsock.c
index 5928f8afffe8,8f8a03c3315a..000000000000
--- a/net/sunrpc/xprtsock.c
+++ b/net/sunrpc/xprtsock.c
@@@ -2263,11 -2231,19 +2263,25 @@@ static void xs_tcp_setup_socket(struct 
  	struct socket *sock = transport->sock;
  	struct rpc_xprt *xprt = &transport->xprt;
  	int status;
 -	unsigned int pflags = current->flags;
  
++<<<<<<< HEAD
 +	if (!sock) {
 +		sock = xs_create_sock(xprt, transport,
 +				xs_addr(xprt)->sa_family, SOCK_STREAM,
 +				IPPROTO_TCP, true);
++=======
+ 	if (atomic_read(&xprt->swapper))
+ 		current->flags |= PF_MEMALLOC;
+ 
+ 	if (xprt_connected(xprt))
+ 		goto out;
+ 	if (test_and_clear_bit(XPRT_SOCK_CONNECT_SENT,
+ 			       &transport->sock_state) ||
+ 	    !sock) {
+ 		xs_reset_transport(transport);
+ 		sock = xs_create_sock(xprt, transport, xs_addr(xprt)->sa_family,
+ 				      SOCK_STREAM, IPPROTO_TCP, true);
++>>>>>>> 89f42494f92f (SUNRPC: Don't call connect() more than once on a TCP socket)
  		if (IS_ERR(sock)) {
  			xprt_wake_pending_tasks(xprt, PTR_ERR(sock));
  			goto out;
@@@ -2288,12 -2264,13 +2302,13 @@@
  	switch (status) {
  	case 0:
  		xs_set_srcport(transport, sock);
 -		fallthrough;
 +		/* fall through */
  	case -EINPROGRESS:
  		/* SYN_SENT! */
+ 		set_bit(XPRT_SOCK_CONNECT_SENT, &transport->sock_state);
  		if (xprt->reestablish_timeout < XS_TCP_INIT_REEST_TO)
  			xprt->reestablish_timeout = XS_TCP_INIT_REEST_TO;
 -		fallthrough;
 +		/* fall through */
  	case -EALREADY:
  		goto out_unlock;
  	case -EADDRNOTAVAIL:
diff --git a/include/linux/sunrpc/xprtsock.h b/include/linux/sunrpc/xprtsock.h
index 3c1423ee74b4..fed813ffe7db 100644
--- a/include/linux/sunrpc/xprtsock.h
+++ b/include/linux/sunrpc/xprtsock.h
@@ -88,5 +88,6 @@ struct sock_xprt {
 #define XPRT_SOCK_WAKE_WRITE	(5)
 #define XPRT_SOCK_WAKE_PENDING	(6)
 #define XPRT_SOCK_WAKE_DISCONNECT	(7)
+#define XPRT_SOCK_CONNECT_SENT	(8)
 
 #endif /* _LINUX_SUNRPC_XPRTSOCK_H */
* Unmerged path net/sunrpc/xprtsock.c
