ASoC: wm_adsp: Split DSP power operations into helper functions

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-425.3.1.el8
commit-author Simon Trimmer <simont@opensource.cirrus.com>
commit 186152df4d431650154c3e3aefc7d3e1004987c8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-425.3.1.el8/186152df.failed

This is preparation for moving the generic DSP support out of
ASoC. This change separates the generic handling of power and state
transitions from the DAPM API wrapper.

	Signed-off-by: Simon Trimmer <simont@opensource.cirrus.com>
	Signed-off-by: Charles Keepax <ckeepax@opensource.cirrus.com>
Link: https://lore.kernel.org/r/20210913160057.103842-9-simont@opensource.cirrus.com
	Signed-off-by: Mark Brown <broonie@kernel.org>
(cherry picked from commit 186152df4d431650154c3e3aefc7d3e1004987c8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/soc/codecs/wm_adsp.c
diff --cc sound/soc/codecs/wm_adsp.c
index c1b5ea3b5718,1bca3922a6b8..000000000000
--- a/sound/soc/codecs/wm_adsp.c
+++ b/sound/soc/codecs/wm_adsp.c
@@@ -2803,92 -2815,62 +2795,144 @@@ static int cs_dsp_adsp1_power_up(struc
  
  	mutex_lock(&dsp->pwr_lock);
  
- 	switch (event) {
- 	case SND_SOC_DAPM_POST_PMU:
- 		regmap_update_bits(dsp->regmap, dsp->base + ADSP1_CONTROL_30,
- 				   ADSP1_SYS_ENA, ADSP1_SYS_ENA);
+ 	regmap_update_bits(dsp->regmap, dsp->base + ADSP1_CONTROL_30,
+ 			   ADSP1_SYS_ENA, ADSP1_SYS_ENA);
  
++<<<<<<< HEAD
 +		/*
 +		 * For simplicity set the DSP clock rate to be the
 +		 * SYSCLK rate rather than making it configurable.
 +		 */
 +		if (dsp->sysclk_reg) {
 +			ret = regmap_read(dsp->regmap, dsp->sysclk_reg, &val);
 +			if (ret != 0) {
 +				adsp_err(dsp, "Failed to read SYSCLK state: %d\n",
 +				ret);
 +				goto err_mutex;
 +			}
 +
 +			val = (val & dsp->sysclk_mask) >> dsp->sysclk_shift;
 +
 +			ret = regmap_update_bits(dsp->regmap,
 +						 dsp->base + ADSP1_CONTROL_31,
 +						 ADSP1_CLK_SEL_MASK, val);
 +			if (ret != 0) {
 +				adsp_err(dsp, "Failed to set clock rate: %d\n",
 +					 ret);
 +				goto err_mutex;
 +			}
 +		}
 +
 +		ret = wm_adsp_load(dsp);
 +		if (ret != 0)
 +			goto err_ena;
 +
 +		ret = wm_adsp1_setup_algs(dsp);
 +		if (ret != 0)
 +			goto err_ena;
 +
 +		ret = wm_adsp_load_coeff(dsp);
 +		if (ret != 0)
 +			goto err_ena;
 +
 +		/* Initialize caches for enabled and unset controls */
 +		ret = wm_coeff_init_control_caches(dsp);
 +		if (ret != 0)
 +			goto err_ena;
 +
 +		/* Sync set controls */
 +		ret = wm_coeff_sync_controls(dsp);
 +		if (ret != 0)
 +			goto err_ena;
 +
 +		dsp->booted = true;
 +
 +		/* Start the core running */
 +		regmap_update_bits(dsp->regmap, dsp->base + ADSP1_CONTROL_30,
 +				   ADSP1_CORE_ENA | ADSP1_START,
 +				   ADSP1_CORE_ENA | ADSP1_START);
 +
 +		dsp->running = true;
 +		break;
 +
 +	case SND_SOC_DAPM_PRE_PMD:
 +		dsp->running = false;
 +		dsp->booted = false;
 +
 +		/* Halt the core */
 +		regmap_update_bits(dsp->regmap, dsp->base + ADSP1_CONTROL_30,
 +				   ADSP1_CORE_ENA | ADSP1_START, 0);
 +
 +		regmap_update_bits(dsp->regmap, dsp->base + ADSP1_CONTROL_19,
 +				   ADSP1_WDMA_BUFFER_LENGTH_MASK, 0);
 +
 +		regmap_update_bits(dsp->regmap, dsp->base + ADSP1_CONTROL_30,
 +				   ADSP1_SYS_ENA, 0);
 +
 +		list_for_each_entry(ctl, &dsp->ctl_list, list)
 +			ctl->enabled = 0;
 +
 +
 +		wm_adsp_free_alg_regions(dsp);
 +		break;
 +
 +	default:
 +		break;
++=======
+ 	/*
+ 	 * For simplicity set the DSP clock rate to be the
+ 	 * SYSCLK rate rather than making it configurable.
+ 	 */
+ 	if (dsp->sysclk_reg) {
+ 		ret = regmap_read(dsp->regmap, dsp->sysclk_reg, &val);
+ 		if (ret != 0) {
+ 			cs_dsp_err(dsp, "Failed to read SYSCLK state: %d\n", ret);
+ 			goto err_mutex;
+ 		}
+ 
+ 		val = (val & dsp->sysclk_mask) >> dsp->sysclk_shift;
+ 
+ 		ret = regmap_update_bits(dsp->regmap,
+ 					 dsp->base + ADSP1_CONTROL_31,
+ 					 ADSP1_CLK_SEL_MASK, val);
+ 		if (ret != 0) {
+ 			cs_dsp_err(dsp, "Failed to set clock rate: %d\n", ret);
+ 			goto err_mutex;
+ 		}
++>>>>>>> 186152df4d43 (ASoC: wm_adsp: Split DSP power operations into helper functions)
  	}
  
+ 	ret = cs_dsp_load(dsp);
+ 	if (ret != 0)
+ 		goto err_ena;
+ 
+ 	ret = cs_dsp_adsp1_setup_algs(dsp);
+ 	if (ret != 0)
+ 		goto err_ena;
+ 
+ 	ret = cs_dsp_load_coeff(dsp);
+ 	if (ret != 0)
+ 		goto err_ena;
+ 
+ 	/* Initialize caches for enabled and unset controls */
+ 	ret = cs_dsp_coeff_init_control_caches(dsp);
+ 	if (ret != 0)
+ 		goto err_ena;
+ 
+ 	/* Sync set controls */
+ 	ret = cs_dsp_coeff_sync_controls(dsp);
+ 	if (ret != 0)
+ 		goto err_ena;
+ 
+ 	dsp->booted = true;
+ 
+ 	/* Start the core running */
+ 	regmap_update_bits(dsp->regmap, dsp->base + ADSP1_CONTROL_30,
+ 			   ADSP1_CORE_ENA | ADSP1_START,
+ 			   ADSP1_CORE_ENA | ADSP1_START);
+ 
+ 	dsp->running = true;
+ 
  	mutex_unlock(&dsp->pwr_lock);
  
  	return 0;
@@@ -3001,64 -3034,7 +3096,68 @@@ static void wm_adsp2v2_disable_core(str
  	regmap_write(dsp->regmap, dsp->base + ADSP2V2_WDMA_CONFIG_2, 0);
  }
  
++<<<<<<< HEAD
 +static void wm_adsp_boot_work(struct work_struct *work)
 +{
 +	struct wm_adsp *dsp = container_of(work,
 +					   struct wm_adsp,
 +					   boot_work);
 +	int ret;
 +
 +	mutex_lock(&dsp->pwr_lock);
 +
 +	if (dsp->ops->enable_memory) {
 +		ret = dsp->ops->enable_memory(dsp);
 +		if (ret != 0)
 +			goto err_mutex;
 +	}
 +
 +	if (dsp->ops->enable_core) {
 +		ret = dsp->ops->enable_core(dsp);
 +		if (ret != 0)
 +			goto err_mem;
 +	}
 +
 +	ret = wm_adsp_load(dsp);
 +	if (ret != 0)
 +		goto err_ena;
 +
 +	ret = dsp->ops->setup_algs(dsp);
 +	if (ret != 0)
 +		goto err_ena;
 +
 +	ret = wm_adsp_load_coeff(dsp);
 +	if (ret != 0)
 +		goto err_ena;
 +
 +	/* Initialize caches for enabled and unset controls */
 +	ret = wm_coeff_init_control_caches(dsp);
 +	if (ret != 0)
 +		goto err_ena;
 +
 +	if (dsp->ops->disable_core)
 +		dsp->ops->disable_core(dsp);
 +
 +	dsp->booted = true;
 +
 +	mutex_unlock(&dsp->pwr_lock);
 +
 +	return;
 +
 +err_ena:
 +	if (dsp->ops->disable_core)
 +		dsp->ops->disable_core(dsp);
 +err_mem:
 +	if (dsp->ops->disable_memory)
 +		dsp->ops->disable_memory(dsp);
 +err_mutex:
 +	mutex_unlock(&dsp->pwr_lock);
 +}
 +
 +static int wm_halo_configure_mpu(struct wm_adsp *dsp, unsigned int lock_regions)
++=======
+ static int cs_dsp_halo_configure_mpu(struct wm_adsp *dsp, unsigned int lock_regions)
++>>>>>>> 186152df4d43 (ASoC: wm_adsp: Split DSP power operations into helper functions)
  {
  	struct reg_sequence config[] = {
  		{ dsp->base + HALO_MPU_LOCK_CONFIG,     0x5555 },
@@@ -3174,26 -3244,7 +3361,30 @@@ int wm_adsp_early_event(struct snd_soc_
  		queue_work(system_unbound_wq, &dsp->boot_work);
  		break;
  	case SND_SOC_DAPM_PRE_PMD:
++<<<<<<< HEAD
 +		mutex_lock(&dsp->pwr_lock);
 +
 +		wm_adsp_debugfs_clear(dsp);
 +
 +		dsp->fw_id = 0;
 +		dsp->fw_id_version = 0;
 +
 +		dsp->booted = false;
 +
 +		if (dsp->ops->disable_memory)
 +			dsp->ops->disable_memory(dsp);
 +
 +		list_for_each_entry(ctl, &dsp->ctl_list, list)
 +			ctl->enabled = 0;
 +
 +		wm_adsp_free_alg_regions(dsp);
 +
 +		mutex_unlock(&dsp->pwr_lock);
 +
 +		adsp_dbg(dsp, "Shutdown complete\n");
++=======
+ 		cs_dsp_power_down(dsp);
++>>>>>>> 186152df4d43 (ASoC: wm_adsp: Split DSP power operations into helper functions)
  		break;
  	default:
  		break;
@@@ -3216,97 -3267,68 +3407,157 @@@ static void wm_adsp2_stop_core(struct w
  			   ADSP2_CORE_ENA | ADSP2_START, 0);
  }
  
- int wm_adsp_event(struct snd_soc_dapm_widget *w,
- 		  struct snd_kcontrol *kcontrol, int event)
+ static int wm_adsp_event_post_run(struct wm_adsp *dsp)
  {
++<<<<<<< HEAD
 +	struct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);
 +	struct wm_adsp *dsps = snd_soc_component_get_drvdata(component);
 +	struct wm_adsp *dsp = &dsps[w->shift];
 +	int ret;
 +
 +	switch (event) {
 +	case SND_SOC_DAPM_POST_PMU:
 +		flush_work(&dsp->boot_work);
 +
 +		mutex_lock(&dsp->pwr_lock);
 +
 +		if (!dsp->booted) {
 +			ret = -EIO;
 +			goto err;
 +		}
 +
 +		if (dsp->ops->enable_core) {
 +			ret = dsp->ops->enable_core(dsp);
 +			if (ret != 0)
 +				goto err;
 +		}
 +
 +		/* Sync set controls */
 +		ret = wm_coeff_sync_controls(dsp);
 +		if (ret != 0)
 +			goto err;
 +
 +		if (dsp->ops->lock_memory) {
 +			ret = dsp->ops->lock_memory(dsp, dsp->lock_regions);
 +			if (ret != 0) {
 +				adsp_err(dsp, "Error configuring MPU: %d\n",
 +					 ret);
 +				goto err;
 +			}
 +		}
 +
 +		if (dsp->ops->start_core) {
 +			ret = dsp->ops->start_core(dsp);
 +			if (ret != 0)
 +				goto err;
 +		}
 +
 +		dsp->running = true;
 +
 +		if (wm_adsp_fw[dsp->fw].num_caps != 0) {
 +			ret = wm_adsp_buffer_init(dsp);
 +			if (ret < 0)
 +				goto err;
 +		}
 +
 +		mutex_unlock(&dsp->pwr_lock);
 +		break;
 +
 +	case SND_SOC_DAPM_PRE_PMD:
 +		/* Tell the firmware to cleanup */
 +		wm_adsp_signal_event_controls(dsp, WM_ADSP_FW_EVENT_SHUTDOWN);
 +
 +		if (dsp->ops->stop_watchdog)
 +			dsp->ops->stop_watchdog(dsp);
 +
 +		/* Log firmware state, it can be useful for analysis */
 +		if (dsp->ops->show_fw_status)
 +			dsp->ops->show_fw_status(dsp);
 +
 +		mutex_lock(&dsp->pwr_lock);
 +
 +		dsp->running = false;
 +
 +		if (dsp->ops->stop_core)
 +			dsp->ops->stop_core(dsp);
 +		if (dsp->ops->disable_core)
 +			dsp->ops->disable_core(dsp);
 +
 +		if (wm_adsp_fw[dsp->fw].num_caps != 0)
 +			wm_adsp_buffer_free(dsp);
 +
 +		dsp->fatal_error = false;
 +
 +		mutex_unlock(&dsp->pwr_lock);
 +
 +		adsp_dbg(dsp, "Execution stopped\n");
 +		break;
 +
 +	default:
 +		break;
 +	}
++=======
+ 	if (wm_adsp_fw[dsp->fw].num_caps != 0)
+ 		return wm_adsp_buffer_init(dsp);
++>>>>>>> 186152df4d43 (ASoC: wm_adsp: Split DSP power operations into helper functions)
+ 
+ 	return 0;
+ }
+ 
+ static void wm_adsp_event_post_stop(struct wm_adsp *dsp)
+ {
+ 	if (wm_adsp_fw[dsp->fw].num_caps != 0)
+ 		wm_adsp_buffer_free(dsp);
+ 
+ 	dsp->fatal_error = false;
+ }
+ 
+ static int cs_dsp_run(struct wm_adsp *dsp)
+ {
+ 	int ret;
+ 
+ 	mutex_lock(&dsp->pwr_lock);
+ 
+ 	if (!dsp->booted) {
+ 		ret = -EIO;
+ 		goto err;
+ 	}
+ 
+ 	if (dsp->ops->enable_core) {
+ 		ret = dsp->ops->enable_core(dsp);
+ 		if (ret != 0)
+ 			goto err;
+ 	}
+ 
+ 	/* Sync set controls */
+ 	ret = cs_dsp_coeff_sync_controls(dsp);
+ 	if (ret != 0)
+ 		goto err;
+ 
+ 	if (dsp->ops->lock_memory) {
+ 		ret = dsp->ops->lock_memory(dsp, dsp->lock_regions);
+ 		if (ret != 0) {
+ 			cs_dsp_err(dsp, "Error configuring MPU: %d\n", ret);
+ 			goto err;
+ 		}
+ 	}
+ 
+ 	if (dsp->ops->start_core) {
+ 		ret = dsp->ops->start_core(dsp);
+ 		if (ret != 0)
+ 			goto err;
+ 	}
+ 
+ 	dsp->running = true;
+ 
+ 	ret = wm_adsp_event_post_run(dsp);
+ 	if (ret < 0)
+ 		goto err;
+ 
+ 	mutex_unlock(&dsp->pwr_lock);
  
  	return 0;
+ 
  err:
  	if (dsp->ops->stop_core)
  		dsp->ops->stop_core(dsp);
* Unmerged path sound/soc/codecs/wm_adsp.c
