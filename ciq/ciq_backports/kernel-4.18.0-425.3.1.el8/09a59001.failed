netfilter: conntrack: remove unneeded indent level

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-425.3.1.el8
commit-author Florian Westphal <fw@strlen.de>
commit 09a59001b0d6417214c86b69263f6b8981c7c2db
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-425.3.1.el8/09a59001.failed

After previous patch, the conditional branch is obsolete, reformat it.
gcc generates same code as before this change.

	Signed-off-by: Florian Westphal <fw@strlen.de>
(cherry picked from commit 09a59001b0d6417214c86b69263f6b8981c7c2db)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/nf_conntrack_proto_tcp.c
diff --cc net/netfilter/nf_conntrack_proto_tcp.c
index f9bb6bbd54e2,0574290326d1..000000000000
--- a/net/netfilter/nf_conntrack_proto_tcp.c
+++ b/net/netfilter/nf_conntrack_proto_tcp.c
@@@ -627,99 -655,66 +627,108 @@@ static bool tcp_in_window(const struct 
  	/* Is the ending sequence in the receive window (if available)? */
  	in_recv_win = !receiver->td_maxwin ||
  		      after(end, sender->td_end - receiver->td_maxwin - 1);
++<<<<<<< HEAD
 +
 +	pr_debug("tcp_in_window: I=%i II=%i III=%i IV=%i\n",
 +		 before(seq, sender->td_maxend + 1),
 +		 (in_recv_win ? 1 : 0),
 +		 before(sack, receiver->td_end + 1),
 +		 after(sack, receiver->td_end - MAXACKWINDOW(sender) - 1));
 +
 +	if (before(seq, sender->td_maxend + 1) &&
 +	    in_recv_win &&
 +	    before(sack, receiver->td_end + 1) &&
 +	    after(sack, receiver->td_end - MAXACKWINDOW(sender) - 1)) {
 +		/*
 +		 * Take into account window scaling (RFC 1323).
 +		 */
 +		if (!tcph->syn)
 +			win <<= sender->td_scale;
- 
- 		/*
- 		 * Update sender data.
- 		 */
- 		swin = win + (sack - ack);
- 		if (sender->td_maxwin < swin)
- 			sender->td_maxwin = swin;
- 		if (after(end, sender->td_end)) {
- 			sender->td_end = end;
- 			sender->flags |= IP_CT_TCP_FLAG_DATA_UNACKNOWLEDGED;
- 		}
- 		if (tcph->ack) {
- 			if (!(sender->flags & IP_CT_TCP_FLAG_MAXACK_SET)) {
- 				sender->td_maxack = ack;
- 				sender->flags |= IP_CT_TCP_FLAG_MAXACK_SET;
- 			} else if (after(ack, sender->td_maxack))
- 				sender->td_maxack = ack;
- 		}
- 
- 		/*
- 		 * Update receiver data.
- 		 */
- 		if (receiver->td_maxwin != 0 && after(end, sender->td_maxend))
- 			receiver->td_maxwin += end - sender->td_maxend;
- 		if (after(sack + win, receiver->td_maxend - 1)) {
- 			receiver->td_maxend = sack + win;
- 			if (win == 0)
- 				receiver->td_maxend++;
++=======
+ 	if (!in_recv_win)
+ 		return nf_tcp_log_invalid(skb, ct, hook_state, sender, NFCT_TCP_IGNORE,
+ 					  "SEQ is under lower bound %u (already ACKed data retransmitted)",
+ 					  sender->td_end - receiver->td_maxwin - 1);
+ 	if (!after(sack, receiver->td_end - MAXACKWINDOW(sender) - 1))
+ 		return nf_tcp_log_invalid(skb, ct, hook_state, sender, NFCT_TCP_IGNORE,
+ 					  "ignored ACK under lower bound %u (possible overly delayed)",
+ 					  receiver->td_end - MAXACKWINDOW(sender) - 1);
++>>>>>>> 09a59001b0d6 (netfilter: conntrack: remove unneeded indent level)
+ 
+ 	/* Take into account window scaling (RFC 1323). */
+ 	if (!tcph->syn)
+ 		win <<= sender->td_scale;
+ 
+ 	/* Update sender data. */
+ 	swin = win + (sack - ack);
+ 	if (sender->td_maxwin < swin)
+ 		sender->td_maxwin = swin;
+ 	if (after(end, sender->td_end)) {
+ 		sender->td_end = end;
+ 		sender->flags |= IP_CT_TCP_FLAG_DATA_UNACKNOWLEDGED;
+ 	}
+ 	if (tcph->ack) {
+ 		if (!(sender->flags & IP_CT_TCP_FLAG_MAXACK_SET)) {
+ 			sender->td_maxack = ack;
+ 			sender->flags |= IP_CT_TCP_FLAG_MAXACK_SET;
+ 		} else if (after(ack, sender->td_maxack)) {
+ 			sender->td_maxack = ack;
  		}
- 		if (ack == receiver->td_end)
- 			receiver->flags &= ~IP_CT_TCP_FLAG_DATA_UNACKNOWLEDGED;
+ 	}
  
- 		/*
- 		 * Check retransmissions.
- 		 */
- 		if (index == TCP_ACK_SET) {
- 			if (state->last_dir == dir
- 			    && state->last_seq == seq
- 			    && state->last_ack == ack
- 			    && state->last_end == end
- 			    && state->last_win == win_raw)
- 				state->retrans++;
- 			else {
- 				state->last_dir = dir;
- 				state->last_seq = seq;
- 				state->last_ack = ack;
- 				state->last_end = end;
- 				state->last_win = win_raw;
- 				state->retrans = 0;
- 			}
+ 	/* Update receiver data. */
+ 	if (receiver->td_maxwin != 0 && after(end, sender->td_maxend))
+ 		receiver->td_maxwin += end - sender->td_maxend;
+ 	if (after(sack + win, receiver->td_maxend - 1)) {
+ 		receiver->td_maxend = sack + win;
+ 		if (win == 0)
+ 			receiver->td_maxend++;
+ 	}
+ 	if (ack == receiver->td_end)
+ 		receiver->flags &= ~IP_CT_TCP_FLAG_DATA_UNACKNOWLEDGED;
+ 
+ 	/* Check retransmissions. */
+ 	if (index == TCP_ACK_SET) {
+ 		if (state->last_dir == dir &&
+ 		    state->last_seq == seq &&
+ 		    state->last_ack == ack &&
+ 		    state->last_end == end &&
+ 		    state->last_win == win_raw) {
+ 			state->retrans++;
+ 		} else {
+ 			state->last_dir = dir;
+ 			state->last_seq = seq;
+ 			state->last_ack = ack;
+ 			state->last_end = end;
+ 			state->last_win = win_raw;
+ 			state->retrans = 0;
  		}
 +		res = true;
 +	} else {
 +		res = false;
 +		if (sender->flags & IP_CT_TCP_FLAG_BE_LIBERAL ||
 +		    tn->tcp_be_liberal)
 +			res = true;
 +		if (!res) {
 +			nf_ct_l4proto_log_invalid(skb, ct,
 +			"%s",
 +			before(seq, sender->td_maxend + 1) ?
 +			in_recv_win ?
 +			before(sack, receiver->td_end + 1) ?
 +			after(sack, receiver->td_end - MAXACKWINDOW(sender) - 1) ? "BUG"
 +			: "ACK is under the lower bound (possible overly delayed ACK)"
 +			: "ACK is over the upper bound (ACKed data not seen yet)"
 +			: "SEQ is under the lower bound (already ACKed data retransmitted)"
 +			: "SEQ is over the upper bound (over the window of the receiver)");
 +		}
  	}
  
 -	return NFCT_TCP_ACCEPT;
 +	pr_debug("tcp_in_window: res=%u sender end=%u maxend=%u maxwin=%u "
 +		 "receiver end=%u maxend=%u maxwin=%u\n",
 +		 res, sender->td_end, sender->td_maxend, sender->td_maxwin,
 +		 receiver->td_end, receiver->td_maxend, receiver->td_maxwin);
 +
 +	return res;
  }
  
  /* table of valid flag combinations - PUSH, ECE and CWR are always valid */
* Unmerged path net/netfilter/nf_conntrack_proto_tcp.c
