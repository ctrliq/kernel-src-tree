usb: dwc3: gadget: Skip resizing EP's TX FIFO if already resized

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-425.3.1.el8
commit-author Jack Pham <jackp@codeaurora.org>
commit 876a75cb520f5869533a30a6ca01545ec817b7a0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-425.3.1.el8/876a75cb.failed

Some functions may dynamically enable and disable their endpoints
regularly throughout their operation, particularly when Set Interface
is employed to switch between Alternate Settings.  For instance the
UAC2 function has its respective endpoints for playback & capture
associated with AltSetting 1, in which case those endpoints would not
get enabled until the host activates the AltSetting.  And they
conversely become disabled when the interfaces' AltSetting 0 is
chosen.

With the DWC3 FIFO resizing algorithm recently added, every
usb_ep_enable() call results in a call to resize that EP's TXFIFO,
but if the same endpoint is enabled again and again, this incorrectly
leads to FIFO RAM allocation exhaustion as the mechanism did not
account for the possibility that endpoints can be re-enabled many
times.

Example log splat:

	dwc3 a600000.dwc3: Fifosize(3717) > RAM size(3462) ep3in depth:217973127
	configfs-gadget gadget: u_audio_start_capture:521 Error!
	dwc3 a600000.dwc3: request 000000000be13e18 was not queued to ep3in

Add another bit DWC3_EP_TXFIFO_RESIZED to dep->flags to keep track of
whether an EP had already been resized in the current configuration.
If so, bail out of dwc3_gadget_resize_tx_fifos() to avoid the
calculation error resulting from accumulating the EP's FIFO depth
repeatedly.  This flag is retained across multiple ep_disable() and
ep_enable() calls and is cleared when GTXFIFOSIZn is reset in
dwc3_gadget_clear_tx_fifos() upon receiving the next Set Config.

Fixes: 9f607a309fbe9 ("usb: dwc3: Resize TX FIFOs to meet EP bursting requirements")
	Reviewed-by: Thinh Nguyen <Thinh.Nguyen@synopsys.com>
	Signed-off-by: Jack Pham <jackp@codeaurora.org>
Link: https://lore.kernel.org/r/20211021180129.27938-1-jackp@codeaurora.org
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 876a75cb520f5869533a30a6ca01545ec817b7a0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/usb/dwc3/gadget.c
diff --cc drivers/usb/dwc3/gadget.c
index 1c1103077f09,23de2a5a40d6..000000000000
--- a/drivers/usb/dwc3/gadget.c
+++ b/drivers/usb/dwc3/gadget.c
@@@ -632,6 -632,193 +632,196 @@@ static void dwc3_stop_active_transfer(s
  		bool interrupt);
  
  /**
++<<<<<<< HEAD
++=======
+  * dwc3_gadget_calc_tx_fifo_size - calculates the txfifo size value
+  * @dwc: pointer to the DWC3 context
+  * @nfifos: number of fifos to calculate for
+  *
+  * Calculates the size value based on the equation below:
+  *
+  * DWC3 revision 280A and prior:
+  * fifo_size = mult * (max_packet / mdwidth) + 1;
+  *
+  * DWC3 revision 290A and onwards:
+  * fifo_size = mult * ((max_packet + mdwidth)/mdwidth + 1) + 1
+  *
+  * The max packet size is set to 1024, as the txfifo requirements mainly apply
+  * to super speed USB use cases.  However, it is safe to overestimate the fifo
+  * allocations for other scenarios, i.e. high speed USB.
+  */
+ static int dwc3_gadget_calc_tx_fifo_size(struct dwc3 *dwc, int mult)
+ {
+ 	int max_packet = 1024;
+ 	int fifo_size;
+ 	int mdwidth;
+ 
+ 	mdwidth = dwc3_mdwidth(dwc);
+ 
+ 	/* MDWIDTH is represented in bits, we need it in bytes */
+ 	mdwidth >>= 3;
+ 
+ 	if (DWC3_VER_IS_PRIOR(DWC3, 290A))
+ 		fifo_size = mult * (max_packet / mdwidth) + 1;
+ 	else
+ 		fifo_size = mult * ((max_packet + mdwidth) / mdwidth) + 1;
+ 	return fifo_size;
+ }
+ 
+ /**
+  * dwc3_gadget_clear_tx_fifo_size - Clears txfifo allocation
+  * @dwc: pointer to the DWC3 context
+  *
+  * Iterates through all the endpoint registers and clears the previous txfifo
+  * allocations.
+  */
+ void dwc3_gadget_clear_tx_fifos(struct dwc3 *dwc)
+ {
+ 	struct dwc3_ep *dep;
+ 	int fifo_depth;
+ 	int size;
+ 	int num;
+ 
+ 	if (!dwc->do_fifo_resize)
+ 		return;
+ 
+ 	/* Read ep0IN related TXFIFO size */
+ 	dep = dwc->eps[1];
+ 	size = dwc3_readl(dwc->regs, DWC3_GTXFIFOSIZ(0));
+ 	if (DWC3_IP_IS(DWC3))
+ 		fifo_depth = DWC3_GTXFIFOSIZ_TXFDEP(size);
+ 	else
+ 		fifo_depth = DWC31_GTXFIFOSIZ_TXFDEP(size);
+ 
+ 	dwc->last_fifo_depth = fifo_depth;
+ 	/* Clear existing TXFIFO for all IN eps except ep0 */
+ 	for (num = 3; num < min_t(int, dwc->num_eps, DWC3_ENDPOINTS_NUM);
+ 	     num += 2) {
+ 		dep = dwc->eps[num];
+ 		/* Don't change TXFRAMNUM on usb31 version */
+ 		size = DWC3_IP_IS(DWC3) ? 0 :
+ 			dwc3_readl(dwc->regs, DWC3_GTXFIFOSIZ(num >> 1)) &
+ 				   DWC31_GTXFIFOSIZ_TXFRAMNUM;
+ 
+ 		dwc3_writel(dwc->regs, DWC3_GTXFIFOSIZ(num >> 1), size);
+ 		dep->flags &= ~DWC3_EP_TXFIFO_RESIZED;
+ 	}
+ 	dwc->num_ep_resized = 0;
+ }
+ 
+ /*
+  * dwc3_gadget_resize_tx_fifos - reallocate fifo spaces for current use-case
+  * @dwc: pointer to our context structure
+  *
+  * This function will a best effort FIFO allocation in order
+  * to improve FIFO usage and throughput, while still allowing
+  * us to enable as many endpoints as possible.
+  *
+  * Keep in mind that this operation will be highly dependent
+  * on the configured size for RAM1 - which contains TxFifo -,
+  * the amount of endpoints enabled on coreConsultant tool, and
+  * the width of the Master Bus.
+  *
+  * In general, FIFO depths are represented with the following equation:
+  *
+  * fifo_size = mult * ((max_packet + mdwidth)/mdwidth + 1) + 1
+  *
+  * In conjunction with dwc3_gadget_check_config(), this resizing logic will
+  * ensure that all endpoints will have enough internal memory for one max
+  * packet per endpoint.
+  */
+ static int dwc3_gadget_resize_tx_fifos(struct dwc3_ep *dep)
+ {
+ 	struct dwc3 *dwc = dep->dwc;
+ 	int fifo_0_start;
+ 	int ram1_depth;
+ 	int fifo_size;
+ 	int min_depth;
+ 	int num_in_ep;
+ 	int remaining;
+ 	int num_fifos = 1;
+ 	int fifo;
+ 	int tmp;
+ 
+ 	if (!dwc->do_fifo_resize)
+ 		return 0;
+ 
+ 	/* resize IN endpoints except ep0 */
+ 	if (!usb_endpoint_dir_in(dep->endpoint.desc) || dep->number <= 1)
+ 		return 0;
+ 
+ 	/* bail if already resized */
+ 	if (dep->flags & DWC3_EP_TXFIFO_RESIZED)
+ 		return 0;
+ 
+ 	ram1_depth = DWC3_RAM1_DEPTH(dwc->hwparams.hwparams7);
+ 
+ 	if ((dep->endpoint.maxburst > 1 &&
+ 	     usb_endpoint_xfer_bulk(dep->endpoint.desc)) ||
+ 	    usb_endpoint_xfer_isoc(dep->endpoint.desc))
+ 		num_fifos = 3;
+ 
+ 	if (dep->endpoint.maxburst > 6 &&
+ 	    usb_endpoint_xfer_bulk(dep->endpoint.desc) && DWC3_IP_IS(DWC31))
+ 		num_fifos = dwc->tx_fifo_resize_max_num;
+ 
+ 	/* FIFO size for a single buffer */
+ 	fifo = dwc3_gadget_calc_tx_fifo_size(dwc, 1);
+ 
+ 	/* Calculate the number of remaining EPs w/o any FIFO */
+ 	num_in_ep = dwc->max_cfg_eps;
+ 	num_in_ep -= dwc->num_ep_resized;
+ 
+ 	/* Reserve at least one FIFO for the number of IN EPs */
+ 	min_depth = num_in_ep * (fifo + 1);
+ 	remaining = ram1_depth - min_depth - dwc->last_fifo_depth;
+ 	remaining = max_t(int, 0, remaining);
+ 	/*
+ 	 * We've already reserved 1 FIFO per EP, so check what we can fit in
+ 	 * addition to it.  If there is not enough remaining space, allocate
+ 	 * all the remaining space to the EP.
+ 	 */
+ 	fifo_size = (num_fifos - 1) * fifo;
+ 	if (remaining < fifo_size)
+ 		fifo_size = remaining;
+ 
+ 	fifo_size += fifo;
+ 	/* Last increment according to the TX FIFO size equation */
+ 	fifo_size++;
+ 
+ 	/* Check if TXFIFOs start at non-zero addr */
+ 	tmp = dwc3_readl(dwc->regs, DWC3_GTXFIFOSIZ(0));
+ 	fifo_0_start = DWC3_GTXFIFOSIZ_TXFSTADDR(tmp);
+ 
+ 	fifo_size |= (fifo_0_start + (dwc->last_fifo_depth << 16));
+ 	if (DWC3_IP_IS(DWC3))
+ 		dwc->last_fifo_depth += DWC3_GTXFIFOSIZ_TXFDEP(fifo_size);
+ 	else
+ 		dwc->last_fifo_depth += DWC31_GTXFIFOSIZ_TXFDEP(fifo_size);
+ 
+ 	/* Check fifo size allocation doesn't exceed available RAM size. */
+ 	if (dwc->last_fifo_depth >= ram1_depth) {
+ 		dev_err(dwc->dev, "Fifosize(%d) > RAM size(%d) %s depth:%d\n",
+ 			dwc->last_fifo_depth, ram1_depth,
+ 			dep->endpoint.name, fifo_size);
+ 		if (DWC3_IP_IS(DWC3))
+ 			fifo_size = DWC3_GTXFIFOSIZ_TXFDEP(fifo_size);
+ 		else
+ 			fifo_size = DWC31_GTXFIFOSIZ_TXFDEP(fifo_size);
+ 
+ 		dwc->last_fifo_depth -= fifo_size;
+ 		return -ENOMEM;
+ 	}
+ 
+ 	dwc3_writel(dwc->regs, DWC3_GTXFIFOSIZ(dep->number >> 1), fifo_size);
+ 	dep->flags |= DWC3_EP_TXFIFO_RESIZED;
+ 	dwc->num_ep_resized++;
+ 
+ 	return 0;
+ }
+ 
+ /**
++>>>>>>> 876a75cb520f (usb: dwc3: gadget: Skip resizing EP's TX FIFO if already resized)
   * __dwc3_gadget_ep_enable - initializes a hw endpoint
   * @dep: endpoint to be initialized
   * @action: one of INIT, MODIFY or RESTORE
@@@ -812,6 -997,12 +1002,15 @@@ static int __dwc3_gadget_ep_disable(str
  		dep->endpoint.desc = NULL;
  	}
  
++<<<<<<< HEAD
++=======
+ 	dwc3_remove_requests(dwc, dep);
+ 
+ 	dep->stream_capable = false;
+ 	dep->type = 0;
+ 	dep->flags &= DWC3_EP_TXFIFO_RESIZED;
+ 
++>>>>>>> 876a75cb520f (usb: dwc3: gadget: Skip resizing EP's TX FIFO if already resized)
  	return 0;
  }
  
diff --git a/drivers/usb/dwc3/core.h b/drivers/usb/dwc3/core.h
index a2215398536d..3661c1381053 100644
--- a/drivers/usb/dwc3/core.h
+++ b/drivers/usb/dwc3/core.h
@@ -729,6 +729,7 @@ struct dwc3_ep {
 #define DWC3_EP_FORCE_RESTART_STREAM	BIT(9)
 #define DWC3_EP_FIRST_STREAM_PRIMED	BIT(10)
 #define DWC3_EP_PENDING_CLEAR_STALL	BIT(11)
+#define DWC3_EP_TXFIFO_RESIZED		BIT(12)
 
 	/* This last one is specific to EP0 */
 #define DWC3_EP0_DIR_IN		BIT(31)
* Unmerged path drivers/usb/dwc3/gadget.c
