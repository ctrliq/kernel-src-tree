PM: runtime: Have devm_pm_runtime_enable() handle pm_runtime_dont_use_autosuspend()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-425.3.1.el8
commit-author Douglas Anderson <dianders@chromium.org>
commit b4060db9251f919506e4d672737c6b8ab9a84701
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-425.3.1.el8/b4060db9.failed

The PM Runtime docs say:

  Drivers in ->remove() callback should undo the runtime PM changes done
  in ->probe(). Usually this means calling pm_runtime_disable(),
  pm_runtime_dont_use_autosuspend() etc.

From grepping code, it's clear that many people aren't aware of the
need to call pm_runtime_dont_use_autosuspend().

When brainstorming solutions, one idea that came up was to leverage
the new-ish devm_pm_runtime_enable() function. The idea here is that:

 * When the devm action is called we know that the driver is being
   removed. It's the perfect time to undo the use_autosuspend.

 * The code of pm_runtime_dont_use_autosuspend() already handles the
   case of being called when autosuspend wasn't enabled.

	Suggested-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
	Signed-off-by: Douglas Anderson <dianders@chromium.org>
	Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit b4060db9251f919506e4d672737c6b8ab9a84701)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/base/power/runtime.c
#	include/linux/pm_runtime.h
diff --cc drivers/base/power/runtime.c
index b97b37ce1cc0,d4059e6ffeae..000000000000
--- a/drivers/base/power/runtime.c
+++ b/drivers/base/power/runtime.c
@@@ -1430,6 -1474,28 +1430,31 @@@ void pm_runtime_enable(struct device *d
  }
  EXPORT_SYMBOL_GPL(pm_runtime_enable);
  
++<<<<<<< HEAD
++=======
+ static void pm_runtime_disable_action(void *data)
+ {
+ 	pm_runtime_dont_use_autosuspend(data);
+ 	pm_runtime_disable(data);
+ }
+ 
+ /**
+  * devm_pm_runtime_enable - devres-enabled version of pm_runtime_enable.
+  *
+  * NOTE: this will also handle calling pm_runtime_dont_use_autosuspend() for
+  * you at driver exit time if needed.
+  *
+  * @dev: Device to handle.
+  */
+ int devm_pm_runtime_enable(struct device *dev)
+ {
+ 	pm_runtime_enable(dev);
+ 
+ 	return devm_add_action_or_reset(dev, pm_runtime_disable_action, dev);
+ }
+ EXPORT_SYMBOL_GPL(devm_pm_runtime_enable);
+ 
++>>>>>>> b4060db9251f (PM: runtime: Have devm_pm_runtime_enable() handle pm_runtime_dont_use_autosuspend())
  /**
   * pm_runtime_forbid - Block runtime PM of a device.
   * @dev: Device to handle.
diff --cc include/linux/pm_runtime.h
index 04c3a1086685,2bff6a10095d..000000000000
--- a/include/linux/pm_runtime.h
+++ b/include/linux/pm_runtime.h
@@@ -299,6 -560,18 +299,21 @@@ static inline void pm_runtime_disable(s
  	__pm_runtime_disable(dev, true);
  }
  
++<<<<<<< HEAD
++=======
+ /**
+  * pm_runtime_use_autosuspend - Allow autosuspend to be used for a device.
+  * @dev: Target device.
+  *
+  * Allow the runtime PM autosuspend mechanism to be used for @dev whenever
+  * requested (or "autosuspend" will be handled as direct runtime-suspend for
+  * it).
+  *
+  * NOTE: It's important to undo this with pm_runtime_dont_use_autosuspend()
+  * at driver exit time unless your driver initially enabled pm_runtime
+  * with devm_pm_runtime_enable() (which handles it for you).
+  */
++>>>>>>> b4060db9251f (PM: runtime: Have devm_pm_runtime_enable() handle pm_runtime_dont_use_autosuspend())
  static inline void pm_runtime_use_autosuspend(struct device *dev)
  {
  	__pm_runtime_use_autosuspend(dev, true);
* Unmerged path drivers/base/power/runtime.c
* Unmerged path include/linux/pm_runtime.h
