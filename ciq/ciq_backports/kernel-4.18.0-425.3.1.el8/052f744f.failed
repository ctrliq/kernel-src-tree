net/sched: act_police: allow 'continue' action offload

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-425.3.1.el8
commit-author Vlad Buslov <vladbu@nvidia.com>
commit 052f744f44462cc49b88a125b0f7b93a9e47a9dd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-425.3.1.el8/052f744f.failed

Offloading police with action TC_ACT_UNSPEC was erroneously disabled even
though it was supported by mlx5 matchall offload implementation, which
didn't verify the action type but instead assumed that any single police
action attached to matchall classifier is a 'continue' action. Lack of
action type check made it non-obvious what mlx5 matchall implementation
actually supports and caused implementers and reviewers of referenced
commits to disallow it as a part of improved validation code.

Fixes: b8cd5831c61c ("net: flow_offload: add tc police action parameters")
Fixes: b50e462bc22d ("net/sched: act_police: Add extack messages for offload failure")
	Signed-off-by: Vlad Buslov <vladbu@nvidia.com>
	Reviewed-by: Ido Schimmel <idosch@nvidia.com>
	Tested-by: Ido Schimmel <idosch@nvidia.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 052f744f44462cc49b88a125b0f7b93a9e47a9dd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/flow_offload.h
#	net/sched/act_police.c
diff --cc include/net/flow_offload.h
index d20115a94aee,7ac313858037..000000000000
--- a/include/net/flow_offload.h
+++ b/include/net/flow_offload.h
@@@ -148,6 -148,11 +148,14 @@@ enum flow_action_id 
  	FLOW_ACTION_MPLS_MANGLE,
  	FLOW_ACTION_GATE,
  	FLOW_ACTION_PPPOE_PUSH,
++<<<<<<< HEAD
++=======
+ 	FLOW_ACTION_JUMP,
+ 	FLOW_ACTION_PIPE,
+ 	FLOW_ACTION_VLAN_PUSH_ETH,
+ 	FLOW_ACTION_VLAN_POP_ETH,
+ 	FLOW_ACTION_CONTINUE,
++>>>>>>> 052f744f4446 (net/sched: act_police: allow 'continue' action offload)
  	NUM_FLOW_ACTIONS,
  };
  
diff --cc net/sched/act_police.c
index ff539596b715,b759628a47c2..000000000000
--- a/net/sched/act_police.c
+++ b/net/sched/act_police.c
@@@ -423,6 -419,88 +423,91 @@@ static int tcf_police_search(struct ne
  	return tcf_idr_search(tn, a, index);
  }
  
++<<<<<<< HEAD
++=======
+ static int tcf_police_act_to_flow_act(int tc_act, u32 *extval,
+ 				      struct netlink_ext_ack *extack)
+ {
+ 	int act_id = -EOPNOTSUPP;
+ 
+ 	if (!TC_ACT_EXT_OPCODE(tc_act)) {
+ 		if (tc_act == TC_ACT_OK)
+ 			act_id = FLOW_ACTION_ACCEPT;
+ 		else if (tc_act ==  TC_ACT_SHOT)
+ 			act_id = FLOW_ACTION_DROP;
+ 		else if (tc_act == TC_ACT_PIPE)
+ 			act_id = FLOW_ACTION_PIPE;
+ 		else if (tc_act == TC_ACT_RECLASSIFY)
+ 			NL_SET_ERR_MSG_MOD(extack, "Offload not supported when conform/exceed action is \"reclassify\"");
+ 		else
+ 			NL_SET_ERR_MSG_MOD(extack, "Unsupported conform/exceed action offload");
+ 	} else if (TC_ACT_EXT_CMP(tc_act, TC_ACT_GOTO_CHAIN)) {
+ 		act_id = FLOW_ACTION_GOTO;
+ 		*extval = tc_act & TC_ACT_EXT_VAL_MASK;
+ 	} else if (TC_ACT_EXT_CMP(tc_act, TC_ACT_JUMP)) {
+ 		act_id = FLOW_ACTION_JUMP;
+ 		*extval = tc_act & TC_ACT_EXT_VAL_MASK;
+ 	} else if (tc_act == TC_ACT_UNSPEC) {
+ 		act_id = FLOW_ACTION_CONTINUE;
+ 	} else {
+ 		NL_SET_ERR_MSG_MOD(extack, "Unsupported conform/exceed action offload");
+ 	}
+ 
+ 	return act_id;
+ }
+ 
+ static int tcf_police_offload_act_setup(struct tc_action *act, void *entry_data,
+ 					u32 *index_inc, bool bind,
+ 					struct netlink_ext_ack *extack)
+ {
+ 	if (bind) {
+ 		struct flow_action_entry *entry = entry_data;
+ 		struct tcf_police *police = to_police(act);
+ 		struct tcf_police_params *p;
+ 		int act_id;
+ 
+ 		p = rcu_dereference_protected(police->params,
+ 					      lockdep_is_held(&police->tcf_lock));
+ 
+ 		entry->id = FLOW_ACTION_POLICE;
+ 		entry->police.burst = tcf_police_burst(act);
+ 		entry->police.rate_bytes_ps =
+ 			tcf_police_rate_bytes_ps(act);
+ 		entry->police.peakrate_bytes_ps = tcf_police_peakrate_bytes_ps(act);
+ 		entry->police.avrate = tcf_police_tcfp_ewma_rate(act);
+ 		entry->police.overhead = tcf_police_rate_overhead(act);
+ 		entry->police.burst_pkt = tcf_police_burst_pkt(act);
+ 		entry->police.rate_pkt_ps =
+ 			tcf_police_rate_pkt_ps(act);
+ 		entry->police.mtu = tcf_police_tcfp_mtu(act);
+ 
+ 		act_id = tcf_police_act_to_flow_act(police->tcf_action,
+ 						    &entry->police.exceed.extval,
+ 						    extack);
+ 		if (act_id < 0)
+ 			return act_id;
+ 
+ 		entry->police.exceed.act_id = act_id;
+ 
+ 		act_id = tcf_police_act_to_flow_act(p->tcfp_result,
+ 						    &entry->police.notexceed.extval,
+ 						    extack);
+ 		if (act_id < 0)
+ 			return act_id;
+ 
+ 		entry->police.notexceed.act_id = act_id;
+ 
+ 		*index_inc = 1;
+ 	} else {
+ 		struct flow_offload_action *fl_action = entry_data;
+ 
+ 		fl_action->id = FLOW_ACTION_POLICE;
+ 	}
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> 052f744f4446 (net/sched: act_police: allow 'continue' action offload)
  MODULE_AUTHOR("Alexey Kuznetsov");
  MODULE_DESCRIPTION("Policing actions");
  MODULE_LICENSE("GPL");
* Unmerged path include/net/flow_offload.h
* Unmerged path net/sched/act_police.c
