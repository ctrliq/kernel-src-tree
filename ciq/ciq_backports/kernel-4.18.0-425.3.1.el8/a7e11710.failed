ice: convert vf->vc_ops to a const pointer

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-425.3.1.el8
commit-author Jacob Keller <jacob.e.keller@intel.com>
commit a7e117109a25b381eacf3206178ed9f661a20e83
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-425.3.1.el8/a7e11710.failed

The vc_ops structure is used to allow different handlers for virtchnl
commands when the driver is in representor mode. The current
implementation uses a copy of the ops table in each VF, and modifies
this copy dynamically.

The usual practice in kernel code is to store the ops table in a
constant structure and point to different versions. This has a number of
advantages:

  1. Reduced memory usage. Each VF merely points to the correct table,
     so they're able to re-use the same constant lookup table in memory.
  2. Consistency. It becomes more difficult to accidentally update or
     edit only one op call. Instead, the code switches to the correct
     able by a single pointer write. In general this is atomic, either
     the pointer is updated or its not.
  3. Code Layout. The VF structure can store a pointer to the table
     without needing to have the full structure definition defined prior
     to the VF structure definition. This will aid in future refactoring
     of code by allowing the VF pointer to be kept in ice_vf_lib.h while
     the virtchnl ops table can be maintained in ice_virtchnl.h

There is one major downside in the case of the vc_ops structure. Most of
the operations in the table are the same between the two current
implementations. This can appear to lead to duplication since each
implementation must now fill in the complete table. It could make
spotting the differences in the representor mode more challenging.
Unfortunately, methods to make this less error prone either add
complexity overhead (macros using CPP token concatenation) or don't work
on all compilers we support (constant initializer from another constant
structure).

The cost of maintaining two structures does not out weigh the benefits
of the constant table model.

While we're making these changes, go ahead and rename the structure and
implementations with "virtchnl" instead of "vc_vf_". This will more
closely align with the planned file renaming, and avoid similar names when
we later introduce a "vf ops" table for separating Scalable IOV and
Single Root IOV implementations.

Leave the accessor/assignment functions in order to avoid issues with
compiling with options disabled. The interface makes it easier to handle
when CONFIG_PCI_IOV is disabled in the kernel.

	Signed-off-by: Jacob Keller <jacob.e.keller@intel.com>
	Tested-by: Sandeep Penigalapati <sandeep.penigalapati@intel.com>
	Signed-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>
(cherry picked from commit a7e117109a25b381eacf3206178ed9f661a20e83)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/ice/ice_sriov.c
#	drivers/net/ethernet/intel/ice/ice_sriov.h
diff --cc drivers/net/ethernet/intel/ice/ice_sriov.c
index 52c6bac41bf7,8578317ceb8a..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_sriov.c
+++ b/drivers/net/ethernet/intel/ice/ice_sriov.c
@@@ -1,42 -1,2425 +1,2018 @@@
  // SPDX-License-Identifier: GPL-2.0
  /* Copyright (c) 2018, Intel Corporation. */
  
 -#include "ice.h"
 -#include "ice_base.h"
 -#include "ice_lib.h"
 -#include "ice_fltr.h"
 -#include "ice_dcb_lib.h"
 -#include "ice_flow.h"
 -#include "ice_eswitch.h"
 -#include "ice_virtchnl_allowlist.h"
 -#include "ice_flex_pipe.h"
 -#include "ice_vf_vsi_vlan_ops.h"
 -#include "ice_vlan.h"
 -
 -#define FIELD_SELECTOR(proto_hdr_field) \
 -		BIT((proto_hdr_field) & PROTO_HDR_FIELD_MASK)
 -
 -struct ice_vc_hdr_match_type {
 -	u32 vc_hdr;	/* virtchnl headers (VIRTCHNL_PROTO_HDR_XXX) */
 -	u32 ice_hdr;	/* ice headers (ICE_FLOW_SEG_HDR_XXX) */
 -};
 -
 -static const struct ice_vc_hdr_match_type ice_vc_hdr_list[] = {
 -	{VIRTCHNL_PROTO_HDR_NONE,	ICE_FLOW_SEG_HDR_NONE},
 -	{VIRTCHNL_PROTO_HDR_ETH,	ICE_FLOW_SEG_HDR_ETH},
 -	{VIRTCHNL_PROTO_HDR_S_VLAN,	ICE_FLOW_SEG_HDR_VLAN},
 -	{VIRTCHNL_PROTO_HDR_C_VLAN,	ICE_FLOW_SEG_HDR_VLAN},
 -	{VIRTCHNL_PROTO_HDR_IPV4,	ICE_FLOW_SEG_HDR_IPV4 |
 -					ICE_FLOW_SEG_HDR_IPV_OTHER},
 -	{VIRTCHNL_PROTO_HDR_IPV6,	ICE_FLOW_SEG_HDR_IPV6 |
 -					ICE_FLOW_SEG_HDR_IPV_OTHER},
 -	{VIRTCHNL_PROTO_HDR_TCP,	ICE_FLOW_SEG_HDR_TCP},
 -	{VIRTCHNL_PROTO_HDR_UDP,	ICE_FLOW_SEG_HDR_UDP},
 -	{VIRTCHNL_PROTO_HDR_SCTP,	ICE_FLOW_SEG_HDR_SCTP},
 -	{VIRTCHNL_PROTO_HDR_PPPOE,	ICE_FLOW_SEG_HDR_PPPOE},
 -	{VIRTCHNL_PROTO_HDR_GTPU_IP,	ICE_FLOW_SEG_HDR_GTPU_IP},
 -	{VIRTCHNL_PROTO_HDR_GTPU_EH,	ICE_FLOW_SEG_HDR_GTPU_EH},
 -	{VIRTCHNL_PROTO_HDR_GTPU_EH_PDU_DWN,
 -					ICE_FLOW_SEG_HDR_GTPU_DWN},
 -	{VIRTCHNL_PROTO_HDR_GTPU_EH_PDU_UP,
 -					ICE_FLOW_SEG_HDR_GTPU_UP},
 -	{VIRTCHNL_PROTO_HDR_L2TPV3,	ICE_FLOW_SEG_HDR_L2TPV3},
 -	{VIRTCHNL_PROTO_HDR_ESP,	ICE_FLOW_SEG_HDR_ESP},
 -	{VIRTCHNL_PROTO_HDR_AH,		ICE_FLOW_SEG_HDR_AH},
 -	{VIRTCHNL_PROTO_HDR_PFCP,	ICE_FLOW_SEG_HDR_PFCP_SESSION},
 -};
 -
 -struct ice_vc_hash_field_match_type {
 -	u32 vc_hdr;		/* virtchnl headers
 -				 * (VIRTCHNL_PROTO_HDR_XXX)
 -				 */
 -	u32 vc_hash_field;	/* virtchnl hash fields selector
 -				 * FIELD_SELECTOR((VIRTCHNL_PROTO_HDR_ETH_XXX))
 -				 */
 -	u64 ice_hash_field;	/* ice hash fields
 -				 * (BIT_ULL(ICE_FLOW_FIELD_IDX_XXX))
 -				 */
 -};
 -
 -static const struct
 -ice_vc_hash_field_match_type ice_vc_hash_field_list[] = {
 -	{VIRTCHNL_PROTO_HDR_ETH, FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_ETH_SRC),
 -		BIT_ULL(ICE_FLOW_FIELD_IDX_ETH_SA)},
 -	{VIRTCHNL_PROTO_HDR_ETH, FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_ETH_DST),
 -		BIT_ULL(ICE_FLOW_FIELD_IDX_ETH_DA)},
 -	{VIRTCHNL_PROTO_HDR_ETH, FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_ETH_SRC) |
 -		FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_ETH_DST),
 -		ICE_FLOW_HASH_ETH},
 -	{VIRTCHNL_PROTO_HDR_ETH,
 -		FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_ETH_ETHERTYPE),
 -		BIT_ULL(ICE_FLOW_FIELD_IDX_ETH_TYPE)},
 -	{VIRTCHNL_PROTO_HDR_S_VLAN,
 -		FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_S_VLAN_ID),
 -		BIT_ULL(ICE_FLOW_FIELD_IDX_S_VLAN)},
 -	{VIRTCHNL_PROTO_HDR_C_VLAN,
 -		FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_C_VLAN_ID),
 -		BIT_ULL(ICE_FLOW_FIELD_IDX_C_VLAN)},
 -	{VIRTCHNL_PROTO_HDR_IPV4, FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_IPV4_SRC),
 -		BIT_ULL(ICE_FLOW_FIELD_IDX_IPV4_SA)},
 -	{VIRTCHNL_PROTO_HDR_IPV4, FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_IPV4_DST),
 -		BIT_ULL(ICE_FLOW_FIELD_IDX_IPV4_DA)},
 -	{VIRTCHNL_PROTO_HDR_IPV4, FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_IPV4_SRC) |
 -		FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_IPV4_DST),
 -		ICE_FLOW_HASH_IPV4},
 -	{VIRTCHNL_PROTO_HDR_IPV4, FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_IPV4_SRC) |
 -		FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_IPV4_PROT),
 -		BIT_ULL(ICE_FLOW_FIELD_IDX_IPV4_SA) |
 -		BIT_ULL(ICE_FLOW_FIELD_IDX_IPV4_PROT)},
 -	{VIRTCHNL_PROTO_HDR_IPV4, FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_IPV4_DST) |
 -		FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_IPV4_PROT),
 -		BIT_ULL(ICE_FLOW_FIELD_IDX_IPV4_DA) |
 -		BIT_ULL(ICE_FLOW_FIELD_IDX_IPV4_PROT)},
 -	{VIRTCHNL_PROTO_HDR_IPV4, FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_IPV4_SRC) |
 -		FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_IPV4_DST) |
 -		FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_IPV4_PROT),
 -		ICE_FLOW_HASH_IPV4 | BIT_ULL(ICE_FLOW_FIELD_IDX_IPV4_PROT)},
 -	{VIRTCHNL_PROTO_HDR_IPV4, FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_IPV4_PROT),
 -		BIT_ULL(ICE_FLOW_FIELD_IDX_IPV4_PROT)},
 -	{VIRTCHNL_PROTO_HDR_IPV6, FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_IPV6_SRC),
 -		BIT_ULL(ICE_FLOW_FIELD_IDX_IPV6_SA)},
 -	{VIRTCHNL_PROTO_HDR_IPV6, FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_IPV6_DST),
 -		BIT_ULL(ICE_FLOW_FIELD_IDX_IPV6_DA)},
 -	{VIRTCHNL_PROTO_HDR_IPV6, FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_IPV6_SRC) |
 -		FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_IPV6_DST),
 -		ICE_FLOW_HASH_IPV6},
 -	{VIRTCHNL_PROTO_HDR_IPV6, FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_IPV6_SRC) |
 -		FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_IPV6_PROT),
 -		BIT_ULL(ICE_FLOW_FIELD_IDX_IPV6_SA) |
 -		BIT_ULL(ICE_FLOW_FIELD_IDX_IPV6_PROT)},
 -	{VIRTCHNL_PROTO_HDR_IPV6, FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_IPV6_DST) |
 -		FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_IPV6_PROT),
 -		BIT_ULL(ICE_FLOW_FIELD_IDX_IPV6_DA) |
 -		BIT_ULL(ICE_FLOW_FIELD_IDX_IPV6_PROT)},
 -	{VIRTCHNL_PROTO_HDR_IPV6, FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_IPV6_SRC) |
 -		FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_IPV6_DST) |
 -		FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_IPV6_PROT),
 -		ICE_FLOW_HASH_IPV6 | BIT_ULL(ICE_FLOW_FIELD_IDX_IPV6_PROT)},
 -	{VIRTCHNL_PROTO_HDR_IPV6, FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_IPV6_PROT),
 -		BIT_ULL(ICE_FLOW_FIELD_IDX_IPV6_PROT)},
 -	{VIRTCHNL_PROTO_HDR_TCP,
 -		FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_TCP_SRC_PORT),
 -		BIT_ULL(ICE_FLOW_FIELD_IDX_TCP_SRC_PORT)},
 -	{VIRTCHNL_PROTO_HDR_TCP,
 -		FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_TCP_DST_PORT),
 -		BIT_ULL(ICE_FLOW_FIELD_IDX_TCP_DST_PORT)},
 -	{VIRTCHNL_PROTO_HDR_TCP,
 -		FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_TCP_SRC_PORT) |
 -		FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_TCP_DST_PORT),
 -		ICE_FLOW_HASH_TCP_PORT},
 -	{VIRTCHNL_PROTO_HDR_UDP,
 -		FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_UDP_SRC_PORT),
 -		BIT_ULL(ICE_FLOW_FIELD_IDX_UDP_SRC_PORT)},
 -	{VIRTCHNL_PROTO_HDR_UDP,
 -		FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_UDP_DST_PORT),
 -		BIT_ULL(ICE_FLOW_FIELD_IDX_UDP_DST_PORT)},
 -	{VIRTCHNL_PROTO_HDR_UDP,
 -		FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_UDP_SRC_PORT) |
 -		FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_UDP_DST_PORT),
 -		ICE_FLOW_HASH_UDP_PORT},
 -	{VIRTCHNL_PROTO_HDR_SCTP,
 -		FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_SCTP_SRC_PORT),
 -		BIT_ULL(ICE_FLOW_FIELD_IDX_SCTP_SRC_PORT)},
 -	{VIRTCHNL_PROTO_HDR_SCTP,
 -		FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_SCTP_DST_PORT),
 -		BIT_ULL(ICE_FLOW_FIELD_IDX_SCTP_DST_PORT)},
 -	{VIRTCHNL_PROTO_HDR_SCTP,
 -		FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_SCTP_SRC_PORT) |
 -		FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_SCTP_DST_PORT),
 -		ICE_FLOW_HASH_SCTP_PORT},
 -	{VIRTCHNL_PROTO_HDR_PPPOE,
 -		FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_PPPOE_SESS_ID),
 -		BIT_ULL(ICE_FLOW_FIELD_IDX_PPPOE_SESS_ID)},
 -	{VIRTCHNL_PROTO_HDR_GTPU_IP,
 -		FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_GTPU_IP_TEID),
 -		BIT_ULL(ICE_FLOW_FIELD_IDX_GTPU_IP_TEID)},
 -	{VIRTCHNL_PROTO_HDR_L2TPV3,
 -		FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_L2TPV3_SESS_ID),
 -		BIT_ULL(ICE_FLOW_FIELD_IDX_L2TPV3_SESS_ID)},
 -	{VIRTCHNL_PROTO_HDR_ESP, FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_ESP_SPI),
 -		BIT_ULL(ICE_FLOW_FIELD_IDX_ESP_SPI)},
 -	{VIRTCHNL_PROTO_HDR_AH, FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_AH_SPI),
 -		BIT_ULL(ICE_FLOW_FIELD_IDX_AH_SPI)},
 -	{VIRTCHNL_PROTO_HDR_PFCP, FIELD_SELECTOR(VIRTCHNL_PROTO_HDR_PFCP_SEID),
 -		BIT_ULL(ICE_FLOW_FIELD_IDX_PFCP_SEID)},
 -};
 -
 -/**
 - * ice_get_vf_vsi - get VF's VSI based on the stored index
 - * @vf: VF used to get VSI
 - */
 -struct ice_vsi *ice_get_vf_vsi(struct ice_vf *vf)
 -{
 -	return vf->pf->vsi[vf->lan_vsi_idx];
 -}
 -
 -/**
 - * ice_get_vf_by_id - Get pointer to VF by ID
 - * @pf: the PF private structure
 - * @vf_id: the VF ID to locate
 - *
 - * Locate and return a pointer to the VF structure associated with a given ID.
 - * Returns NULL if the ID does not have a valid VF structure associated with
 - * it.
 - *
 - * This function takes a reference to the VF, which must be released by
 - * calling ice_put_vf() once the caller is finished accessing the VF structure
 - * returned.
 - */
 -struct ice_vf *ice_get_vf_by_id(struct ice_pf *pf, u16 vf_id)
 -{
 -	struct ice_vf *vf;
 -
 -	rcu_read_lock();
 -	hash_for_each_possible_rcu(pf->vfs.table, vf, entry, vf_id) {
 -		if (vf->vf_id == vf_id) {
 -			struct ice_vf *found;
 -
 -			if (kref_get_unless_zero(&vf->refcnt))
 -				found = vf;
 -			else
 -				found = NULL;
 -
 -			rcu_read_unlock();
 -			return found;
 -		}
 -	}
 -	rcu_read_unlock();
 -
 -	return NULL;
 -}
 -
 -/**
 - * ice_release_vf - Release VF associated with a refcount
 - * @ref: the kref decremented to zero
 - *
 - * Callback function for kref_put to release a VF once its reference count has
 - * hit zero.
 - */
 -static void ice_release_vf(struct kref *ref)
 -{
 -	struct ice_vf *vf = container_of(ref, struct ice_vf, refcnt);
 -
 -	mutex_destroy(&vf->cfg_lock);
 -
 -	kfree_rcu(vf, rcu);
 -}
 -
 -/**
 - * ice_put_vf - Release a reference to a VF
 - * @vf: the VF structure to decrease reference count on
 - *
 - * This must be called after ice_get_vf_by_id() once the reference to the VF
 - * structure is no longer used. Otherwise, the VF structure will never be
 - * freed.
 - */
 -void ice_put_vf(struct ice_vf *vf)
 -{
 -	kref_put(&vf->refcnt, ice_release_vf);
 -}
 -
 -/**
 - * ice_has_vfs - Return true if the PF has any associated VFs
 - * @pf: the PF private structure
 - *
 - * Return whether or not the PF has any allocated VFs.
 - *
 - * Note that this function only guarantees that there are no VFs at the point
 - * of calling it. It does not guarantee that no more VFs will be added.
 - */
 -bool ice_has_vfs(struct ice_pf *pf)
 -{
 -	/* A simple check that the hash table is not empty does not require
 -	 * the mutex or rcu_read_lock.
 -	 */
 -	return !hash_empty(pf->vfs.table);
 -}
 -
 -/**
 - * ice_get_num_vfs - Get number of allocated VFs
 - * @pf: the PF private structure
 - *
 - * Return the total number of allocated VFs. NOTE: VF IDs are not guaranteed
 - * to be contiguous. Do not assume that a VF ID is guaranteed to be less than
 - * the output of this function.
 - */
 -u16 ice_get_num_vfs(struct ice_pf *pf)
 -{
 -	struct ice_vf *vf;
 -	unsigned int bkt;
 -	u16 num_vfs = 0;
 -
 -	rcu_read_lock();
 -	ice_for_each_vf_rcu(pf, bkt, vf)
 -		num_vfs++;
 -	rcu_read_unlock();
 -
 -	return num_vfs;
 -}
 +#include "ice_common.h"
 +#include "ice_sriov.h"
  
  /**
 - * ice_check_vf_init - helper to check if VF init complete
 - * @pf: pointer to the PF structure
 - * @vf: the pointer to the VF to check
 - */
 -static int ice_check_vf_init(struct ice_pf *pf, struct ice_vf *vf)
 -{
 -	if (!test_bit(ICE_VF_STATE_INIT, vf->vf_states)) {
 -		dev_err(ice_pf_to_dev(pf), "VF ID: %u in reset. Try again.\n",
 -			vf->vf_id);
 -		return -EBUSY;
 -	}
 -	return 0;
 -}
 -
 -/**
 - * ice_free_vf_entries - Free all VF entries from the hash table
 - * @pf: pointer to the PF structure
 - *
 - * Iterate over the VF hash table, removing and releasing all VF entries.
 - * Called during VF teardown or as cleanup during failed VF initialization.
 - */
 -static void ice_free_vf_entries(struct ice_pf *pf)
 -{
 -	struct ice_vfs *vfs = &pf->vfs;
 -	struct hlist_node *tmp;
 -	struct ice_vf *vf;
 -	unsigned int bkt;
 -
 -	/* Remove all VFs from the hash table and release their main
 -	 * reference. Once all references to the VF are dropped, ice_put_vf()
 -	 * will call ice_release_vf which will remove the VF memory.
 -	 */
 -	lockdep_assert_held(&vfs->table_lock);
 -
 -	hash_for_each_safe(vfs->table, bkt, tmp, vf, entry) {
 -		hash_del_rcu(&vf->entry);
 -		ice_put_vf(vf);
 -	}
 -}
 -
 -/**
 - * ice_vc_vf_broadcast - Broadcast a message to all VFs on PF
 - * @pf: pointer to the PF structure
 - * @v_opcode: operation code
 - * @v_retval: return value
 + * ice_aq_send_msg_to_vf
 + * @hw: pointer to the hardware structure
 + * @vfid: VF ID to send msg
 + * @v_opcode: opcodes for VF-PF communication
 + * @v_retval: return error code
   * @msg: pointer to the msg buffer
   * @msglen: msg length
 - */
 -static void
 -ice_vc_vf_broadcast(struct ice_pf *pf, enum virtchnl_ops v_opcode,
 -		    enum virtchnl_status_code v_retval, u8 *msg, u16 msglen)
 -{
 -	struct ice_hw *hw = &pf->hw;
 -	struct ice_vf *vf;
 -	unsigned int bkt;
 -
 -	mutex_lock(&pf->vfs.table_lock);
 -	ice_for_each_vf(pf, bkt, vf) {
 -		/* Not all vfs are enabled so skip the ones that are not */
 -		if (!test_bit(ICE_VF_STATE_INIT, vf->vf_states) &&
 -		    !test_bit(ICE_VF_STATE_ACTIVE, vf->vf_states))
 -			continue;
 -
 -		/* Ignore return value on purpose - a given VF may fail, but
 -		 * we need to keep going and send to all of them
 -		 */
 -		ice_aq_send_msg_to_vf(hw, vf->vf_id, v_opcode, v_retval, msg,
 -				      msglen, NULL);
 -	}
 -	mutex_unlock(&pf->vfs.table_lock);
 -}
 -
 -/**
 - * ice_set_pfe_link - Set the link speed/status of the virtchnl_pf_event
 - * @vf: pointer to the VF structure
 - * @pfe: pointer to the virtchnl_pf_event to set link speed/status for
 - * @ice_link_speed: link speed specified by ICE_AQ_LINK_SPEED_*
 - * @link_up: whether or not to set the link up/down
 - */
 -static void
 -ice_set_pfe_link(struct ice_vf *vf, struct virtchnl_pf_event *pfe,
 -		 int ice_link_speed, bool link_up)
 -{
 -	if (vf->driver_caps & VIRTCHNL_VF_CAP_ADV_LINK_SPEED) {
 -		pfe->event_data.link_event_adv.link_status = link_up;
 -		/* Speed in Mbps */
 -		pfe->event_data.link_event_adv.link_speed =
 -			ice_conv_link_speed_to_virtchnl(true, ice_link_speed);
 -	} else {
 -		pfe->event_data.link_event.link_status = link_up;
 -		/* Legacy method for virtchnl link speeds */
 -		pfe->event_data.link_event.link_speed =
 -			(enum virtchnl_link_speed)
 -			ice_conv_link_speed_to_virtchnl(false, ice_link_speed);
 -	}
 -}
 -
 -/**
 - * ice_vf_has_no_qs_ena - check if the VF has any Rx or Tx queues enabled
 - * @vf: the VF to check
 + * @cd: pointer to command details
   *
++<<<<<<< HEAD
 + * Send message to VF driver (0x0802) using mailbox
 + * queue and asynchronously sending message via
 + * ice_sq_send_cmd() function
++=======
+  * Returns true if the VF has no Rx and no Tx queues enabled and returns false
+  * otherwise
+  */
+ static bool ice_vf_has_no_qs_ena(struct ice_vf *vf)
+ {
+ 	return (!bitmap_weight(vf->rxq_ena, ICE_MAX_RSS_QS_PER_VF) &&
+ 		!bitmap_weight(vf->txq_ena, ICE_MAX_RSS_QS_PER_VF));
+ }
+ 
+ /**
+  * ice_is_vf_link_up - check if the VF's link is up
+  * @vf: VF to check if link is up
+  */
+ static bool ice_is_vf_link_up(struct ice_vf *vf)
+ {
+ 	struct ice_pf *pf = vf->pf;
+ 
+ 	if (ice_check_vf_init(pf, vf))
+ 		return false;
+ 
+ 	if (ice_vf_has_no_qs_ena(vf))
+ 		return false;
+ 	else if (vf->link_forced)
+ 		return vf->link_up;
+ 	else
+ 		return pf->hw.port_info->phy.link_info.link_info &
+ 			ICE_AQ_LINK_UP;
+ }
+ 
+ /**
+  * ice_vc_notify_vf_link_state - Inform a VF of link status
+  * @vf: pointer to the VF structure
+  *
+  * send a link status message to a single VF
+  */
+ void ice_vc_notify_vf_link_state(struct ice_vf *vf)
+ {
+ 	struct virtchnl_pf_event pfe = { 0 };
+ 	struct ice_hw *hw = &vf->pf->hw;
+ 
+ 	pfe.event = VIRTCHNL_EVENT_LINK_CHANGE;
+ 	pfe.severity = PF_EVENT_SEVERITY_INFO;
+ 
+ 	if (ice_is_vf_link_up(vf))
+ 		ice_set_pfe_link(vf, &pfe,
+ 				 hw->port_info->phy.link_info.link_speed, true);
+ 	else
+ 		ice_set_pfe_link(vf, &pfe, ICE_AQ_LINK_SPEED_UNKNOWN, false);
+ 
+ 	ice_aq_send_msg_to_vf(hw, vf->vf_id, VIRTCHNL_OP_EVENT,
+ 			      VIRTCHNL_STATUS_SUCCESS, (u8 *)&pfe,
+ 			      sizeof(pfe), NULL);
+ }
+ 
+ /**
+  * ice_vf_invalidate_vsi - invalidate vsi_idx/vsi_num to remove VSI access
+  * @vf: VF to remove access to VSI for
+  */
+ static void ice_vf_invalidate_vsi(struct ice_vf *vf)
+ {
+ 	vf->lan_vsi_idx = ICE_NO_VSI;
+ 	vf->lan_vsi_num = ICE_NO_VSI;
+ }
+ 
+ /**
+  * ice_vf_vsi_release - invalidate the VF's VSI after freeing it
+  * @vf: invalidate this VF's VSI after freeing it
+  */
+ static void ice_vf_vsi_release(struct ice_vf *vf)
+ {
+ 	ice_vsi_release(ice_get_vf_vsi(vf));
+ 	ice_vf_invalidate_vsi(vf);
+ }
+ 
+ /**
+  * ice_vf_ctrl_invalidate_vsi - invalidate ctrl_vsi_idx to remove VSI access
+  * @vf: VF that control VSI is being invalidated on
+  */
+ static void ice_vf_ctrl_invalidate_vsi(struct ice_vf *vf)
+ {
+ 	vf->ctrl_vsi_idx = ICE_NO_VSI;
+ }
+ 
+ /**
+  * ice_vf_ctrl_vsi_release - invalidate the VF's control VSI after freeing it
+  * @vf: VF that control VSI is being released on
+  */
+ static void ice_vf_ctrl_vsi_release(struct ice_vf *vf)
+ {
+ 	ice_vsi_release(vf->pf->vsi[vf->ctrl_vsi_idx]);
+ 	ice_vf_ctrl_invalidate_vsi(vf);
+ }
+ 
+ /**
+  * ice_free_vf_res - Free a VF's resources
+  * @vf: pointer to the VF info
+  */
+ static void ice_free_vf_res(struct ice_vf *vf)
+ {
+ 	struct ice_pf *pf = vf->pf;
+ 	int i, last_vector_idx;
+ 
+ 	/* First, disable VF's configuration API to prevent OS from
+ 	 * accessing the VF's VSI after it's freed or invalidated.
+ 	 */
+ 	clear_bit(ICE_VF_STATE_INIT, vf->vf_states);
+ 	ice_vf_fdir_exit(vf);
+ 	/* free VF control VSI */
+ 	if (vf->ctrl_vsi_idx != ICE_NO_VSI)
+ 		ice_vf_ctrl_vsi_release(vf);
+ 
+ 	/* free VSI and disconnect it from the parent uplink */
+ 	if (vf->lan_vsi_idx != ICE_NO_VSI) {
+ 		ice_vf_vsi_release(vf);
+ 		vf->num_mac = 0;
+ 	}
+ 
+ 	last_vector_idx = vf->first_vector_idx + pf->vfs.num_msix_per - 1;
+ 
+ 	/* clear VF MDD event information */
+ 	memset(&vf->mdd_tx_events, 0, sizeof(vf->mdd_tx_events));
+ 	memset(&vf->mdd_rx_events, 0, sizeof(vf->mdd_rx_events));
+ 
+ 	/* Disable interrupts so that VF starts in a known state */
+ 	for (i = vf->first_vector_idx; i <= last_vector_idx; i++) {
+ 		wr32(&pf->hw, GLINT_DYN_CTL(i), GLINT_DYN_CTL_CLEARPBA_M);
+ 		ice_flush(&pf->hw);
+ 	}
+ 	/* reset some of the state variables keeping track of the resources */
+ 	clear_bit(ICE_VF_STATE_MC_PROMISC, vf->vf_states);
+ 	clear_bit(ICE_VF_STATE_UC_PROMISC, vf->vf_states);
+ }
+ 
+ /**
+  * ice_dis_vf_mappings
+  * @vf: pointer to the VF structure
+  */
+ static void ice_dis_vf_mappings(struct ice_vf *vf)
+ {
+ 	struct ice_pf *pf = vf->pf;
+ 	struct ice_vsi *vsi;
+ 	struct device *dev;
+ 	int first, last, v;
+ 	struct ice_hw *hw;
+ 
+ 	hw = &pf->hw;
+ 	vsi = ice_get_vf_vsi(vf);
+ 
+ 	dev = ice_pf_to_dev(pf);
+ 	wr32(hw, VPINT_ALLOC(vf->vf_id), 0);
+ 	wr32(hw, VPINT_ALLOC_PCI(vf->vf_id), 0);
+ 
+ 	first = vf->first_vector_idx;
+ 	last = first + pf->vfs.num_msix_per - 1;
+ 	for (v = first; v <= last; v++) {
+ 		u32 reg;
+ 
+ 		reg = (((1 << GLINT_VECT2FUNC_IS_PF_S) &
+ 			GLINT_VECT2FUNC_IS_PF_M) |
+ 		       ((hw->pf_id << GLINT_VECT2FUNC_PF_NUM_S) &
+ 			GLINT_VECT2FUNC_PF_NUM_M));
+ 		wr32(hw, GLINT_VECT2FUNC(v), reg);
+ 	}
+ 
+ 	if (vsi->tx_mapping_mode == ICE_VSI_MAP_CONTIG)
+ 		wr32(hw, VPLAN_TX_QBASE(vf->vf_id), 0);
+ 	else
+ 		dev_err(dev, "Scattered mode for VF Tx queues is not yet implemented\n");
+ 
+ 	if (vsi->rx_mapping_mode == ICE_VSI_MAP_CONTIG)
+ 		wr32(hw, VPLAN_RX_QBASE(vf->vf_id), 0);
+ 	else
+ 		dev_err(dev, "Scattered mode for VF Rx queues is not yet implemented\n");
+ }
+ 
+ /**
+  * ice_sriov_free_msix_res - Reset/free any used MSIX resources
+  * @pf: pointer to the PF structure
+  *
+  * Since no MSIX entries are taken from the pf->irq_tracker then just clear
+  * the pf->sriov_base_vector.
+  *
+  * Returns 0 on success, and -EINVAL on error.
+  */
+ static int ice_sriov_free_msix_res(struct ice_pf *pf)
+ {
+ 	struct ice_res_tracker *res;
+ 
+ 	if (!pf)
+ 		return -EINVAL;
+ 
+ 	res = pf->irq_tracker;
+ 	if (!res)
+ 		return -EINVAL;
+ 
+ 	/* give back irq_tracker resources used */
+ 	WARN_ON(pf->sriov_base_vector < res->num_entries);
+ 
+ 	pf->sriov_base_vector = 0;
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * ice_set_vf_state_qs_dis - Set VF queues state to disabled
+  * @vf: pointer to the VF structure
+  */
+ void ice_set_vf_state_qs_dis(struct ice_vf *vf)
+ {
+ 	/* Clear Rx/Tx enabled queues flag */
+ 	bitmap_zero(vf->txq_ena, ICE_MAX_RSS_QS_PER_VF);
+ 	bitmap_zero(vf->rxq_ena, ICE_MAX_RSS_QS_PER_VF);
+ 	clear_bit(ICE_VF_STATE_QS_ENA, vf->vf_states);
+ }
+ 
+ /**
+  * ice_dis_vf_qs - Disable the VF queues
+  * @vf: pointer to the VF structure
+  */
+ static void ice_dis_vf_qs(struct ice_vf *vf)
+ {
+ 	struct ice_vsi *vsi = ice_get_vf_vsi(vf);
+ 
+ 	ice_vsi_stop_lan_tx_rings(vsi, ICE_NO_RESET, vf->vf_id);
+ 	ice_vsi_stop_all_rx_rings(vsi);
+ 	ice_set_vf_state_qs_dis(vf);
+ }
+ 
+ /**
+  * ice_free_vfs - Free all VFs
+  * @pf: pointer to the PF structure
+  */
+ void ice_free_vfs(struct ice_pf *pf)
+ {
+ 	struct device *dev = ice_pf_to_dev(pf);
+ 	struct ice_vfs *vfs = &pf->vfs;
+ 	struct ice_hw *hw = &pf->hw;
+ 	struct ice_vf *vf;
+ 	unsigned int bkt;
+ 
+ 	if (!ice_has_vfs(pf))
+ 		return;
+ 
+ 	while (test_and_set_bit(ICE_VF_DIS, pf->state))
+ 		usleep_range(1000, 2000);
+ 
+ 	/* Disable IOV before freeing resources. This lets any VF drivers
+ 	 * running in the host get themselves cleaned up before we yank
+ 	 * the carpet out from underneath their feet.
+ 	 */
+ 	if (!pci_vfs_assigned(pf->pdev))
+ 		pci_disable_sriov(pf->pdev);
+ 	else
+ 		dev_warn(dev, "VFs are assigned - not disabling SR-IOV\n");
+ 
+ 	mutex_lock(&vfs->table_lock);
+ 
+ 	ice_eswitch_release(pf);
+ 
+ 	ice_for_each_vf(pf, bkt, vf) {
+ 		mutex_lock(&vf->cfg_lock);
+ 
+ 		ice_dis_vf_qs(vf);
+ 
+ 		if (test_bit(ICE_VF_STATE_INIT, vf->vf_states)) {
+ 			/* disable VF qp mappings and set VF disable state */
+ 			ice_dis_vf_mappings(vf);
+ 			set_bit(ICE_VF_STATE_DIS, vf->vf_states);
+ 			ice_free_vf_res(vf);
+ 		}
+ 
+ 		if (!pci_vfs_assigned(pf->pdev)) {
+ 			u32 reg_idx, bit_idx;
+ 
+ 			reg_idx = (hw->func_caps.vf_base_id + vf->vf_id) / 32;
+ 			bit_idx = (hw->func_caps.vf_base_id + vf->vf_id) % 32;
+ 			wr32(hw, GLGEN_VFLRSTAT(reg_idx), BIT(bit_idx));
+ 		}
+ 
+ 		/* clear malicious info since the VF is getting released */
+ 		if (ice_mbx_clear_malvf(&hw->mbx_snapshot, pf->vfs.malvfs,
+ 					ICE_MAX_VF_COUNT, vf->vf_id))
+ 			dev_dbg(dev, "failed to clear malicious VF state for VF %u\n",
+ 				vf->vf_id);
+ 
+ 		mutex_unlock(&vf->cfg_lock);
+ 	}
+ 
+ 	if (ice_sriov_free_msix_res(pf))
+ 		dev_err(dev, "Failed to free MSIX resources used by SR-IOV\n");
+ 
+ 	vfs->num_qps_per = 0;
+ 	ice_free_vf_entries(pf);
+ 
+ 	mutex_unlock(&vfs->table_lock);
+ 
+ 	clear_bit(ICE_VF_DIS, pf->state);
+ 	clear_bit(ICE_FLAG_SRIOV_ENA, pf->flags);
+ }
+ 
+ /**
+  * ice_trigger_vf_reset - Reset a VF on HW
+  * @vf: pointer to the VF structure
+  * @is_vflr: true if VFLR was issued, false if not
+  * @is_pfr: true if the reset was triggered due to a previous PFR
+  *
+  * Trigger hardware to start a reset for a particular VF. Expects the caller
+  * to wait the proper amount of time to allow hardware to reset the VF before
+  * it cleans up and restores VF functionality.
+  */
+ static void ice_trigger_vf_reset(struct ice_vf *vf, bool is_vflr, bool is_pfr)
+ {
+ 	struct ice_pf *pf = vf->pf;
+ 	u32 reg, reg_idx, bit_idx;
+ 	unsigned int vf_abs_id, i;
+ 	struct device *dev;
+ 	struct ice_hw *hw;
+ 
+ 	dev = ice_pf_to_dev(pf);
+ 	hw = &pf->hw;
+ 	vf_abs_id = vf->vf_id + hw->func_caps.vf_base_id;
+ 
+ 	/* Inform VF that it is no longer active, as a warning */
+ 	clear_bit(ICE_VF_STATE_ACTIVE, vf->vf_states);
+ 
+ 	/* Disable VF's configuration API during reset. The flag is re-enabled
+ 	 * when it's safe again to access VF's VSI.
+ 	 */
+ 	clear_bit(ICE_VF_STATE_INIT, vf->vf_states);
+ 
+ 	/* VF_MBX_ARQLEN and VF_MBX_ATQLEN are cleared by PFR, so the driver
+ 	 * needs to clear them in the case of VFR/VFLR. If this is done for
+ 	 * PFR, it can mess up VF resets because the VF driver may already
+ 	 * have started cleanup by the time we get here.
+ 	 */
+ 	if (!is_pfr) {
+ 		wr32(hw, VF_MBX_ARQLEN(vf->vf_id), 0);
+ 		wr32(hw, VF_MBX_ATQLEN(vf->vf_id), 0);
+ 	}
+ 
+ 	/* In the case of a VFLR, the HW has already reset the VF and we
+ 	 * just need to clean up, so don't hit the VFRTRIG register.
+ 	 */
+ 	if (!is_vflr) {
+ 		/* reset VF using VPGEN_VFRTRIG reg */
+ 		reg = rd32(hw, VPGEN_VFRTRIG(vf->vf_id));
+ 		reg |= VPGEN_VFRTRIG_VFSWR_M;
+ 		wr32(hw, VPGEN_VFRTRIG(vf->vf_id), reg);
+ 	}
+ 	/* clear the VFLR bit in GLGEN_VFLRSTAT */
+ 	reg_idx = (vf_abs_id) / 32;
+ 	bit_idx = (vf_abs_id) % 32;
+ 	wr32(hw, GLGEN_VFLRSTAT(reg_idx), BIT(bit_idx));
+ 	ice_flush(hw);
+ 
+ 	wr32(hw, PF_PCI_CIAA,
+ 	     VF_DEVICE_STATUS | (vf_abs_id << PF_PCI_CIAA_VF_NUM_S));
+ 	for (i = 0; i < ICE_PCI_CIAD_WAIT_COUNT; i++) {
+ 		reg = rd32(hw, PF_PCI_CIAD);
+ 		/* no transactions pending so stop polling */
+ 		if ((reg & VF_TRANS_PENDING_M) == 0)
+ 			break;
+ 
+ 		dev_err(dev, "VF %u PCI transactions stuck\n", vf->vf_id);
+ 		udelay(ICE_PCI_CIAD_WAIT_DELAY_US);
+ 	}
+ }
+ 
+ /**
+  * ice_vf_get_port_info - Get the VF's port info structure
+  * @vf: VF used to get the port info structure for
+  */
+ static struct ice_port_info *ice_vf_get_port_info(struct ice_vf *vf)
+ {
+ 	return vf->pf->hw.port_info;
+ }
+ 
+ /**
+  * ice_vf_vsi_setup - Set up a VF VSI
+  * @vf: VF to setup VSI for
+  *
+  * Returns pointer to the successfully allocated VSI struct on success,
+  * otherwise returns NULL on failure.
+  */
+ static struct ice_vsi *ice_vf_vsi_setup(struct ice_vf *vf)
+ {
+ 	struct ice_port_info *pi = ice_vf_get_port_info(vf);
+ 	struct ice_pf *pf = vf->pf;
+ 	struct ice_vsi *vsi;
+ 
+ 	vsi = ice_vsi_setup(pf, pi, ICE_VSI_VF, vf, NULL);
+ 
+ 	if (!vsi) {
+ 		dev_err(ice_pf_to_dev(pf), "Failed to create VF VSI\n");
+ 		ice_vf_invalidate_vsi(vf);
+ 		return NULL;
+ 	}
+ 
+ 	vf->lan_vsi_idx = vsi->idx;
+ 	vf->lan_vsi_num = vsi->vsi_num;
+ 
+ 	return vsi;
+ }
+ 
+ /**
+  * ice_vf_ctrl_vsi_setup - Set up a VF control VSI
+  * @vf: VF to setup control VSI for
+  *
+  * Returns pointer to the successfully allocated VSI struct on success,
+  * otherwise returns NULL on failure.
+  */
+ struct ice_vsi *ice_vf_ctrl_vsi_setup(struct ice_vf *vf)
+ {
+ 	struct ice_port_info *pi = ice_vf_get_port_info(vf);
+ 	struct ice_pf *pf = vf->pf;
+ 	struct ice_vsi *vsi;
+ 
+ 	vsi = ice_vsi_setup(pf, pi, ICE_VSI_CTRL, vf, NULL);
+ 	if (!vsi) {
+ 		dev_err(ice_pf_to_dev(pf), "Failed to create VF control VSI\n");
+ 		ice_vf_ctrl_invalidate_vsi(vf);
+ 	}
+ 
+ 	return vsi;
+ }
+ 
+ /**
+  * ice_calc_vf_first_vector_idx - Calculate MSIX vector index in the PF space
+  * @pf: pointer to PF structure
+  * @vf: pointer to VF that the first MSIX vector index is being calculated for
+  *
+  * This returns the first MSIX vector index in PF space that is used by this VF.
+  * This index is used when accessing PF relative registers such as
+  * GLINT_VECT2FUNC and GLINT_DYN_CTL.
+  * This will always be the OICR index in the AVF driver so any functionality
+  * using vf->first_vector_idx for queue configuration will have to increment by
+  * 1 to avoid meddling with the OICR index.
+  */
+ static int ice_calc_vf_first_vector_idx(struct ice_pf *pf, struct ice_vf *vf)
+ {
+ 	return pf->sriov_base_vector + vf->vf_id * pf->vfs.num_msix_per;
+ }
+ 
+ /**
+  * ice_vf_rebuild_host_tx_rate_cfg - re-apply the Tx rate limiting configuration
+  * @vf: VF to re-apply the configuration for
+  *
+  * Called after a VF VSI has been re-added/rebuild during reset. The PF driver
+  * needs to re-apply the host configured Tx rate limiting configuration.
+  */
+ static int ice_vf_rebuild_host_tx_rate_cfg(struct ice_vf *vf)
+ {
+ 	struct device *dev = ice_pf_to_dev(vf->pf);
+ 	struct ice_vsi *vsi = ice_get_vf_vsi(vf);
+ 	int err;
+ 
+ 	if (vf->min_tx_rate) {
+ 		err = ice_set_min_bw_limit(vsi, (u64)vf->min_tx_rate * 1000);
+ 		if (err) {
+ 			dev_err(dev, "failed to set min Tx rate to %d Mbps for VF %u, error %d\n",
+ 				vf->min_tx_rate, vf->vf_id, err);
+ 			return err;
+ 		}
+ 	}
+ 
+ 	if (vf->max_tx_rate) {
+ 		err = ice_set_max_bw_limit(vsi, (u64)vf->max_tx_rate * 1000);
+ 		if (err) {
+ 			dev_err(dev, "failed to set max Tx rate to %d Mbps for VF %u, error %d\n",
+ 				vf->max_tx_rate, vf->vf_id, err);
+ 			return err;
+ 		}
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static u16 ice_vf_get_port_vlan_id(struct ice_vf *vf)
+ {
+ 	return vf->port_vlan_info.vid;
+ }
+ 
+ static u8 ice_vf_get_port_vlan_prio(struct ice_vf *vf)
+ {
+ 	return vf->port_vlan_info.prio;
+ }
+ 
+ bool ice_vf_is_port_vlan_ena(struct ice_vf *vf)
+ {
+ 	return (ice_vf_get_port_vlan_id(vf) || ice_vf_get_port_vlan_prio(vf));
+ }
+ 
+ static u16 ice_vf_get_port_vlan_tpid(struct ice_vf *vf)
+ {
+ 	return vf->port_vlan_info.tpid;
+ }
+ 
+ /**
+  * ice_vf_rebuild_host_vlan_cfg - add VLAN 0 filter or rebuild the Port VLAN
+  * @vf: VF to add MAC filters for
+  * @vsi: Pointer to VSI
+  *
+  * Called after a VF VSI has been re-added/rebuilt during reset. The PF driver
+  * always re-adds either a VLAN 0 or port VLAN based filter after reset.
+  */
+ static int ice_vf_rebuild_host_vlan_cfg(struct ice_vf *vf, struct ice_vsi *vsi)
+ {
+ 	struct ice_vsi_vlan_ops *vlan_ops = ice_get_compat_vsi_vlan_ops(vsi);
+ 	struct device *dev = ice_pf_to_dev(vf->pf);
+ 	int err;
+ 
+ 	if (ice_vf_is_port_vlan_ena(vf)) {
+ 		err = vlan_ops->set_port_vlan(vsi, &vf->port_vlan_info);
+ 		if (err) {
+ 			dev_err(dev, "failed to configure port VLAN via VSI parameters for VF %u, error %d\n",
+ 				vf->vf_id, err);
+ 			return err;
+ 		}
+ 
+ 		err = vlan_ops->add_vlan(vsi, &vf->port_vlan_info);
+ 	} else {
+ 		err = ice_vsi_add_vlan_zero(vsi);
+ 	}
+ 
+ 	if (err) {
+ 		dev_err(dev, "failed to add VLAN %u filter for VF %u during VF rebuild, error %d\n",
+ 			ice_vf_is_port_vlan_ena(vf) ?
+ 			ice_vf_get_port_vlan_id(vf) : 0, vf->vf_id, err);
+ 		return err;
+ 	}
+ 
+ 	err = vlan_ops->ena_rx_filtering(vsi);
+ 	if (err)
+ 		dev_warn(dev, "failed to enable Rx VLAN filtering for VF %d VSI %d during VF rebuild, error %d\n",
+ 			 vf->vf_id, vsi->idx, err);
+ 
+ 	return 0;
+ }
+ 
+ static int ice_cfg_mac_antispoof(struct ice_vsi *vsi, bool enable)
+ {
+ 	struct ice_vsi_ctx *ctx;
+ 	int err;
+ 
+ 	ctx = kzalloc(sizeof(*ctx), GFP_KERNEL);
+ 	if (!ctx)
+ 		return -ENOMEM;
+ 
+ 	ctx->info.sec_flags = vsi->info.sec_flags;
+ 	ctx->info.valid_sections = cpu_to_le16(ICE_AQ_VSI_PROP_SECURITY_VALID);
+ 
+ 	if (enable)
+ 		ctx->info.sec_flags |= ICE_AQ_VSI_SEC_FLAG_ENA_MAC_ANTI_SPOOF;
+ 	else
+ 		ctx->info.sec_flags &= ~ICE_AQ_VSI_SEC_FLAG_ENA_MAC_ANTI_SPOOF;
+ 
+ 	err = ice_update_vsi(&vsi->back->hw, vsi->idx, ctx, NULL);
+ 	if (err)
+ 		dev_err(ice_pf_to_dev(vsi->back), "Failed to configure Tx MAC anti-spoof %s for VSI %d, error %d\n",
+ 			enable ? "ON" : "OFF", vsi->vsi_num, err);
+ 	else
+ 		vsi->info.sec_flags = ctx->info.sec_flags;
+ 
+ 	kfree(ctx);
+ 
+ 	return err;
+ }
+ 
+ /**
+  * ice_vsi_ena_spoofchk - enable Tx spoof checking for this VSI
+  * @vsi: VSI to enable Tx spoof checking for
+  */
+ static int ice_vsi_ena_spoofchk(struct ice_vsi *vsi)
+ {
+ 	struct ice_vsi_vlan_ops *vlan_ops;
+ 	int err;
+ 
+ 	vlan_ops = ice_get_compat_vsi_vlan_ops(vsi);
+ 
+ 	err = vlan_ops->ena_tx_filtering(vsi);
+ 	if (err)
+ 		return err;
+ 
+ 	return ice_cfg_mac_antispoof(vsi, true);
+ }
+ 
+ /**
+  * ice_vsi_dis_spoofchk - disable Tx spoof checking for this VSI
+  * @vsi: VSI to disable Tx spoof checking for
+  */
+ static int ice_vsi_dis_spoofchk(struct ice_vsi *vsi)
+ {
+ 	struct ice_vsi_vlan_ops *vlan_ops;
+ 	int err;
+ 
+ 	vlan_ops = ice_get_compat_vsi_vlan_ops(vsi);
+ 
+ 	err = vlan_ops->dis_tx_filtering(vsi);
+ 	if (err)
+ 		return err;
+ 
+ 	return ice_cfg_mac_antispoof(vsi, false);
+ }
+ 
+ /**
+  * ice_vf_set_spoofchk_cfg - apply Tx spoof checking setting
+  * @vf: VF set spoofchk for
+  * @vsi: VSI associated to the VF
+  */
+ static int
+ ice_vf_set_spoofchk_cfg(struct ice_vf *vf, struct ice_vsi *vsi)
+ {
+ 	int err;
+ 
+ 	if (vf->spoofchk)
+ 		err = ice_vsi_ena_spoofchk(vsi);
+ 	else
+ 		err = ice_vsi_dis_spoofchk(vsi);
+ 
+ 	return err;
+ }
+ 
+ /**
+  * ice_vf_rebuild_host_mac_cfg - add broadcast and the VF's perm_addr/LAA
+  * @vf: VF to add MAC filters for
+  *
+  * Called after a VF VSI has been re-added/rebuilt during reset. The PF driver
+  * always re-adds a broadcast filter and the VF's perm_addr/LAA after reset.
+  */
+ static int ice_vf_rebuild_host_mac_cfg(struct ice_vf *vf)
+ {
+ 	struct device *dev = ice_pf_to_dev(vf->pf);
+ 	struct ice_vsi *vsi = ice_get_vf_vsi(vf);
+ 	u8 broadcast[ETH_ALEN];
+ 	int status;
+ 
+ 	if (ice_is_eswitch_mode_switchdev(vf->pf))
+ 		return 0;
+ 
+ 	eth_broadcast_addr(broadcast);
+ 	status = ice_fltr_add_mac(vsi, broadcast, ICE_FWD_TO_VSI);
+ 	if (status) {
+ 		dev_err(dev, "failed to add broadcast MAC filter for VF %u, error %d\n",
+ 			vf->vf_id, status);
+ 		return status;
+ 	}
+ 
+ 	vf->num_mac++;
+ 
+ 	if (is_valid_ether_addr(vf->hw_lan_addr.addr)) {
+ 		status = ice_fltr_add_mac(vsi, vf->hw_lan_addr.addr,
+ 					  ICE_FWD_TO_VSI);
+ 		if (status) {
+ 			dev_err(dev, "failed to add default unicast MAC filter %pM for VF %u, error %d\n",
+ 				&vf->hw_lan_addr.addr[0], vf->vf_id,
+ 				status);
+ 			return status;
+ 		}
+ 		vf->num_mac++;
+ 
+ 		ether_addr_copy(vf->dev_lan_addr.addr, vf->hw_lan_addr.addr);
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * ice_vf_set_host_trust_cfg - set trust setting based on pre-reset value
+  * @vf: VF to configure trust setting for
+  */
+ static void ice_vf_set_host_trust_cfg(struct ice_vf *vf)
+ {
+ 	if (vf->trusted)
+ 		set_bit(ICE_VIRTCHNL_VF_CAP_PRIVILEGE, &vf->vf_caps);
+ 	else
+ 		clear_bit(ICE_VIRTCHNL_VF_CAP_PRIVILEGE, &vf->vf_caps);
+ }
+ 
+ /**
+  * ice_ena_vf_msix_mappings - enable VF MSIX mappings in hardware
+  * @vf: VF to enable MSIX mappings for
+  *
+  * Some of the registers need to be indexed/configured using hardware global
+  * device values and other registers need 0-based values, which represent PF
+  * based values.
+  */
+ static void ice_ena_vf_msix_mappings(struct ice_vf *vf)
+ {
+ 	int device_based_first_msix, device_based_last_msix;
+ 	int pf_based_first_msix, pf_based_last_msix, v;
+ 	struct ice_pf *pf = vf->pf;
+ 	int device_based_vf_id;
+ 	struct ice_hw *hw;
+ 	u32 reg;
+ 
+ 	hw = &pf->hw;
+ 	pf_based_first_msix = vf->first_vector_idx;
+ 	pf_based_last_msix = (pf_based_first_msix + pf->vfs.num_msix_per) - 1;
+ 
+ 	device_based_first_msix = pf_based_first_msix +
+ 		pf->hw.func_caps.common_cap.msix_vector_first_id;
+ 	device_based_last_msix =
+ 		(device_based_first_msix + pf->vfs.num_msix_per) - 1;
+ 	device_based_vf_id = vf->vf_id + hw->func_caps.vf_base_id;
+ 
+ 	reg = (((device_based_first_msix << VPINT_ALLOC_FIRST_S) &
+ 		VPINT_ALLOC_FIRST_M) |
+ 	       ((device_based_last_msix << VPINT_ALLOC_LAST_S) &
+ 		VPINT_ALLOC_LAST_M) | VPINT_ALLOC_VALID_M);
+ 	wr32(hw, VPINT_ALLOC(vf->vf_id), reg);
+ 
+ 	reg = (((device_based_first_msix << VPINT_ALLOC_PCI_FIRST_S)
+ 		 & VPINT_ALLOC_PCI_FIRST_M) |
+ 	       ((device_based_last_msix << VPINT_ALLOC_PCI_LAST_S) &
+ 		VPINT_ALLOC_PCI_LAST_M) | VPINT_ALLOC_PCI_VALID_M);
+ 	wr32(hw, VPINT_ALLOC_PCI(vf->vf_id), reg);
+ 
+ 	/* map the interrupts to its functions */
+ 	for (v = pf_based_first_msix; v <= pf_based_last_msix; v++) {
+ 		reg = (((device_based_vf_id << GLINT_VECT2FUNC_VF_NUM_S) &
+ 			GLINT_VECT2FUNC_VF_NUM_M) |
+ 		       ((hw->pf_id << GLINT_VECT2FUNC_PF_NUM_S) &
+ 			GLINT_VECT2FUNC_PF_NUM_M));
+ 		wr32(hw, GLINT_VECT2FUNC(v), reg);
+ 	}
+ 
+ 	/* Map mailbox interrupt to VF MSI-X vector 0 */
+ 	wr32(hw, VPINT_MBX_CTL(device_based_vf_id), VPINT_MBX_CTL_CAUSE_ENA_M);
+ }
+ 
+ /**
+  * ice_ena_vf_q_mappings - enable Rx/Tx queue mappings for a VF
+  * @vf: VF to enable the mappings for
+  * @max_txq: max Tx queues allowed on the VF's VSI
+  * @max_rxq: max Rx queues allowed on the VF's VSI
+  */
+ static void ice_ena_vf_q_mappings(struct ice_vf *vf, u16 max_txq, u16 max_rxq)
+ {
+ 	struct device *dev = ice_pf_to_dev(vf->pf);
+ 	struct ice_vsi *vsi = ice_get_vf_vsi(vf);
+ 	struct ice_hw *hw = &vf->pf->hw;
+ 	u32 reg;
+ 
+ 	/* set regardless of mapping mode */
+ 	wr32(hw, VPLAN_TXQ_MAPENA(vf->vf_id), VPLAN_TXQ_MAPENA_TX_ENA_M);
+ 
+ 	/* VF Tx queues allocation */
+ 	if (vsi->tx_mapping_mode == ICE_VSI_MAP_CONTIG) {
+ 		/* set the VF PF Tx queue range
+ 		 * VFNUMQ value should be set to (number of queues - 1). A value
+ 		 * of 0 means 1 queue and a value of 255 means 256 queues
+ 		 */
+ 		reg = (((vsi->txq_map[0] << VPLAN_TX_QBASE_VFFIRSTQ_S) &
+ 			VPLAN_TX_QBASE_VFFIRSTQ_M) |
+ 		       (((max_txq - 1) << VPLAN_TX_QBASE_VFNUMQ_S) &
+ 			VPLAN_TX_QBASE_VFNUMQ_M));
+ 		wr32(hw, VPLAN_TX_QBASE(vf->vf_id), reg);
+ 	} else {
+ 		dev_err(dev, "Scattered mode for VF Tx queues is not yet implemented\n");
+ 	}
+ 
+ 	/* set regardless of mapping mode */
+ 	wr32(hw, VPLAN_RXQ_MAPENA(vf->vf_id), VPLAN_RXQ_MAPENA_RX_ENA_M);
+ 
+ 	/* VF Rx queues allocation */
+ 	if (vsi->rx_mapping_mode == ICE_VSI_MAP_CONTIG) {
+ 		/* set the VF PF Rx queue range
+ 		 * VFNUMQ value should be set to (number of queues - 1). A value
+ 		 * of 0 means 1 queue and a value of 255 means 256 queues
+ 		 */
+ 		reg = (((vsi->rxq_map[0] << VPLAN_RX_QBASE_VFFIRSTQ_S) &
+ 			VPLAN_RX_QBASE_VFFIRSTQ_M) |
+ 		       (((max_rxq - 1) << VPLAN_RX_QBASE_VFNUMQ_S) &
+ 			VPLAN_RX_QBASE_VFNUMQ_M));
+ 		wr32(hw, VPLAN_RX_QBASE(vf->vf_id), reg);
+ 	} else {
+ 		dev_err(dev, "Scattered mode for VF Rx queues is not yet implemented\n");
+ 	}
+ }
+ 
+ /**
+  * ice_ena_vf_mappings - enable VF MSIX and queue mapping
+  * @vf: pointer to the VF structure
+  */
+ static void ice_ena_vf_mappings(struct ice_vf *vf)
+ {
+ 	struct ice_vsi *vsi = ice_get_vf_vsi(vf);
+ 
+ 	ice_ena_vf_msix_mappings(vf);
+ 	ice_ena_vf_q_mappings(vf, vsi->alloc_txq, vsi->alloc_rxq);
+ }
+ 
+ /**
+  * ice_calc_vf_reg_idx - Calculate the VF's register index in the PF space
+  * @vf: VF to calculate the register index for
+  * @q_vector: a q_vector associated to the VF
+  */
+ int ice_calc_vf_reg_idx(struct ice_vf *vf, struct ice_q_vector *q_vector)
+ {
+ 	struct ice_pf *pf;
+ 
+ 	if (!vf || !q_vector)
+ 		return -EINVAL;
+ 
+ 	pf = vf->pf;
+ 
+ 	/* always add one to account for the OICR being the first MSIX */
+ 	return pf->sriov_base_vector + pf->vfs.num_msix_per * vf->vf_id +
+ 		q_vector->v_idx + 1;
+ }
+ 
+ /**
+  * ice_get_max_valid_res_idx - Get the max valid resource index
+  * @res: pointer to the resource to find the max valid index for
+  *
+  * Start from the end of the ice_res_tracker and return right when we find the
+  * first res->list entry with the ICE_RES_VALID_BIT set. This function is only
+  * valid for SR-IOV because it is the only consumer that manipulates the
+  * res->end and this is always called when res->end is set to res->num_entries.
+  */
+ static int ice_get_max_valid_res_idx(struct ice_res_tracker *res)
+ {
+ 	int i;
+ 
+ 	if (!res)
+ 		return -EINVAL;
+ 
+ 	for (i = res->num_entries - 1; i >= 0; i--)
+ 		if (res->list[i] & ICE_RES_VALID_BIT)
+ 			return i;
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * ice_sriov_set_msix_res - Set any used MSIX resources
+  * @pf: pointer to PF structure
+  * @num_msix_needed: number of MSIX vectors needed for all SR-IOV VFs
+  *
+  * This function allows SR-IOV resources to be taken from the end of the PF's
+  * allowed HW MSIX vectors so that the irq_tracker will not be affected. We
+  * just set the pf->sriov_base_vector and return success.
+  *
+  * If there are not enough resources available, return an error. This should
+  * always be caught by ice_set_per_vf_res().
+  *
+  * Return 0 on success, and -EINVAL when there are not enough MSIX vectors
+  * in the PF's space available for SR-IOV.
+  */
+ static int ice_sriov_set_msix_res(struct ice_pf *pf, u16 num_msix_needed)
+ {
+ 	u16 total_vectors = pf->hw.func_caps.common_cap.num_msix_vectors;
+ 	int vectors_used = pf->irq_tracker->num_entries;
+ 	int sriov_base_vector;
+ 
+ 	sriov_base_vector = total_vectors - num_msix_needed;
+ 
+ 	/* make sure we only grab irq_tracker entries from the list end and
+ 	 * that we have enough available MSIX vectors
+ 	 */
+ 	if (sriov_base_vector < vectors_used)
+ 		return -EINVAL;
+ 
+ 	pf->sriov_base_vector = sriov_base_vector;
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * ice_set_per_vf_res - check if vectors and queues are available
+  * @pf: pointer to the PF structure
+  * @num_vfs: the number of SR-IOV VFs being configured
+  *
+  * First, determine HW interrupts from common pool. If we allocate fewer VFs, we
+  * get more vectors and can enable more queues per VF. Note that this does not
+  * grab any vectors from the SW pool already allocated. Also note, that all
+  * vector counts include one for each VF's miscellaneous interrupt vector
+  * (i.e. OICR).
+  *
+  * Minimum VFs - 2 vectors, 1 queue pair
+  * Small VFs - 5 vectors, 4 queue pairs
+  * Medium VFs - 17 vectors, 16 queue pairs
+  *
+  * Second, determine number of queue pairs per VF by starting with a pre-defined
+  * maximum each VF supports. If this is not possible, then we adjust based on
+  * queue pairs available on the device.
+  *
+  * Lastly, set queue and MSI-X VF variables tracked by the PF so it can be used
+  * by each VF during VF initialization and reset.
+  */
+ static int ice_set_per_vf_res(struct ice_pf *pf, u16 num_vfs)
+ {
+ 	int max_valid_res_idx = ice_get_max_valid_res_idx(pf->irq_tracker);
+ 	u16 num_msix_per_vf, num_txq, num_rxq, avail_qs;
+ 	int msix_avail_per_vf, msix_avail_for_sriov;
+ 	struct device *dev = ice_pf_to_dev(pf);
+ 
+ 	lockdep_assert_held(&pf->vfs.table_lock);
+ 
+ 	if (!num_vfs || max_valid_res_idx < 0)
+ 		return -EINVAL;
+ 
+ 	/* determine MSI-X resources per VF */
+ 	msix_avail_for_sriov = pf->hw.func_caps.common_cap.num_msix_vectors -
+ 		pf->irq_tracker->num_entries;
+ 	msix_avail_per_vf = msix_avail_for_sriov / num_vfs;
+ 	if (msix_avail_per_vf >= ICE_NUM_VF_MSIX_MED) {
+ 		num_msix_per_vf = ICE_NUM_VF_MSIX_MED;
+ 	} else if (msix_avail_per_vf >= ICE_NUM_VF_MSIX_SMALL) {
+ 		num_msix_per_vf = ICE_NUM_VF_MSIX_SMALL;
+ 	} else if (msix_avail_per_vf >= ICE_NUM_VF_MSIX_MULTIQ_MIN) {
+ 		num_msix_per_vf = ICE_NUM_VF_MSIX_MULTIQ_MIN;
+ 	} else if (msix_avail_per_vf >= ICE_MIN_INTR_PER_VF) {
+ 		num_msix_per_vf = ICE_MIN_INTR_PER_VF;
+ 	} else {
+ 		dev_err(dev, "Only %d MSI-X interrupts available for SR-IOV. Not enough to support minimum of %d MSI-X interrupts per VF for %d VFs\n",
+ 			msix_avail_for_sriov, ICE_MIN_INTR_PER_VF,
+ 			num_vfs);
+ 		return -EIO;
+ 	}
+ 
+ 	num_txq = min_t(u16, num_msix_per_vf - ICE_NONQ_VECS_VF,
+ 			ICE_MAX_RSS_QS_PER_VF);
+ 	avail_qs = ice_get_avail_txq_count(pf) / num_vfs;
+ 	if (!avail_qs)
+ 		num_txq = 0;
+ 	else if (num_txq > avail_qs)
+ 		num_txq = rounddown_pow_of_two(avail_qs);
+ 
+ 	num_rxq = min_t(u16, num_msix_per_vf - ICE_NONQ_VECS_VF,
+ 			ICE_MAX_RSS_QS_PER_VF);
+ 	avail_qs = ice_get_avail_rxq_count(pf) / num_vfs;
+ 	if (!avail_qs)
+ 		num_rxq = 0;
+ 	else if (num_rxq > avail_qs)
+ 		num_rxq = rounddown_pow_of_two(avail_qs);
+ 
+ 	if (num_txq < ICE_MIN_QS_PER_VF || num_rxq < ICE_MIN_QS_PER_VF) {
+ 		dev_err(dev, "Not enough queues to support minimum of %d queue pairs per VF for %d VFs\n",
+ 			ICE_MIN_QS_PER_VF, num_vfs);
+ 		return -EIO;
+ 	}
+ 
+ 	if (ice_sriov_set_msix_res(pf, num_msix_per_vf * num_vfs)) {
+ 		dev_err(dev, "Unable to set MSI-X resources for %d VFs\n",
+ 			num_vfs);
+ 		return -EINVAL;
+ 	}
+ 
+ 	/* only allow equal Tx/Rx queue count (i.e. queue pairs) */
+ 	pf->vfs.num_qps_per = min_t(int, num_txq, num_rxq);
+ 	pf->vfs.num_msix_per = num_msix_per_vf;
+ 	dev_info(dev, "Enabling %d VFs with %d vectors and %d queues per VF\n",
+ 		 num_vfs, pf->vfs.num_msix_per, pf->vfs.num_qps_per);
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * ice_clear_vf_reset_trigger - enable VF to access hardware
+  * @vf: VF to enabled hardware access for
+  */
+ static void ice_clear_vf_reset_trigger(struct ice_vf *vf)
+ {
+ 	struct ice_hw *hw = &vf->pf->hw;
+ 	u32 reg;
+ 
+ 	reg = rd32(hw, VPGEN_VFRTRIG(vf->vf_id));
+ 	reg &= ~VPGEN_VFRTRIG_VFSWR_M;
+ 	wr32(hw, VPGEN_VFRTRIG(vf->vf_id), reg);
+ 	ice_flush(hw);
+ }
+ 
+ static int
+ ice_vf_set_vsi_promisc(struct ice_vf *vf, struct ice_vsi *vsi, u8 promisc_m)
+ {
+ 	struct ice_hw *hw = &vsi->back->hw;
+ 	int status;
+ 
+ 	if (ice_vf_is_port_vlan_ena(vf))
+ 		status = ice_fltr_set_vsi_promisc(hw, vsi->idx, promisc_m,
+ 						  ice_vf_get_port_vlan_id(vf));
+ 	else if (ice_vsi_has_non_zero_vlans(vsi))
+ 		status = ice_fltr_set_vlan_vsi_promisc(hw, vsi, promisc_m);
+ 	else
+ 		status = ice_fltr_set_vsi_promisc(hw, vsi->idx, promisc_m, 0);
+ 
+ 	if (status && status != -EEXIST) {
+ 		dev_err(ice_pf_to_dev(vsi->back), "enable Tx/Rx filter promiscuous mode on VF-%u failed, error: %d\n",
+ 			vf->vf_id, status);
+ 		return status;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int
+ ice_vf_clear_vsi_promisc(struct ice_vf *vf, struct ice_vsi *vsi, u8 promisc_m)
+ {
+ 	struct ice_hw *hw = &vsi->back->hw;
+ 	int status;
+ 
+ 	if (ice_vf_is_port_vlan_ena(vf))
+ 		status = ice_fltr_clear_vsi_promisc(hw, vsi->idx, promisc_m,
+ 						    ice_vf_get_port_vlan_id(vf));
+ 	else if (ice_vsi_has_non_zero_vlans(vsi))
+ 		status = ice_fltr_clear_vlan_vsi_promisc(hw, vsi, promisc_m);
+ 	else
+ 		status = ice_fltr_clear_vsi_promisc(hw, vsi->idx, promisc_m, 0);
+ 
+ 	if (status && status != -ENOENT) {
+ 		dev_err(ice_pf_to_dev(vsi->back), "disable Tx/Rx filter promiscuous mode on VF-%u failed, error: %d\n",
+ 			vf->vf_id, status);
+ 		return status;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static void ice_vf_clear_counters(struct ice_vf *vf)
+ {
+ 	struct ice_vsi *vsi = ice_get_vf_vsi(vf);
+ 
+ 	vf->num_mac = 0;
+ 	vsi->num_vlan = 0;
+ 	memset(&vf->mdd_tx_events, 0, sizeof(vf->mdd_tx_events));
+ 	memset(&vf->mdd_rx_events, 0, sizeof(vf->mdd_rx_events));
+ }
+ 
+ /**
+  * ice_vf_pre_vsi_rebuild - tasks to be done prior to VSI rebuild
+  * @vf: VF to perform pre VSI rebuild tasks
+  *
+  * These tasks are items that don't need to be amortized since they are most
+  * likely called in a for loop with all VF(s) in the reset_all_vfs() case.
+  */
+ static void ice_vf_pre_vsi_rebuild(struct ice_vf *vf)
+ {
+ 	ice_vf_clear_counters(vf);
+ 	ice_clear_vf_reset_trigger(vf);
+ }
+ 
+ /**
+  * ice_vf_rebuild_aggregator_node_cfg - rebuild aggregator node config
+  * @vsi: Pointer to VSI
+  *
+  * This function moves VSI into corresponding scheduler aggregator node
+  * based on cached value of "aggregator node info" per VSI
+  */
+ static void ice_vf_rebuild_aggregator_node_cfg(struct ice_vsi *vsi)
+ {
+ 	struct ice_pf *pf = vsi->back;
+ 	struct device *dev;
+ 	int status;
+ 
+ 	if (!vsi->agg_node)
+ 		return;
+ 
+ 	dev = ice_pf_to_dev(pf);
+ 	if (vsi->agg_node->num_vsis == ICE_MAX_VSIS_IN_AGG_NODE) {
+ 		dev_dbg(dev,
+ 			"agg_id %u already has reached max_num_vsis %u\n",
+ 			vsi->agg_node->agg_id, vsi->agg_node->num_vsis);
+ 		return;
+ 	}
+ 
+ 	status = ice_move_vsi_to_agg(pf->hw.port_info, vsi->agg_node->agg_id,
+ 				     vsi->idx, vsi->tc_cfg.ena_tc);
+ 	if (status)
+ 		dev_dbg(dev, "unable to move VSI idx %u into aggregator %u node",
+ 			vsi->idx, vsi->agg_node->agg_id);
+ 	else
+ 		vsi->agg_node->num_vsis++;
+ }
+ 
+ /**
+  * ice_vf_rebuild_host_cfg - host admin configuration is persistent across reset
+  * @vf: VF to rebuild host configuration on
+  */
+ static void ice_vf_rebuild_host_cfg(struct ice_vf *vf)
+ {
+ 	struct device *dev = ice_pf_to_dev(vf->pf);
+ 	struct ice_vsi *vsi = ice_get_vf_vsi(vf);
+ 
+ 	ice_vf_set_host_trust_cfg(vf);
+ 
+ 	if (ice_vf_rebuild_host_mac_cfg(vf))
+ 		dev_err(dev, "failed to rebuild default MAC configuration for VF %d\n",
+ 			vf->vf_id);
+ 
+ 	if (ice_vf_rebuild_host_vlan_cfg(vf, vsi))
+ 		dev_err(dev, "failed to rebuild VLAN configuration for VF %u\n",
+ 			vf->vf_id);
+ 
+ 	if (ice_vf_rebuild_host_tx_rate_cfg(vf))
+ 		dev_err(dev, "failed to rebuild Tx rate limiting configuration for VF %u\n",
+ 			vf->vf_id);
+ 
+ 	if (ice_vf_set_spoofchk_cfg(vf, vsi))
+ 		dev_err(dev, "failed to rebuild spoofchk configuration for VF %d\n",
+ 			vf->vf_id);
+ 
+ 	/* rebuild aggregator node config for main VF VSI */
+ 	ice_vf_rebuild_aggregator_node_cfg(vsi);
+ }
+ 
+ /**
+  * ice_vf_rebuild_vsi_with_release - release and setup the VF's VSI
+  * @vf: VF to release and setup the VSI for
+  *
+  * This is only called when a single VF is being reset (i.e. VFR, VFLR, host VF
+  * configuration change, etc.).
+  */
+ static int ice_vf_rebuild_vsi_with_release(struct ice_vf *vf)
+ {
+ 	ice_vf_vsi_release(vf);
+ 	if (!ice_vf_vsi_setup(vf))
+ 		return -ENOMEM;
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * ice_vf_rebuild_vsi - rebuild the VF's VSI
+  * @vf: VF to rebuild the VSI for
+  *
+  * This is only called when all VF(s) are being reset (i.e. PCIe Reset on the
+  * host, PFR, CORER, etc.).
+  */
+ static int ice_vf_rebuild_vsi(struct ice_vf *vf)
+ {
+ 	struct ice_vsi *vsi = ice_get_vf_vsi(vf);
+ 	struct ice_pf *pf = vf->pf;
+ 
+ 	if (ice_vsi_rebuild(vsi, true)) {
+ 		dev_err(ice_pf_to_dev(pf), "failed to rebuild VF %d VSI\n",
+ 			vf->vf_id);
+ 		return -EIO;
+ 	}
+ 	/* vsi->idx will remain the same in this case so don't update
+ 	 * vf->lan_vsi_idx
+ 	 */
+ 	vsi->vsi_num = ice_get_hw_vsi_num(&pf->hw, vsi->idx);
+ 	vf->lan_vsi_num = vsi->vsi_num;
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * ice_vf_set_initialized - VF is ready for VIRTCHNL communication
+  * @vf: VF to set in initialized state
+  *
+  * After this function the VF will be ready to receive/handle the
+  * VIRTCHNL_OP_GET_VF_RESOURCES message
+  */
+ static void ice_vf_set_initialized(struct ice_vf *vf)
+ {
+ 	ice_set_vf_state_qs_dis(vf);
+ 	clear_bit(ICE_VF_STATE_MC_PROMISC, vf->vf_states);
+ 	clear_bit(ICE_VF_STATE_UC_PROMISC, vf->vf_states);
+ 	clear_bit(ICE_VF_STATE_DIS, vf->vf_states);
+ 	set_bit(ICE_VF_STATE_INIT, vf->vf_states);
+ 	memset(&vf->vlan_v2_caps, 0, sizeof(vf->vlan_v2_caps));
+ }
+ 
+ /**
+  * ice_vf_post_vsi_rebuild - tasks to do after the VF's VSI have been rebuilt
+  * @vf: VF to perform tasks on
+  */
+ static void ice_vf_post_vsi_rebuild(struct ice_vf *vf)
+ {
+ 	struct ice_pf *pf = vf->pf;
+ 	struct ice_hw *hw;
+ 
+ 	hw = &pf->hw;
+ 
+ 	ice_vf_rebuild_host_cfg(vf);
+ 
+ 	ice_vf_set_initialized(vf);
+ 	ice_ena_vf_mappings(vf);
+ 	wr32(hw, VFGEN_RSTAT(vf->vf_id), VIRTCHNL_VFR_VFACTIVE);
+ }
+ 
+ /**
+  * ice_reset_all_vfs - reset all allocated VFs in one go
+  * @pf: pointer to the PF structure
+  * @is_vflr: true if VFLR was issued, false if not
+  *
+  * First, tell the hardware to reset each VF, then do all the waiting in one
+  * chunk, and finally finish restoring each VF after the wait. This is useful
+  * during PF routines which need to reset all VFs, as otherwise it must perform
+  * these resets in a serialized fashion.
+  *
+  * Returns true if any VFs were reset, and false otherwise.
+  */
+ bool ice_reset_all_vfs(struct ice_pf *pf, bool is_vflr)
+ {
+ 	struct device *dev = ice_pf_to_dev(pf);
+ 	struct ice_hw *hw = &pf->hw;
+ 	struct ice_vf *vf;
+ 	unsigned int bkt;
+ 
+ 	/* If we don't have any VFs, then there is nothing to reset */
+ 	if (!ice_has_vfs(pf))
+ 		return false;
+ 
+ 	mutex_lock(&pf->vfs.table_lock);
+ 
+ 	/* clear all malicious info if the VFs are getting reset */
+ 	ice_for_each_vf(pf, bkt, vf)
+ 		if (ice_mbx_clear_malvf(&hw->mbx_snapshot, pf->vfs.malvfs,
+ 					ICE_MAX_VF_COUNT, vf->vf_id))
+ 			dev_dbg(dev, "failed to clear malicious VF state for VF %u\n",
+ 				vf->vf_id);
+ 
+ 	/* If VFs have been disabled, there is no need to reset */
+ 	if (test_and_set_bit(ICE_VF_DIS, pf->state)) {
+ 		mutex_unlock(&pf->vfs.table_lock);
+ 		return false;
+ 	}
+ 
+ 	/* Begin reset on all VFs at once */
+ 	ice_for_each_vf(pf, bkt, vf)
+ 		ice_trigger_vf_reset(vf, is_vflr, true);
+ 
+ 	/* HW requires some time to make sure it can flush the FIFO for a VF
+ 	 * when it resets it. Poll the VPGEN_VFRSTAT register for each VF in
+ 	 * sequence to make sure that it has completed. We'll keep track of
+ 	 * the VFs using a simple iterator that increments once that VF has
+ 	 * finished resetting.
+ 	 */
+ 	ice_for_each_vf(pf, bkt, vf) {
+ 		bool done = false;
+ 		unsigned int i;
+ 		u32 reg;
+ 
+ 		for (i = 0; i < 10; i++) {
+ 			reg = rd32(&pf->hw, VPGEN_VFRSTAT(vf->vf_id));
+ 			if (reg & VPGEN_VFRSTAT_VFRD_M) {
+ 				done = true;
+ 				break;
+ 			}
+ 
+ 			/* only delay if check failed */
+ 			usleep_range(10, 20);
+ 		}
+ 
+ 		if (!done) {
+ 			/* Display a warning if at least one VF didn't manage
+ 			 * to reset in time, but continue on with the
+ 			 * operation.
+ 			 */
+ 			dev_warn(dev, "VF %u reset check timeout\n", vf->vf_id);
+ 			break;
+ 		}
+ 	}
+ 
+ 	/* free VF resources to begin resetting the VSI state */
+ 	ice_for_each_vf(pf, bkt, vf) {
+ 		mutex_lock(&vf->cfg_lock);
+ 
+ 		vf->driver_caps = 0;
+ 		ice_vc_set_default_allowlist(vf);
+ 
+ 		ice_vf_fdir_exit(vf);
+ 		ice_vf_fdir_init(vf);
+ 		/* clean VF control VSI when resetting VFs since it should be
+ 		 * setup only when VF creates its first FDIR rule.
+ 		 */
+ 		if (vf->ctrl_vsi_idx != ICE_NO_VSI)
+ 			ice_vf_ctrl_invalidate_vsi(vf);
+ 
+ 		ice_vf_pre_vsi_rebuild(vf);
+ 		ice_vf_rebuild_vsi(vf);
+ 		ice_vf_post_vsi_rebuild(vf);
+ 
+ 		mutex_unlock(&vf->cfg_lock);
+ 	}
+ 
+ 	if (ice_is_eswitch_mode_switchdev(pf))
+ 		if (ice_eswitch_rebuild(pf))
+ 			dev_warn(dev, "eswitch rebuild failed\n");
+ 
+ 	ice_flush(hw);
+ 	clear_bit(ICE_VF_DIS, pf->state);
+ 
+ 	mutex_unlock(&pf->vfs.table_lock);
+ 
+ 	return true;
+ }
+ 
+ /**
+  * ice_is_vf_disabled
+  * @vf: pointer to the VF info
+  *
+  * Returns true if the PF or VF is disabled, false otherwise.
+  */
+ bool ice_is_vf_disabled(struct ice_vf *vf)
+ {
+ 	struct ice_pf *pf = vf->pf;
+ 
+ 	/* If the PF has been disabled, there is no need resetting VF until
+ 	 * PF is active again. Similarly, if the VF has been disabled, this
+ 	 * means something else is resetting the VF, so we shouldn't continue.
+ 	 * Otherwise, set disable VF state bit for actual reset, and continue.
+ 	 */
+ 	return (test_bit(ICE_VF_DIS, pf->state) ||
+ 		test_bit(ICE_VF_STATE_DIS, vf->vf_states));
+ }
+ 
+ /**
+  * ice_reset_vf - Reset a particular VF
+  * @vf: pointer to the VF structure
+  * @is_vflr: true if VFLR was issued, false if not
+  *
+  * Returns true if the VF is currently in reset, resets successfully, or resets
+  * are disabled and false otherwise.
+  */
+ bool ice_reset_vf(struct ice_vf *vf, bool is_vflr)
+ {
+ 	struct ice_pf *pf = vf->pf;
+ 	struct ice_vsi *vsi;
+ 	struct device *dev;
+ 	struct ice_hw *hw;
+ 	bool rsd = false;
+ 	u8 promisc_m;
+ 	u32 reg;
+ 	int i;
+ 
+ 	lockdep_assert_held(&vf->cfg_lock);
+ 
+ 	dev = ice_pf_to_dev(pf);
+ 
+ 	if (test_bit(ICE_VF_RESETS_DISABLED, pf->state)) {
+ 		dev_dbg(dev, "Trying to reset VF %d, but all VF resets are disabled\n",
+ 			vf->vf_id);
+ 		return true;
+ 	}
+ 
+ 	if (ice_is_vf_disabled(vf)) {
+ 		dev_dbg(dev, "VF is already disabled, there is no need for resetting it, telling VM, all is fine %d\n",
+ 			vf->vf_id);
+ 		return true;
+ 	}
+ 
+ 	/* Set VF disable bit state here, before triggering reset */
+ 	set_bit(ICE_VF_STATE_DIS, vf->vf_states);
+ 	ice_trigger_vf_reset(vf, is_vflr, false);
+ 
+ 	vsi = ice_get_vf_vsi(vf);
+ 
+ 	ice_dis_vf_qs(vf);
+ 
+ 	/* Call Disable LAN Tx queue AQ whether or not queues are
+ 	 * enabled. This is needed for successful completion of VFR.
+ 	 */
+ 	ice_dis_vsi_txq(vsi->port_info, vsi->idx, 0, 0, NULL, NULL,
+ 			NULL, ICE_VF_RESET, vf->vf_id, NULL);
+ 
+ 	hw = &pf->hw;
+ 	/* poll VPGEN_VFRSTAT reg to make sure
+ 	 * that reset is complete
+ 	 */
+ 	for (i = 0; i < 10; i++) {
+ 		/* VF reset requires driver to first reset the VF and then
+ 		 * poll the status register to make sure that the reset
+ 		 * completed successfully.
+ 		 */
+ 		reg = rd32(hw, VPGEN_VFRSTAT(vf->vf_id));
+ 		if (reg & VPGEN_VFRSTAT_VFRD_M) {
+ 			rsd = true;
+ 			break;
+ 		}
+ 
+ 		/* only sleep if the reset is not done */
+ 		usleep_range(10, 20);
+ 	}
+ 
+ 	vf->driver_caps = 0;
+ 	ice_vc_set_default_allowlist(vf);
+ 
+ 	/* Display a warning if VF didn't manage to reset in time, but need to
+ 	 * continue on with the operation.
+ 	 */
+ 	if (!rsd)
+ 		dev_warn(dev, "VF reset check timeout on VF %d\n", vf->vf_id);
+ 
+ 	/* disable promiscuous modes in case they were enabled
+ 	 * ignore any error if disabling process failed
+ 	 */
+ 	if (test_bit(ICE_VF_STATE_UC_PROMISC, vf->vf_states) ||
+ 	    test_bit(ICE_VF_STATE_MC_PROMISC, vf->vf_states)) {
+ 		if (ice_vf_is_port_vlan_ena(vf) || vsi->num_vlan)
+ 			promisc_m = ICE_UCAST_VLAN_PROMISC_BITS;
+ 		else
+ 			promisc_m = ICE_UCAST_PROMISC_BITS;
+ 
+ 		if (ice_vf_clear_vsi_promisc(vf, vsi, promisc_m))
+ 			dev_err(dev, "disabling promiscuous mode failed\n");
+ 	}
+ 
+ 	ice_eswitch_del_vf_mac_rule(vf);
+ 
+ 	ice_vf_fdir_exit(vf);
+ 	ice_vf_fdir_init(vf);
+ 	/* clean VF control VSI when resetting VF since it should be setup
+ 	 * only when VF creates its first FDIR rule.
+ 	 */
+ 	if (vf->ctrl_vsi_idx != ICE_NO_VSI)
+ 		ice_vf_ctrl_vsi_release(vf);
+ 
+ 	ice_vf_pre_vsi_rebuild(vf);
+ 
+ 	if (ice_vf_rebuild_vsi_with_release(vf)) {
+ 		dev_err(dev, "Failed to release and setup the VF%u's VSI\n", vf->vf_id);
+ 		return false;
+ 	}
+ 
+ 	ice_vf_post_vsi_rebuild(vf);
+ 	vsi = ice_get_vf_vsi(vf);
+ 	ice_eswitch_update_repr(vsi);
+ 	ice_eswitch_replay_vf_mac_rule(vf);
+ 
+ 	/* if the VF has been reset allow it to come up again */
+ 	if (ice_mbx_clear_malvf(&hw->mbx_snapshot, pf->vfs.malvfs,
+ 				ICE_MAX_VF_COUNT, vf->vf_id))
+ 		dev_dbg(dev, "failed to clear malicious VF state for VF %u\n", i);
+ 
+ 	return true;
+ }
+ 
+ /**
+  * ice_vc_notify_link_state - Inform all VFs on a PF of link status
+  * @pf: pointer to the PF structure
+  */
+ void ice_vc_notify_link_state(struct ice_pf *pf)
+ {
+ 	struct ice_vf *vf;
+ 	unsigned int bkt;
+ 
+ 	mutex_lock(&pf->vfs.table_lock);
+ 	ice_for_each_vf(pf, bkt, vf)
+ 		ice_vc_notify_vf_link_state(vf);
+ 	mutex_unlock(&pf->vfs.table_lock);
+ }
+ 
+ /**
+  * ice_vc_notify_reset - Send pending reset message to all VFs
+  * @pf: pointer to the PF structure
+  *
+  * indicate a pending reset to all VFs on a given PF
+  */
+ void ice_vc_notify_reset(struct ice_pf *pf)
+ {
+ 	struct virtchnl_pf_event pfe;
+ 
+ 	if (!ice_has_vfs(pf))
+ 		return;
+ 
+ 	pfe.event = VIRTCHNL_EVENT_RESET_IMPENDING;
+ 	pfe.severity = PF_EVENT_SEVERITY_CERTAIN_DOOM;
+ 	ice_vc_vf_broadcast(pf, VIRTCHNL_OP_EVENT, VIRTCHNL_STATUS_SUCCESS,
+ 			    (u8 *)&pfe, sizeof(struct virtchnl_pf_event));
+ }
+ 
+ /**
+  * ice_vc_notify_vf_reset - Notify VF of a reset event
+  * @vf: pointer to the VF structure
+  */
+ static void ice_vc_notify_vf_reset(struct ice_vf *vf)
+ {
+ 	struct virtchnl_pf_event pfe;
+ 	struct ice_pf *pf = vf->pf;
+ 
+ 	/* Bail out if VF is in disabled state, neither initialized, nor active
+ 	 * state - otherwise proceed with notifications
+ 	 */
+ 	if ((!test_bit(ICE_VF_STATE_INIT, vf->vf_states) &&
+ 	     !test_bit(ICE_VF_STATE_ACTIVE, vf->vf_states)) ||
+ 	    test_bit(ICE_VF_STATE_DIS, vf->vf_states))
+ 		return;
+ 
+ 	pfe.event = VIRTCHNL_EVENT_RESET_IMPENDING;
+ 	pfe.severity = PF_EVENT_SEVERITY_CERTAIN_DOOM;
+ 	ice_aq_send_msg_to_vf(&pf->hw, vf->vf_id, VIRTCHNL_OP_EVENT,
+ 			      VIRTCHNL_STATUS_SUCCESS, (u8 *)&pfe, sizeof(pfe),
+ 			      NULL);
+ }
+ 
+ /**
+  * ice_init_vf_vsi_res - initialize/setup VF VSI resources
+  * @vf: VF to initialize/setup the VSI for
+  *
+  * This function creates a VSI for the VF, adds a VLAN 0 filter, and sets up the
+  * VF VSI's broadcast filter and is only used during initial VF creation.
+  */
+ static int ice_init_vf_vsi_res(struct ice_vf *vf)
+ {
+ 	struct ice_vsi_vlan_ops *vlan_ops;
+ 	struct ice_pf *pf = vf->pf;
+ 	u8 broadcast[ETH_ALEN];
+ 	struct ice_vsi *vsi;
+ 	struct device *dev;
+ 	int err;
+ 
+ 	vf->first_vector_idx = ice_calc_vf_first_vector_idx(pf, vf);
+ 
+ 	dev = ice_pf_to_dev(pf);
+ 	vsi = ice_vf_vsi_setup(vf);
+ 	if (!vsi)
+ 		return -ENOMEM;
+ 
+ 	err = ice_vsi_add_vlan_zero(vsi);
+ 	if (err) {
+ 		dev_warn(dev, "Failed to add VLAN 0 filter for VF %d\n",
+ 			 vf->vf_id);
+ 		goto release_vsi;
+ 	}
+ 
+ 	vlan_ops = ice_get_compat_vsi_vlan_ops(vsi);
+ 	err = vlan_ops->ena_rx_filtering(vsi);
+ 	if (err) {
+ 		dev_warn(dev, "Failed to enable Rx VLAN filtering for VF %d\n",
+ 			 vf->vf_id);
+ 		goto release_vsi;
+ 	}
+ 
+ 	eth_broadcast_addr(broadcast);
+ 	err = ice_fltr_add_mac(vsi, broadcast, ICE_FWD_TO_VSI);
+ 	if (err) {
+ 		dev_err(dev, "Failed to add broadcast MAC filter for VF %d, error %d\n",
+ 			vf->vf_id, err);
+ 		goto release_vsi;
+ 	}
+ 
+ 	err = ice_vf_set_spoofchk_cfg(vf, vsi);
+ 	if (err) {
+ 		dev_warn(dev, "Failed to initialize spoofchk setting for VF %d\n",
+ 			 vf->vf_id);
+ 		goto release_vsi;
+ 	}
+ 
+ 	vf->num_mac = 1;
+ 
+ 	return 0;
+ 
+ release_vsi:
+ 	ice_vf_vsi_release(vf);
+ 	return err;
+ }
+ 
+ /**
+  * ice_start_vfs - start VFs so they are ready to be used by SR-IOV
+  * @pf: PF the VFs are associated with
+  */
+ static int ice_start_vfs(struct ice_pf *pf)
+ {
+ 	struct ice_hw *hw = &pf->hw;
+ 	unsigned int bkt, it_cnt;
+ 	struct ice_vf *vf;
+ 	int retval;
+ 
+ 	lockdep_assert_held(&pf->vfs.table_lock);
+ 
+ 	it_cnt = 0;
+ 	ice_for_each_vf(pf, bkt, vf) {
+ 		ice_clear_vf_reset_trigger(vf);
+ 
+ 		retval = ice_init_vf_vsi_res(vf);
+ 		if (retval) {
+ 			dev_err(ice_pf_to_dev(pf), "Failed to initialize VSI resources for VF %d, error %d\n",
+ 				vf->vf_id, retval);
+ 			goto teardown;
+ 		}
+ 
+ 		set_bit(ICE_VF_STATE_INIT, vf->vf_states);
+ 		ice_ena_vf_mappings(vf);
+ 		wr32(hw, VFGEN_RSTAT(vf->vf_id), VIRTCHNL_VFR_VFACTIVE);
+ 		it_cnt++;
+ 	}
+ 
+ 	ice_flush(hw);
+ 	return 0;
+ 
+ teardown:
+ 	ice_for_each_vf(pf, bkt, vf) {
+ 		if (it_cnt == 0)
+ 			break;
+ 
+ 		ice_dis_vf_mappings(vf);
+ 		ice_vf_vsi_release(vf);
+ 		it_cnt--;
+ 	}
+ 
+ 	return retval;
+ }
+ 
+ /**
+  * ice_create_vf_entries - Allocate and insert VF entries
+  * @pf: pointer to the PF structure
+  * @num_vfs: the number of VFs to allocate
+  *
+  * Allocate new VF entries and insert them into the hash table. Set some
+  * basic default fields for initializing the new VFs.
+  *
+  * After this function exits, the hash table will have num_vfs entries
+  * inserted.
+  *
+  * Returns 0 on success or an integer error code on failure.
+  */
+ static int ice_create_vf_entries(struct ice_pf *pf, u16 num_vfs)
+ {
+ 	struct ice_vfs *vfs = &pf->vfs;
+ 	struct ice_vf *vf;
+ 	u16 vf_id;
+ 	int err;
+ 
+ 	lockdep_assert_held(&vfs->table_lock);
+ 
+ 	for (vf_id = 0; vf_id < num_vfs; vf_id++) {
+ 		vf = kzalloc(sizeof(*vf), GFP_KERNEL);
+ 		if (!vf) {
+ 			err = -ENOMEM;
+ 			goto err_free_entries;
+ 		}
+ 		kref_init(&vf->refcnt);
+ 
+ 		vf->pf = pf;
+ 		vf->vf_id = vf_id;
+ 
+ 		vf->vf_sw_id = pf->first_sw;
+ 		/* assign default capabilities */
+ 		set_bit(ICE_VIRTCHNL_VF_CAP_L2, &vf->vf_caps);
+ 		vf->spoofchk = true;
+ 		vf->num_vf_qs = pf->vfs.num_qps_per;
+ 		ice_vc_set_default_allowlist(vf);
+ 
+ 		/* ctrl_vsi_idx will be set to a valid value only when VF
+ 		 * creates its first fdir rule.
+ 		 */
+ 		ice_vf_ctrl_invalidate_vsi(vf);
+ 		ice_vf_fdir_init(vf);
+ 
+ 		ice_virtchnl_set_dflt_ops(vf);
+ 
+ 		mutex_init(&vf->cfg_lock);
+ 
+ 		hash_add_rcu(vfs->table, &vf->entry, vf_id);
+ 	}
+ 
+ 	return 0;
+ 
+ err_free_entries:
+ 	ice_free_vf_entries(pf);
+ 	return err;
+ }
+ 
+ /**
+  * ice_ena_vfs - enable VFs so they are ready to be used
+  * @pf: pointer to the PF structure
+  * @num_vfs: number of VFs to enable
+  */
+ static int ice_ena_vfs(struct ice_pf *pf, u16 num_vfs)
+ {
+ 	struct device *dev = ice_pf_to_dev(pf);
+ 	struct ice_hw *hw = &pf->hw;
+ 	int ret;
+ 
+ 	/* Disable global interrupt 0 so we don't try to handle the VFLR. */
+ 	wr32(hw, GLINT_DYN_CTL(pf->oicr_idx),
+ 	     ICE_ITR_NONE << GLINT_DYN_CTL_ITR_INDX_S);
+ 	set_bit(ICE_OICR_INTR_DIS, pf->state);
+ 	ice_flush(hw);
+ 
+ 	ret = pci_enable_sriov(pf->pdev, num_vfs);
+ 	if (ret)
+ 		goto err_unroll_intr;
+ 
+ 	mutex_lock(&pf->vfs.table_lock);
+ 
+ 	if (ice_set_per_vf_res(pf, num_vfs)) {
+ 		dev_err(dev, "Not enough resources for %d VFs, try with fewer number of VFs\n",
+ 			num_vfs);
+ 		ret = -ENOSPC;
+ 		goto err_unroll_sriov;
+ 	}
+ 
+ 	ret = ice_create_vf_entries(pf, num_vfs);
+ 	if (ret) {
+ 		dev_err(dev, "Failed to allocate VF entries for %d VFs\n",
+ 			num_vfs);
+ 		goto err_unroll_sriov;
+ 	}
+ 
+ 	if (ice_start_vfs(pf)) {
+ 		dev_err(dev, "Failed to start VF(s)\n");
+ 		ret = -EAGAIN;
+ 		goto err_unroll_vf_entries;
+ 	}
+ 
+ 	clear_bit(ICE_VF_DIS, pf->state);
+ 
+ 	ret = ice_eswitch_configure(pf);
+ 	if (ret)
+ 		goto err_unroll_sriov;
+ 
+ 	/* rearm global interrupts */
+ 	if (test_and_clear_bit(ICE_OICR_INTR_DIS, pf->state))
+ 		ice_irq_dynamic_ena(hw, NULL, NULL);
+ 
+ 	mutex_unlock(&pf->vfs.table_lock);
+ 
+ 	return 0;
+ 
+ err_unroll_vf_entries:
+ 	ice_free_vf_entries(pf);
+ err_unroll_sriov:
+ 	mutex_unlock(&pf->vfs.table_lock);
+ 	pci_disable_sriov(pf->pdev);
+ err_unroll_intr:
+ 	/* rearm interrupts here */
+ 	ice_irq_dynamic_ena(hw, NULL, NULL);
+ 	clear_bit(ICE_OICR_INTR_DIS, pf->state);
+ 	return ret;
+ }
+ 
+ /**
+  * ice_pci_sriov_ena - Enable or change number of VFs
+  * @pf: pointer to the PF structure
+  * @num_vfs: number of VFs to allocate
+  *
+  * Returns 0 on success and negative on failure
+  */
+ static int ice_pci_sriov_ena(struct ice_pf *pf, int num_vfs)
+ {
+ 	int pre_existing_vfs = pci_num_vf(pf->pdev);
+ 	struct device *dev = ice_pf_to_dev(pf);
+ 	int err;
+ 
+ 	if (pre_existing_vfs && pre_existing_vfs != num_vfs)
+ 		ice_free_vfs(pf);
+ 	else if (pre_existing_vfs && pre_existing_vfs == num_vfs)
+ 		return 0;
+ 
+ 	if (num_vfs > pf->vfs.num_supported) {
+ 		dev_err(dev, "Can't enable %d VFs, max VFs supported is %d\n",
+ 			num_vfs, pf->vfs.num_supported);
+ 		return -EOPNOTSUPP;
+ 	}
+ 
+ 	dev_info(dev, "Enabling %d VFs\n", num_vfs);
+ 	err = ice_ena_vfs(pf, num_vfs);
+ 	if (err) {
+ 		dev_err(dev, "Failed to enable SR-IOV: %d\n", err);
+ 		return err;
+ 	}
+ 
+ 	set_bit(ICE_FLAG_SRIOV_ENA, pf->flags);
+ 	return 0;
+ }
+ 
+ /**
+  * ice_check_sriov_allowed - check if SR-IOV is allowed based on various checks
+  * @pf: PF to enabled SR-IOV on
+  */
+ static int ice_check_sriov_allowed(struct ice_pf *pf)
+ {
+ 	struct device *dev = ice_pf_to_dev(pf);
+ 
+ 	if (!test_bit(ICE_FLAG_SRIOV_CAPABLE, pf->flags)) {
+ 		dev_err(dev, "This device is not capable of SR-IOV\n");
+ 		return -EOPNOTSUPP;
+ 	}
+ 
+ 	if (ice_is_safe_mode(pf)) {
+ 		dev_err(dev, "SR-IOV cannot be configured - Device is in Safe Mode\n");
+ 		return -EOPNOTSUPP;
+ 	}
+ 
+ 	if (!ice_pf_state_is_nominal(pf)) {
+ 		dev_err(dev, "Cannot enable SR-IOV, device not ready\n");
+ 		return -EBUSY;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * ice_sriov_configure - Enable or change number of VFs via sysfs
+  * @pdev: pointer to a pci_dev structure
+  * @num_vfs: number of VFs to allocate or 0 to free VFs
+  *
+  * This function is called when the user updates the number of VFs in sysfs. On
+  * success return whatever num_vfs was set to by the caller. Return negative on
+  * failure.
+  */
+ int ice_sriov_configure(struct pci_dev *pdev, int num_vfs)
+ {
+ 	struct ice_pf *pf = pci_get_drvdata(pdev);
+ 	struct device *dev = ice_pf_to_dev(pf);
+ 	int err;
+ 
+ 	err = ice_check_sriov_allowed(pf);
+ 	if (err)
+ 		return err;
+ 
+ 	if (!num_vfs) {
+ 		if (!pci_vfs_assigned(pdev)) {
+ 			ice_mbx_deinit_snapshot(&pf->hw);
+ 			ice_free_vfs(pf);
+ 			if (pf->lag)
+ 				ice_enable_lag(pf->lag);
+ 			return 0;
+ 		}
+ 
+ 		dev_err(dev, "can't free VFs because some are assigned to VMs.\n");
+ 		return -EBUSY;
+ 	}
+ 
+ 	err = ice_mbx_init_snapshot(&pf->hw, num_vfs);
+ 	if (err)
+ 		return err;
+ 
+ 	err = ice_pci_sriov_ena(pf, num_vfs);
+ 	if (err) {
+ 		ice_mbx_deinit_snapshot(&pf->hw);
+ 		return err;
+ 	}
+ 
+ 	if (pf->lag)
+ 		ice_disable_lag(pf->lag);
+ 	return num_vfs;
+ }
+ 
+ /**
+  * ice_process_vflr_event - Free VF resources via IRQ calls
+  * @pf: pointer to the PF structure
+  *
+  * called from the VFLR IRQ handler to
+  * free up VF resources and state variables
+  */
+ void ice_process_vflr_event(struct ice_pf *pf)
+ {
+ 	struct ice_hw *hw = &pf->hw;
+ 	struct ice_vf *vf;
+ 	unsigned int bkt;
+ 	u32 reg;
+ 
+ 	if (!test_and_clear_bit(ICE_VFLR_EVENT_PENDING, pf->state) ||
+ 	    !ice_has_vfs(pf))
+ 		return;
+ 
+ 	mutex_lock(&pf->vfs.table_lock);
+ 	ice_for_each_vf(pf, bkt, vf) {
+ 		u32 reg_idx, bit_idx;
+ 
+ 		reg_idx = (hw->func_caps.vf_base_id + vf->vf_id) / 32;
+ 		bit_idx = (hw->func_caps.vf_base_id + vf->vf_id) % 32;
+ 		/* read GLGEN_VFLRSTAT register to find out the flr VFs */
+ 		reg = rd32(hw, GLGEN_VFLRSTAT(reg_idx));
+ 		if (reg & BIT(bit_idx)) {
+ 			/* GLGEN_VFLRSTAT bit will be cleared in ice_reset_vf */
+ 			mutex_lock(&vf->cfg_lock);
+ 			ice_reset_vf(vf, true);
+ 			mutex_unlock(&vf->cfg_lock);
+ 		}
+ 	}
+ 	mutex_unlock(&pf->vfs.table_lock);
+ }
+ 
+ /**
+  * ice_vc_reset_vf - Perform software reset on the VF after informing the AVF
+  * @vf: pointer to the VF info
+  */
+ static void ice_vc_reset_vf(struct ice_vf *vf)
+ {
+ 	ice_vc_notify_vf_reset(vf);
+ 	ice_reset_vf(vf, false);
+ }
+ 
+ /**
+  * ice_get_vf_from_pfq - get the VF who owns the PF space queue passed in
+  * @pf: PF used to index all VFs
+  * @pfq: queue index relative to the PF's function space
+  *
+  * If no VF is found who owns the pfq then return NULL, otherwise return a
+  * pointer to the VF who owns the pfq
+  *
+  * If this function returns non-NULL, it acquires a reference count of the VF
+  * structure. The caller is responsible for calling ice_put_vf() to drop this
+  * reference.
+  */
+ static struct ice_vf *ice_get_vf_from_pfq(struct ice_pf *pf, u16 pfq)
+ {
+ 	struct ice_vf *vf;
+ 	unsigned int bkt;
+ 
+ 	rcu_read_lock();
+ 	ice_for_each_vf_rcu(pf, bkt, vf) {
+ 		struct ice_vsi *vsi;
+ 		u16 rxq_idx;
+ 
+ 		vsi = ice_get_vf_vsi(vf);
+ 
+ 		ice_for_each_rxq(vsi, rxq_idx)
+ 			if (vsi->rxq_map[rxq_idx] == pfq) {
+ 				struct ice_vf *found;
+ 
+ 				if (kref_get_unless_zero(&vf->refcnt))
+ 					found = vf;
+ 				else
+ 					found = NULL;
+ 				rcu_read_unlock();
+ 				return found;
+ 			}
+ 	}
+ 	rcu_read_unlock();
+ 
+ 	return NULL;
+ }
+ 
+ /**
+  * ice_globalq_to_pfq - convert from global queue index to PF space queue index
+  * @pf: PF used for conversion
+  * @globalq: global queue index used to convert to PF space queue index
+  */
+ static u32 ice_globalq_to_pfq(struct ice_pf *pf, u32 globalq)
+ {
+ 	return globalq - pf->hw.func_caps.common_cap.rxq_first_id;
+ }
+ 
+ /**
+  * ice_vf_lan_overflow_event - handle LAN overflow event for a VF
+  * @pf: PF that the LAN overflow event happened on
+  * @event: structure holding the event information for the LAN overflow event
+  *
+  * Determine if the LAN overflow event was caused by a VF queue. If it was not
+  * caused by a VF, do nothing. If a VF caused this LAN overflow event trigger a
+  * reset on the offending VF.
+  */
+ void
+ ice_vf_lan_overflow_event(struct ice_pf *pf, struct ice_rq_event_info *event)
+ {
+ 	u32 gldcb_rtctq, queue;
+ 	struct ice_vf *vf;
+ 
+ 	gldcb_rtctq = le32_to_cpu(event->desc.params.lan_overflow.prtdcb_ruptq);
+ 	dev_dbg(ice_pf_to_dev(pf), "GLDCB_RTCTQ: 0x%08x\n", gldcb_rtctq);
+ 
+ 	/* event returns device global Rx queue number */
+ 	queue = (gldcb_rtctq & GLDCB_RTCTQ_RXQNUM_M) >>
+ 		GLDCB_RTCTQ_RXQNUM_S;
+ 
+ 	vf = ice_get_vf_from_pfq(pf, ice_globalq_to_pfq(pf, queue));
+ 	if (!vf)
+ 		return;
+ 
+ 	mutex_lock(&vf->cfg_lock);
+ 	ice_vc_reset_vf(vf);
+ 	mutex_unlock(&vf->cfg_lock);
+ 
+ 	ice_put_vf(vf);
+ }
+ 
+ /**
+  * ice_vc_send_msg_to_vf - Send message to VF
+  * @vf: pointer to the VF info
+  * @v_opcode: virtual channel opcode
+  * @v_retval: virtual channel return value
+  * @msg: pointer to the msg buffer
+  * @msglen: msg length
+  *
+  * send msg to VF
++>>>>>>> a7e117109a25 (ice: convert vf->vc_ops to a const pointer)
   */
  int
 -ice_vc_send_msg_to_vf(struct ice_vf *vf, u32 v_opcode,
 -		      enum virtchnl_status_code v_retval, u8 *msg, u16 msglen)
 +ice_aq_send_msg_to_vf(struct ice_hw *hw, u16 vfid, u32 v_opcode, u32 v_retval,
 +		      u8 *msg, u16 msglen, struct ice_sq_cd *cd)
  {
 -	struct device *dev;
 -	struct ice_pf *pf;
 -	int aq_ret;
 -
 -	pf = vf->pf;
 -	dev = ice_pf_to_dev(pf);
 -
 -	aq_ret = ice_aq_send_msg_to_vf(&pf->hw, vf->vf_id, v_opcode, v_retval,
 -				       msg, msglen, NULL);
 -	if (aq_ret && pf->hw.mailboxq.sq_last_status != ICE_AQ_RC_ENOSYS) {
 -		dev_info(dev, "Unable to send the message to VF %d ret %d aq_err %s\n",
 -			 vf->vf_id, aq_ret,
 -			 ice_aq_str(pf->hw.mailboxq.sq_last_status));
 -		return -EIO;
 -	}
 -
 -	return 0;
 -}
 +	struct ice_aqc_pf_vf_msg *cmd;
 +	struct ice_aq_desc desc;
  
 -/**
 - * ice_vc_get_ver_msg
 - * @vf: pointer to the VF info
 - * @msg: pointer to the msg buffer
 - *
 - * called from the VF to request the API version used by the PF
 - */
 -static int ice_vc_get_ver_msg(struct ice_vf *vf, u8 *msg)
 -{
 -	struct virtchnl_version_info info = {
 -		VIRTCHNL_VERSION_MAJOR, VIRTCHNL_VERSION_MINOR
 -	};
 -
 -	vf->vf_ver = *(struct virtchnl_version_info *)msg;
 -	/* VFs running the 1.0 API expect to get 1.0 back or they will cry. */
 -	if (VF_IS_V10(&vf->vf_ver))
 -		info.minor = VIRTCHNL_VERSION_MINOR_NO_VF_CAPS;
 -
 -	return ice_vc_send_msg_to_vf(vf, VIRTCHNL_OP_VERSION,
 -				     VIRTCHNL_STATUS_SUCCESS, (u8 *)&info,
 -				     sizeof(struct virtchnl_version_info));
 -}
 +	ice_fill_dflt_direct_cmd_desc(&desc, ice_mbx_opc_send_msg_to_vf);
  
 -/**
 - * ice_vc_get_max_frame_size - get max frame size allowed for VF
 - * @vf: VF used to determine max frame size
 - *
 - * Max frame size is determined based on the current port's max frame size and
 - * whether a port VLAN is configured on this VF. The VF is not aware whether
 - * it's in a port VLAN so the PF needs to account for this in max frame size
 - * checks and sending the max frame size to the VF.
 - */
 -static u16 ice_vc_get_max_frame_size(struct ice_vf *vf)
 -{
 -	struct ice_port_info *pi = ice_vf_get_port_info(vf);
 -	u16 max_frame_size;
 +	cmd = &desc.params.virt;
 +	cmd->id = cpu_to_le32(vfid);
  
 -	max_frame_size = pi->phy.link_info.max_frame_size;
 +	desc.cookie_high = cpu_to_le32(v_opcode);
 +	desc.cookie_low = cpu_to_le32(v_retval);
  
 -	if (ice_vf_is_port_vlan_ena(vf))
 -		max_frame_size -= VLAN_HLEN;
 +	if (msglen)
 +		desc.flags |= cpu_to_le16(ICE_AQ_FLAG_RD);
  
 -	return max_frame_size;
 +	return ice_sq_send_cmd(hw, &hw->mailboxq, &desc, msg, msglen, cd);
  }
  
  /**
@@@ -251,144 -2613,3720 +2227,746 @@@ ice_mbx_detect_malvf(struct ice_hw *hw
  }
  
  /**
 - * ice_vc_isvalid_q_id
 - * @vf: pointer to the VF info
 - * @vsi_id: VSI ID
 - * @qid: VSI relative queue ID
 + * ice_mbx_reset_snapshot - Reset mailbox snapshot structure
 + * @snap: pointer to mailbox snapshot structure in the ice_hw struct
   *
 - * check for the valid queue ID
 + * Reset the mailbox snapshot structure and clear VF counter array.
   */
 -static bool ice_vc_isvalid_q_id(struct ice_vf *vf, u16 vsi_id, u8 qid)
 +static void ice_mbx_reset_snapshot(struct ice_mbx_snapshot *snap)
  {
 -	struct ice_vsi *vsi = ice_find_vsi_from_id(vf->pf, vsi_id);
 -	/* allocated Tx and Rx queues should be always equal for VF VSI */
 -	return (vsi && (qid < vsi->alloc_txq));
 -}
 +	u32 vfcntr_len;
  
 -/**
 - * ice_vc_isvalid_ring_len
 - * @ring_len: length of ring
 - *
 - * check for the valid ring count, should be multiple of ICE_REQ_DESC_MULTIPLE
 - * or zero
 +	if (!snap || !snap->mbx_vf.vf_cntr)
 +		return;
 +
 +	/* Clear VF counters. */
 +	vfcntr_len = snap->mbx_vf.vfcntr_len;
 +	if (vfcntr_len)
 +		memset(snap->mbx_vf.vf_cntr, 0,
 +		       (vfcntr_len * sizeof(*snap->mbx_vf.vf_cntr)));
 +
 +	/* Reset mailbox snapshot for a new capture. */
 +	memset(&snap->mbx_buf, 0, sizeof(snap->mbx_buf));
 +	snap->mbx_buf.state = ICE_MAL_VF_DETECT_STATE_NEW_SNAPSHOT;
 +}
 +
 +/**
 + * ice_mbx_vf_state_handler - Handle states of the overflow algorithm
 + * @hw: pointer to the HW struct
 + * @mbx_data: pointer to structure containing mailbox data
 + * @vf_id: relative virtual function (VF) ID
 + * @is_malvf: boolean output to indicate if VF is malicious
 + *
 + * The function serves as an entry point for the malicious VF
 + * detection algorithm by handling the different states and state
 + * transitions of the algorithm:
 + * New snapshot: This state is entered when creating a new static
 + * snapshot. The data from any previous mailbox snapshot is
 + * cleared and a new capture of the mailbox head and tail is
 + * logged. This will be the new static snapshot to detect
 + * asynchronous messages sent by VFs. On capturing the snapshot
 + * and depending on whether the number of pending messages in that
 + * snapshot exceed the watermark value, the state machine enters
 + * traverse or detect states.
 + * Traverse: If pending message count is below watermark then iterate
 + * through the snapshot without any action on VF.
 + * Detect: If pending message count exceeds watermark traverse
 + * the static snapshot and look for a malicious VF.
   */
 -static bool ice_vc_isvalid_ring_len(u16 ring_len)
 -{
 -	return ring_len == 0 ||
 -	       (ring_len >= ICE_MIN_NUM_DESC &&
 -		ring_len <= ICE_MAX_NUM_DESC &&
 -		!(ring_len % ICE_REQ_DESC_MULTIPLE));
 +int
 +ice_mbx_vf_state_handler(struct ice_hw *hw,
 +			 struct ice_mbx_data *mbx_data, u16 vf_id,
 +			 bool *is_malvf)
 +{
 +	struct ice_mbx_snapshot *snap = &hw->mbx_snapshot;
 +	struct ice_mbx_snap_buffer_data *snap_buf;
 +	struct ice_ctl_q_info *cq = &hw->mailboxq;
 +	enum ice_mbx_snapshot_state new_state;
 +	int status = 0;
 +
 +	if (!is_malvf || !mbx_data)
 +		return -EINVAL;
 +
 +	/* When entering the mailbox state machine assume that the VF
 +	 * is not malicious until detected.
 +	 */
 +	*is_malvf = false;
 +
 +	 /* Checking if max messages allowed to be processed while servicing current
 +	  * interrupt is not less than the defined AVF message threshold.
 +	  */
 +	if (mbx_data->max_num_msgs_mbx <= ICE_ASYNC_VF_MSG_THRESHOLD)
 +		return -EINVAL;
 +
++<<<<<<< HEAD
 +	/* The watermark value should not be lesser than the threshold limit
 +	 * set for the number of asynchronous messages a VF can send to mailbox
 +	 * nor should it be greater than the maximum number of messages in the
 +	 * mailbox serviced in current interrupt.
++=======
++	return 0;
+ }
+ 
+ /**
 - * ice_vc_validate_pattern
 - * @vf: pointer to the VF info
 - * @proto: virtchnl protocol headers
 - *
 - * validate the pattern is supported or not.
 - *
 - * Return: true on success, false on error.
++ * ice_vc_ena_vlan_offload - enable VLAN offload based on the ethertype_setting
++ * @vsi: VF's VSI used to enable the VLAN offload
++ * @ena_offload: function used to enable the VLAN offload
++ * @ethertype_setting: VIRTCHNL_VLAN_ETHERTYPE_* to enable offloads for
+  */
 -bool
 -ice_vc_validate_pattern(struct ice_vf *vf, struct virtchnl_proto_hdrs *proto)
 -{
 -	bool is_ipv4 = false;
 -	bool is_ipv6 = false;
 -	bool is_udp = false;
 -	u16 ptype = -1;
 -	int i = 0;
 -
 -	while (i < proto->count &&
 -	       proto->proto_hdr[i].type != VIRTCHNL_PROTO_HDR_NONE) {
 -		switch (proto->proto_hdr[i].type) {
 -		case VIRTCHNL_PROTO_HDR_ETH:
 -			ptype = ICE_PTYPE_MAC_PAY;
 -			break;
 -		case VIRTCHNL_PROTO_HDR_IPV4:
 -			ptype = ICE_PTYPE_IPV4_PAY;
 -			is_ipv4 = true;
 -			break;
 -		case VIRTCHNL_PROTO_HDR_IPV6:
 -			ptype = ICE_PTYPE_IPV6_PAY;
 -			is_ipv6 = true;
 -			break;
 -		case VIRTCHNL_PROTO_HDR_UDP:
 -			if (is_ipv4)
 -				ptype = ICE_PTYPE_IPV4_UDP_PAY;
 -			else if (is_ipv6)
 -				ptype = ICE_PTYPE_IPV6_UDP_PAY;
 -			is_udp = true;
 -			break;
 -		case VIRTCHNL_PROTO_HDR_TCP:
 -			if (is_ipv4)
 -				ptype = ICE_PTYPE_IPV4_TCP_PAY;
 -			else if (is_ipv6)
 -				ptype = ICE_PTYPE_IPV6_TCP_PAY;
 -			break;
 -		case VIRTCHNL_PROTO_HDR_SCTP:
 -			if (is_ipv4)
 -				ptype = ICE_PTYPE_IPV4_SCTP_PAY;
 -			else if (is_ipv6)
 -				ptype = ICE_PTYPE_IPV6_SCTP_PAY;
 -			break;
 -		case VIRTCHNL_PROTO_HDR_GTPU_IP:
 -		case VIRTCHNL_PROTO_HDR_GTPU_EH:
 -			if (is_ipv4)
 -				ptype = ICE_MAC_IPV4_GTPU;
 -			else if (is_ipv6)
 -				ptype = ICE_MAC_IPV6_GTPU;
 -			goto out;
 -		case VIRTCHNL_PROTO_HDR_L2TPV3:
 -			if (is_ipv4)
 -				ptype = ICE_MAC_IPV4_L2TPV3;
 -			else if (is_ipv6)
 -				ptype = ICE_MAC_IPV6_L2TPV3;
 -			goto out;
 -		case VIRTCHNL_PROTO_HDR_ESP:
 -			if (is_ipv4)
 -				ptype = is_udp ? ICE_MAC_IPV4_NAT_T_ESP :
 -						ICE_MAC_IPV4_ESP;
 -			else if (is_ipv6)
 -				ptype = is_udp ? ICE_MAC_IPV6_NAT_T_ESP :
 -						ICE_MAC_IPV6_ESP;
 -			goto out;
 -		case VIRTCHNL_PROTO_HDR_AH:
 -			if (is_ipv4)
 -				ptype = ICE_MAC_IPV4_AH;
 -			else if (is_ipv6)
 -				ptype = ICE_MAC_IPV6_AH;
 -			goto out;
 -		case VIRTCHNL_PROTO_HDR_PFCP:
 -			if (is_ipv4)
 -				ptype = ICE_MAC_IPV4_PFCP_SESSION;
 -			else if (is_ipv6)
 -				ptype = ICE_MAC_IPV6_PFCP_SESSION;
 -			goto out;
 -		default:
 -			break;
 -		}
 -		i++;
 -	}
++static int
++ice_vc_ena_vlan_offload(struct ice_vsi *vsi,
++			int (*ena_offload)(struct ice_vsi *vsi, u16 tpid),
++			u32 ethertype_setting)
++{
++	u16 tpid;
++	int err;
+ 
 -out:
 -	return ice_hw_ptype_ena(&vf->pf->hw, ptype);
++	err = ice_vc_get_tpid(ethertype_setting, &tpid);
++	if (err)
++		return err;
++
++	err = ena_offload(vsi, tpid);
++	if (err)
++		return err;
++
++	return 0;
+ }
+ 
++#define ICE_L2TSEL_QRX_CONTEXT_REG_IDX	3
++#define ICE_L2TSEL_BIT_OFFSET		23
++enum ice_l2tsel {
++	ICE_L2TSEL_EXTRACT_FIRST_TAG_L2TAG2_2ND,
++	ICE_L2TSEL_EXTRACT_FIRST_TAG_L2TAG1,
++};
++
+ /**
 - * ice_vc_parse_rss_cfg - parses hash fields and headers from
 - * a specific virtchnl RSS cfg
 - * @hw: pointer to the hardware
 - * @rss_cfg: pointer to the virtchnl RSS cfg
 - * @addl_hdrs: pointer to the protocol header fields (ICE_FLOW_SEG_HDR_*)
 - * to configure
 - * @hash_flds: pointer to the hash bit fields (ICE_FLOW_HASH_*) to configure
 - *
 - * Return true if all the protocol header and hash fields in the RSS cfg could
 - * be parsed, else return false
++ * ice_vsi_update_l2tsel - update l2tsel field for all Rx rings on this VSI
++ * @vsi: VSI used to update l2tsel on
++ * @l2tsel: l2tsel setting requested
+  *
 - * This function parses the virtchnl RSS cfg to be the intended
 - * hash fields and the intended header for RSS configuration
++ * Use the l2tsel setting to update all of the Rx queue context bits for l2tsel.
++ * This will modify which descriptor field the first offloaded VLAN will be
++ * stripped into.
+  */
 -static bool
 -ice_vc_parse_rss_cfg(struct ice_hw *hw, struct virtchnl_rss_cfg *rss_cfg,
 -		     u32 *addl_hdrs, u64 *hash_flds)
++static void ice_vsi_update_l2tsel(struct ice_vsi *vsi, enum ice_l2tsel l2tsel)
+ {
 -	const struct ice_vc_hash_field_match_type *hf_list;
 -	const struct ice_vc_hdr_match_type *hdr_list;
 -	int i, hf_list_len, hdr_list_len;
 -
 -	hf_list = ice_vc_hash_field_list;
 -	hf_list_len = ARRAY_SIZE(ice_vc_hash_field_list);
 -	hdr_list = ice_vc_hdr_list;
 -	hdr_list_len = ARRAY_SIZE(ice_vc_hdr_list);
 -
 -	for (i = 0; i < rss_cfg->proto_hdrs.count; i++) {
 -		struct virtchnl_proto_hdr *proto_hdr =
 -					&rss_cfg->proto_hdrs.proto_hdr[i];
 -		bool hdr_found = false;
 -		int j;
 -
 -		/* Find matched ice headers according to virtchnl headers. */
 -		for (j = 0; j < hdr_list_len; j++) {
 -			struct ice_vc_hdr_match_type hdr_map = hdr_list[j];
 -
 -			if (proto_hdr->type == hdr_map.vc_hdr) {
 -				*addl_hdrs |= hdr_map.ice_hdr;
 -				hdr_found = true;
 -			}
 -		}
 -
 -		if (!hdr_found)
 -			return false;
++	struct ice_hw *hw = &vsi->back->hw;
++	u32 l2tsel_bit;
++	int i;
+ 
 -		/* Find matched ice hash fields according to
 -		 * virtchnl hash fields.
 -		 */
 -		for (j = 0; j < hf_list_len; j++) {
 -			struct ice_vc_hash_field_match_type hf_map = hf_list[j];
++	if (l2tsel == ICE_L2TSEL_EXTRACT_FIRST_TAG_L2TAG2_2ND)
++		l2tsel_bit = 0;
++	else
++		l2tsel_bit = BIT(ICE_L2TSEL_BIT_OFFSET);
+ 
 -			if (proto_hdr->type == hf_map.vc_hdr &&
 -			    proto_hdr->field_selector == hf_map.vc_hash_field) {
 -				*hash_flds |= hf_map.ice_hash_field;
 -				break;
 -			}
 -		}
 -	}
++	for (i = 0; i < vsi->alloc_rxq; i++) {
++		u16 pfq = vsi->rxq_map[i];
++		u32 qrx_context_offset;
++		u32 regval;
+ 
 -	return true;
 -}
++		qrx_context_offset =
++			QRX_CONTEXT(ICE_L2TSEL_QRX_CONTEXT_REG_IDX, pfq);
+ 
 -/**
 - * ice_vf_adv_rss_offload_ena - determine if capabilities support advanced
 - * RSS offloads
 - * @caps: VF driver negotiated capabilities
 - *
 - * Return true if VIRTCHNL_VF_OFFLOAD_ADV_RSS_PF capability is set,
 - * else return false
 - */
 -static bool ice_vf_adv_rss_offload_ena(u32 caps)
 -{
 -	return !!(caps & VIRTCHNL_VF_OFFLOAD_ADV_RSS_PF);
++		regval = rd32(hw, qrx_context_offset);
++		regval &= ~BIT(ICE_L2TSEL_BIT_OFFSET);
++		regval |= l2tsel_bit;
++		wr32(hw, qrx_context_offset, regval);
++	}
+ }
+ 
+ /**
 - * ice_vc_handle_rss_cfg
 - * @vf: pointer to the VF info
 - * @msg: pointer to the message buffer
 - * @add: add a RSS config if true, otherwise delete a RSS config
++ * ice_vc_ena_vlan_stripping_v2_msg
++ * @vf: VF the message was received from
++ * @msg: message received from the VF
+  *
 - * This function adds/deletes a RSS config
++ * virthcnl handler for VIRTCHNL_OP_ENABLE_VLAN_STRIPPING_V2
+  */
 -static int ice_vc_handle_rss_cfg(struct ice_vf *vf, u8 *msg, bool add)
++static int ice_vc_ena_vlan_stripping_v2_msg(struct ice_vf *vf, u8 *msg)
+ {
 -	u32 v_opcode = add ? VIRTCHNL_OP_ADD_RSS_CFG : VIRTCHNL_OP_DEL_RSS_CFG;
 -	struct virtchnl_rss_cfg *rss_cfg = (struct virtchnl_rss_cfg *)msg;
+ 	enum virtchnl_status_code v_ret = VIRTCHNL_STATUS_SUCCESS;
 -	struct device *dev = ice_pf_to_dev(vf->pf);
 -	struct ice_hw *hw = &vf->pf->hw;
++	struct virtchnl_vlan_supported_caps *stripping_support;
++	struct virtchnl_vlan_setting *strip_msg =
++		(struct virtchnl_vlan_setting *)msg;
++	u32 ethertype_setting;
+ 	struct ice_vsi *vsi;
+ 
 -	if (!test_bit(ICE_FLAG_RSS_ENA, vf->pf->flags)) {
 -		dev_dbg(dev, "VF %d attempting to configure RSS, but RSS is not supported by the PF\n",
 -			vf->vf_id);
 -		v_ret = VIRTCHNL_STATUS_ERR_NOT_SUPPORTED;
 -		goto error_param;
 -	}
 -
 -	if (!ice_vf_adv_rss_offload_ena(vf->driver_caps)) {
 -		dev_dbg(dev, "VF %d attempting to configure RSS, but Advanced RSS offload is not supported\n",
 -			vf->vf_id);
 -		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -		goto error_param;
 -	}
 -
+ 	if (!test_bit(ICE_VF_STATE_ACTIVE, vf->vf_states)) {
+ 		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -		goto error_param;
++		goto out;
+ 	}
+ 
 -	if (rss_cfg->proto_hdrs.count > VIRTCHNL_MAX_NUM_PROTO_HDRS ||
 -	    rss_cfg->rss_algorithm < VIRTCHNL_RSS_ALG_TOEPLITZ_ASYMMETRIC ||
 -	    rss_cfg->rss_algorithm > VIRTCHNL_RSS_ALG_XOR_SYMMETRIC) {
 -		dev_dbg(dev, "VF %d attempting to configure RSS, but RSS configuration is not valid\n",
 -			vf->vf_id);
++	if (!ice_vc_isvalid_vsi_id(vf, strip_msg->vport_id)) {
+ 		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -		goto error_param;
++		goto out;
+ 	}
+ 
+ 	vsi = ice_get_vf_vsi(vf);
+ 	if (!vsi) {
+ 		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -		goto error_param;
++		goto out;
+ 	}
+ 
 -	if (!ice_vc_validate_pattern(vf, &rss_cfg->proto_hdrs)) {
++	stripping_support = &vf->vlan_v2_caps.offloads.stripping_support;
++	if (!ice_vc_valid_vlan_setting_msg(stripping_support, strip_msg)) {
+ 		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -		goto error_param;
++		goto out;
+ 	}
+ 
 -	if (rss_cfg->rss_algorithm == VIRTCHNL_RSS_ALG_R_ASYMMETRIC) {
 -		struct ice_vsi_ctx *ctx;
 -		u8 lut_type, hash_type;
 -		int status;
 -
 -		lut_type = ICE_AQ_VSI_Q_OPT_RSS_LUT_VSI;
 -		hash_type = add ? ICE_AQ_VSI_Q_OPT_RSS_XOR :
 -				ICE_AQ_VSI_Q_OPT_RSS_TPLZ;
 -
 -		ctx = kzalloc(sizeof(*ctx), GFP_KERNEL);
 -		if (!ctx) {
 -			v_ret = VIRTCHNL_STATUS_ERR_NO_MEMORY;
 -			goto error_param;
 -		}
 -
 -		ctx->info.q_opt_rss = ((lut_type <<
 -					ICE_AQ_VSI_Q_OPT_RSS_LUT_S) &
 -				       ICE_AQ_VSI_Q_OPT_RSS_LUT_M) |
 -				       (hash_type &
 -					ICE_AQ_VSI_Q_OPT_RSS_HASH_M);
 -
 -		/* Preserve existing queueing option setting */
 -		ctx->info.q_opt_rss |= (vsi->info.q_opt_rss &
 -					  ICE_AQ_VSI_Q_OPT_RSS_GBL_LUT_M);
 -		ctx->info.q_opt_tc = vsi->info.q_opt_tc;
 -		ctx->info.q_opt_flags = vsi->info.q_opt_rss;
 -
 -		ctx->info.valid_sections =
 -				cpu_to_le16(ICE_AQ_VSI_PROP_Q_OPT_VALID);
 -
 -		status = ice_update_vsi(hw, vsi->idx, ctx, NULL);
 -		if (status) {
 -			dev_err(dev, "update VSI for RSS failed, err %d aq_err %s\n",
 -				status, ice_aq_str(hw->adminq.sq_last_status));
 -			v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -		} else {
 -			vsi->info.q_opt_rss = ctx->info.q_opt_rss;
 -		}
 -
 -		kfree(ctx);
 -	} else {
 -		u32 addl_hdrs = ICE_FLOW_SEG_HDR_NONE;
 -		u64 hash_flds = ICE_HASH_INVALID;
 -
 -		if (!ice_vc_parse_rss_cfg(hw, rss_cfg, &addl_hdrs,
 -					  &hash_flds)) {
++	ethertype_setting = strip_msg->outer_ethertype_setting;
++	if (ethertype_setting) {
++		if (ice_vc_ena_vlan_offload(vsi,
++					    vsi->outer_vlan_ops.ena_stripping,
++					    ethertype_setting)) {
+ 			v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -			goto error_param;
 -		}
 -
 -		if (add) {
 -			if (ice_add_rss_cfg(hw, vsi->idx, hash_flds,
 -					    addl_hdrs)) {
 -				v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -				dev_err(dev, "ice_add_rss_cfg failed for vsi = %d, v_ret = %d\n",
 -					vsi->vsi_num, v_ret);
 -			}
++			goto out;
+ 		} else {
 -			int status;
++			enum ice_l2tsel l2tsel =
++				ICE_L2TSEL_EXTRACT_FIRST_TAG_L2TAG2_2ND;
+ 
 -			status = ice_rem_rss_cfg(hw, vsi->idx, hash_flds,
 -						 addl_hdrs);
 -			/* We just ignore -ENOENT, because if two configurations
 -			 * share the same profile remove one of them actually
 -			 * removes both, since the profile is deleted.
++			/* PF tells the VF that the outer VLAN tag is always
++			 * extracted to VIRTCHNL_VLAN_TAG_LOCATION_L2TAG2_2 and
++			 * inner is always extracted to
++			 * VIRTCHNL_VLAN_TAG_LOCATION_L2TAG1. This is needed to
++			 * support outer stripping so the first tag always ends
++			 * up in L2TAG2_2ND and the second/inner tag, if
++			 * enabled, is extracted in L2TAG1.
+ 			 */
 -			if (status && status != -ENOENT) {
 -				v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -				dev_err(dev, "ice_rem_rss_cfg failed for VF ID:%d, error:%d\n",
 -					vf->vf_id, status);
 -			}
++			ice_vsi_update_l2tsel(vsi, l2tsel);
+ 		}
+ 	}
+ 
 -error_param:
 -	return ice_vc_send_msg_to_vf(vf, v_opcode, v_ret, NULL, 0);
++	ethertype_setting = strip_msg->inner_ethertype_setting;
++	if (ethertype_setting &&
++	    ice_vc_ena_vlan_offload(vsi, vsi->inner_vlan_ops.ena_stripping,
++				    ethertype_setting)) {
++		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
++		goto out;
++	}
++
++out:
++	return ice_vc_send_msg_to_vf(vf, VIRTCHNL_OP_ENABLE_VLAN_STRIPPING_V2, v_ret, NULL, 0);
+ }
+ 
+ /**
 - * ice_vc_config_rss_key
 - * @vf: pointer to the VF info
 - * @msg: pointer to the msg buffer
++ * ice_vc_dis_vlan_stripping_v2_msg
++ * @vf: VF the message was received from
++ * @msg: message received from the VF
+  *
 - * Configure the VF's RSS key
++ * virthcnl handler for VIRTCHNL_OP_DISABLE_VLAN_STRIPPING_V2
+  */
 -static int ice_vc_config_rss_key(struct ice_vf *vf, u8 *msg)
++static int ice_vc_dis_vlan_stripping_v2_msg(struct ice_vf *vf, u8 *msg)
+ {
+ 	enum virtchnl_status_code v_ret = VIRTCHNL_STATUS_SUCCESS;
 -	struct virtchnl_rss_key *vrk =
 -		(struct virtchnl_rss_key *)msg;
++	struct virtchnl_vlan_supported_caps *stripping_support;
++	struct virtchnl_vlan_setting *strip_msg =
++		(struct virtchnl_vlan_setting *)msg;
++	u32 ethertype_setting;
+ 	struct ice_vsi *vsi;
+ 
+ 	if (!test_bit(ICE_VF_STATE_ACTIVE, vf->vf_states)) {
+ 		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -		goto error_param;
++		goto out;
+ 	}
+ 
 -	if (!ice_vc_isvalid_vsi_id(vf, vrk->vsi_id)) {
++	if (!ice_vc_isvalid_vsi_id(vf, strip_msg->vport_id)) {
+ 		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -		goto error_param;
++		goto out;
+ 	}
+ 
 -	if (vrk->key_len != ICE_VSIQF_HKEY_ARRAY_SIZE) {
++	vsi = ice_get_vf_vsi(vf);
++	if (!vsi) {
+ 		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -		goto error_param;
++		goto out;
+ 	}
+ 
 -	if (!test_bit(ICE_FLAG_RSS_ENA, vf->pf->flags)) {
++	stripping_support = &vf->vlan_v2_caps.offloads.stripping_support;
++	if (!ice_vc_valid_vlan_setting_msg(stripping_support, strip_msg)) {
+ 		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -		goto error_param;
++		goto out;
+ 	}
+ 
 -	vsi = ice_get_vf_vsi(vf);
 -	if (!vsi) {
++	ethertype_setting = strip_msg->outer_ethertype_setting;
++	if (ethertype_setting) {
++		if (vsi->outer_vlan_ops.dis_stripping(vsi)) {
++			v_ret = VIRTCHNL_STATUS_ERR_PARAM;
++			goto out;
++		} else {
++			enum ice_l2tsel l2tsel =
++				ICE_L2TSEL_EXTRACT_FIRST_TAG_L2TAG1;
++
++			/* PF tells the VF that the outer VLAN tag is always
++			 * extracted to VIRTCHNL_VLAN_TAG_LOCATION_L2TAG2_2 and
++			 * inner is always extracted to
++			 * VIRTCHNL_VLAN_TAG_LOCATION_L2TAG1. This is needed to
++			 * support inner stripping while outer stripping is
++			 * disabled so that the first and only tag is extracted
++			 * in L2TAG1.
++			 */
++			ice_vsi_update_l2tsel(vsi, l2tsel);
++		}
++	}
++
++	ethertype_setting = strip_msg->inner_ethertype_setting;
++	if (ethertype_setting && vsi->inner_vlan_ops.dis_stripping(vsi)) {
+ 		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -		goto error_param;
++		goto out;
+ 	}
+ 
 -	if (ice_set_rss_key(vsi, vrk->key))
 -		v_ret = VIRTCHNL_STATUS_ERR_ADMIN_QUEUE_ERROR;
 -error_param:
 -	return ice_vc_send_msg_to_vf(vf, VIRTCHNL_OP_CONFIG_RSS_KEY, v_ret,
 -				     NULL, 0);
++out:
++	return ice_vc_send_msg_to_vf(vf, VIRTCHNL_OP_DISABLE_VLAN_STRIPPING_V2, v_ret, NULL, 0);
+ }
+ 
+ /**
 - * ice_vc_config_rss_lut
 - * @vf: pointer to the VF info
 - * @msg: pointer to the msg buffer
++ * ice_vc_ena_vlan_insertion_v2_msg
++ * @vf: VF the message was received from
++ * @msg: message received from the VF
+  *
 - * Configure the VF's RSS LUT
++ * virthcnl handler for VIRTCHNL_OP_ENABLE_VLAN_INSERTION_V2
+  */
 -static int ice_vc_config_rss_lut(struct ice_vf *vf, u8 *msg)
++static int ice_vc_ena_vlan_insertion_v2_msg(struct ice_vf *vf, u8 *msg)
+ {
 -	struct virtchnl_rss_lut *vrl = (struct virtchnl_rss_lut *)msg;
+ 	enum virtchnl_status_code v_ret = VIRTCHNL_STATUS_SUCCESS;
++	struct virtchnl_vlan_supported_caps *insertion_support;
++	struct virtchnl_vlan_setting *insertion_msg =
++		(struct virtchnl_vlan_setting *)msg;
++	u32 ethertype_setting;
+ 	struct ice_vsi *vsi;
+ 
+ 	if (!test_bit(ICE_VF_STATE_ACTIVE, vf->vf_states)) {
+ 		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -		goto error_param;
++		goto out;
+ 	}
+ 
 -	if (!ice_vc_isvalid_vsi_id(vf, vrl->vsi_id)) {
++	if (!ice_vc_isvalid_vsi_id(vf, insertion_msg->vport_id)) {
+ 		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -		goto error_param;
++		goto out;
+ 	}
+ 
 -	if (vrl->lut_entries != ICE_VSIQF_HLUT_ARRAY_SIZE) {
++	vsi = ice_get_vf_vsi(vf);
++	if (!vsi) {
+ 		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -		goto error_param;
++		goto out;
+ 	}
+ 
 -	if (!test_bit(ICE_FLAG_RSS_ENA, vf->pf->flags)) {
++	insertion_support = &vf->vlan_v2_caps.offloads.insertion_support;
++	if (!ice_vc_valid_vlan_setting_msg(insertion_support, insertion_msg)) {
+ 		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -		goto error_param;
++		goto out;
+ 	}
+ 
 -	vsi = ice_get_vf_vsi(vf);
 -	if (!vsi) {
++	ethertype_setting = insertion_msg->outer_ethertype_setting;
++	if (ethertype_setting &&
++	    ice_vc_ena_vlan_offload(vsi, vsi->outer_vlan_ops.ena_insertion,
++				    ethertype_setting)) {
++		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
++		goto out;
++	}
++
++	ethertype_setting = insertion_msg->inner_ethertype_setting;
++	if (ethertype_setting &&
++	    ice_vc_ena_vlan_offload(vsi, vsi->inner_vlan_ops.ena_insertion,
++				    ethertype_setting)) {
+ 		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -		goto error_param;
++		goto out;
+ 	}
+ 
 -	if (ice_set_rss_lut(vsi, vrl->lut, ICE_VSIQF_HLUT_ARRAY_SIZE))
 -		v_ret = VIRTCHNL_STATUS_ERR_ADMIN_QUEUE_ERROR;
 -error_param:
 -	return ice_vc_send_msg_to_vf(vf, VIRTCHNL_OP_CONFIG_RSS_LUT, v_ret,
 -				     NULL, 0);
++out:
++	return ice_vc_send_msg_to_vf(vf, VIRTCHNL_OP_ENABLE_VLAN_INSERTION_V2, v_ret, NULL, 0);
+ }
+ 
+ /**
 - * ice_wait_on_vf_reset - poll to make sure a given VF is ready after reset
 - * @vf: The VF being resseting
++ * ice_vc_dis_vlan_insertion_v2_msg
++ * @vf: VF the message was received from
++ * @msg: message received from the VF
+  *
 - * The max poll time is about ~800ms, which is about the maximum time it takes
 - * for a VF to be reset and/or a VF driver to be removed.
++ * virthcnl handler for VIRTCHNL_OP_DISABLE_VLAN_INSERTION_V2
+  */
 -static void ice_wait_on_vf_reset(struct ice_vf *vf)
++static int ice_vc_dis_vlan_insertion_v2_msg(struct ice_vf *vf, u8 *msg)
+ {
 -	int i;
++	enum virtchnl_status_code v_ret = VIRTCHNL_STATUS_SUCCESS;
++	struct virtchnl_vlan_supported_caps *insertion_support;
++	struct virtchnl_vlan_setting *insertion_msg =
++		(struct virtchnl_vlan_setting *)msg;
++	u32 ethertype_setting;
++	struct ice_vsi *vsi;
+ 
 -	for (i = 0; i < ICE_MAX_VF_RESET_TRIES; i++) {
 -		if (test_bit(ICE_VF_STATE_INIT, vf->vf_states))
 -			break;
 -		msleep(ICE_MAX_VF_RESET_SLEEP_MS);
 -	}
 -}
 -
 -/**
 - * ice_check_vf_ready_for_cfg - check if VF is ready to be configured/queried
 - * @vf: VF to check if it's ready to be configured/queried
 - *
 - * The purpose of this function is to make sure the VF is not in reset, not
 - * disabled, and initialized so it can be configured and/or queried by a host
 - * administrator.
 - */
 -int ice_check_vf_ready_for_cfg(struct ice_vf *vf)
 -{
 -	struct ice_pf *pf;
 -
 -	ice_wait_on_vf_reset(vf);
 -
 -	if (ice_is_vf_disabled(vf))
 -		return -EINVAL;
 -
 -	pf = vf->pf;
 -	if (ice_check_vf_init(pf, vf))
 -		return -EBUSY;
 -
 -	return 0;
 -}
 -
 -/**
 - * ice_set_vf_spoofchk
 - * @netdev: network interface device structure
 - * @vf_id: VF identifier
 - * @ena: flag to enable or disable feature
 - *
 - * Enable or disable VF spoof checking
 - */
 -int ice_set_vf_spoofchk(struct net_device *netdev, int vf_id, bool ena)
 -{
 -	struct ice_netdev_priv *np = netdev_priv(netdev);
 -	struct ice_pf *pf = np->vsi->back;
 -	struct ice_vsi *vf_vsi;
 -	struct device *dev;
 -	struct ice_vf *vf;
 -	int ret;
 -
 -	dev = ice_pf_to_dev(pf);
 -
 -	vf = ice_get_vf_by_id(pf, vf_id);
 -	if (!vf)
 -		return -EINVAL;
 -
 -	ret = ice_check_vf_ready_for_cfg(vf);
 -	if (ret)
 -		goto out_put_vf;
 -
 -	vf_vsi = ice_get_vf_vsi(vf);
 -	if (!vf_vsi) {
 -		netdev_err(netdev, "VSI %d for VF %d is null\n",
 -			   vf->lan_vsi_idx, vf->vf_id);
 -		ret = -EINVAL;
 -		goto out_put_vf;
 -	}
 -
 -	if (vf_vsi->type != ICE_VSI_VF) {
 -		netdev_err(netdev, "Type %d of VSI %d for VF %d is no ICE_VSI_VF\n",
 -			   vf_vsi->type, vf_vsi->vsi_num, vf->vf_id);
 -		ret = -ENODEV;
 -		goto out_put_vf;
 -	}
 -
 -	if (ena == vf->spoofchk) {
 -		dev_dbg(dev, "VF spoofchk already %s\n", ena ? "ON" : "OFF");
 -		ret = 0;
 -		goto out_put_vf;
 -	}
 -
 -	if (ena)
 -		ret = ice_vsi_ena_spoofchk(vf_vsi);
 -	else
 -		ret = ice_vsi_dis_spoofchk(vf_vsi);
 -	if (ret)
 -		dev_err(dev, "Failed to set spoofchk %s for VF %d VSI %d\n error %d\n",
 -			ena ? "ON" : "OFF", vf->vf_id, vf_vsi->vsi_num, ret);
 -	else
 -		vf->spoofchk = ena;
 -
 -out_put_vf:
 -	ice_put_vf(vf);
 -	return ret;
 -}
 -
 -/**
 - * ice_is_any_vf_in_promisc - check if any VF(s) are in promiscuous mode
 - * @pf: PF structure for accessing VF(s)
 - *
 - * Return false if no VF(s) are in unicast and/or multicast promiscuous mode,
 - * else return true
 - */
 -bool ice_is_any_vf_in_promisc(struct ice_pf *pf)
 -{
 -	bool is_vf_promisc = false;
 -	struct ice_vf *vf;
 -	unsigned int bkt;
 -
 -	rcu_read_lock();
 -	ice_for_each_vf_rcu(pf, bkt, vf) {
 -		/* found a VF that has promiscuous mode configured */
 -		if (test_bit(ICE_VF_STATE_UC_PROMISC, vf->vf_states) ||
 -		    test_bit(ICE_VF_STATE_MC_PROMISC, vf->vf_states)) {
 -			is_vf_promisc = true;
 -			break;
 -		}
 -	}
 -	rcu_read_unlock();
 -
 -	return is_vf_promisc;
 -}
 -
 -/**
 - * ice_vc_cfg_promiscuous_mode_msg
 - * @vf: pointer to the VF info
 - * @msg: pointer to the msg buffer
 - *
 - * called from the VF to configure VF VSIs promiscuous mode
 - */
 -static int ice_vc_cfg_promiscuous_mode_msg(struct ice_vf *vf, u8 *msg)
 -{
 -	enum virtchnl_status_code v_ret = VIRTCHNL_STATUS_SUCCESS;
 -	bool rm_promisc, alluni = false, allmulti = false;
 -	struct virtchnl_promisc_info *info =
 -	    (struct virtchnl_promisc_info *)msg;
 -	struct ice_vsi_vlan_ops *vlan_ops;
 -	int mcast_err = 0, ucast_err = 0;
 -	struct ice_pf *pf = vf->pf;
 -	struct ice_vsi *vsi;
 -	struct device *dev;
 -	int ret = 0;
 -
 -	if (!test_bit(ICE_VF_STATE_ACTIVE, vf->vf_states)) {
 -		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -		goto error_param;
 -	}
 -
 -	if (!ice_vc_isvalid_vsi_id(vf, info->vsi_id)) {
 -		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -		goto error_param;
 -	}
 -
 -	vsi = ice_get_vf_vsi(vf);
 -	if (!vsi) {
 -		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -		goto error_param;
 -	}
 -
 -	dev = ice_pf_to_dev(pf);
 -	if (!test_bit(ICE_VIRTCHNL_VF_CAP_PRIVILEGE, &vf->vf_caps)) {
 -		dev_err(dev, "Unprivileged VF %d is attempting to configure promiscuous mode\n",
 -			vf->vf_id);
 -		/* Leave v_ret alone, lie to the VF on purpose. */
 -		goto error_param;
 -	}
 -
 -	if (info->flags & FLAG_VF_UNICAST_PROMISC)
 -		alluni = true;
 -
 -	if (info->flags & FLAG_VF_MULTICAST_PROMISC)
 -		allmulti = true;
 -
 -	rm_promisc = !allmulti && !alluni;
 -
 -	vlan_ops = ice_get_compat_vsi_vlan_ops(vsi);
 -	if (rm_promisc)
 -		ret = vlan_ops->ena_rx_filtering(vsi);
 -	else
 -		ret = vlan_ops->dis_rx_filtering(vsi);
 -	if (ret) {
 -		dev_err(dev, "Failed to configure VLAN pruning in promiscuous mode\n");
 -		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -		goto error_param;
 -	}
 -
 -	if (!test_bit(ICE_FLAG_VF_TRUE_PROMISC_ENA, pf->flags)) {
 -		bool set_dflt_vsi = alluni || allmulti;
 -
 -		if (set_dflt_vsi && !ice_is_dflt_vsi_in_use(pf->first_sw))
 -			/* only attempt to set the default forwarding VSI if
 -			 * it's not currently set
 -			 */
 -			ret = ice_set_dflt_vsi(pf->first_sw, vsi);
 -		else if (!set_dflt_vsi &&
 -			 ice_is_vsi_dflt_vsi(pf->first_sw, vsi))
 -			/* only attempt to free the default forwarding VSI if we
 -			 * are the owner
 -			 */
 -			ret = ice_clear_dflt_vsi(pf->first_sw);
 -
 -		if (ret) {
 -			dev_err(dev, "%sable VF %d as the default VSI failed, error %d\n",
 -				set_dflt_vsi ? "en" : "dis", vf->vf_id, ret);
 -			v_ret = VIRTCHNL_STATUS_ERR_ADMIN_QUEUE_ERROR;
 -			goto error_param;
 -		}
 -	} else {
 -		u8 mcast_m, ucast_m;
 -
 -		if (ice_vf_is_port_vlan_ena(vf) ||
 -		    ice_vsi_has_non_zero_vlans(vsi)) {
 -			mcast_m = ICE_MCAST_VLAN_PROMISC_BITS;
 -			ucast_m = ICE_UCAST_VLAN_PROMISC_BITS;
 -		} else {
 -			mcast_m = ICE_MCAST_PROMISC_BITS;
 -			ucast_m = ICE_UCAST_PROMISC_BITS;
 -		}
 -
 -		if (alluni)
 -			ucast_err = ice_vf_set_vsi_promisc(vf, vsi, ucast_m);
 -		else
 -			ucast_err = ice_vf_clear_vsi_promisc(vf, vsi, ucast_m);
 -
 -		if (allmulti)
 -			mcast_err = ice_vf_set_vsi_promisc(vf, vsi, mcast_m);
 -		else
 -			mcast_err = ice_vf_clear_vsi_promisc(vf, vsi, mcast_m);
 -
 -		if (ucast_err || mcast_err)
 -			v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -	}
 -
 -	if (!mcast_err) {
 -		if (allmulti &&
 -		    !test_and_set_bit(ICE_VF_STATE_MC_PROMISC, vf->vf_states))
 -			dev_info(dev, "VF %u successfully set multicast promiscuous mode\n",
 -				 vf->vf_id);
 -		else if (!allmulti && test_and_clear_bit(ICE_VF_STATE_MC_PROMISC, vf->vf_states))
 -			dev_info(dev, "VF %u successfully unset multicast promiscuous mode\n",
 -				 vf->vf_id);
 -	}
 -
 -	if (!ucast_err) {
 -		if (alluni && !test_and_set_bit(ICE_VF_STATE_UC_PROMISC, vf->vf_states))
 -			dev_info(dev, "VF %u successfully set unicast promiscuous mode\n",
 -				 vf->vf_id);
 -		else if (!alluni && test_and_clear_bit(ICE_VF_STATE_UC_PROMISC, vf->vf_states))
 -			dev_info(dev, "VF %u successfully unset unicast promiscuous mode\n",
 -				 vf->vf_id);
 -	}
 -
 -error_param:
 -	return ice_vc_send_msg_to_vf(vf, VIRTCHNL_OP_CONFIG_PROMISCUOUS_MODE,
 -				     v_ret, NULL, 0);
 -}
 -
 -/**
 - * ice_vc_get_stats_msg
 - * @vf: pointer to the VF info
 - * @msg: pointer to the msg buffer
 - *
 - * called from the VF to get VSI stats
 - */
 -static int ice_vc_get_stats_msg(struct ice_vf *vf, u8 *msg)
 -{
 -	enum virtchnl_status_code v_ret = VIRTCHNL_STATUS_SUCCESS;
 -	struct virtchnl_queue_select *vqs =
 -		(struct virtchnl_queue_select *)msg;
 -	struct ice_eth_stats stats = { 0 };
 -	struct ice_vsi *vsi;
 -
 -	if (!test_bit(ICE_VF_STATE_ACTIVE, vf->vf_states)) {
 -		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -		goto error_param;
 -	}
 -
 -	if (!ice_vc_isvalid_vsi_id(vf, vqs->vsi_id)) {
 -		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -		goto error_param;
 -	}
 -
 -	vsi = ice_get_vf_vsi(vf);
 -	if (!vsi) {
 -		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -		goto error_param;
 -	}
 -
 -	ice_update_eth_stats(vsi);
 -
 -	stats = vsi->eth_stats;
 -
 -error_param:
 -	/* send the response to the VF */
 -	return ice_vc_send_msg_to_vf(vf, VIRTCHNL_OP_GET_STATS, v_ret,
 -				     (u8 *)&stats, sizeof(stats));
 -}
 -
 -/**
 - * ice_vc_validate_vqs_bitmaps - validate Rx/Tx queue bitmaps from VIRTCHNL
 - * @vqs: virtchnl_queue_select structure containing bitmaps to validate
 - *
 - * Return true on successful validation, else false
 - */
 -static bool ice_vc_validate_vqs_bitmaps(struct virtchnl_queue_select *vqs)
 -{
 -	if ((!vqs->rx_queues && !vqs->tx_queues) ||
 -	    vqs->rx_queues >= BIT(ICE_MAX_RSS_QS_PER_VF) ||
 -	    vqs->tx_queues >= BIT(ICE_MAX_RSS_QS_PER_VF))
 -		return false;
 -
 -	return true;
 -}
 -
 -/**
 - * ice_vf_ena_txq_interrupt - enable Tx queue interrupt via QINT_TQCTL
 - * @vsi: VSI of the VF to configure
 - * @q_idx: VF queue index used to determine the queue in the PF's space
 - */
 -static void ice_vf_ena_txq_interrupt(struct ice_vsi *vsi, u32 q_idx)
 -{
 -	struct ice_hw *hw = &vsi->back->hw;
 -	u32 pfq = vsi->txq_map[q_idx];
 -	u32 reg;
 -
 -	reg = rd32(hw, QINT_TQCTL(pfq));
 -
 -	/* MSI-X index 0 in the VF's space is always for the OICR, which means
 -	 * this is most likely a poll mode VF driver, so don't enable an
 -	 * interrupt that was never configured via VIRTCHNL_OP_CONFIG_IRQ_MAP
 -	 */
 -	if (!(reg & QINT_TQCTL_MSIX_INDX_M))
 -		return;
 -
 -	wr32(hw, QINT_TQCTL(pfq), reg | QINT_TQCTL_CAUSE_ENA_M);
 -}
 -
 -/**
 - * ice_vf_ena_rxq_interrupt - enable Tx queue interrupt via QINT_RQCTL
 - * @vsi: VSI of the VF to configure
 - * @q_idx: VF queue index used to determine the queue in the PF's space
 - */
 -static void ice_vf_ena_rxq_interrupt(struct ice_vsi *vsi, u32 q_idx)
 -{
 -	struct ice_hw *hw = &vsi->back->hw;
 -	u32 pfq = vsi->rxq_map[q_idx];
 -	u32 reg;
 -
 -	reg = rd32(hw, QINT_RQCTL(pfq));
 -
 -	/* MSI-X index 0 in the VF's space is always for the OICR, which means
 -	 * this is most likely a poll mode VF driver, so don't enable an
 -	 * interrupt that was never configured via VIRTCHNL_OP_CONFIG_IRQ_MAP
 -	 */
 -	if (!(reg & QINT_RQCTL_MSIX_INDX_M))
 -		return;
 -
 -	wr32(hw, QINT_RQCTL(pfq), reg | QINT_RQCTL_CAUSE_ENA_M);
 -}
 -
 -/**
 - * ice_vc_ena_qs_msg
 - * @vf: pointer to the VF info
 - * @msg: pointer to the msg buffer
 - *
 - * called from the VF to enable all or specific queue(s)
 - */
 -static int ice_vc_ena_qs_msg(struct ice_vf *vf, u8 *msg)
 -{
 -	enum virtchnl_status_code v_ret = VIRTCHNL_STATUS_SUCCESS;
 -	struct virtchnl_queue_select *vqs =
 -	    (struct virtchnl_queue_select *)msg;
 -	struct ice_vsi *vsi;
 -	unsigned long q_map;
 -	u16 vf_q_id;
 -
 -	if (!test_bit(ICE_VF_STATE_ACTIVE, vf->vf_states)) {
 -		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -		goto error_param;
 -	}
 -
 -	if (!ice_vc_isvalid_vsi_id(vf, vqs->vsi_id)) {
 -		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -		goto error_param;
 -	}
 -
 -	if (!ice_vc_validate_vqs_bitmaps(vqs)) {
 -		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -		goto error_param;
 -	}
 -
 -	vsi = ice_get_vf_vsi(vf);
 -	if (!vsi) {
 -		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -		goto error_param;
 -	}
 -
 -	/* Enable only Rx rings, Tx rings were enabled by the FW when the
 -	 * Tx queue group list was configured and the context bits were
 -	 * programmed using ice_vsi_cfg_txqs
 -	 */
 -	q_map = vqs->rx_queues;
 -	for_each_set_bit(vf_q_id, &q_map, ICE_MAX_RSS_QS_PER_VF) {
 -		if (!ice_vc_isvalid_q_id(vf, vqs->vsi_id, vf_q_id)) {
 -			v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -			goto error_param;
 -		}
 -
 -		/* Skip queue if enabled */
 -		if (test_bit(vf_q_id, vf->rxq_ena))
 -			continue;
 -
 -		if (ice_vsi_ctrl_one_rx_ring(vsi, true, vf_q_id, true)) {
 -			dev_err(ice_pf_to_dev(vsi->back), "Failed to enable Rx ring %d on VSI %d\n",
 -				vf_q_id, vsi->vsi_num);
 -			v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -			goto error_param;
 -		}
 -
 -		ice_vf_ena_rxq_interrupt(vsi, vf_q_id);
 -		set_bit(vf_q_id, vf->rxq_ena);
 -	}
 -
 -	q_map = vqs->tx_queues;
 -	for_each_set_bit(vf_q_id, &q_map, ICE_MAX_RSS_QS_PER_VF) {
 -		if (!ice_vc_isvalid_q_id(vf, vqs->vsi_id, vf_q_id)) {
 -			v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -			goto error_param;
 -		}
 -
 -		/* Skip queue if enabled */
 -		if (test_bit(vf_q_id, vf->txq_ena))
 -			continue;
 -
 -		ice_vf_ena_txq_interrupt(vsi, vf_q_id);
 -		set_bit(vf_q_id, vf->txq_ena);
 -	}
 -
 -	/* Set flag to indicate that queues are enabled */
 -	if (v_ret == VIRTCHNL_STATUS_SUCCESS)
 -		set_bit(ICE_VF_STATE_QS_ENA, vf->vf_states);
 -
 -error_param:
 -	/* send the response to the VF */
 -	return ice_vc_send_msg_to_vf(vf, VIRTCHNL_OP_ENABLE_QUEUES, v_ret,
 -				     NULL, 0);
 -}
 -
 -/**
 - * ice_vc_dis_qs_msg
 - * @vf: pointer to the VF info
 - * @msg: pointer to the msg buffer
 - *
 - * called from the VF to disable all or specific
 - * queue(s)
 - */
 -static int ice_vc_dis_qs_msg(struct ice_vf *vf, u8 *msg)
 -{
 -	enum virtchnl_status_code v_ret = VIRTCHNL_STATUS_SUCCESS;
 -	struct virtchnl_queue_select *vqs =
 -	    (struct virtchnl_queue_select *)msg;
 -	struct ice_vsi *vsi;
 -	unsigned long q_map;
 -	u16 vf_q_id;
 -
 -	if (!test_bit(ICE_VF_STATE_ACTIVE, vf->vf_states) &&
 -	    !test_bit(ICE_VF_STATE_QS_ENA, vf->vf_states)) {
 -		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -		goto error_param;
 -	}
 -
 -	if (!ice_vc_isvalid_vsi_id(vf, vqs->vsi_id)) {
 -		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -		goto error_param;
 -	}
 -
 -	if (!ice_vc_validate_vqs_bitmaps(vqs)) {
 -		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -		goto error_param;
 -	}
 -
 -	vsi = ice_get_vf_vsi(vf);
 -	if (!vsi) {
 -		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -		goto error_param;
 -	}
 -
 -	if (vqs->tx_queues) {
 -		q_map = vqs->tx_queues;
 -
 -		for_each_set_bit(vf_q_id, &q_map, ICE_MAX_RSS_QS_PER_VF) {
 -			struct ice_tx_ring *ring = vsi->tx_rings[vf_q_id];
 -			struct ice_txq_meta txq_meta = { 0 };
 -
 -			if (!ice_vc_isvalid_q_id(vf, vqs->vsi_id, vf_q_id)) {
 -				v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -				goto error_param;
 -			}
 -
 -			/* Skip queue if not enabled */
 -			if (!test_bit(vf_q_id, vf->txq_ena))
 -				continue;
 -
 -			ice_fill_txq_meta(vsi, ring, &txq_meta);
 -
 -			if (ice_vsi_stop_tx_ring(vsi, ICE_NO_RESET, vf->vf_id,
 -						 ring, &txq_meta)) {
 -				dev_err(ice_pf_to_dev(vsi->back), "Failed to stop Tx ring %d on VSI %d\n",
 -					vf_q_id, vsi->vsi_num);
 -				v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -				goto error_param;
 -			}
 -
 -			/* Clear enabled queues flag */
 -			clear_bit(vf_q_id, vf->txq_ena);
 -		}
 -	}
 -
 -	q_map = vqs->rx_queues;
 -	/* speed up Rx queue disable by batching them if possible */
 -	if (q_map &&
 -	    bitmap_equal(&q_map, vf->rxq_ena, ICE_MAX_RSS_QS_PER_VF)) {
 -		if (ice_vsi_stop_all_rx_rings(vsi)) {
 -			dev_err(ice_pf_to_dev(vsi->back), "Failed to stop all Rx rings on VSI %d\n",
 -				vsi->vsi_num);
 -			v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -			goto error_param;
 -		}
 -
 -		bitmap_zero(vf->rxq_ena, ICE_MAX_RSS_QS_PER_VF);
 -	} else if (q_map) {
 -		for_each_set_bit(vf_q_id, &q_map, ICE_MAX_RSS_QS_PER_VF) {
 -			if (!ice_vc_isvalid_q_id(vf, vqs->vsi_id, vf_q_id)) {
 -				v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -				goto error_param;
 -			}
 -
 -			/* Skip queue if not enabled */
 -			if (!test_bit(vf_q_id, vf->rxq_ena))
 -				continue;
 -
 -			if (ice_vsi_ctrl_one_rx_ring(vsi, false, vf_q_id,
 -						     true)) {
 -				dev_err(ice_pf_to_dev(vsi->back), "Failed to stop Rx ring %d on VSI %d\n",
 -					vf_q_id, vsi->vsi_num);
 -				v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -				goto error_param;
 -			}
 -
 -			/* Clear enabled queues flag */
 -			clear_bit(vf_q_id, vf->rxq_ena);
 -		}
 -	}
 -
 -	/* Clear enabled queues flag */
 -	if (v_ret == VIRTCHNL_STATUS_SUCCESS && ice_vf_has_no_qs_ena(vf))
 -		clear_bit(ICE_VF_STATE_QS_ENA, vf->vf_states);
 -
 -error_param:
 -	/* send the response to the VF */
 -	return ice_vc_send_msg_to_vf(vf, VIRTCHNL_OP_DISABLE_QUEUES, v_ret,
 -				     NULL, 0);
 -}
 -
 -/**
 - * ice_cfg_interrupt
 - * @vf: pointer to the VF info
 - * @vsi: the VSI being configured
 - * @vector_id: vector ID
 - * @map: vector map for mapping vectors to queues
 - * @q_vector: structure for interrupt vector
 - * configure the IRQ to queue map
 - */
 -static int
 -ice_cfg_interrupt(struct ice_vf *vf, struct ice_vsi *vsi, u16 vector_id,
 -		  struct virtchnl_vector_map *map,
 -		  struct ice_q_vector *q_vector)
 -{
 -	u16 vsi_q_id, vsi_q_id_idx;
 -	unsigned long qmap;
 -
 -	q_vector->num_ring_rx = 0;
 -	q_vector->num_ring_tx = 0;
 -
 -	qmap = map->rxq_map;
 -	for_each_set_bit(vsi_q_id_idx, &qmap, ICE_MAX_RSS_QS_PER_VF) {
 -		vsi_q_id = vsi_q_id_idx;
 -
 -		if (!ice_vc_isvalid_q_id(vf, vsi->vsi_num, vsi_q_id))
 -			return VIRTCHNL_STATUS_ERR_PARAM;
 -
 -		q_vector->num_ring_rx++;
 -		q_vector->rx.itr_idx = map->rxitr_idx;
 -		vsi->rx_rings[vsi_q_id]->q_vector = q_vector;
 -		ice_cfg_rxq_interrupt(vsi, vsi_q_id, vector_id,
 -				      q_vector->rx.itr_idx);
 -	}
 -
 -	qmap = map->txq_map;
 -	for_each_set_bit(vsi_q_id_idx, &qmap, ICE_MAX_RSS_QS_PER_VF) {
 -		vsi_q_id = vsi_q_id_idx;
 -
 -		if (!ice_vc_isvalid_q_id(vf, vsi->vsi_num, vsi_q_id))
 -			return VIRTCHNL_STATUS_ERR_PARAM;
 -
 -		q_vector->num_ring_tx++;
 -		q_vector->tx.itr_idx = map->txitr_idx;
 -		vsi->tx_rings[vsi_q_id]->q_vector = q_vector;
 -		ice_cfg_txq_interrupt(vsi, vsi_q_id, vector_id,
 -				      q_vector->tx.itr_idx);
 -	}
 -
 -	return VIRTCHNL_STATUS_SUCCESS;
 -}
 -
 -/**
 - * ice_vc_cfg_irq_map_msg
 - * @vf: pointer to the VF info
 - * @msg: pointer to the msg buffer
 - *
 - * called from the VF to configure the IRQ to queue map
 - */
 -static int ice_vc_cfg_irq_map_msg(struct ice_vf *vf, u8 *msg)
 -{
 -	enum virtchnl_status_code v_ret = VIRTCHNL_STATUS_SUCCESS;
 -	u16 num_q_vectors_mapped, vsi_id, vector_id;
 -	struct virtchnl_irq_map_info *irqmap_info;
 -	struct virtchnl_vector_map *map;
 -	struct ice_pf *pf = vf->pf;
 -	struct ice_vsi *vsi;
 -	int i;
 -
 -	irqmap_info = (struct virtchnl_irq_map_info *)msg;
 -	num_q_vectors_mapped = irqmap_info->num_vectors;
 -
 -	/* Check to make sure number of VF vectors mapped is not greater than
 -	 * number of VF vectors originally allocated, and check that
 -	 * there is actually at least a single VF queue vector mapped
 -	 */
 -	if (!test_bit(ICE_VF_STATE_ACTIVE, vf->vf_states) ||
 -	    pf->vfs.num_msix_per < num_q_vectors_mapped ||
 -	    !num_q_vectors_mapped) {
 -		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -		goto error_param;
 -	}
 -
 -	vsi = ice_get_vf_vsi(vf);
 -	if (!vsi) {
 -		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -		goto error_param;
 -	}
 -
 -	for (i = 0; i < num_q_vectors_mapped; i++) {
 -		struct ice_q_vector *q_vector;
 -
 -		map = &irqmap_info->vecmap[i];
 -
 -		vector_id = map->vector_id;
 -		vsi_id = map->vsi_id;
 -		/* vector_id is always 0-based for each VF, and can never be
 -		 * larger than or equal to the max allowed interrupts per VF
 -		 */
 -		if (!(vector_id < pf->vfs.num_msix_per) ||
 -		    !ice_vc_isvalid_vsi_id(vf, vsi_id) ||
 -		    (!vector_id && (map->rxq_map || map->txq_map))) {
 -			v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -			goto error_param;
 -		}
 -
 -		/* No need to map VF miscellaneous or rogue vector */
 -		if (!vector_id)
 -			continue;
 -
 -		/* Subtract non queue vector from vector_id passed by VF
 -		 * to get actual number of VSI queue vector array index
 -		 */
 -		q_vector = vsi->q_vectors[vector_id - ICE_NONQ_VECS_VF];
 -		if (!q_vector) {
 -			v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -			goto error_param;
 -		}
 -
 -		/* lookout for the invalid queue index */
 -		v_ret = (enum virtchnl_status_code)
 -			ice_cfg_interrupt(vf, vsi, vector_id, map, q_vector);
 -		if (v_ret)
 -			goto error_param;
 -	}
 -
 -error_param:
 -	/* send the response to the VF */
 -	return ice_vc_send_msg_to_vf(vf, VIRTCHNL_OP_CONFIG_IRQ_MAP, v_ret,
 -				     NULL, 0);
 -}
 -
 -/**
 - * ice_vc_cfg_qs_msg
 - * @vf: pointer to the VF info
 - * @msg: pointer to the msg buffer
 - *
 - * called from the VF to configure the Rx/Tx queues
 - */
 -static int ice_vc_cfg_qs_msg(struct ice_vf *vf, u8 *msg)
 -{
 -	enum virtchnl_status_code v_ret = VIRTCHNL_STATUS_SUCCESS;
 -	struct virtchnl_vsi_queue_config_info *qci =
 -	    (struct virtchnl_vsi_queue_config_info *)msg;
 -	struct virtchnl_queue_pair_info *qpi;
 -	struct ice_pf *pf = vf->pf;
 -	struct ice_vsi *vsi;
 -	int i, q_idx;
 -
 -	if (!test_bit(ICE_VF_STATE_ACTIVE, vf->vf_states)) {
 -		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -		goto error_param;
 -	}
 -
 -	if (!ice_vc_isvalid_vsi_id(vf, qci->vsi_id)) {
 -		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -		goto error_param;
 -	}
 -
 -	vsi = ice_get_vf_vsi(vf);
 -	if (!vsi) {
 -		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -		goto error_param;
 -	}
 -
 -	if (qci->num_queue_pairs > ICE_MAX_RSS_QS_PER_VF ||
 -	    qci->num_queue_pairs > min_t(u16, vsi->alloc_txq, vsi->alloc_rxq)) {
 -		dev_err(ice_pf_to_dev(pf), "VF-%d requesting more than supported number of queues: %d\n",
 -			vf->vf_id, min_t(u16, vsi->alloc_txq, vsi->alloc_rxq));
 -		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -		goto error_param;
 -	}
 -
 -	for (i = 0; i < qci->num_queue_pairs; i++) {
 -		qpi = &qci->qpair[i];
 -		if (qpi->txq.vsi_id != qci->vsi_id ||
 -		    qpi->rxq.vsi_id != qci->vsi_id ||
 -		    qpi->rxq.queue_id != qpi->txq.queue_id ||
 -		    qpi->txq.headwb_enabled ||
 -		    !ice_vc_isvalid_ring_len(qpi->txq.ring_len) ||
 -		    !ice_vc_isvalid_ring_len(qpi->rxq.ring_len) ||
 -		    !ice_vc_isvalid_q_id(vf, qci->vsi_id, qpi->txq.queue_id)) {
 -			v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -			goto error_param;
 -		}
 -
 -		q_idx = qpi->rxq.queue_id;
 -
 -		/* make sure selected "q_idx" is in valid range of queues
 -		 * for selected "vsi"
 -		 */
 -		if (q_idx >= vsi->alloc_txq || q_idx >= vsi->alloc_rxq) {
 -			v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -			goto error_param;
 -		}
 -
 -		/* copy Tx queue info from VF into VSI */
 -		if (qpi->txq.ring_len > 0) {
 -			vsi->tx_rings[i]->dma = qpi->txq.dma_ring_addr;
 -			vsi->tx_rings[i]->count = qpi->txq.ring_len;
 -			if (ice_vsi_cfg_single_txq(vsi, vsi->tx_rings, q_idx)) {
 -				v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -				goto error_param;
 -			}
 -		}
 -
 -		/* copy Rx queue info from VF into VSI */
 -		if (qpi->rxq.ring_len > 0) {
 -			u16 max_frame_size = ice_vc_get_max_frame_size(vf);
 -
 -			vsi->rx_rings[i]->dma = qpi->rxq.dma_ring_addr;
 -			vsi->rx_rings[i]->count = qpi->rxq.ring_len;
 -
 -			if (qpi->rxq.databuffer_size != 0 &&
 -			    (qpi->rxq.databuffer_size > ((16 * 1024) - 128) ||
 -			     qpi->rxq.databuffer_size < 1024)) {
 -				v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -				goto error_param;
 -			}
 -			vsi->rx_buf_len = qpi->rxq.databuffer_size;
 -			vsi->rx_rings[i]->rx_buf_len = vsi->rx_buf_len;
 -			if (qpi->rxq.max_pkt_size > max_frame_size ||
 -			    qpi->rxq.max_pkt_size < 64) {
 -				v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -				goto error_param;
 -			}
 -
 -			vsi->max_frame = qpi->rxq.max_pkt_size;
 -			/* add space for the port VLAN since the VF driver is not
 -			 * expected to account for it in the MTU calculation
 -			 */
 -			if (ice_vf_is_port_vlan_ena(vf))
 -				vsi->max_frame += VLAN_HLEN;
 -
 -			if (ice_vsi_cfg_single_rxq(vsi, q_idx)) {
 -				v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -				goto error_param;
 -			}
 -		}
 -	}
 -
 -error_param:
 -	/* send the response to the VF */
 -	return ice_vc_send_msg_to_vf(vf, VIRTCHNL_OP_CONFIG_VSI_QUEUES, v_ret,
 -				     NULL, 0);
 -}
 -
 -/**
 - * ice_is_vf_trusted
 - * @vf: pointer to the VF info
 - */
 -static bool ice_is_vf_trusted(struct ice_vf *vf)
 -{
 -	return test_bit(ICE_VIRTCHNL_VF_CAP_PRIVILEGE, &vf->vf_caps);
 -}
 -
 -/**
 - * ice_can_vf_change_mac
 - * @vf: pointer to the VF info
 - *
 - * Return true if the VF is allowed to change its MAC filters, false otherwise
 - */
 -static bool ice_can_vf_change_mac(struct ice_vf *vf)
 -{
 -	/* If the VF MAC address has been set administratively (via the
 -	 * ndo_set_vf_mac command), then deny permission to the VF to
 -	 * add/delete unicast MAC addresses, unless the VF is trusted
 -	 */
 -	if (vf->pf_set_mac && !ice_is_vf_trusted(vf))
 -		return false;
 -
 -	return true;
 -}
 -
 -/**
 - * ice_vc_ether_addr_type - get type of virtchnl_ether_addr
 - * @vc_ether_addr: used to extract the type
 - */
 -static u8
 -ice_vc_ether_addr_type(struct virtchnl_ether_addr *vc_ether_addr)
 -{
 -	return (vc_ether_addr->type & VIRTCHNL_ETHER_ADDR_TYPE_MASK);
 -}
 -
 -/**
 - * ice_is_vc_addr_legacy - check if the MAC address is from an older VF
 - * @vc_ether_addr: VIRTCHNL structure that contains MAC and type
 - */
 -static bool
 -ice_is_vc_addr_legacy(struct virtchnl_ether_addr *vc_ether_addr)
 -{
 -	u8 type = ice_vc_ether_addr_type(vc_ether_addr);
 -
 -	return (type == VIRTCHNL_ETHER_ADDR_LEGACY);
 -}
 -
 -/**
 - * ice_is_vc_addr_primary - check if the MAC address is the VF's primary MAC
 - * @vc_ether_addr: VIRTCHNL structure that contains MAC and type
 - *
 - * This function should only be called when the MAC address in
 - * virtchnl_ether_addr is a valid unicast MAC
 - */
 -static bool
 -ice_is_vc_addr_primary(struct virtchnl_ether_addr __maybe_unused *vc_ether_addr)
 -{
 -	u8 type = ice_vc_ether_addr_type(vc_ether_addr);
 -
 -	return (type == VIRTCHNL_ETHER_ADDR_PRIMARY);
 -}
 -
 -/**
 - * ice_vfhw_mac_add - update the VF's cached hardware MAC if allowed
 - * @vf: VF to update
 - * @vc_ether_addr: structure from VIRTCHNL with MAC to add
 - */
 -static void
 -ice_vfhw_mac_add(struct ice_vf *vf, struct virtchnl_ether_addr *vc_ether_addr)
 -{
 -	u8 *mac_addr = vc_ether_addr->addr;
 -
 -	if (!is_valid_ether_addr(mac_addr))
 -		return;
 -
 -	/* only allow legacy VF drivers to set the device and hardware MAC if it
 -	 * is zero and allow new VF drivers to set the hardware MAC if the type
 -	 * was correctly specified over VIRTCHNL
 -	 */
 -	if ((ice_is_vc_addr_legacy(vc_ether_addr) &&
 -	     is_zero_ether_addr(vf->hw_lan_addr.addr)) ||
 -	    ice_is_vc_addr_primary(vc_ether_addr)) {
 -		ether_addr_copy(vf->dev_lan_addr.addr, mac_addr);
 -		ether_addr_copy(vf->hw_lan_addr.addr, mac_addr);
 -	}
 -
 -	/* hardware and device MACs are already set, but its possible that the
 -	 * VF driver sent the VIRTCHNL_OP_ADD_ETH_ADDR message before the
 -	 * VIRTCHNL_OP_DEL_ETH_ADDR when trying to update its MAC, so save it
 -	 * away for the legacy VF driver case as it will be updated in the
 -	 * delete flow for this case
 -	 */
 -	if (ice_is_vc_addr_legacy(vc_ether_addr)) {
 -		ether_addr_copy(vf->legacy_last_added_umac.addr,
 -				mac_addr);
 -		vf->legacy_last_added_umac.time_modified = jiffies;
 -	}
 -}
 -
 -/**
 - * ice_vc_add_mac_addr - attempt to add the MAC address passed in
 - * @vf: pointer to the VF info
 - * @vsi: pointer to the VF's VSI
 - * @vc_ether_addr: VIRTCHNL MAC address structure used to add MAC
 - */
 -static int
 -ice_vc_add_mac_addr(struct ice_vf *vf, struct ice_vsi *vsi,
 -		    struct virtchnl_ether_addr *vc_ether_addr)
 -{
 -	struct device *dev = ice_pf_to_dev(vf->pf);
 -	u8 *mac_addr = vc_ether_addr->addr;
 -	int ret;
 -
 -	/* device MAC already added */
 -	if (ether_addr_equal(mac_addr, vf->dev_lan_addr.addr))
 -		return 0;
 -
 -	if (is_unicast_ether_addr(mac_addr) && !ice_can_vf_change_mac(vf)) {
 -		dev_err(dev, "VF attempting to override administratively set MAC address, bring down and up the VF interface to resume normal operation\n");
 -		return -EPERM;
 -	}
 -
 -	ret = ice_fltr_add_mac(vsi, mac_addr, ICE_FWD_TO_VSI);
 -	if (ret == -EEXIST) {
 -		dev_dbg(dev, "MAC %pM already exists for VF %d\n", mac_addr,
 -			vf->vf_id);
 -		/* don't return since we might need to update
 -		 * the primary MAC in ice_vfhw_mac_add() below
 -		 */
 -	} else if (ret) {
 -		dev_err(dev, "Failed to add MAC %pM for VF %d\n, error %d\n",
 -			mac_addr, vf->vf_id, ret);
 -		return ret;
 -	} else {
 -		vf->num_mac++;
 -	}
 -
 -	ice_vfhw_mac_add(vf, vc_ether_addr);
 -
 -	return ret;
 -}
 -
 -/**
 - * ice_is_legacy_umac_expired - check if last added legacy unicast MAC expired
 - * @last_added_umac: structure used to check expiration
 - */
 -static bool ice_is_legacy_umac_expired(struct ice_time_mac *last_added_umac)
 -{
 -#define ICE_LEGACY_VF_MAC_CHANGE_EXPIRE_TIME	msecs_to_jiffies(3000)
 -	return time_is_before_jiffies(last_added_umac->time_modified +
 -				      ICE_LEGACY_VF_MAC_CHANGE_EXPIRE_TIME);
 -}
 -
 -/**
 - * ice_update_legacy_cached_mac - update cached hardware MAC for legacy VF
 - * @vf: VF to update
 - * @vc_ether_addr: structure from VIRTCHNL with MAC to check
 - *
 - * only update cached hardware MAC for legacy VF drivers on delete
 - * because we cannot guarantee order/type of MAC from the VF driver
 - */
 -static void
 -ice_update_legacy_cached_mac(struct ice_vf *vf,
 -			     struct virtchnl_ether_addr *vc_ether_addr)
 -{
 -	if (!ice_is_vc_addr_legacy(vc_ether_addr) ||
 -	    ice_is_legacy_umac_expired(&vf->legacy_last_added_umac))
 -		return;
 -
 -	ether_addr_copy(vf->dev_lan_addr.addr, vf->legacy_last_added_umac.addr);
 -	ether_addr_copy(vf->hw_lan_addr.addr, vf->legacy_last_added_umac.addr);
 -}
 -
 -/**
 - * ice_vfhw_mac_del - update the VF's cached hardware MAC if allowed
 - * @vf: VF to update
 - * @vc_ether_addr: structure from VIRTCHNL with MAC to delete
 - */
 -static void
 -ice_vfhw_mac_del(struct ice_vf *vf, struct virtchnl_ether_addr *vc_ether_addr)
 -{
 -	u8 *mac_addr = vc_ether_addr->addr;
 -
 -	if (!is_valid_ether_addr(mac_addr) ||
 -	    !ether_addr_equal(vf->dev_lan_addr.addr, mac_addr))
 -		return;
 -
 -	/* allow the device MAC to be repopulated in the add flow and don't
 -	 * clear the hardware MAC (i.e. hw_lan_addr.addr) here as that is meant
 -	 * to be persistent on VM reboot and across driver unload/load, which
 -	 * won't work if we clear the hardware MAC here
 -	 */
 -	eth_zero_addr(vf->dev_lan_addr.addr);
 -
 -	ice_update_legacy_cached_mac(vf, vc_ether_addr);
 -}
 -
 -/**
 - * ice_vc_del_mac_addr - attempt to delete the MAC address passed in
 - * @vf: pointer to the VF info
 - * @vsi: pointer to the VF's VSI
 - * @vc_ether_addr: VIRTCHNL MAC address structure used to delete MAC
 - */
 -static int
 -ice_vc_del_mac_addr(struct ice_vf *vf, struct ice_vsi *vsi,
 -		    struct virtchnl_ether_addr *vc_ether_addr)
 -{
 -	struct device *dev = ice_pf_to_dev(vf->pf);
 -	u8 *mac_addr = vc_ether_addr->addr;
 -	int status;
 -
 -	if (!ice_can_vf_change_mac(vf) &&
 -	    ether_addr_equal(vf->dev_lan_addr.addr, mac_addr))
 -		return 0;
 -
 -	status = ice_fltr_remove_mac(vsi, mac_addr, ICE_FWD_TO_VSI);
 -	if (status == -ENOENT) {
 -		dev_err(dev, "MAC %pM does not exist for VF %d\n", mac_addr,
 -			vf->vf_id);
 -		return -ENOENT;
 -	} else if (status) {
 -		dev_err(dev, "Failed to delete MAC %pM for VF %d, error %d\n",
 -			mac_addr, vf->vf_id, status);
 -		return -EIO;
 -	}
 -
 -	ice_vfhw_mac_del(vf, vc_ether_addr);
 -
 -	vf->num_mac--;
 -
 -	return 0;
 -}
 -
 -/**
 - * ice_vc_handle_mac_addr_msg
 - * @vf: pointer to the VF info
 - * @msg: pointer to the msg buffer
 - * @set: true if MAC filters are being set, false otherwise
 - *
 - * add guest MAC address filter
 - */
 -static int
 -ice_vc_handle_mac_addr_msg(struct ice_vf *vf, u8 *msg, bool set)
 -{
 -	int (*ice_vc_cfg_mac)
 -		(struct ice_vf *vf, struct ice_vsi *vsi,
 -		 struct virtchnl_ether_addr *virtchnl_ether_addr);
 -	enum virtchnl_status_code v_ret = VIRTCHNL_STATUS_SUCCESS;
 -	struct virtchnl_ether_addr_list *al =
 -	    (struct virtchnl_ether_addr_list *)msg;
 -	struct ice_pf *pf = vf->pf;
 -	enum virtchnl_ops vc_op;
 -	struct ice_vsi *vsi;
 -	int i;
 -
 -	if (set) {
 -		vc_op = VIRTCHNL_OP_ADD_ETH_ADDR;
 -		ice_vc_cfg_mac = ice_vc_add_mac_addr;
 -	} else {
 -		vc_op = VIRTCHNL_OP_DEL_ETH_ADDR;
 -		ice_vc_cfg_mac = ice_vc_del_mac_addr;
 -	}
 -
 -	if (!test_bit(ICE_VF_STATE_ACTIVE, vf->vf_states) ||
 -	    !ice_vc_isvalid_vsi_id(vf, al->vsi_id)) {
 -		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -		goto handle_mac_exit;
 -	}
 -
 -	/* If this VF is not privileged, then we can't add more than a
 -	 * limited number of addresses. Check to make sure that the
 -	 * additions do not push us over the limit.
 -	 */
 -	if (set && !ice_is_vf_trusted(vf) &&
 -	    (vf->num_mac + al->num_elements) > ICE_MAX_MACADDR_PER_VF) {
 -		dev_err(ice_pf_to_dev(pf), "Can't add more MAC addresses, because VF-%d is not trusted, switch the VF to trusted mode in order to add more functionalities\n",
 -			vf->vf_id);
 -		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -		goto handle_mac_exit;
 -	}
 -
 -	vsi = ice_get_vf_vsi(vf);
 -	if (!vsi) {
 -		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -		goto handle_mac_exit;
 -	}
 -
 -	for (i = 0; i < al->num_elements; i++) {
 -		u8 *mac_addr = al->list[i].addr;
 -		int result;
 -
 -		if (is_broadcast_ether_addr(mac_addr) ||
 -		    is_zero_ether_addr(mac_addr))
 -			continue;
 -
 -		result = ice_vc_cfg_mac(vf, vsi, &al->list[i]);
 -		if (result == -EEXIST || result == -ENOENT) {
 -			continue;
 -		} else if (result) {
 -			v_ret = VIRTCHNL_STATUS_ERR_ADMIN_QUEUE_ERROR;
 -			goto handle_mac_exit;
 -		}
 -	}
 -
 -handle_mac_exit:
 -	/* send the response to the VF */
 -	return ice_vc_send_msg_to_vf(vf, vc_op, v_ret, NULL, 0);
 -}
 -
 -/**
 - * ice_vc_add_mac_addr_msg
 - * @vf: pointer to the VF info
 - * @msg: pointer to the msg buffer
 - *
 - * add guest MAC address filter
 - */
 -static int ice_vc_add_mac_addr_msg(struct ice_vf *vf, u8 *msg)
 -{
 -	return ice_vc_handle_mac_addr_msg(vf, msg, true);
 -}
 -
 -/**
 - * ice_vc_del_mac_addr_msg
 - * @vf: pointer to the VF info
 - * @msg: pointer to the msg buffer
 - *
 - * remove guest MAC address filter
 - */
 -static int ice_vc_del_mac_addr_msg(struct ice_vf *vf, u8 *msg)
 -{
 -	return ice_vc_handle_mac_addr_msg(vf, msg, false);
 -}
 -
 -/**
 - * ice_vc_request_qs_msg
 - * @vf: pointer to the VF info
 - * @msg: pointer to the msg buffer
 - *
 - * VFs get a default number of queues but can use this message to request a
 - * different number. If the request is successful, PF will reset the VF and
 - * return 0. If unsuccessful, PF will send message informing VF of number of
 - * available queue pairs via virtchnl message response to VF.
 - */
 -static int ice_vc_request_qs_msg(struct ice_vf *vf, u8 *msg)
 -{
 -	enum virtchnl_status_code v_ret = VIRTCHNL_STATUS_SUCCESS;
 -	struct virtchnl_vf_res_request *vfres =
 -		(struct virtchnl_vf_res_request *)msg;
 -	u16 req_queues = vfres->num_queue_pairs;
 -	struct ice_pf *pf = vf->pf;
 -	u16 max_allowed_vf_queues;
 -	u16 tx_rx_queue_left;
 -	struct device *dev;
 -	u16 cur_queues;
 -
 -	dev = ice_pf_to_dev(pf);
 -	if (!test_bit(ICE_VF_STATE_ACTIVE, vf->vf_states)) {
 -		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -		goto error_param;
 -	}
 -
 -	cur_queues = vf->num_vf_qs;
 -	tx_rx_queue_left = min_t(u16, ice_get_avail_txq_count(pf),
 -				 ice_get_avail_rxq_count(pf));
 -	max_allowed_vf_queues = tx_rx_queue_left + cur_queues;
 -	if (!req_queues) {
 -		dev_err(dev, "VF %d tried to request 0 queues. Ignoring.\n",
 -			vf->vf_id);
 -	} else if (req_queues > ICE_MAX_RSS_QS_PER_VF) {
 -		dev_err(dev, "VF %d tried to request more than %d queues.\n",
 -			vf->vf_id, ICE_MAX_RSS_QS_PER_VF);
 -		vfres->num_queue_pairs = ICE_MAX_RSS_QS_PER_VF;
 -	} else if (req_queues > cur_queues &&
 -		   req_queues - cur_queues > tx_rx_queue_left) {
 -		dev_warn(dev, "VF %d requested %u more queues, but only %u left.\n",
 -			 vf->vf_id, req_queues - cur_queues, tx_rx_queue_left);
 -		vfres->num_queue_pairs = min_t(u16, max_allowed_vf_queues,
 -					       ICE_MAX_RSS_QS_PER_VF);
 -	} else {
 -		/* request is successful, then reset VF */
 -		vf->num_req_qs = req_queues;
 -		ice_vc_reset_vf(vf);
 -		dev_info(dev, "VF %d granted request of %u queues.\n",
 -			 vf->vf_id, req_queues);
 -		return 0;
 -	}
 -
 -error_param:
 -	/* send the response to the VF */
 -	return ice_vc_send_msg_to_vf(vf, VIRTCHNL_OP_REQUEST_QUEUES,
 -				     v_ret, (u8 *)vfres, sizeof(*vfres));
 -}
 -
 -/**
 - * ice_is_supported_port_vlan_proto - make sure the vlan_proto is supported
 - * @hw: hardware structure used to check the VLAN mode
 - * @vlan_proto: VLAN TPID being checked
 - *
 - * If the device is configured in Double VLAN Mode (DVM), then both ETH_P_8021Q
 - * and ETH_P_8021AD are supported. If the device is configured in Single VLAN
 - * Mode (SVM), then only ETH_P_8021Q is supported.
 - */
 -static bool
 -ice_is_supported_port_vlan_proto(struct ice_hw *hw, u16 vlan_proto)
 -{
 -	bool is_supported = false;
 -
 -	switch (vlan_proto) {
 -	case ETH_P_8021Q:
 -		is_supported = true;
 -		break;
 -	case ETH_P_8021AD:
 -		if (ice_is_dvm_ena(hw))
 -			is_supported = true;
 -		break;
 -	}
 -
 -	return is_supported;
 -}
 -
 -/**
 - * ice_set_vf_port_vlan
 - * @netdev: network interface device structure
 - * @vf_id: VF identifier
 - * @vlan_id: VLAN ID being set
 - * @qos: priority setting
 - * @vlan_proto: VLAN protocol
 - *
 - * program VF Port VLAN ID and/or QoS
 - */
 -int
 -ice_set_vf_port_vlan(struct net_device *netdev, int vf_id, u16 vlan_id, u8 qos,
 -		     __be16 vlan_proto)
 -{
 -	struct ice_pf *pf = ice_netdev_to_pf(netdev);
 -	u16 local_vlan_proto = ntohs(vlan_proto);
 -	struct device *dev;
 -	struct ice_vf *vf;
 -	int ret;
 -
 -	dev = ice_pf_to_dev(pf);
 -
 -	if (vlan_id >= VLAN_N_VID || qos > 7) {
 -		dev_err(dev, "Invalid Port VLAN parameters for VF %d, ID %d, QoS %d\n",
 -			vf_id, vlan_id, qos);
 -		return -EINVAL;
 -	}
 -
 -	if (!ice_is_supported_port_vlan_proto(&pf->hw, local_vlan_proto)) {
 -		dev_err(dev, "VF VLAN protocol 0x%04x is not supported\n",
 -			local_vlan_proto);
 -		return -EPROTONOSUPPORT;
 -	}
 -
 -	vf = ice_get_vf_by_id(pf, vf_id);
 -	if (!vf)
 -		return -EINVAL;
 -
 -	ret = ice_check_vf_ready_for_cfg(vf);
 -	if (ret)
 -		goto out_put_vf;
 -
 -	if (ice_vf_get_port_vlan_prio(vf) == qos &&
 -	    ice_vf_get_port_vlan_tpid(vf) == local_vlan_proto &&
 -	    ice_vf_get_port_vlan_id(vf) == vlan_id) {
 -		/* duplicate request, so just return success */
 -		dev_dbg(dev, "Duplicate port VLAN %u, QoS %u, TPID 0x%04x request\n",
 -			vlan_id, qos, local_vlan_proto);
 -		ret = 0;
 -		goto out_put_vf;
 -	}
 -
 -	mutex_lock(&vf->cfg_lock);
 -
 -	vf->port_vlan_info = ICE_VLAN(local_vlan_proto, vlan_id, qos);
 -	if (ice_vf_is_port_vlan_ena(vf))
 -		dev_info(dev, "Setting VLAN %u, QoS %u, TPID 0x%04x on VF %d\n",
 -			 vlan_id, qos, local_vlan_proto, vf_id);
 -	else
 -		dev_info(dev, "Clearing port VLAN on VF %d\n", vf_id);
 -
 -	ice_vc_reset_vf(vf);
 -	mutex_unlock(&vf->cfg_lock);
 -
 -out_put_vf:
 -	ice_put_vf(vf);
 -	return ret;
 -}
 -
 -/**
 - * ice_vf_vlan_offload_ena - determine if capabilities support VLAN offloads
 - * @caps: VF driver negotiated capabilities
 - *
 - * Return true if VIRTCHNL_VF_OFFLOAD_VLAN capability is set, else return false
 - */
 -static bool ice_vf_vlan_offload_ena(u32 caps)
 -{
 -	return !!(caps & VIRTCHNL_VF_OFFLOAD_VLAN);
 -}
 -
 -/**
 - * ice_is_vlan_promisc_allowed - check if VLAN promiscuous config is allowed
 - * @vf: VF used to determine if VLAN promiscuous config is allowed
 - */
 -static bool ice_is_vlan_promisc_allowed(struct ice_vf *vf)
 -{
 -	if ((test_bit(ICE_VF_STATE_UC_PROMISC, vf->vf_states) ||
 -	     test_bit(ICE_VF_STATE_MC_PROMISC, vf->vf_states)) &&
 -	    test_bit(ICE_FLAG_VF_TRUE_PROMISC_ENA, vf->pf->flags))
 -		return true;
 -
 -	return false;
 -}
 -
 -/**
 - * ice_vf_ena_vlan_promisc - Enable Tx/Rx VLAN promiscuous for the VLAN
 - * @vsi: VF's VSI used to enable VLAN promiscuous mode
 - * @vlan: VLAN used to enable VLAN promiscuous
 - *
 - * This function should only be called if VLAN promiscuous mode is allowed,
 - * which can be determined via ice_is_vlan_promisc_allowed().
 - */
 -static int ice_vf_ena_vlan_promisc(struct ice_vsi *vsi, struct ice_vlan *vlan)
 -{
 -	u8 promisc_m = ICE_PROMISC_VLAN_TX | ICE_PROMISC_VLAN_RX;
 -	int status;
 -
 -	status = ice_fltr_set_vsi_promisc(&vsi->back->hw, vsi->idx, promisc_m,
 -					  vlan->vid);
 -	if (status && status != -EEXIST)
 -		return status;
 -
 -	return 0;
 -}
 -
 -/**
 - * ice_vf_dis_vlan_promisc - Disable Tx/Rx VLAN promiscuous for the VLAN
 - * @vsi: VF's VSI used to disable VLAN promiscuous mode for
 - * @vlan: VLAN used to disable VLAN promiscuous
 - *
 - * This function should only be called if VLAN promiscuous mode is allowed,
 - * which can be determined via ice_is_vlan_promisc_allowed().
 - */
 -static int ice_vf_dis_vlan_promisc(struct ice_vsi *vsi, struct ice_vlan *vlan)
 -{
 -	u8 promisc_m = ICE_PROMISC_VLAN_TX | ICE_PROMISC_VLAN_RX;
 -	int status;
 -
 -	status = ice_fltr_clear_vsi_promisc(&vsi->back->hw, vsi->idx, promisc_m,
 -					    vlan->vid);
 -	if (status && status != -ENOENT)
 -		return status;
 -
 -	return 0;
 -}
 -
 -/**
 - * ice_vf_has_max_vlans - check if VF already has the max allowed VLAN filters
 - * @vf: VF to check against
 - * @vsi: VF's VSI
 - *
 - * If the VF is trusted then the VF is allowed to add as many VLANs as it
 - * wants to, so return false.
 - *
 - * When the VF is untrusted compare the number of non-zero VLANs + 1 to the max
 - * allowed VLANs for an untrusted VF. Return the result of this comparison.
 - */
 -static bool ice_vf_has_max_vlans(struct ice_vf *vf, struct ice_vsi *vsi)
 -{
 -	if (ice_is_vf_trusted(vf))
 -		return false;
 -
 -#define ICE_VF_ADDED_VLAN_ZERO_FLTRS	1
 -	return ((ice_vsi_num_non_zero_vlans(vsi) +
 -		ICE_VF_ADDED_VLAN_ZERO_FLTRS) >= ICE_MAX_VLAN_PER_VF);
 -}
 -
 -/**
 - * ice_vc_process_vlan_msg
 - * @vf: pointer to the VF info
 - * @msg: pointer to the msg buffer
 - * @add_v: Add VLAN if true, otherwise delete VLAN
 - *
 - * Process virtchnl op to add or remove programmed guest VLAN ID
 - */
 -static int ice_vc_process_vlan_msg(struct ice_vf *vf, u8 *msg, bool add_v)
 -{
 -	enum virtchnl_status_code v_ret = VIRTCHNL_STATUS_SUCCESS;
 -	struct virtchnl_vlan_filter_list *vfl =
 -	    (struct virtchnl_vlan_filter_list *)msg;
 -	struct ice_pf *pf = vf->pf;
 -	bool vlan_promisc = false;
 -	struct ice_vsi *vsi;
 -	struct device *dev;
 -	int status = 0;
 -	int i;
 -
 -	dev = ice_pf_to_dev(pf);
 -	if (!test_bit(ICE_VF_STATE_ACTIVE, vf->vf_states)) {
 -		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -		goto error_param;
 -	}
 -
 -	if (!ice_vf_vlan_offload_ena(vf->driver_caps)) {
 -		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -		goto error_param;
 -	}
 -
 -	if (!ice_vc_isvalid_vsi_id(vf, vfl->vsi_id)) {
 -		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -		goto error_param;
 -	}
 -
 -	for (i = 0; i < vfl->num_elements; i++) {
 -		if (vfl->vlan_id[i] >= VLAN_N_VID) {
 -			v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -			dev_err(dev, "invalid VF VLAN id %d\n",
 -				vfl->vlan_id[i]);
 -			goto error_param;
 -		}
 -	}
 -
 -	vsi = ice_get_vf_vsi(vf);
 -	if (!vsi) {
 -		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -		goto error_param;
 -	}
 -
 -	if (add_v && ice_vf_has_max_vlans(vf, vsi)) {
 -		dev_info(dev, "VF-%d is not trusted, switch the VF to trusted mode, in order to add more VLAN addresses\n",
 -			 vf->vf_id);
 -		/* There is no need to let VF know about being not trusted,
 -		 * so we can just return success message here
 -		 */
 -		goto error_param;
 -	}
 -
 -	/* in DVM a VF can add/delete inner VLAN filters when
 -	 * VIRTCHNL_VF_OFFLOAD_VLAN is negotiated, so only reject in SVM
 -	 */
 -	if (ice_vf_is_port_vlan_ena(vf) && !ice_is_dvm_ena(&pf->hw)) {
 -		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -		goto error_param;
 -	}
 -
 -	/* in DVM VLAN promiscuous is based on the outer VLAN, which would be
 -	 * the port VLAN if VIRTCHNL_VF_OFFLOAD_VLAN was negotiated, so only
 -	 * allow vlan_promisc = true in SVM and if no port VLAN is configured
 -	 */
 -	vlan_promisc = ice_is_vlan_promisc_allowed(vf) &&
 -		!ice_is_dvm_ena(&pf->hw) &&
 -		!ice_vf_is_port_vlan_ena(vf);
 -
 -	if (add_v) {
 -		for (i = 0; i < vfl->num_elements; i++) {
 -			u16 vid = vfl->vlan_id[i];
 -			struct ice_vlan vlan;
 -
 -			if (ice_vf_has_max_vlans(vf, vsi)) {
 -				dev_info(dev, "VF-%d is not trusted, switch the VF to trusted mode, in order to add more VLAN addresses\n",
 -					 vf->vf_id);
 -				/* There is no need to let VF know about being
 -				 * not trusted, so we can just return success
 -				 * message here as well.
 -				 */
 -				goto error_param;
 -			}
 -
 -			/* we add VLAN 0 by default for each VF so we can enable
 -			 * Tx VLAN anti-spoof without triggering MDD events so
 -			 * we don't need to add it again here
 -			 */
 -			if (!vid)
 -				continue;
 -
 -			vlan = ICE_VLAN(ETH_P_8021Q, vid, 0);
 -			status = vsi->inner_vlan_ops.add_vlan(vsi, &vlan);
 -			if (status) {
 -				v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -				goto error_param;
 -			}
 -
 -			/* Enable VLAN filtering on first non-zero VLAN */
 -			if (!vlan_promisc && vid && !ice_is_dvm_ena(&pf->hw)) {
 -				if (vsi->inner_vlan_ops.ena_rx_filtering(vsi)) {
 -					v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -					dev_err(dev, "Enable VLAN pruning on VLAN ID: %d failed error-%d\n",
 -						vid, status);
 -					goto error_param;
 -				}
 -			} else if (vlan_promisc) {
 -				status = ice_vf_ena_vlan_promisc(vsi, &vlan);
 -				if (status) {
 -					v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -					dev_err(dev, "Enable Unicast/multicast promiscuous mode on VLAN ID:%d failed error-%d\n",
 -						vid, status);
 -				}
 -			}
 -		}
 -	} else {
 -		/* In case of non_trusted VF, number of VLAN elements passed
 -		 * to PF for removal might be greater than number of VLANs
 -		 * filter programmed for that VF - So, use actual number of
 -		 * VLANS added earlier with add VLAN opcode. In order to avoid
 -		 * removing VLAN that doesn't exist, which result to sending
 -		 * erroneous failed message back to the VF
 -		 */
 -		int num_vf_vlan;
 -
 -		num_vf_vlan = vsi->num_vlan;
 -		for (i = 0; i < vfl->num_elements && i < num_vf_vlan; i++) {
 -			u16 vid = vfl->vlan_id[i];
 -			struct ice_vlan vlan;
 -
 -			/* we add VLAN 0 by default for each VF so we can enable
 -			 * Tx VLAN anti-spoof without triggering MDD events so
 -			 * we don't want a VIRTCHNL request to remove it
 -			 */
 -			if (!vid)
 -				continue;
 -
 -			vlan = ICE_VLAN(ETH_P_8021Q, vid, 0);
 -			status = vsi->inner_vlan_ops.del_vlan(vsi, &vlan);
 -			if (status) {
 -				v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -				goto error_param;
 -			}
 -
 -			/* Disable VLAN filtering when only VLAN 0 is left */
 -			if (!ice_vsi_has_non_zero_vlans(vsi))
 -				vsi->inner_vlan_ops.dis_rx_filtering(vsi);
 -
 -			if (vlan_promisc)
 -				ice_vf_dis_vlan_promisc(vsi, &vlan);
 -		}
 -	}
 -
 -error_param:
 -	/* send the response to the VF */
 -	if (add_v)
 -		return ice_vc_send_msg_to_vf(vf, VIRTCHNL_OP_ADD_VLAN, v_ret,
 -					     NULL, 0);
 -	else
 -		return ice_vc_send_msg_to_vf(vf, VIRTCHNL_OP_DEL_VLAN, v_ret,
 -					     NULL, 0);
 -}
 -
 -/**
 - * ice_vc_add_vlan_msg
 - * @vf: pointer to the VF info
 - * @msg: pointer to the msg buffer
 - *
 - * Add and program guest VLAN ID
 - */
 -static int ice_vc_add_vlan_msg(struct ice_vf *vf, u8 *msg)
 -{
 -	return ice_vc_process_vlan_msg(vf, msg, true);
 -}
 -
 -/**
 - * ice_vc_remove_vlan_msg
 - * @vf: pointer to the VF info
 - * @msg: pointer to the msg buffer
 - *
 - * remove programmed guest VLAN ID
 - */
 -static int ice_vc_remove_vlan_msg(struct ice_vf *vf, u8 *msg)
 -{
 -	return ice_vc_process_vlan_msg(vf, msg, false);
 -}
 -
 -/**
 - * ice_vc_ena_vlan_stripping
 - * @vf: pointer to the VF info
 - *
 - * Enable VLAN header stripping for a given VF
 - */
 -static int ice_vc_ena_vlan_stripping(struct ice_vf *vf)
 -{
 -	enum virtchnl_status_code v_ret = VIRTCHNL_STATUS_SUCCESS;
 -	struct ice_vsi *vsi;
 -
 -	if (!test_bit(ICE_VF_STATE_ACTIVE, vf->vf_states)) {
 -		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -		goto error_param;
 -	}
 -
 -	if (!ice_vf_vlan_offload_ena(vf->driver_caps)) {
 -		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -		goto error_param;
 -	}
 -
 -	vsi = ice_get_vf_vsi(vf);
 -	if (vsi->inner_vlan_ops.ena_stripping(vsi, ETH_P_8021Q))
 -		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -
 -error_param:
 -	return ice_vc_send_msg_to_vf(vf, VIRTCHNL_OP_ENABLE_VLAN_STRIPPING,
 -				     v_ret, NULL, 0);
 -}
 -
 -/**
 - * ice_vc_dis_vlan_stripping
 - * @vf: pointer to the VF info
 - *
 - * Disable VLAN header stripping for a given VF
 - */
 -static int ice_vc_dis_vlan_stripping(struct ice_vf *vf)
 -{
 -	enum virtchnl_status_code v_ret = VIRTCHNL_STATUS_SUCCESS;
 -	struct ice_vsi *vsi;
 -
 -	if (!test_bit(ICE_VF_STATE_ACTIVE, vf->vf_states)) {
 -		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -		goto error_param;
 -	}
 -
 -	if (!ice_vf_vlan_offload_ena(vf->driver_caps)) {
 -		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -		goto error_param;
 -	}
 -
 -	vsi = ice_get_vf_vsi(vf);
 -	if (!vsi) {
 -		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -		goto error_param;
 -	}
 -
 -	if (vsi->inner_vlan_ops.dis_stripping(vsi))
 -		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -
 -error_param:
 -	return ice_vc_send_msg_to_vf(vf, VIRTCHNL_OP_DISABLE_VLAN_STRIPPING,
 -				     v_ret, NULL, 0);
 -}
 -
 -/**
 - * ice_vf_init_vlan_stripping - enable/disable VLAN stripping on initialization
 - * @vf: VF to enable/disable VLAN stripping for on initialization
 - *
 - * Set the default for VLAN stripping based on whether a port VLAN is configured
 - * and the current VLAN mode of the device.
 - */
 -static int ice_vf_init_vlan_stripping(struct ice_vf *vf)
 -{
 -	struct ice_vsi *vsi = ice_get_vf_vsi(vf);
 -
 -	if (!vsi)
 -		return -EINVAL;
 -
 -	/* don't modify stripping if port VLAN is configured in SVM since the
 -	 * port VLAN is based on the inner/single VLAN in SVM
 -	 */
 -	if (ice_vf_is_port_vlan_ena(vf) && !ice_is_dvm_ena(&vsi->back->hw))
 -		return 0;
 -
 -	if (ice_vf_vlan_offload_ena(vf->driver_caps))
 -		return vsi->inner_vlan_ops.ena_stripping(vsi, ETH_P_8021Q);
 -	else
 -		return vsi->inner_vlan_ops.dis_stripping(vsi);
 -}
 -
 -static u16 ice_vc_get_max_vlan_fltrs(struct ice_vf *vf)
 -{
 -	if (vf->trusted)
 -		return VLAN_N_VID;
 -	else
 -		return ICE_MAX_VLAN_PER_VF;
 -}
 -
 -/**
 - * ice_vf_outer_vlan_not_allowed - check outer VLAN can be used when the device is in DVM
 - * @vf: VF that being checked for
 - */
 -static bool ice_vf_outer_vlan_not_allowed(struct ice_vf *vf)
 -{
 -	if (ice_vf_is_port_vlan_ena(vf))
 -		return true;
 -
 -	return false;
 -}
 -
 -/**
 - * ice_vc_set_dvm_caps - set VLAN capabilities when the device is in DVM
 - * @vf: VF that capabilities are being set for
 - * @caps: VLAN capabilities to populate
 - *
 - * Determine VLAN capabilities support based on whether a port VLAN is
 - * configured. If a port VLAN is configured then the VF should use the inner
 - * filtering/offload capabilities since the port VLAN is using the outer VLAN
 - * capabilies.
 - */
 -static void
 -ice_vc_set_dvm_caps(struct ice_vf *vf, struct virtchnl_vlan_caps *caps)
 -{
 -	struct virtchnl_vlan_supported_caps *supported_caps;
 -
 -	if (ice_vf_outer_vlan_not_allowed(vf)) {
 -		/* until support for inner VLAN filtering is added when a port
 -		 * VLAN is configured, only support software offloaded inner
 -		 * VLANs when a port VLAN is confgured in DVM
 -		 */
 -		supported_caps = &caps->filtering.filtering_support;
 -		supported_caps->inner = VIRTCHNL_VLAN_UNSUPPORTED;
 -
 -		supported_caps = &caps->offloads.stripping_support;
 -		supported_caps->inner = VIRTCHNL_VLAN_ETHERTYPE_8100 |
 -					VIRTCHNL_VLAN_TOGGLE |
 -					VIRTCHNL_VLAN_TAG_LOCATION_L2TAG1;
 -		supported_caps->outer = VIRTCHNL_VLAN_UNSUPPORTED;
 -
 -		supported_caps = &caps->offloads.insertion_support;
 -		supported_caps->inner = VIRTCHNL_VLAN_ETHERTYPE_8100 |
 -					VIRTCHNL_VLAN_TOGGLE |
 -					VIRTCHNL_VLAN_TAG_LOCATION_L2TAG1;
 -		supported_caps->outer = VIRTCHNL_VLAN_UNSUPPORTED;
 -
 -		caps->offloads.ethertype_init = VIRTCHNL_VLAN_ETHERTYPE_8100;
 -		caps->offloads.ethertype_match =
 -			VIRTCHNL_ETHERTYPE_STRIPPING_MATCHES_INSERTION;
 -	} else {
 -		supported_caps = &caps->filtering.filtering_support;
 -		supported_caps->inner = VIRTCHNL_VLAN_UNSUPPORTED;
 -		supported_caps->outer = VIRTCHNL_VLAN_ETHERTYPE_8100 |
 -					VIRTCHNL_VLAN_ETHERTYPE_88A8 |
 -					VIRTCHNL_VLAN_ETHERTYPE_9100 |
 -					VIRTCHNL_VLAN_ETHERTYPE_AND;
 -		caps->filtering.ethertype_init = VIRTCHNL_VLAN_ETHERTYPE_8100 |
 -						 VIRTCHNL_VLAN_ETHERTYPE_88A8 |
 -						 VIRTCHNL_VLAN_ETHERTYPE_9100;
 -
 -		supported_caps = &caps->offloads.stripping_support;
 -		supported_caps->inner = VIRTCHNL_VLAN_TOGGLE |
 -					VIRTCHNL_VLAN_ETHERTYPE_8100 |
 -					VIRTCHNL_VLAN_TAG_LOCATION_L2TAG1;
 -		supported_caps->outer = VIRTCHNL_VLAN_TOGGLE |
 -					VIRTCHNL_VLAN_ETHERTYPE_8100 |
 -					VIRTCHNL_VLAN_ETHERTYPE_88A8 |
 -					VIRTCHNL_VLAN_ETHERTYPE_9100 |
 -					VIRTCHNL_VLAN_ETHERTYPE_XOR |
 -					VIRTCHNL_VLAN_TAG_LOCATION_L2TAG2_2;
 -
 -		supported_caps = &caps->offloads.insertion_support;
 -		supported_caps->inner = VIRTCHNL_VLAN_TOGGLE |
 -					VIRTCHNL_VLAN_ETHERTYPE_8100 |
 -					VIRTCHNL_VLAN_TAG_LOCATION_L2TAG1;
 -		supported_caps->outer = VIRTCHNL_VLAN_TOGGLE |
 -					VIRTCHNL_VLAN_ETHERTYPE_8100 |
 -					VIRTCHNL_VLAN_ETHERTYPE_88A8 |
 -					VIRTCHNL_VLAN_ETHERTYPE_9100 |
 -					VIRTCHNL_VLAN_ETHERTYPE_XOR |
 -					VIRTCHNL_VLAN_TAG_LOCATION_L2TAG2;
 -
 -		caps->offloads.ethertype_init = VIRTCHNL_VLAN_ETHERTYPE_8100;
 -
 -		caps->offloads.ethertype_match =
 -			VIRTCHNL_ETHERTYPE_STRIPPING_MATCHES_INSERTION;
 -	}
 -
 -	caps->filtering.max_filters = ice_vc_get_max_vlan_fltrs(vf);
 -}
 -
 -/**
 - * ice_vc_set_svm_caps - set VLAN capabilities when the device is in SVM
 - * @vf: VF that capabilities are being set for
 - * @caps: VLAN capabilities to populate
 - *
 - * Determine VLAN capabilities support based on whether a port VLAN is
 - * configured. If a port VLAN is configured then the VF does not have any VLAN
 - * filtering or offload capabilities since the port VLAN is using the inner VLAN
 - * capabilities in single VLAN mode (SVM). Otherwise allow the VF to use inner
 - * VLAN fitlering and offload capabilities.
 - */
 -static void
 -ice_vc_set_svm_caps(struct ice_vf *vf, struct virtchnl_vlan_caps *caps)
 -{
 -	struct virtchnl_vlan_supported_caps *supported_caps;
 -
 -	if (ice_vf_is_port_vlan_ena(vf)) {
 -		supported_caps = &caps->filtering.filtering_support;
 -		supported_caps->inner = VIRTCHNL_VLAN_UNSUPPORTED;
 -		supported_caps->outer = VIRTCHNL_VLAN_UNSUPPORTED;
 -
 -		supported_caps = &caps->offloads.stripping_support;
 -		supported_caps->inner = VIRTCHNL_VLAN_UNSUPPORTED;
 -		supported_caps->outer = VIRTCHNL_VLAN_UNSUPPORTED;
 -
 -		supported_caps = &caps->offloads.insertion_support;
 -		supported_caps->inner = VIRTCHNL_VLAN_UNSUPPORTED;
 -		supported_caps->outer = VIRTCHNL_VLAN_UNSUPPORTED;
 -
 -		caps->offloads.ethertype_init = VIRTCHNL_VLAN_UNSUPPORTED;
 -		caps->offloads.ethertype_match = VIRTCHNL_VLAN_UNSUPPORTED;
 -		caps->filtering.max_filters = 0;
 -	} else {
 -		supported_caps = &caps->filtering.filtering_support;
 -		supported_caps->inner = VIRTCHNL_VLAN_ETHERTYPE_8100;
 -		supported_caps->outer = VIRTCHNL_VLAN_UNSUPPORTED;
 -		caps->filtering.ethertype_init = VIRTCHNL_VLAN_ETHERTYPE_8100;
 -
 -		supported_caps = &caps->offloads.stripping_support;
 -		supported_caps->inner = VIRTCHNL_VLAN_ETHERTYPE_8100 |
 -					VIRTCHNL_VLAN_TOGGLE |
 -					VIRTCHNL_VLAN_TAG_LOCATION_L2TAG1;
 -		supported_caps->outer = VIRTCHNL_VLAN_UNSUPPORTED;
 -
 -		supported_caps = &caps->offloads.insertion_support;
 -		supported_caps->inner = VIRTCHNL_VLAN_ETHERTYPE_8100 |
 -					VIRTCHNL_VLAN_TOGGLE |
 -					VIRTCHNL_VLAN_TAG_LOCATION_L2TAG1;
 -		supported_caps->outer = VIRTCHNL_VLAN_UNSUPPORTED;
 -
 -		caps->offloads.ethertype_init = VIRTCHNL_VLAN_ETHERTYPE_8100;
 -		caps->offloads.ethertype_match =
 -			VIRTCHNL_ETHERTYPE_STRIPPING_MATCHES_INSERTION;
 -		caps->filtering.max_filters = ice_vc_get_max_vlan_fltrs(vf);
 -	}
 -}
 -
 -/**
 - * ice_vc_get_offload_vlan_v2_caps - determine VF's VLAN capabilities
 - * @vf: VF to determine VLAN capabilities for
 - *
 - * This will only be called if the VF and PF successfully negotiated
 - * VIRTCHNL_VF_OFFLOAD_VLAN_V2.
 - *
 - * Set VLAN capabilities based on the current VLAN mode and whether a port VLAN
 - * is configured or not.
 - */
 -static int ice_vc_get_offload_vlan_v2_caps(struct ice_vf *vf)
 -{
 -	enum virtchnl_status_code v_ret = VIRTCHNL_STATUS_SUCCESS;
 -	struct virtchnl_vlan_caps *caps = NULL;
 -	int err, len = 0;
 -
 -	if (!test_bit(ICE_VF_STATE_ACTIVE, vf->vf_states)) {
 -		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -		goto out;
 -	}
 -
 -	caps = kzalloc(sizeof(*caps), GFP_KERNEL);
 -	if (!caps) {
 -		v_ret = VIRTCHNL_STATUS_ERR_NO_MEMORY;
 -		goto out;
 -	}
 -	len = sizeof(*caps);
 -
 -	if (ice_is_dvm_ena(&vf->pf->hw))
 -		ice_vc_set_dvm_caps(vf, caps);
 -	else
 -		ice_vc_set_svm_caps(vf, caps);
 -
 -	/* store negotiated caps to prevent invalid VF messages */
 -	memcpy(&vf->vlan_v2_caps, caps, sizeof(*caps));
 -
 -out:
 -	err = ice_vc_send_msg_to_vf(vf, VIRTCHNL_OP_GET_OFFLOAD_VLAN_V2_CAPS,
 -				    v_ret, (u8 *)caps, len);
 -	kfree(caps);
 -	return err;
 -}
 -
 -/**
 - * ice_vc_validate_vlan_tpid - validate VLAN TPID
 - * @filtering_caps: negotiated/supported VLAN filtering capabilities
 - * @tpid: VLAN TPID used for validation
 - *
 - * Convert the VLAN TPID to a VIRTCHNL_VLAN_ETHERTYPE_* and then compare against
 - * the negotiated/supported filtering caps to see if the VLAN TPID is valid.
 - */
 -static bool ice_vc_validate_vlan_tpid(u16 filtering_caps, u16 tpid)
 -{
 -	enum virtchnl_vlan_support vlan_ethertype = VIRTCHNL_VLAN_UNSUPPORTED;
 -
 -	switch (tpid) {
 -	case ETH_P_8021Q:
 -		vlan_ethertype = VIRTCHNL_VLAN_ETHERTYPE_8100;
 -		break;
 -	case ETH_P_8021AD:
 -		vlan_ethertype = VIRTCHNL_VLAN_ETHERTYPE_88A8;
 -		break;
 -	case ETH_P_QINQ1:
 -		vlan_ethertype = VIRTCHNL_VLAN_ETHERTYPE_9100;
 -		break;
 -	}
 -
 -	if (!(filtering_caps & vlan_ethertype))
 -		return false;
 -
 -	return true;
 -}
 -
 -/**
 - * ice_vc_is_valid_vlan - validate the virtchnl_vlan
 - * @vc_vlan: virtchnl_vlan to validate
 - *
 - * If the VLAN TCI and VLAN TPID are 0, then this filter is invalid, so return
 - * false. Otherwise return true.
 - */
 -static bool ice_vc_is_valid_vlan(struct virtchnl_vlan *vc_vlan)
 -{
 -	if (!vc_vlan->tci || !vc_vlan->tpid)
 -		return false;
 -
 -	return true;
 -}
 -
 -/**
 - * ice_vc_validate_vlan_filter_list - validate the filter list from the VF
 - * @vfc: negotiated/supported VLAN filtering capabilities
 - * @vfl: VLAN filter list from VF to validate
 - *
 - * Validate all of the filters in the VLAN filter list from the VF. If any of
 - * the checks fail then return false. Otherwise return true.
 - */
 -static bool
 -ice_vc_validate_vlan_filter_list(struct virtchnl_vlan_filtering_caps *vfc,
 -				 struct virtchnl_vlan_filter_list_v2 *vfl)
 -{
 -	u16 i;
 -
 -	if (!vfl->num_elements)
 -		return false;
 -
 -	for (i = 0; i < vfl->num_elements; i++) {
 -		struct virtchnl_vlan_supported_caps *filtering_support =
 -			&vfc->filtering_support;
 -		struct virtchnl_vlan_filter *vlan_fltr = &vfl->filters[i];
 -		struct virtchnl_vlan *outer = &vlan_fltr->outer;
 -		struct virtchnl_vlan *inner = &vlan_fltr->inner;
 -
 -		if ((ice_vc_is_valid_vlan(outer) &&
 -		     filtering_support->outer == VIRTCHNL_VLAN_UNSUPPORTED) ||
 -		    (ice_vc_is_valid_vlan(inner) &&
 -		     filtering_support->inner == VIRTCHNL_VLAN_UNSUPPORTED))
 -			return false;
 -
 -		if ((outer->tci_mask &&
 -		     !(filtering_support->outer & VIRTCHNL_VLAN_FILTER_MASK)) ||
 -		    (inner->tci_mask &&
 -		     !(filtering_support->inner & VIRTCHNL_VLAN_FILTER_MASK)))
 -			return false;
 -
 -		if (((outer->tci & VLAN_PRIO_MASK) &&
 -		     !(filtering_support->outer & VIRTCHNL_VLAN_PRIO)) ||
 -		    ((inner->tci & VLAN_PRIO_MASK) &&
 -		     !(filtering_support->inner & VIRTCHNL_VLAN_PRIO)))
 -			return false;
 -
 -		if ((ice_vc_is_valid_vlan(outer) &&
 -		     !ice_vc_validate_vlan_tpid(filtering_support->outer, outer->tpid)) ||
 -		    (ice_vc_is_valid_vlan(inner) &&
 -		     !ice_vc_validate_vlan_tpid(filtering_support->inner, inner->tpid)))
 -			return false;
 -	}
 -
 -	return true;
 -}
 -
 -/**
 - * ice_vc_to_vlan - transform from struct virtchnl_vlan to struct ice_vlan
 - * @vc_vlan: struct virtchnl_vlan to transform
 - */
 -static struct ice_vlan ice_vc_to_vlan(struct virtchnl_vlan *vc_vlan)
 -{
 -	struct ice_vlan vlan = { 0 };
 -
 -	vlan.prio = (vc_vlan->tci & VLAN_PRIO_MASK) >> VLAN_PRIO_SHIFT;
 -	vlan.vid = vc_vlan->tci & VLAN_VID_MASK;
 -	vlan.tpid = vc_vlan->tpid;
 -
 -	return vlan;
 -}
 -
 -/**
 - * ice_vc_vlan_action - action to perform on the virthcnl_vlan
 - * @vsi: VF's VSI used to perform the action
 - * @vlan_action: function to perform the action with (i.e. add/del)
 - * @vlan: VLAN filter to perform the action with
 - */
 -static int
 -ice_vc_vlan_action(struct ice_vsi *vsi,
 -		   int (*vlan_action)(struct ice_vsi *, struct ice_vlan *),
 -		   struct ice_vlan *vlan)
 -{
 -	int err;
 -
 -	err = vlan_action(vsi, vlan);
 -	if (err)
 -		return err;
 -
 -	return 0;
 -}
 -
 -/**
 - * ice_vc_del_vlans - delete VLAN(s) from the virtchnl filter list
 - * @vf: VF used to delete the VLAN(s)
 - * @vsi: VF's VSI used to delete the VLAN(s)
 - * @vfl: virthchnl filter list used to delete the filters
 - */
 -static int
 -ice_vc_del_vlans(struct ice_vf *vf, struct ice_vsi *vsi,
 -		 struct virtchnl_vlan_filter_list_v2 *vfl)
 -{
 -	bool vlan_promisc = ice_is_vlan_promisc_allowed(vf);
 -	int err;
 -	u16 i;
 -
 -	for (i = 0; i < vfl->num_elements; i++) {
 -		struct virtchnl_vlan_filter *vlan_fltr = &vfl->filters[i];
 -		struct virtchnl_vlan *vc_vlan;
 -
 -		vc_vlan = &vlan_fltr->outer;
 -		if (ice_vc_is_valid_vlan(vc_vlan)) {
 -			struct ice_vlan vlan = ice_vc_to_vlan(vc_vlan);
 -
 -			err = ice_vc_vlan_action(vsi,
 -						 vsi->outer_vlan_ops.del_vlan,
 -						 &vlan);
 -			if (err)
 -				return err;
 -
 -			if (vlan_promisc)
 -				ice_vf_dis_vlan_promisc(vsi, &vlan);
 -		}
 -
 -		vc_vlan = &vlan_fltr->inner;
 -		if (ice_vc_is_valid_vlan(vc_vlan)) {
 -			struct ice_vlan vlan = ice_vc_to_vlan(vc_vlan);
 -
 -			err = ice_vc_vlan_action(vsi,
 -						 vsi->inner_vlan_ops.del_vlan,
 -						 &vlan);
 -			if (err)
 -				return err;
 -
 -			/* no support for VLAN promiscuous on inner VLAN unless
 -			 * we are in Single VLAN Mode (SVM)
 -			 */
 -			if (!ice_is_dvm_ena(&vsi->back->hw) && vlan_promisc)
 -				ice_vf_dis_vlan_promisc(vsi, &vlan);
 -		}
 -	}
 -
 -	return 0;
 -}
 -
 -/**
 - * ice_vc_remove_vlan_v2_msg - virtchnl handler for VIRTCHNL_OP_DEL_VLAN_V2
 - * @vf: VF the message was received from
 - * @msg: message received from the VF
 - */
 -static int ice_vc_remove_vlan_v2_msg(struct ice_vf *vf, u8 *msg)
 -{
 -	struct virtchnl_vlan_filter_list_v2 *vfl =
 -		(struct virtchnl_vlan_filter_list_v2 *)msg;
 -	enum virtchnl_status_code v_ret = VIRTCHNL_STATUS_SUCCESS;
 -	struct ice_vsi *vsi;
 -
 -	if (!ice_vc_validate_vlan_filter_list(&vf->vlan_v2_caps.filtering,
 -					      vfl)) {
 -		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -		goto out;
 -	}
 -
 -	if (!ice_vc_isvalid_vsi_id(vf, vfl->vport_id)) {
 -		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -		goto out;
 -	}
 -
 -	vsi = ice_get_vf_vsi(vf);
 -	if (!vsi) {
 -		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -		goto out;
 -	}
 -
 -	if (ice_vc_del_vlans(vf, vsi, vfl))
 -		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -
 -out:
 -	return ice_vc_send_msg_to_vf(vf, VIRTCHNL_OP_DEL_VLAN_V2, v_ret, NULL,
 -				     0);
 -}
 -
 -/**
 - * ice_vc_add_vlans - add VLAN(s) from the virtchnl filter list
 - * @vf: VF used to add the VLAN(s)
 - * @vsi: VF's VSI used to add the VLAN(s)
 - * @vfl: virthchnl filter list used to add the filters
 - */
 -static int
 -ice_vc_add_vlans(struct ice_vf *vf, struct ice_vsi *vsi,
 -		 struct virtchnl_vlan_filter_list_v2 *vfl)
 -{
 -	bool vlan_promisc = ice_is_vlan_promisc_allowed(vf);
 -	int err;
 -	u16 i;
 -
 -	for (i = 0; i < vfl->num_elements; i++) {
 -		struct virtchnl_vlan_filter *vlan_fltr = &vfl->filters[i];
 -		struct virtchnl_vlan *vc_vlan;
 -
 -		vc_vlan = &vlan_fltr->outer;
 -		if (ice_vc_is_valid_vlan(vc_vlan)) {
 -			struct ice_vlan vlan = ice_vc_to_vlan(vc_vlan);
 -
 -			err = ice_vc_vlan_action(vsi,
 -						 vsi->outer_vlan_ops.add_vlan,
 -						 &vlan);
 -			if (err)
 -				return err;
 -
 -			if (vlan_promisc) {
 -				err = ice_vf_ena_vlan_promisc(vsi, &vlan);
 -				if (err)
 -					return err;
 -			}
 -		}
 -
 -		vc_vlan = &vlan_fltr->inner;
 -		if (ice_vc_is_valid_vlan(vc_vlan)) {
 -			struct ice_vlan vlan = ice_vc_to_vlan(vc_vlan);
 -
 -			err = ice_vc_vlan_action(vsi,
 -						 vsi->inner_vlan_ops.add_vlan,
 -						 &vlan);
 -			if (err)
 -				return err;
 -
 -			/* no support for VLAN promiscuous on inner VLAN unless
 -			 * we are in Single VLAN Mode (SVM)
 -			 */
 -			if (!ice_is_dvm_ena(&vsi->back->hw) && vlan_promisc) {
 -				err = ice_vf_ena_vlan_promisc(vsi, &vlan);
 -				if (err)
 -					return err;
 -			}
 -		}
 -	}
 -
 -	return 0;
 -}
 -
 -/**
 - * ice_vc_validate_add_vlan_filter_list - validate add filter list from the VF
 - * @vsi: VF VSI used to get number of existing VLAN filters
 - * @vfc: negotiated/supported VLAN filtering capabilities
 - * @vfl: VLAN filter list from VF to validate
 - *
 - * Validate all of the filters in the VLAN filter list from the VF during the
 - * VIRTCHNL_OP_ADD_VLAN_V2 opcode. If any of the checks fail then return false.
 - * Otherwise return true.
 - */
 -static bool
 -ice_vc_validate_add_vlan_filter_list(struct ice_vsi *vsi,
 -				     struct virtchnl_vlan_filtering_caps *vfc,
 -				     struct virtchnl_vlan_filter_list_v2 *vfl)
 -{
 -	u16 num_requested_filters = vsi->num_vlan + vfl->num_elements;
 -
 -	if (num_requested_filters > vfc->max_filters)
 -		return false;
 -
 -	return ice_vc_validate_vlan_filter_list(vfc, vfl);
 -}
 -
 -/**
 - * ice_vc_add_vlan_v2_msg - virtchnl handler for VIRTCHNL_OP_ADD_VLAN_V2
 - * @vf: VF the message was received from
 - * @msg: message received from the VF
 - */
 -static int ice_vc_add_vlan_v2_msg(struct ice_vf *vf, u8 *msg)
 -{
 -	enum virtchnl_status_code v_ret = VIRTCHNL_STATUS_SUCCESS;
 -	struct virtchnl_vlan_filter_list_v2 *vfl =
 -		(struct virtchnl_vlan_filter_list_v2 *)msg;
 -	struct ice_vsi *vsi;
 -
 -	if (!test_bit(ICE_VF_STATE_ACTIVE, vf->vf_states)) {
 -		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -		goto out;
 -	}
 -
 -	if (!ice_vc_isvalid_vsi_id(vf, vfl->vport_id)) {
 -		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -		goto out;
 -	}
 -
 -	vsi = ice_get_vf_vsi(vf);
 -	if (!vsi) {
 -		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -		goto out;
 -	}
 -
 -	if (!ice_vc_validate_add_vlan_filter_list(vsi,
 -						  &vf->vlan_v2_caps.filtering,
 -						  vfl)) {
 -		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -		goto out;
 -	}
 -
 -	if (ice_vc_add_vlans(vf, vsi, vfl))
 -		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -
 -out:
 -	return ice_vc_send_msg_to_vf(vf, VIRTCHNL_OP_ADD_VLAN_V2, v_ret, NULL,
 -				     0);
 -}
 -
 -/**
 - * ice_vc_valid_vlan_setting - validate VLAN setting
 - * @negotiated_settings: negotiated VLAN settings during VF init
 - * @ethertype_setting: ethertype(s) requested for the VLAN setting
 - */
 -static bool
 -ice_vc_valid_vlan_setting(u32 negotiated_settings, u32 ethertype_setting)
 -{
 -	if (ethertype_setting && !(negotiated_settings & ethertype_setting))
 -		return false;
 -
 -	/* only allow a single VIRTCHNL_VLAN_ETHERTYPE if
 -	 * VIRTHCNL_VLAN_ETHERTYPE_AND is not negotiated/supported
 -	 */
 -	if (!(negotiated_settings & VIRTCHNL_VLAN_ETHERTYPE_AND) &&
 -	    hweight32(ethertype_setting) > 1)
 -		return false;
 -
 -	/* ability to modify the VLAN setting was not negotiated */
 -	if (!(negotiated_settings & VIRTCHNL_VLAN_TOGGLE))
 -		return false;
 -
 -	return true;
 -}
 -
 -/**
 - * ice_vc_valid_vlan_setting_msg - validate the VLAN setting message
 - * @caps: negotiated VLAN settings during VF init
 - * @msg: message to validate
 - *
 - * Used to validate any VLAN virtchnl message sent as a
 - * virtchnl_vlan_setting structure. Validates the message against the
 - * negotiated/supported caps during VF driver init.
 - */
 -static bool
 -ice_vc_valid_vlan_setting_msg(struct virtchnl_vlan_supported_caps *caps,
 -			      struct virtchnl_vlan_setting *msg)
 -{
 -	if ((!msg->outer_ethertype_setting &&
 -	     !msg->inner_ethertype_setting) ||
 -	    (!caps->outer && !caps->inner))
 -		return false;
 -
 -	if (msg->outer_ethertype_setting &&
 -	    !ice_vc_valid_vlan_setting(caps->outer,
 -				       msg->outer_ethertype_setting))
 -		return false;
 -
 -	if (msg->inner_ethertype_setting &&
 -	    !ice_vc_valid_vlan_setting(caps->inner,
 -				       msg->inner_ethertype_setting))
 -		return false;
 -
 -	return true;
 -}
 -
 -/**
 - * ice_vc_get_tpid - transform from VIRTCHNL_VLAN_ETHERTYPE_* to VLAN TPID
 - * @ethertype_setting: VIRTCHNL_VLAN_ETHERTYPE_* used to get VLAN TPID
 - * @tpid: VLAN TPID to populate
 - */
 -static int ice_vc_get_tpid(u32 ethertype_setting, u16 *tpid)
 -{
 -	switch (ethertype_setting) {
 -	case VIRTCHNL_VLAN_ETHERTYPE_8100:
 -		*tpid = ETH_P_8021Q;
 -		break;
 -	case VIRTCHNL_VLAN_ETHERTYPE_88A8:
 -		*tpid = ETH_P_8021AD;
 -		break;
 -	case VIRTCHNL_VLAN_ETHERTYPE_9100:
 -		*tpid = ETH_P_QINQ1;
 -		break;
 -	default:
 -		*tpid = 0;
 -		return -EINVAL;
 -	}
 -
 -	return 0;
 -}
 -
 -/**
 - * ice_vc_ena_vlan_offload - enable VLAN offload based on the ethertype_setting
 - * @vsi: VF's VSI used to enable the VLAN offload
 - * @ena_offload: function used to enable the VLAN offload
 - * @ethertype_setting: VIRTCHNL_VLAN_ETHERTYPE_* to enable offloads for
 - */
 -static int
 -ice_vc_ena_vlan_offload(struct ice_vsi *vsi,
 -			int (*ena_offload)(struct ice_vsi *vsi, u16 tpid),
 -			u32 ethertype_setting)
 -{
 -	u16 tpid;
 -	int err;
 -
 -	err = ice_vc_get_tpid(ethertype_setting, &tpid);
 -	if (err)
 -		return err;
 -
 -	err = ena_offload(vsi, tpid);
 -	if (err)
 -		return err;
 -
 -	return 0;
 -}
 -
 -#define ICE_L2TSEL_QRX_CONTEXT_REG_IDX	3
 -#define ICE_L2TSEL_BIT_OFFSET		23
 -enum ice_l2tsel {
 -	ICE_L2TSEL_EXTRACT_FIRST_TAG_L2TAG2_2ND,
 -	ICE_L2TSEL_EXTRACT_FIRST_TAG_L2TAG1,
 -};
 -
 -/**
 - * ice_vsi_update_l2tsel - update l2tsel field for all Rx rings on this VSI
 - * @vsi: VSI used to update l2tsel on
 - * @l2tsel: l2tsel setting requested
 - *
 - * Use the l2tsel setting to update all of the Rx queue context bits for l2tsel.
 - * This will modify which descriptor field the first offloaded VLAN will be
 - * stripped into.
 - */
 -static void ice_vsi_update_l2tsel(struct ice_vsi *vsi, enum ice_l2tsel l2tsel)
 -{
 -	struct ice_hw *hw = &vsi->back->hw;
 -	u32 l2tsel_bit;
 -	int i;
 -
 -	if (l2tsel == ICE_L2TSEL_EXTRACT_FIRST_TAG_L2TAG2_2ND)
 -		l2tsel_bit = 0;
 -	else
 -		l2tsel_bit = BIT(ICE_L2TSEL_BIT_OFFSET);
 -
 -	for (i = 0; i < vsi->alloc_rxq; i++) {
 -		u16 pfq = vsi->rxq_map[i];
 -		u32 qrx_context_offset;
 -		u32 regval;
 -
 -		qrx_context_offset =
 -			QRX_CONTEXT(ICE_L2TSEL_QRX_CONTEXT_REG_IDX, pfq);
 -
 -		regval = rd32(hw, qrx_context_offset);
 -		regval &= ~BIT(ICE_L2TSEL_BIT_OFFSET);
 -		regval |= l2tsel_bit;
 -		wr32(hw, qrx_context_offset, regval);
 -	}
 -}
 -
 -/**
 - * ice_vc_ena_vlan_stripping_v2_msg
 - * @vf: VF the message was received from
 - * @msg: message received from the VF
 - *
 - * virthcnl handler for VIRTCHNL_OP_ENABLE_VLAN_STRIPPING_V2
 - */
 -static int ice_vc_ena_vlan_stripping_v2_msg(struct ice_vf *vf, u8 *msg)
 -{
 -	enum virtchnl_status_code v_ret = VIRTCHNL_STATUS_SUCCESS;
 -	struct virtchnl_vlan_supported_caps *stripping_support;
 -	struct virtchnl_vlan_setting *strip_msg =
 -		(struct virtchnl_vlan_setting *)msg;
 -	u32 ethertype_setting;
 -	struct ice_vsi *vsi;
 -
 -	if (!test_bit(ICE_VF_STATE_ACTIVE, vf->vf_states)) {
 -		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -		goto out;
 -	}
 -
 -	if (!ice_vc_isvalid_vsi_id(vf, strip_msg->vport_id)) {
 -		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -		goto out;
 -	}
 -
 -	vsi = ice_get_vf_vsi(vf);
 -	if (!vsi) {
 -		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -		goto out;
 -	}
 -
 -	stripping_support = &vf->vlan_v2_caps.offloads.stripping_support;
 -	if (!ice_vc_valid_vlan_setting_msg(stripping_support, strip_msg)) {
 -		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -		goto out;
 -	}
 -
 -	ethertype_setting = strip_msg->outer_ethertype_setting;
 -	if (ethertype_setting) {
 -		if (ice_vc_ena_vlan_offload(vsi,
 -					    vsi->outer_vlan_ops.ena_stripping,
 -					    ethertype_setting)) {
 -			v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -			goto out;
 -		} else {
 -			enum ice_l2tsel l2tsel =
 -				ICE_L2TSEL_EXTRACT_FIRST_TAG_L2TAG2_2ND;
 -
 -			/* PF tells the VF that the outer VLAN tag is always
 -			 * extracted to VIRTCHNL_VLAN_TAG_LOCATION_L2TAG2_2 and
 -			 * inner is always extracted to
 -			 * VIRTCHNL_VLAN_TAG_LOCATION_L2TAG1. This is needed to
 -			 * support outer stripping so the first tag always ends
 -			 * up in L2TAG2_2ND and the second/inner tag, if
 -			 * enabled, is extracted in L2TAG1.
 -			 */
 -			ice_vsi_update_l2tsel(vsi, l2tsel);
 -		}
 -	}
 -
 -	ethertype_setting = strip_msg->inner_ethertype_setting;
 -	if (ethertype_setting &&
 -	    ice_vc_ena_vlan_offload(vsi, vsi->inner_vlan_ops.ena_stripping,
 -				    ethertype_setting)) {
 -		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -		goto out;
 -	}
 -
 -out:
 -	return ice_vc_send_msg_to_vf(vf, VIRTCHNL_OP_ENABLE_VLAN_STRIPPING_V2, v_ret, NULL, 0);
 -}
 -
 -/**
 - * ice_vc_dis_vlan_stripping_v2_msg
 - * @vf: VF the message was received from
 - * @msg: message received from the VF
 - *
 - * virthcnl handler for VIRTCHNL_OP_DISABLE_VLAN_STRIPPING_V2
 - */
 -static int ice_vc_dis_vlan_stripping_v2_msg(struct ice_vf *vf, u8 *msg)
 -{
 -	enum virtchnl_status_code v_ret = VIRTCHNL_STATUS_SUCCESS;
 -	struct virtchnl_vlan_supported_caps *stripping_support;
 -	struct virtchnl_vlan_setting *strip_msg =
 -		(struct virtchnl_vlan_setting *)msg;
 -	u32 ethertype_setting;
 -	struct ice_vsi *vsi;
 -
 -	if (!test_bit(ICE_VF_STATE_ACTIVE, vf->vf_states)) {
 -		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -		goto out;
 -	}
 -
 -	if (!ice_vc_isvalid_vsi_id(vf, strip_msg->vport_id)) {
 -		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -		goto out;
 -	}
 -
 -	vsi = ice_get_vf_vsi(vf);
 -	if (!vsi) {
 -		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -		goto out;
 -	}
 -
 -	stripping_support = &vf->vlan_v2_caps.offloads.stripping_support;
 -	if (!ice_vc_valid_vlan_setting_msg(stripping_support, strip_msg)) {
 -		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -		goto out;
 -	}
 -
 -	ethertype_setting = strip_msg->outer_ethertype_setting;
 -	if (ethertype_setting) {
 -		if (vsi->outer_vlan_ops.dis_stripping(vsi)) {
 -			v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -			goto out;
 -		} else {
 -			enum ice_l2tsel l2tsel =
 -				ICE_L2TSEL_EXTRACT_FIRST_TAG_L2TAG1;
 -
 -			/* PF tells the VF that the outer VLAN tag is always
 -			 * extracted to VIRTCHNL_VLAN_TAG_LOCATION_L2TAG2_2 and
 -			 * inner is always extracted to
 -			 * VIRTCHNL_VLAN_TAG_LOCATION_L2TAG1. This is needed to
 -			 * support inner stripping while outer stripping is
 -			 * disabled so that the first and only tag is extracted
 -			 * in L2TAG1.
 -			 */
 -			ice_vsi_update_l2tsel(vsi, l2tsel);
 -		}
 -	}
 -
 -	ethertype_setting = strip_msg->inner_ethertype_setting;
 -	if (ethertype_setting && vsi->inner_vlan_ops.dis_stripping(vsi)) {
 -		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -		goto out;
 -	}
 -
 -out:
 -	return ice_vc_send_msg_to_vf(vf, VIRTCHNL_OP_DISABLE_VLAN_STRIPPING_V2, v_ret, NULL, 0);
 -}
 -
 -/**
 - * ice_vc_ena_vlan_insertion_v2_msg
 - * @vf: VF the message was received from
 - * @msg: message received from the VF
 - *
 - * virthcnl handler for VIRTCHNL_OP_ENABLE_VLAN_INSERTION_V2
 - */
 -static int ice_vc_ena_vlan_insertion_v2_msg(struct ice_vf *vf, u8 *msg)
 -{
 -	enum virtchnl_status_code v_ret = VIRTCHNL_STATUS_SUCCESS;
 -	struct virtchnl_vlan_supported_caps *insertion_support;
 -	struct virtchnl_vlan_setting *insertion_msg =
 -		(struct virtchnl_vlan_setting *)msg;
 -	u32 ethertype_setting;
 -	struct ice_vsi *vsi;
 -
 -	if (!test_bit(ICE_VF_STATE_ACTIVE, vf->vf_states)) {
 -		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -		goto out;
 -	}
 -
 -	if (!ice_vc_isvalid_vsi_id(vf, insertion_msg->vport_id)) {
 -		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -		goto out;
 -	}
 -
 -	vsi = ice_get_vf_vsi(vf);
 -	if (!vsi) {
 -		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -		goto out;
 -	}
 -
 -	insertion_support = &vf->vlan_v2_caps.offloads.insertion_support;
 -	if (!ice_vc_valid_vlan_setting_msg(insertion_support, insertion_msg)) {
 -		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -		goto out;
 -	}
 -
 -	ethertype_setting = insertion_msg->outer_ethertype_setting;
 -	if (ethertype_setting &&
 -	    ice_vc_ena_vlan_offload(vsi, vsi->outer_vlan_ops.ena_insertion,
 -				    ethertype_setting)) {
 -		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -		goto out;
 -	}
 -
 -	ethertype_setting = insertion_msg->inner_ethertype_setting;
 -	if (ethertype_setting &&
 -	    ice_vc_ena_vlan_offload(vsi, vsi->inner_vlan_ops.ena_insertion,
 -				    ethertype_setting)) {
 -		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -		goto out;
 -	}
 -
 -out:
 -	return ice_vc_send_msg_to_vf(vf, VIRTCHNL_OP_ENABLE_VLAN_INSERTION_V2, v_ret, NULL, 0);
 -}
 -
 -/**
 - * ice_vc_dis_vlan_insertion_v2_msg
 - * @vf: VF the message was received from
 - * @msg: message received from the VF
 - *
 - * virthcnl handler for VIRTCHNL_OP_DISABLE_VLAN_INSERTION_V2
 - */
 -static int ice_vc_dis_vlan_insertion_v2_msg(struct ice_vf *vf, u8 *msg)
 -{
 -	enum virtchnl_status_code v_ret = VIRTCHNL_STATUS_SUCCESS;
 -	struct virtchnl_vlan_supported_caps *insertion_support;
 -	struct virtchnl_vlan_setting *insertion_msg =
 -		(struct virtchnl_vlan_setting *)msg;
 -	u32 ethertype_setting;
 -	struct ice_vsi *vsi;
 -
 -	if (!test_bit(ICE_VF_STATE_ACTIVE, vf->vf_states)) {
 -		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
 -		goto out;
++	if (!test_bit(ICE_VF_STATE_ACTIVE, vf->vf_states)) {
++		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
++		goto out;
+ 	}
+ 
+ 	if (!ice_vc_isvalid_vsi_id(vf, insertion_msg->vport_id)) {
+ 		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
+ 		goto out;
+ 	}
+ 
+ 	vsi = ice_get_vf_vsi(vf);
+ 	if (!vsi) {
+ 		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
+ 		goto out;
+ 	}
+ 
+ 	insertion_support = &vf->vlan_v2_caps.offloads.insertion_support;
+ 	if (!ice_vc_valid_vlan_setting_msg(insertion_support, insertion_msg)) {
+ 		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
+ 		goto out;
+ 	}
+ 
+ 	ethertype_setting = insertion_msg->outer_ethertype_setting;
+ 	if (ethertype_setting && vsi->outer_vlan_ops.dis_insertion(vsi)) {
+ 		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
+ 		goto out;
+ 	}
+ 
+ 	ethertype_setting = insertion_msg->inner_ethertype_setting;
+ 	if (ethertype_setting && vsi->inner_vlan_ops.dis_insertion(vsi)) {
+ 		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
+ 		goto out;
+ 	}
+ 
+ out:
+ 	return ice_vc_send_msg_to_vf(vf, VIRTCHNL_OP_DISABLE_VLAN_INSERTION_V2, v_ret, NULL, 0);
+ }
+ 
+ static const struct ice_virtchnl_ops ice_virtchnl_dflt_ops = {
+ 	.get_ver_msg = ice_vc_get_ver_msg,
+ 	.get_vf_res_msg = ice_vc_get_vf_res_msg,
+ 	.reset_vf = ice_vc_reset_vf_msg,
+ 	.add_mac_addr_msg = ice_vc_add_mac_addr_msg,
+ 	.del_mac_addr_msg = ice_vc_del_mac_addr_msg,
+ 	.cfg_qs_msg = ice_vc_cfg_qs_msg,
+ 	.ena_qs_msg = ice_vc_ena_qs_msg,
+ 	.dis_qs_msg = ice_vc_dis_qs_msg,
+ 	.request_qs_msg = ice_vc_request_qs_msg,
+ 	.cfg_irq_map_msg = ice_vc_cfg_irq_map_msg,
+ 	.config_rss_key = ice_vc_config_rss_key,
+ 	.config_rss_lut = ice_vc_config_rss_lut,
+ 	.get_stats_msg = ice_vc_get_stats_msg,
+ 	.cfg_promiscuous_mode_msg = ice_vc_cfg_promiscuous_mode_msg,
+ 	.add_vlan_msg = ice_vc_add_vlan_msg,
+ 	.remove_vlan_msg = ice_vc_remove_vlan_msg,
+ 	.ena_vlan_stripping = ice_vc_ena_vlan_stripping,
+ 	.dis_vlan_stripping = ice_vc_dis_vlan_stripping,
+ 	.handle_rss_cfg_msg = ice_vc_handle_rss_cfg,
+ 	.add_fdir_fltr_msg = ice_vc_add_fdir_fltr,
+ 	.del_fdir_fltr_msg = ice_vc_del_fdir_fltr,
+ 	.get_offload_vlan_v2_caps = ice_vc_get_offload_vlan_v2_caps,
+ 	.add_vlan_v2_msg = ice_vc_add_vlan_v2_msg,
+ 	.remove_vlan_v2_msg = ice_vc_remove_vlan_v2_msg,
+ 	.ena_vlan_stripping_v2_msg = ice_vc_ena_vlan_stripping_v2_msg,
+ 	.dis_vlan_stripping_v2_msg = ice_vc_dis_vlan_stripping_v2_msg,
+ 	.ena_vlan_insertion_v2_msg = ice_vc_ena_vlan_insertion_v2_msg,
+ 	.dis_vlan_insertion_v2_msg = ice_vc_dis_vlan_insertion_v2_msg,
+ };
+ 
+ /**
+  * ice_virtchnl_set_dflt_ops - Switch to default virtchnl ops
+  * @vf: the VF to switch ops
+  */
+ void ice_virtchnl_set_dflt_ops(struct ice_vf *vf)
+ {
+ 	vf->virtchnl_ops = &ice_virtchnl_dflt_ops;
+ }
+ 
+ /**
+  * ice_vc_repr_add_mac
+  * @vf: pointer to VF
+  * @msg: virtchannel message
+  *
+  * When port representors are created, we do not add MAC rule
+  * to firmware, we store it so that PF could report same
+  * MAC as VF.
+  */
+ static int ice_vc_repr_add_mac(struct ice_vf *vf, u8 *msg)
+ {
+ 	enum virtchnl_status_code v_ret = VIRTCHNL_STATUS_SUCCESS;
+ 	struct virtchnl_ether_addr_list *al =
+ 	    (struct virtchnl_ether_addr_list *)msg;
+ 	struct ice_vsi *vsi;
+ 	struct ice_pf *pf;
+ 	int i;
+ 
+ 	if (!test_bit(ICE_VF_STATE_ACTIVE, vf->vf_states) ||
+ 	    !ice_vc_isvalid_vsi_id(vf, al->vsi_id)) {
+ 		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
+ 		goto handle_mac_exit;
+ 	}
+ 
+ 	pf = vf->pf;
+ 
+ 	vsi = ice_get_vf_vsi(vf);
+ 	if (!vsi) {
+ 		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
+ 		goto handle_mac_exit;
+ 	}
+ 
+ 	for (i = 0; i < al->num_elements; i++) {
+ 		u8 *mac_addr = al->list[i].addr;
+ 		int result;
+ 
+ 		if (!is_unicast_ether_addr(mac_addr) ||
+ 		    ether_addr_equal(mac_addr, vf->hw_lan_addr.addr))
+ 			continue;
+ 
+ 		if (vf->pf_set_mac) {
+ 			dev_err(ice_pf_to_dev(pf), "VF attempting to override administratively set MAC address\n");
+ 			v_ret = VIRTCHNL_STATUS_ERR_NOT_SUPPORTED;
+ 			goto handle_mac_exit;
+ 		}
+ 
+ 		result = ice_eswitch_add_vf_mac_rule(pf, vf, mac_addr);
+ 		if (result) {
+ 			dev_err(ice_pf_to_dev(pf), "Failed to add MAC %pM for VF %d\n, error %d\n",
+ 				mac_addr, vf->vf_id, result);
+ 			goto handle_mac_exit;
+ 		}
+ 
+ 		ice_vfhw_mac_add(vf, &al->list[i]);
+ 		vf->num_mac++;
+ 		break;
+ 	}
+ 
+ handle_mac_exit:
+ 	return ice_vc_send_msg_to_vf(vf, VIRTCHNL_OP_ADD_ETH_ADDR,
+ 				     v_ret, NULL, 0);
+ }
+ 
+ /**
+  * ice_vc_repr_del_mac - response with success for deleting MAC
+  * @vf: pointer to VF
+  * @msg: virtchannel message
+  *
+  * Respond with success to not break normal VF flow.
+  * For legacy VF driver try to update cached MAC address.
+  */
+ static int
+ ice_vc_repr_del_mac(struct ice_vf __always_unused *vf, u8 __always_unused *msg)
+ {
+ 	struct virtchnl_ether_addr_list *al =
+ 		(struct virtchnl_ether_addr_list *)msg;
+ 
+ 	ice_update_legacy_cached_mac(vf, &al->list[0]);
+ 
+ 	return ice_vc_send_msg_to_vf(vf, VIRTCHNL_OP_DEL_ETH_ADDR,
+ 				     VIRTCHNL_STATUS_SUCCESS, NULL, 0);
+ }
+ 
+ static int ice_vc_repr_add_vlan(struct ice_vf *vf, u8 __always_unused *msg)
+ {
+ 	dev_dbg(ice_pf_to_dev(vf->pf),
+ 		"Can't add VLAN in switchdev mode for VF %d\n", vf->vf_id);
+ 	return ice_vc_send_msg_to_vf(vf, VIRTCHNL_OP_ADD_VLAN,
+ 				     VIRTCHNL_STATUS_SUCCESS, NULL, 0);
+ }
+ 
+ static int ice_vc_repr_del_vlan(struct ice_vf *vf, u8 __always_unused *msg)
+ {
+ 	dev_dbg(ice_pf_to_dev(vf->pf),
+ 		"Can't delete VLAN in switchdev mode for VF %d\n", vf->vf_id);
+ 	return ice_vc_send_msg_to_vf(vf, VIRTCHNL_OP_DEL_VLAN,
+ 				     VIRTCHNL_STATUS_SUCCESS, NULL, 0);
+ }
+ 
+ static int ice_vc_repr_ena_vlan_stripping(struct ice_vf *vf)
+ {
+ 	dev_dbg(ice_pf_to_dev(vf->pf),
+ 		"Can't enable VLAN stripping in switchdev mode for VF %d\n",
+ 		vf->vf_id);
+ 	return ice_vc_send_msg_to_vf(vf, VIRTCHNL_OP_ENABLE_VLAN_STRIPPING,
+ 				     VIRTCHNL_STATUS_ERR_NOT_SUPPORTED,
+ 				     NULL, 0);
+ }
+ 
+ static int ice_vc_repr_dis_vlan_stripping(struct ice_vf *vf)
+ {
+ 	dev_dbg(ice_pf_to_dev(vf->pf),
+ 		"Can't disable VLAN stripping in switchdev mode for VF %d\n",
+ 		vf->vf_id);
+ 	return ice_vc_send_msg_to_vf(vf, VIRTCHNL_OP_DISABLE_VLAN_STRIPPING,
+ 				     VIRTCHNL_STATUS_ERR_NOT_SUPPORTED,
+ 				     NULL, 0);
+ }
+ 
+ static int
+ ice_vc_repr_cfg_promiscuous_mode(struct ice_vf *vf, u8 __always_unused *msg)
+ {
+ 	dev_dbg(ice_pf_to_dev(vf->pf),
+ 		"Can't config promiscuous mode in switchdev mode for VF %d\n",
+ 		vf->vf_id);
+ 	return ice_vc_send_msg_to_vf(vf, VIRTCHNL_OP_CONFIG_PROMISCUOUS_MODE,
+ 				     VIRTCHNL_STATUS_ERR_NOT_SUPPORTED,
+ 				     NULL, 0);
+ }
+ 
+ static const struct ice_virtchnl_ops ice_virtchnl_repr_ops = {
+ 	.get_ver_msg = ice_vc_get_ver_msg,
+ 	.get_vf_res_msg = ice_vc_get_vf_res_msg,
+ 	.reset_vf = ice_vc_reset_vf_msg,
+ 	.add_mac_addr_msg = ice_vc_repr_add_mac,
+ 	.del_mac_addr_msg = ice_vc_repr_del_mac,
+ 	.cfg_qs_msg = ice_vc_cfg_qs_msg,
+ 	.ena_qs_msg = ice_vc_ena_qs_msg,
+ 	.dis_qs_msg = ice_vc_dis_qs_msg,
+ 	.request_qs_msg = ice_vc_request_qs_msg,
+ 	.cfg_irq_map_msg = ice_vc_cfg_irq_map_msg,
+ 	.config_rss_key = ice_vc_config_rss_key,
+ 	.config_rss_lut = ice_vc_config_rss_lut,
+ 	.get_stats_msg = ice_vc_get_stats_msg,
+ 	.cfg_promiscuous_mode_msg = ice_vc_repr_cfg_promiscuous_mode,
+ 	.add_vlan_msg = ice_vc_repr_add_vlan,
+ 	.remove_vlan_msg = ice_vc_repr_del_vlan,
+ 	.ena_vlan_stripping = ice_vc_repr_ena_vlan_stripping,
+ 	.dis_vlan_stripping = ice_vc_repr_dis_vlan_stripping,
+ 	.handle_rss_cfg_msg = ice_vc_handle_rss_cfg,
+ 	.add_fdir_fltr_msg = ice_vc_add_fdir_fltr,
+ 	.del_fdir_fltr_msg = ice_vc_del_fdir_fltr,
+ 	.get_offload_vlan_v2_caps = ice_vc_get_offload_vlan_v2_caps,
+ 	.add_vlan_v2_msg = ice_vc_add_vlan_v2_msg,
+ 	.remove_vlan_v2_msg = ice_vc_remove_vlan_v2_msg,
+ 	.ena_vlan_stripping_v2_msg = ice_vc_ena_vlan_stripping_v2_msg,
+ 	.dis_vlan_stripping_v2_msg = ice_vc_dis_vlan_stripping_v2_msg,
+ 	.ena_vlan_insertion_v2_msg = ice_vc_ena_vlan_insertion_v2_msg,
 -	.dis_vlan_insertion_v2_msg = ice_vc_dis_vlan_insertion_v2_msg,
 -};
 -
 -/**
 - * ice_virtchnl_set_repr_ops - Switch to representor virtchnl ops
 - * @vf: the VF to switch ops
 - */
 -void ice_virtchnl_set_repr_ops(struct ice_vf *vf)
 -{
 -	vf->virtchnl_ops = &ice_virtchnl_repr_ops;
 -}
 -
 -/**
 - * ice_vc_process_vf_msg - Process request from VF
 - * @pf: pointer to the PF structure
 - * @event: pointer to the AQ event
 - *
 - * called from the common asq/arq handler to
 - * process request from VF
 - */
 -void ice_vc_process_vf_msg(struct ice_pf *pf, struct ice_rq_event_info *event)
 -{
 -	u32 v_opcode = le32_to_cpu(event->desc.cookie_high);
 -	s16 vf_id = le16_to_cpu(event->desc.retval);
 -	const struct ice_virtchnl_ops *ops;
 -	u16 msglen = event->msg_len;
 -	u8 *msg = event->msg_buf;
 -	struct ice_vf *vf = NULL;
 -	struct device *dev;
 -	int err = 0;
 -
 -	dev = ice_pf_to_dev(pf);
 -
 -	vf = ice_get_vf_by_id(pf, vf_id);
 -	if (!vf) {
 -		dev_err(dev, "Unable to locate VF for message from VF ID %d, opcode %d, len %d\n",
 -			vf_id, v_opcode, msglen);
 -		return;
 -	}
 -
 -	/* Check if VF is disabled. */
 -	if (test_bit(ICE_VF_STATE_DIS, vf->vf_states)) {
 -		err = -EPERM;
 -		goto error_handler;
 -	}
 -
 -	ops = vf->virtchnl_ops;
 -
 -	/* Perform basic checks on the msg */
 -	err = virtchnl_vc_validate_vf_msg(&vf->vf_ver, v_opcode, msg, msglen);
 -	if (err) {
 -		if (err == VIRTCHNL_STATUS_ERR_PARAM)
 -			err = -EPERM;
 -		else
 -			err = -EINVAL;
 -	}
 -
 -	if (!ice_vc_is_opcode_allowed(vf, v_opcode)) {
 -		ice_vc_send_msg_to_vf(vf, v_opcode,
 -				      VIRTCHNL_STATUS_ERR_NOT_SUPPORTED, NULL,
 -				      0);
 -		ice_put_vf(vf);
 -		return;
 -	}
 -
 -error_handler:
 -	if (err) {
 -		ice_vc_send_msg_to_vf(vf, v_opcode, VIRTCHNL_STATUS_ERR_PARAM,
 -				      NULL, 0);
 -		dev_err(dev, "Invalid message from VF %d, opcode %d, len %d, error %d\n",
 -			vf_id, v_opcode, msglen, err);
 -		ice_put_vf(vf);
 -		return;
 -	}
 -
 -	/* VF is being configured in another context that triggers a VFR, so no
 -	 * need to process this message
 -	 */
 -	if (!mutex_trylock(&vf->cfg_lock)) {
 -		dev_info(dev, "VF %u is being configured in another context that will trigger a VFR, so there is no need to handle this message\n",
 -			 vf->vf_id);
 -		ice_put_vf(vf);
 -		return;
 -	}
 -
 -	switch (v_opcode) {
 -	case VIRTCHNL_OP_VERSION:
 -		err = ops->get_ver_msg(vf, msg);
 -		break;
 -	case VIRTCHNL_OP_GET_VF_RESOURCES:
 -		err = ops->get_vf_res_msg(vf, msg);
 -		if (ice_vf_init_vlan_stripping(vf))
 -			dev_dbg(dev, "Failed to initialize VLAN stripping for VF %d\n",
 -				vf->vf_id);
 -		ice_vc_notify_vf_link_state(vf);
 -		break;
 -	case VIRTCHNL_OP_RESET_VF:
 -		ops->reset_vf(vf);
 -		break;
 -	case VIRTCHNL_OP_ADD_ETH_ADDR:
 -		err = ops->add_mac_addr_msg(vf, msg);
 -		break;
 -	case VIRTCHNL_OP_DEL_ETH_ADDR:
 -		err = ops->del_mac_addr_msg(vf, msg);
 -		break;
 -	case VIRTCHNL_OP_CONFIG_VSI_QUEUES:
 -		err = ops->cfg_qs_msg(vf, msg);
 -		break;
 -	case VIRTCHNL_OP_ENABLE_QUEUES:
 -		err = ops->ena_qs_msg(vf, msg);
 -		ice_vc_notify_vf_link_state(vf);
 -		break;
 -	case VIRTCHNL_OP_DISABLE_QUEUES:
 -		err = ops->dis_qs_msg(vf, msg);
 -		break;
 -	case VIRTCHNL_OP_REQUEST_QUEUES:
 -		err = ops->request_qs_msg(vf, msg);
 -		break;
 -	case VIRTCHNL_OP_CONFIG_IRQ_MAP:
 -		err = ops->cfg_irq_map_msg(vf, msg);
 -		break;
 -	case VIRTCHNL_OP_CONFIG_RSS_KEY:
 -		err = ops->config_rss_key(vf, msg);
 -		break;
 -	case VIRTCHNL_OP_CONFIG_RSS_LUT:
 -		err = ops->config_rss_lut(vf, msg);
 -		break;
 -	case VIRTCHNL_OP_GET_STATS:
 -		err = ops->get_stats_msg(vf, msg);
 -		break;
 -	case VIRTCHNL_OP_CONFIG_PROMISCUOUS_MODE:
 -		err = ops->cfg_promiscuous_mode_msg(vf, msg);
 -		break;
 -	case VIRTCHNL_OP_ADD_VLAN:
 -		err = ops->add_vlan_msg(vf, msg);
 -		break;
 -	case VIRTCHNL_OP_DEL_VLAN:
 -		err = ops->remove_vlan_msg(vf, msg);
 -		break;
 -	case VIRTCHNL_OP_ENABLE_VLAN_STRIPPING:
 -		err = ops->ena_vlan_stripping(vf);
 -		break;
 -	case VIRTCHNL_OP_DISABLE_VLAN_STRIPPING:
 -		err = ops->dis_vlan_stripping(vf);
 -		break;
 -	case VIRTCHNL_OP_ADD_FDIR_FILTER:
 -		err = ops->add_fdir_fltr_msg(vf, msg);
 -		break;
 -	case VIRTCHNL_OP_DEL_FDIR_FILTER:
 -		err = ops->del_fdir_fltr_msg(vf, msg);
 -		break;
 -	case VIRTCHNL_OP_ADD_RSS_CFG:
 -		err = ops->handle_rss_cfg_msg(vf, msg, true);
 -		break;
 -	case VIRTCHNL_OP_DEL_RSS_CFG:
 -		err = ops->handle_rss_cfg_msg(vf, msg, false);
 -		break;
 -	case VIRTCHNL_OP_GET_OFFLOAD_VLAN_V2_CAPS:
 -		err = ops->get_offload_vlan_v2_caps(vf);
 -		break;
 -	case VIRTCHNL_OP_ADD_VLAN_V2:
 -		err = ops->add_vlan_v2_msg(vf, msg);
 -		break;
 -	case VIRTCHNL_OP_DEL_VLAN_V2:
 -		err = ops->remove_vlan_v2_msg(vf, msg);
 -		break;
 -	case VIRTCHNL_OP_ENABLE_VLAN_STRIPPING_V2:
 -		err = ops->ena_vlan_stripping_v2_msg(vf, msg);
 -		break;
 -	case VIRTCHNL_OP_DISABLE_VLAN_STRIPPING_V2:
 -		err = ops->dis_vlan_stripping_v2_msg(vf, msg);
 -		break;
 -	case VIRTCHNL_OP_ENABLE_VLAN_INSERTION_V2:
 -		err = ops->ena_vlan_insertion_v2_msg(vf, msg);
 -		break;
 -	case VIRTCHNL_OP_DISABLE_VLAN_INSERTION_V2:
 -		err = ops->dis_vlan_insertion_v2_msg(vf, msg);
 -		break;
 -	case VIRTCHNL_OP_UNKNOWN:
 -	default:
 -		dev_err(dev, "Unsupported opcode %d from VF %d\n", v_opcode,
 -			vf_id);
 -		err = ice_vc_send_msg_to_vf(vf, v_opcode,
 -					    VIRTCHNL_STATUS_ERR_NOT_SUPPORTED,
 -					    NULL, 0);
 -		break;
 -	}
 -	if (err) {
 -		/* Helper function cares less about error return values here
 -		 * as it is busy with pending work.
 -		 */
 -		dev_info(dev, "PF failed to honor VF %d, opcode %d, error %d\n",
 -			 vf_id, v_opcode, err);
 -	}
 -
 -	mutex_unlock(&vf->cfg_lock);
 -	ice_put_vf(vf);
 -}
 -
 -/**
 - * ice_get_vf_cfg
 - * @netdev: network interface device structure
 - * @vf_id: VF identifier
 - * @ivi: VF configuration structure
 - *
 - * return VF configuration
 - */
 -int
 -ice_get_vf_cfg(struct net_device *netdev, int vf_id, struct ifla_vf_info *ivi)
 -{
 -	struct ice_pf *pf = ice_netdev_to_pf(netdev);
 -	struct ice_vf *vf;
 -	int ret;
 -
 -	vf = ice_get_vf_by_id(pf, vf_id);
 -	if (!vf)
 -		return -EINVAL;
 -
 -	ret = ice_check_vf_ready_for_cfg(vf);
 -	if (ret)
 -		goto out_put_vf;
 -
 -	ivi->vf = vf_id;
 -	ether_addr_copy(ivi->mac, vf->hw_lan_addr.addr);
 -
 -	/* VF configuration for VLAN and applicable QoS */
 -	ivi->vlan = ice_vf_get_port_vlan_id(vf);
 -	ivi->qos = ice_vf_get_port_vlan_prio(vf);
 -	if (ice_vf_is_port_vlan_ena(vf))
 -		ivi->vlan_proto = cpu_to_be16(ice_vf_get_port_vlan_tpid(vf));
 -
 -	ivi->trusted = vf->trusted;
 -	ivi->spoofchk = vf->spoofchk;
 -	if (!vf->link_forced)
 -		ivi->linkstate = IFLA_VF_LINK_STATE_AUTO;
 -	else if (vf->link_up)
 -		ivi->linkstate = IFLA_VF_LINK_STATE_ENABLE;
 -	else
 -		ivi->linkstate = IFLA_VF_LINK_STATE_DISABLE;
 -	ivi->max_tx_rate = vf->max_tx_rate;
 -	ivi->min_tx_rate = vf->min_tx_rate;
 -
 -out_put_vf:
 -	ice_put_vf(vf);
 -	return ret;
 -}
++	.dis_vlan_insertion_v2_msg = ice_vc_dis_vlan_insertion_v2_msg,
++};
+ 
+ /**
 - * ice_unicast_mac_exists - check if the unicast MAC exists on the PF's switch
 - * @pf: PF used to reference the switch's rules
 - * @umac: unicast MAC to compare against existing switch rules
 - *
 - * Return true on the first/any match, else return false
++ * ice_virtchnl_set_repr_ops - Switch to representor virtchnl ops
++ * @vf: the VF to switch ops
+  */
 -static bool ice_unicast_mac_exists(struct ice_pf *pf, u8 *umac)
++void ice_virtchnl_set_repr_ops(struct ice_vf *vf)
+ {
 -	struct ice_sw_recipe *mac_recipe_list =
 -		&pf->hw.switch_info->recp_list[ICE_SW_LKUP_MAC];
 -	struct ice_fltr_mgmt_list_entry *list_itr;
 -	struct list_head *rule_head;
 -	struct mutex *rule_lock; /* protect MAC filter list access */
 -
 -	rule_head = &mac_recipe_list->filt_rules;
 -	rule_lock = &mac_recipe_list->filt_rule_lock;
 -
 -	mutex_lock(rule_lock);
 -	list_for_each_entry(list_itr, rule_head, list_entry) {
 -		u8 *existing_mac = &list_itr->fltr_info.l_data.mac.mac_addr[0];
 -
 -		if (ether_addr_equal(existing_mac, umac)) {
 -			mutex_unlock(rule_lock);
 -			return true;
 -		}
 -	}
 -
 -	mutex_unlock(rule_lock);
 -
 -	return false;
++	vf->virtchnl_ops = &ice_virtchnl_repr_ops;
+ }
+ 
+ /**
 - * ice_set_vf_mac
 - * @netdev: network interface device structure
 - * @vf_id: VF identifier
 - * @mac: MAC address
++ * ice_vc_process_vf_msg - Process request from VF
++ * @pf: pointer to the PF structure
++ * @event: pointer to the AQ event
+  *
 - * program VF MAC address
++ * called from the common asq/arq handler to
++ * process request from VF
+  */
 -int ice_set_vf_mac(struct net_device *netdev, int vf_id, u8 *mac)
++void ice_vc_process_vf_msg(struct ice_pf *pf, struct ice_rq_event_info *event)
+ {
 -	struct ice_pf *pf = ice_netdev_to_pf(netdev);
 -	struct ice_vf *vf;
 -	int ret;
++	u32 v_opcode = le32_to_cpu(event->desc.cookie_high);
++	s16 vf_id = le16_to_cpu(event->desc.retval);
++	const struct ice_virtchnl_ops *ops;
++	u16 msglen = event->msg_len;
++	u8 *msg = event->msg_buf;
++	struct ice_vf *vf = NULL;
++	struct device *dev;
++	int err = 0;
+ 
 -	if (is_multicast_ether_addr(mac)) {
 -		netdev_err(netdev, "%pM not a valid unicast address\n", mac);
 -		return -EINVAL;
 -	}
++	dev = ice_pf_to_dev(pf);
+ 
+ 	vf = ice_get_vf_by_id(pf, vf_id);
 -	if (!vf)
 -		return -EINVAL;
 -
 -	/* nothing left to do, unicast MAC already set */
 -	if (ether_addr_equal(vf->dev_lan_addr.addr, mac) &&
 -	    ether_addr_equal(vf->hw_lan_addr.addr, mac)) {
 -		ret = 0;
 -		goto out_put_vf;
++	if (!vf) {
++		dev_err(dev, "Unable to locate VF for message from VF ID %d, opcode %d, len %d\n",
++			vf_id, v_opcode, msglen);
++		return;
+ 	}
+ 
 -	ret = ice_check_vf_ready_for_cfg(vf);
 -	if (ret)
 -		goto out_put_vf;
 -
 -	if (ice_unicast_mac_exists(pf, mac)) {
 -		netdev_err(netdev, "Unicast MAC %pM already exists on this PF. Preventing setting VF %u unicast MAC address to %pM\n",
 -			   mac, vf_id, mac);
 -		ret = -EINVAL;
 -		goto out_put_vf;
++	/* Check if VF is disabled. */
++	if (test_bit(ICE_VF_STATE_DIS, vf->vf_states)) {
++		err = -EPERM;
++		goto error_handler;
+ 	}
+ 
 -	mutex_lock(&vf->cfg_lock);
++	ops = vf->virtchnl_ops;
+ 
 -	/* VF is notified of its new MAC via the PF's response to the
 -	 * VIRTCHNL_OP_GET_VF_RESOURCES message after the VF has been reset
 -	 */
 -	ether_addr_copy(vf->dev_lan_addr.addr, mac);
 -	ether_addr_copy(vf->hw_lan_addr.addr, mac);
 -	if (is_zero_ether_addr(mac)) {
 -		/* VF will send VIRTCHNL_OP_ADD_ETH_ADDR message with its MAC */
 -		vf->pf_set_mac = false;
 -		netdev_info(netdev, "Removing MAC on VF %d. VF driver will be reinitialized\n",
 -			    vf->vf_id);
 -	} else {
 -		/* PF will add MAC rule for the VF */
 -		vf->pf_set_mac = true;
 -		netdev_info(netdev, "Setting MAC %pM on VF %d. VF driver will be reinitialized\n",
 -			    mac, vf_id);
++	/* Perform basic checks on the msg */
++	err = virtchnl_vc_validate_vf_msg(&vf->vf_ver, v_opcode, msg, msglen);
++	if (err) {
++		if (err == VIRTCHNL_STATUS_ERR_PARAM)
++			err = -EPERM;
++		else
++			err = -EINVAL;
+ 	}
+ 
 -	ice_vc_reset_vf(vf);
 -	mutex_unlock(&vf->cfg_lock);
 -
 -out_put_vf:
 -	ice_put_vf(vf);
 -	return ret;
 -}
 -
 -/**
 - * ice_set_vf_trust
 - * @netdev: network interface device structure
 - * @vf_id: VF identifier
 - * @trusted: Boolean value to enable/disable trusted VF
 - *
 - * Enable or disable a given VF as trusted
 - */
 -int ice_set_vf_trust(struct net_device *netdev, int vf_id, bool trusted)
 -{
 -	struct ice_pf *pf = ice_netdev_to_pf(netdev);
 -	struct ice_vf *vf;
 -	int ret;
 -
 -	if (ice_is_eswitch_mode_switchdev(pf)) {
 -		dev_info(ice_pf_to_dev(pf), "Trusted VF is forbidden in switchdev mode\n");
 -		return -EOPNOTSUPP;
++	if (!ice_vc_is_opcode_allowed(vf, v_opcode)) {
++		ice_vc_send_msg_to_vf(vf, v_opcode,
++				      VIRTCHNL_STATUS_ERR_NOT_SUPPORTED, NULL,
++				      0);
++		ice_put_vf(vf);
++		return;
+ 	}
+ 
 -	vf = ice_get_vf_by_id(pf, vf_id);
 -	if (!vf)
 -		return -EINVAL;
 -
 -	ret = ice_check_vf_ready_for_cfg(vf);
 -	if (ret)
 -		goto out_put_vf;
 -
 -	/* Check if already trusted */
 -	if (trusted == vf->trusted) {
 -		ret = 0;
 -		goto out_put_vf;
++error_handler:
++	if (err) {
++		ice_vc_send_msg_to_vf(vf, v_opcode, VIRTCHNL_STATUS_ERR_PARAM,
++				      NULL, 0);
++		dev_err(dev, "Invalid message from VF %d, opcode %d, len %d, error %d\n",
++			vf_id, v_opcode, msglen, err);
++		ice_put_vf(vf);
++		return;
+ 	}
+ 
 -	mutex_lock(&vf->cfg_lock);
 -
 -	vf->trusted = trusted;
 -	ice_vc_reset_vf(vf);
 -	dev_info(ice_pf_to_dev(pf), "VF %u is now %strusted\n",
 -		 vf_id, trusted ? "" : "un");
 -
 -	mutex_unlock(&vf->cfg_lock);
 -
 -out_put_vf:
 -	ice_put_vf(vf);
 -	return ret;
 -}
++	/* VF is being configured in another context that triggers a VFR, so no
++	 * need to process this message
++>>>>>>> a7e117109a25 (ice: convert vf->vc_ops to a const pointer)
 +	 */
 +	if (mbx_data->async_watermark_val < ICE_ASYNC_VF_MSG_THRESHOLD ||
 +	    mbx_data->async_watermark_val > mbx_data->max_num_msgs_mbx)
 +		return -EINVAL;
  
 -/**
 - * ice_set_vf_link_state
 - * @netdev: network interface device structure
 - * @vf_id: VF identifier
 - * @link_state: required link state
 - *
 - * Set VF's link state, irrespective of physical link state status
 - */
 -int ice_set_vf_link_state(struct net_device *netdev, int vf_id, int link_state)
 -{
 -	struct ice_pf *pf = ice_netdev_to_pf(netdev);
 -	struct ice_vf *vf;
 -	int ret;
 +	new_state = ICE_MAL_VF_DETECT_STATE_INVALID;
 +	snap_buf = &snap->mbx_buf;
  
 -	vf = ice_get_vf_by_id(pf, vf_id);
 -	if (!vf)
 -		return -EINVAL;
 +	switch (snap_buf->state) {
 +	case ICE_MAL_VF_DETECT_STATE_NEW_SNAPSHOT:
 +		/* Clear any previously held data in mailbox snapshot structure. */
 +		ice_mbx_reset_snapshot(snap);
  
 -	ret = ice_check_vf_ready_for_cfg(vf);
 -	if (ret)
 -		goto out_put_vf;
 +		/* Collect the pending ARQ count, number of messages processed and
 +		 * the maximum number of messages allowed to be processed from the
 +		 * Mailbox for current interrupt.
 +		 */
 +		snap_buf->num_pending_arq = mbx_data->num_pending_arq;
 +		snap_buf->num_msg_proc = mbx_data->num_msg_proc;
 +		snap_buf->max_num_msgs_mbx = mbx_data->max_num_msgs_mbx;
  
 -	switch (link_state) {
 -	case IFLA_VF_LINK_STATE_AUTO:
 -		vf->link_forced = false;
 +		/* Capture a new static snapshot of the mailbox by logging the
 +		 * head and tail of snapshot and set num_iterations to the tail
 +		 * value to mark the start of the iteration through the snapshot.
 +		 */
 +		snap_buf->head = ICE_RQ_DATA_MASK(cq->rq.next_to_clean +
 +						  mbx_data->num_pending_arq);
 +		snap_buf->tail = ICE_RQ_DATA_MASK(cq->rq.next_to_clean - 1);
 +		snap_buf->num_iterations = snap_buf->tail;
 +
 +		/* Pending ARQ messages returned by ice_clean_rq_elem
 +		 * is the difference between the head and tail of the
 +		 * mailbox queue. Comparing this value against the watermark
 +		 * helps to check if we potentially have malicious VFs.
 +		 */
 +		if (snap_buf->num_pending_arq >=
 +		    mbx_data->async_watermark_val) {
 +			new_state = ICE_MAL_VF_DETECT_STATE_DETECT;
 +			status = ice_mbx_detect_malvf(hw, vf_id, &new_state, is_malvf);
 +		} else {
 +			new_state = ICE_MAL_VF_DETECT_STATE_TRAVERSE;
 +			ice_mbx_traverse(hw, &new_state);
 +		}
  		break;
 -	case IFLA_VF_LINK_STATE_ENABLE:
 -		vf->link_forced = true;
 -		vf->link_up = true;
 +
 +	case ICE_MAL_VF_DETECT_STATE_TRAVERSE:
 +		new_state = ICE_MAL_VF_DETECT_STATE_TRAVERSE;
 +		ice_mbx_traverse(hw, &new_state);
  		break;
 -	case IFLA_VF_LINK_STATE_DISABLE:
 -		vf->link_forced = true;
 -		vf->link_up = false;
 +
 +	case ICE_MAL_VF_DETECT_STATE_DETECT:
 +		new_state = ICE_MAL_VF_DETECT_STATE_DETECT;
 +		status = ice_mbx_detect_malvf(hw, vf_id, &new_state, is_malvf);
  		break;
 +
  	default:
 -		ret = -EINVAL;
 -		goto out_put_vf;
 +		new_state = ICE_MAL_VF_DETECT_STATE_INVALID;
 +		status = -EIO;
  	}
  
 -	ice_vc_notify_vf_link_state(vf);
 -
 -out_put_vf:
 -	ice_put_vf(vf);
 -	return ret;
 -}
 -
 -/**
 - * ice_calc_all_vfs_min_tx_rate - calculate cumulative min Tx rate on all VFs
 - * @pf: PF associated with VFs
 - */
 -static int ice_calc_all_vfs_min_tx_rate(struct ice_pf *pf)
 -{
 -	struct ice_vf *vf;
 -	unsigned int bkt;
 -	int rate = 0;
 -
 -	rcu_read_lock();
 -	ice_for_each_vf_rcu(pf, bkt, vf)
 -		rate += vf->min_tx_rate;
 -	rcu_read_unlock();
 +	snap_buf->state = new_state;
  
 -	return rate;
 +	return status;
  }
  
  /**
diff --cc drivers/net/ethernet/intel/ice/ice_sriov.h
index 68686a3fd7e8,b6951d718592..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_sriov.h
+++ b/drivers/net/ethernet/intel/ice/ice_sriov.h
@@@ -3,47 -3,413 +3,386 @@@
  
  #ifndef _ICE_SRIOV_H_
  #define _ICE_SRIOV_H_
 -#include "ice_virtchnl_fdir.h"
 -#include "ice_vsi_vlan_ops.h"
  
 -/* Restrict number of MAC Addr and VLAN that non-trusted VF can programmed */
 -#define ICE_MAX_VLAN_PER_VF		8
 -/* MAC filters: 1 is reserved for the VF's default/perm_addr/LAA MAC, 1 for
 - * broadcast, and 16 for additional unicast/multicast filters
 +#include "ice_type.h"
 +#include "ice_controlq.h"
 +
 +/* Defining the mailbox message threshold as 63 asynchronous
 + * pending messages. Normal VF functionality does not require
 + * sending more than 63 asynchronous pending message.
   */
++<<<<<<< HEAD
 +#define ICE_ASYNC_VF_MSG_THRESHOLD	63
++=======
+ #define ICE_MAX_MACADDR_PER_VF		18
+ 
+ /* Malicious Driver Detection */
+ #define ICE_MDD_EVENTS_THRESHOLD		30
+ 
+ /* Static VF transaction/status register def */
+ #define VF_DEVICE_STATUS		0xAA
+ #define VF_TRANS_PENDING_M		0x20
+ 
+ /* wait defines for polling PF_PCI_CIAD register status */
+ #define ICE_PCI_CIAD_WAIT_COUNT		100
+ #define ICE_PCI_CIAD_WAIT_DELAY_US	1
+ 
+ /* VF resource constraints */
+ #define ICE_MAX_VF_COUNT		256
+ #define ICE_MIN_QS_PER_VF		1
+ #define ICE_NONQ_VECS_VF		1
+ #define ICE_MAX_SCATTER_QS_PER_VF	16
+ #define ICE_MAX_RSS_QS_PER_VF		16
+ #define ICE_NUM_VF_MSIX_MED		17
+ #define ICE_NUM_VF_MSIX_SMALL		5
+ #define ICE_NUM_VF_MSIX_MULTIQ_MIN	3
+ #define ICE_MIN_INTR_PER_VF		(ICE_MIN_QS_PER_VF + 1)
+ #define ICE_MAX_VF_RESET_TRIES		40
+ #define ICE_MAX_VF_RESET_SLEEP_MS	20
+ 
+ /* VF Hash Table access functions
+  *
+  * These functions provide abstraction for interacting with the VF hash table.
+  * In general, direct access to the hash table should be avoided outside of
+  * these functions where possible.
+  *
+  * The VF entries in the hash table are protected by reference counting to
+  * track lifetime of accesses from the table. The ice_get_vf_by_id() function
+  * obtains a reference to the VF structure which must be dropped by using
+  * ice_put_vf().
+  */
+ 
+ /**
+  * ice_for_each_vf - Iterate over each VF entry
+  * @pf: pointer to the PF private structure
+  * @bkt: bucket index used for iteration
+  * @vf: pointer to the VF entry currently being processed in the loop.
+  *
+  * The bkt variable is an unsigned integer iterator used to traverse the VF
+  * entries. It is *not* guaranteed to be the VF's vf_id. Do not assume it is.
+  * Use vf->vf_id to get the id number if needed.
+  *
+  * The caller is expected to be under the table_lock mutex for the entire
+  * loop. Use this iterator if your loop is long or if it might sleep.
+  */
+ #define ice_for_each_vf(pf, bkt, vf) \
+ 	hash_for_each((pf)->vfs.table, (bkt), (vf), entry)
+ 
+ /**
+  * ice_for_each_vf_rcu - Iterate over each VF entry protected by RCU
+  * @pf: pointer to the PF private structure
+  * @bkt: bucket index used for iteration
+  * @vf: pointer to the VF entry currently being processed in the loop.
+  *
+  * The bkt variable is an unsigned integer iterator used to traverse the VF
+  * entries. It is *not* guaranteed to be the VF's vf_id. Do not assume it is.
+  * Use vf->vf_id to get the id number if needed.
+  *
+  * The caller is expected to be under rcu_read_lock() for the entire loop.
+  * Only use this iterator if your loop is short and you can guarantee it does
+  * not sleep.
+  */
+ #define ice_for_each_vf_rcu(pf, bkt, vf) \
+ 	hash_for_each_rcu((pf)->vfs.table, (bkt), (vf), entry)
+ 
+ /* Specific VF states */
+ enum ice_vf_states {
+ 	ICE_VF_STATE_INIT = 0,		/* PF is initializing VF */
+ 	ICE_VF_STATE_ACTIVE,		/* VF resources are allocated for use */
+ 	ICE_VF_STATE_QS_ENA,		/* VF queue(s) enabled */
+ 	ICE_VF_STATE_DIS,
+ 	ICE_VF_STATE_MC_PROMISC,
+ 	ICE_VF_STATE_UC_PROMISC,
+ 	ICE_VF_STATES_NBITS
+ };
+ 
+ /* VF capabilities */
+ enum ice_virtchnl_cap {
+ 	ICE_VIRTCHNL_VF_CAP_L2 = 0,
+ 	ICE_VIRTCHNL_VF_CAP_PRIVILEGE,
+ };
+ 
+ struct ice_time_mac {
+ 	unsigned long time_modified;
+ 	u8 addr[ETH_ALEN];
+ };
+ 
+ /* VF MDD events print structure */
+ struct ice_mdd_vf_events {
+ 	u16 count;			/* total count of Rx|Tx events */
+ 	/* count number of the last printed event */
+ 	u16 last_printed;
+ };
+ 
+ struct ice_vf;
+ 
+ struct ice_virtchnl_ops {
+ 	int (*get_ver_msg)(struct ice_vf *vf, u8 *msg);
+ 	int (*get_vf_res_msg)(struct ice_vf *vf, u8 *msg);
+ 	void (*reset_vf)(struct ice_vf *vf);
+ 	int (*add_mac_addr_msg)(struct ice_vf *vf, u8 *msg);
+ 	int (*del_mac_addr_msg)(struct ice_vf *vf, u8 *msg);
+ 	int (*cfg_qs_msg)(struct ice_vf *vf, u8 *msg);
+ 	int (*ena_qs_msg)(struct ice_vf *vf, u8 *msg);
+ 	int (*dis_qs_msg)(struct ice_vf *vf, u8 *msg);
+ 	int (*request_qs_msg)(struct ice_vf *vf, u8 *msg);
+ 	int (*cfg_irq_map_msg)(struct ice_vf *vf, u8 *msg);
+ 	int (*config_rss_key)(struct ice_vf *vf, u8 *msg);
+ 	int (*config_rss_lut)(struct ice_vf *vf, u8 *msg);
+ 	int (*get_stats_msg)(struct ice_vf *vf, u8 *msg);
+ 	int (*cfg_promiscuous_mode_msg)(struct ice_vf *vf, u8 *msg);
+ 	int (*add_vlan_msg)(struct ice_vf *vf, u8 *msg);
+ 	int (*remove_vlan_msg)(struct ice_vf *vf, u8 *msg);
+ 	int (*ena_vlan_stripping)(struct ice_vf *vf);
+ 	int (*dis_vlan_stripping)(struct ice_vf *vf);
+ 	int (*handle_rss_cfg_msg)(struct ice_vf *vf, u8 *msg, bool add);
+ 	int (*add_fdir_fltr_msg)(struct ice_vf *vf, u8 *msg);
+ 	int (*del_fdir_fltr_msg)(struct ice_vf *vf, u8 *msg);
+ 	int (*get_offload_vlan_v2_caps)(struct ice_vf *vf);
+ 	int (*add_vlan_v2_msg)(struct ice_vf *vf, u8 *msg);
+ 	int (*remove_vlan_v2_msg)(struct ice_vf *vf, u8 *msg);
+ 	int (*ena_vlan_stripping_v2_msg)(struct ice_vf *vf, u8 *msg);
+ 	int (*dis_vlan_stripping_v2_msg)(struct ice_vf *vf, u8 *msg);
+ 	int (*ena_vlan_insertion_v2_msg)(struct ice_vf *vf, u8 *msg);
+ 	int (*dis_vlan_insertion_v2_msg)(struct ice_vf *vf, u8 *msg);
+ };
+ 
+ /* Virtchnl/SR-IOV config info */
+ struct ice_vfs {
+ 	DECLARE_HASHTABLE(table, 8);	/* table of VF entries */
+ 	struct mutex table_lock;	/* Lock for protecting the hash table */
+ 	u16 num_supported;		/* max supported VFs on this PF */
+ 	u16 num_qps_per;		/* number of queue pairs per VF */
+ 	u16 num_msix_per;		/* number of MSI-X vectors per VF */
+ 	unsigned long last_printed_mdd_jiffies;	/* MDD message rate limit */
+ 	DECLARE_BITMAP(malvfs, ICE_MAX_VF_COUNT); /* malicious VF indicator */
+ };
+ 
+ /* VF information structure */
+ struct ice_vf {
+ 	struct hlist_node entry;
+ 	struct rcu_head rcu;
+ 	struct kref refcnt;
+ 	struct ice_pf *pf;
+ 
+ 	/* Used during virtchnl message handling and NDO ops against the VF
+ 	 * that will trigger a VFR
+ 	 */
+ 	struct mutex cfg_lock;
+ 
+ 	u16 vf_id;			/* VF ID in the PF space */
+ 	u16 lan_vsi_idx;		/* index into PF struct */
+ 	u16 ctrl_vsi_idx;
+ 	struct ice_vf_fdir fdir;
+ 	/* first vector index of this VF in the PF space */
+ 	int first_vector_idx;
+ 	struct ice_sw *vf_sw_id;	/* switch ID the VF VSIs connect to */
+ 	struct virtchnl_version_info vf_ver;
+ 	u32 driver_caps;		/* reported by VF driver */
+ 	struct virtchnl_ether_addr dev_lan_addr;
+ 	struct virtchnl_ether_addr hw_lan_addr;
+ 	struct ice_time_mac legacy_last_added_umac;
+ 	DECLARE_BITMAP(txq_ena, ICE_MAX_RSS_QS_PER_VF);
+ 	DECLARE_BITMAP(rxq_ena, ICE_MAX_RSS_QS_PER_VF);
+ 	struct ice_vlan port_vlan_info;	/* Port VLAN ID, QoS, and TPID */
+ 	struct virtchnl_vlan_caps vlan_v2_caps;
+ 	u8 pf_set_mac:1;		/* VF MAC address set by VMM admin */
+ 	u8 trusted:1;
+ 	u8 spoofchk:1;
+ 	u8 link_forced:1;
+ 	u8 link_up:1;			/* only valid if VF link is forced */
+ 	/* VSI indices - actual VSI pointers are maintained in the PF structure
+ 	 * When assigned, these will be non-zero, because VSI 0 is always
+ 	 * the main LAN VSI for the PF.
+ 	 */
+ 	u16 lan_vsi_num;		/* ID as used by firmware */
+ 	unsigned int min_tx_rate;	/* Minimum Tx bandwidth limit in Mbps */
+ 	unsigned int max_tx_rate;	/* Maximum Tx bandwidth limit in Mbps */
+ 	DECLARE_BITMAP(vf_states, ICE_VF_STATES_NBITS);	/* VF runtime states */
+ 
+ 	unsigned long vf_caps;		/* VF's adv. capabilities */
+ 	u8 num_req_qs;			/* num of queue pairs requested by VF */
+ 	u16 num_mac;
+ 	u16 num_vf_qs;			/* num of queue configured per VF */
+ 	struct ice_mdd_vf_events mdd_rx_events;
+ 	struct ice_mdd_vf_events mdd_tx_events;
+ 	DECLARE_BITMAP(opcodes_allowlist, VIRTCHNL_OP_MAX);
+ 
+ 	struct ice_repr *repr;
+ 	const struct ice_virtchnl_ops *virtchnl_ops;
+ 
+ 	/* devlink port data */
+ 	struct devlink_port devlink_port;
+ };
++>>>>>>> a7e117109a25 (ice: convert vf->vc_ops to a const pointer)
  
  #ifdef CONFIG_PCI_IOV
 -struct ice_vf *ice_get_vf_by_id(struct ice_pf *pf, u16 vf_id);
 -void ice_put_vf(struct ice_vf *vf);
 -bool ice_has_vfs(struct ice_pf *pf);
 -u16 ice_get_num_vfs(struct ice_pf *pf);
 -struct ice_vsi *ice_get_vf_vsi(struct ice_vf *vf);
 -void ice_process_vflr_event(struct ice_pf *pf);
 -int ice_sriov_configure(struct pci_dev *pdev, int num_vfs);
 -int ice_set_vf_mac(struct net_device *netdev, int vf_id, u8 *mac);
  int
++<<<<<<< HEAD
 +ice_aq_send_msg_to_vf(struct ice_hw *hw, u16 vfid, u32 v_opcode, u32 v_retval,
 +		      u8 *msg, u16 msglen, struct ice_sq_cd *cd);
++=======
+ ice_get_vf_cfg(struct net_device *netdev, int vf_id, struct ifla_vf_info *ivi);
+ 
+ void ice_free_vfs(struct ice_pf *pf);
+ void ice_vc_process_vf_msg(struct ice_pf *pf, struct ice_rq_event_info *event);
+ void ice_vc_notify_link_state(struct ice_pf *pf);
+ void ice_vc_notify_reset(struct ice_pf *pf);
+ void ice_vc_notify_vf_link_state(struct ice_vf *vf);
+ void ice_virtchnl_set_repr_ops(struct ice_vf *vf);
+ void ice_virtchnl_set_dflt_ops(struct ice_vf *vf);
+ bool ice_reset_all_vfs(struct ice_pf *pf, bool is_vflr);
+ bool ice_reset_vf(struct ice_vf *vf, bool is_vflr);
+ void ice_restore_all_vfs_msi_state(struct pci_dev *pdev);
+ bool
+ ice_is_malicious_vf(struct ice_pf *pf, struct ice_rq_event_info *event,
+ 		    u16 num_msg_proc, u16 num_msg_pending);
++>>>>>>> a7e117109a25 (ice: convert vf->vc_ops to a const pointer)
  
 +u32 ice_conv_link_speed_to_virtchnl(bool adv_link_support, u16 link_speed);
  int
 -ice_set_vf_port_vlan(struct net_device *netdev, int vf_id, u16 vlan_id, u8 qos,
 -		     __be16 vlan_proto);
 -
 -int
 -ice_set_vf_bw(struct net_device *netdev, int vf_id, int min_tx_rate,
 -	      int max_tx_rate);
 -
 -int ice_set_vf_trust(struct net_device *netdev, int vf_id, bool trusted);
 -
 -int ice_set_vf_link_state(struct net_device *netdev, int vf_id, int link_state);
 -
 -int ice_check_vf_ready_for_cfg(struct ice_vf *vf);
 -
 -bool ice_is_vf_disabled(struct ice_vf *vf);
 -
 -int ice_set_vf_spoofchk(struct net_device *netdev, int vf_id, bool ena);
 -
 -int ice_calc_vf_reg_idx(struct ice_vf *vf, struct ice_q_vector *q_vector);
 -
 -void ice_set_vf_state_qs_dis(struct ice_vf *vf);
 +ice_mbx_vf_state_handler(struct ice_hw *hw, struct ice_mbx_data *mbx_data,
 +			 u16 vf_id, bool *is_mal_vf);
  int
 -ice_get_vf_stats(struct net_device *netdev, int vf_id,
 -		 struct ifla_vf_stats *vf_stats);
 -bool ice_is_any_vf_in_promisc(struct ice_pf *pf);
 -void
 -ice_vf_lan_overflow_event(struct ice_pf *pf, struct ice_rq_event_info *event);
 -void ice_print_vfs_mdd_events(struct ice_pf *pf);
 -void ice_print_vf_rx_mdd_event(struct ice_vf *vf);
 -bool
 -ice_vc_validate_pattern(struct ice_vf *vf, struct virtchnl_proto_hdrs *proto);
 -struct ice_vsi *ice_vf_ctrl_vsi_setup(struct ice_vf *vf);
 +ice_mbx_clear_malvf(struct ice_mbx_snapshot *snap, unsigned long *all_malvfs,
 +		    u16 bitmap_len, u16 vf_id);
 +int ice_mbx_init_snapshot(struct ice_hw *hw, u16 vf_count);
 +void ice_mbx_deinit_snapshot(struct ice_hw *hw);
  int
 -ice_vc_send_msg_to_vf(struct ice_vf *vf, u32 v_opcode,
 -		      enum virtchnl_status_code v_retval, u8 *msg, u16 msglen);
 -bool ice_vc_isvalid_vsi_id(struct ice_vf *vf, u16 vsi_id);
 -bool ice_vf_is_port_vlan_ena(struct ice_vf *vf);
 +ice_mbx_report_malvf(struct ice_hw *hw, unsigned long *all_malvfs,
 +		     u16 bitmap_len, u16 vf_id, bool *report_malvf);
  #else /* CONFIG_PCI_IOV */
 -static inline struct ice_vf *ice_get_vf_by_id(struct ice_pf *pf, u16 vf_id)
 -{
 -	return NULL;
 -}
 -
 -static inline void ice_put_vf(struct ice_vf *vf)
 -{
 -}
 -
 -static inline bool ice_has_vfs(struct ice_pf *pf)
 -{
 -	return false;
 -}
 -
 -static inline u16 ice_get_num_vfs(struct ice_pf *pf)
 +static inline int
 +ice_aq_send_msg_to_vf(struct ice_hw __always_unused *hw,
 +		      u16 __always_unused vfid, u32 __always_unused v_opcode,
 +		      u32 __always_unused v_retval, u8 __always_unused *msg,
 +		      u16 __always_unused msglen,
 +		      struct ice_sq_cd __always_unused *cd)
  {
  	return 0;
  }
  
++<<<<<<< HEAD
 +static inline u32
 +ice_conv_link_speed_to_virtchnl(bool __always_unused adv_link_support,
 +				u16 __always_unused link_speed)
++=======
+ static inline void ice_process_vflr_event(struct ice_pf *pf) { }
+ static inline void ice_free_vfs(struct ice_pf *pf) { }
+ static inline
+ void ice_vc_process_vf_msg(struct ice_pf *pf, struct ice_rq_event_info *event) { }
+ static inline void ice_vc_notify_link_state(struct ice_pf *pf) { }
+ static inline void ice_vc_notify_reset(struct ice_pf *pf) { }
+ static inline void ice_vc_notify_vf_link_state(struct ice_vf *vf) { }
+ static inline void ice_virtchnl_set_repr_ops(struct ice_vf *vf) { }
+ static inline void ice_virtchnl_set_dflt_ops(struct ice_vf *vf) { }
+ static inline void ice_set_vf_state_qs_dis(struct ice_vf *vf) { }
+ static inline
+ void ice_vf_lan_overflow_event(struct ice_pf *pf, struct ice_rq_event_info *event) { }
+ static inline void ice_print_vfs_mdd_events(struct ice_pf *pf) { }
+ static inline void ice_print_vf_rx_mdd_event(struct ice_vf *vf) { }
+ static inline void ice_restore_all_vfs_msi_state(struct pci_dev *pdev) { }
+ 
+ static inline int ice_check_vf_ready_for_cfg(struct ice_vf *vf)
+ {
+ 	return -EOPNOTSUPP;
+ }
+ 
+ static inline bool ice_is_vf_disabled(struct ice_vf *vf)
+ {
+ 	return true;
+ }
+ 
+ static inline struct ice_vsi *ice_get_vf_vsi(struct ice_vf *vf)
+ {
+ 	return NULL;
+ }
+ 
+ static inline bool
+ ice_is_malicious_vf(struct ice_pf __always_unused *pf,
+ 		    struct ice_rq_event_info __always_unused *event,
+ 		    u16 __always_unused num_msg_proc,
+ 		    u16 __always_unused num_msg_pending)
+ {
+ 	return false;
+ }
+ 
+ static inline bool
+ ice_reset_all_vfs(struct ice_pf __always_unused *pf,
+ 		  bool __always_unused is_vflr)
+ {
+ 	return true;
+ }
+ 
+ static inline bool
+ ice_reset_vf(struct ice_vf __always_unused *vf, bool __always_unused is_vflr)
+ {
+ 	return true;
+ }
+ 
+ static inline int
+ ice_sriov_configure(struct pci_dev __always_unused *pdev,
+ 		    int __always_unused num_vfs)
+ {
+ 	return -EOPNOTSUPP;
+ }
+ 
+ static inline int
+ ice_set_vf_mac(struct net_device __always_unused *netdev,
+ 	       int __always_unused vf_id, u8 __always_unused *mac)
+ {
+ 	return -EOPNOTSUPP;
+ }
+ 
+ static inline int
+ ice_get_vf_cfg(struct net_device __always_unused *netdev,
+ 	       int __always_unused vf_id,
+ 	       struct ifla_vf_info __always_unused *ivi)
+ {
+ 	return -EOPNOTSUPP;
+ }
+ 
+ static inline int
+ ice_set_vf_trust(struct net_device __always_unused *netdev,
+ 		 int __always_unused vf_id, bool __always_unused trusted)
+ {
+ 	return -EOPNOTSUPP;
+ }
+ 
+ static inline int
+ ice_set_vf_port_vlan(struct net_device __always_unused *netdev,
+ 		     int __always_unused vf_id, u16 __always_unused vid,
+ 		     u8 __always_unused qos, __be16 __always_unused v_proto)
+ {
+ 	return -EOPNOTSUPP;
+ }
+ 
+ static inline int
+ ice_set_vf_spoofchk(struct net_device __always_unused *netdev,
+ 		    int __always_unused vf_id, bool __always_unused ena)
+ {
+ 	return -EOPNOTSUPP;
+ }
+ 
+ static inline int
+ ice_set_vf_link_state(struct net_device __always_unused *netdev,
+ 		      int __always_unused vf_id, int __always_unused link_state)
+ {
+ 	return -EOPNOTSUPP;
+ }
+ 
+ static inline int
+ ice_set_vf_bw(struct net_device __always_unused *netdev,
+ 	      int __always_unused vf_id, int __always_unused min_tx_rate,
+ 	      int __always_unused max_tx_rate)
+ {
+ 	return -EOPNOTSUPP;
+ }
+ 
+ static inline int
+ ice_calc_vf_reg_idx(struct ice_vf __always_unused *vf,
+ 		    struct ice_q_vector __always_unused *q_vector)
++>>>>>>> a7e117109a25 (ice: convert vf->vc_ops to a const pointer)
  {
  	return 0;
  }
diff --git a/drivers/net/ethernet/intel/ice/ice_repr.c b/drivers/net/ethernet/intel/ice/ice_repr.c
index 0f9826e89381..ddd4d9fb8db7 100644
--- a/drivers/net/ethernet/intel/ice/ice_repr.c
+++ b/drivers/net/ethernet/intel/ice/ice_repr.c
@@ -339,7 +339,7 @@ static int ice_repr_add(struct ice_vf *vf)
 
 	devlink_port_type_eth_set(&vf->devlink_port, repr->netdev);
 
-	ice_vc_change_ops_to_repr(&vf->vc_ops);
+	ice_virtchnl_set_repr_ops(vf);
 
 	return 0;
 
@@ -384,7 +384,7 @@ static void ice_repr_rem(struct ice_vf *vf)
 	kfree(vf->repr);
 	vf->repr = NULL;
 
-	ice_vc_set_dflt_vf_ops(&vf->vc_ops);
+	ice_virtchnl_set_dflt_ops(vf);
 }
 
 /**
* Unmerged path drivers/net/ethernet/intel/ice/ice_sriov.c
* Unmerged path drivers/net/ethernet/intel/ice/ice_sriov.h
