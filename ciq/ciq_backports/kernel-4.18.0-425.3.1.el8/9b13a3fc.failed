drm/format-helper: Rename drm_fb_xrgb8888_to_mono_reversed()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-425.3.1.el8
commit-author Geert Uytterhoeven <geert@linux-m68k.org>
commit 9b13a3fcd35fc24045d2fd0f0e13ddd8d7985b4b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-425.3.1.el8/9b13a3fc.failed

There is no "reversed" handling in drm_fb_xrgb8888_to_mono_reversed():
the function just converts from color to grayscale, and reduces the
number of grayscale levels from 256 to 2 (i.e. brightness 0-127 is
mapped to 0, 128-255 to 1).  All "reversed" handling is done in the
repaper driver, where this function originated.

Hence make this clear by renaming drm_fb_xrgb8888_to_mono_reversed() to
drm_fb_xrgb8888_to_mono(), and documenting the black/white pixel
mapping.

Fixes: bcf8b616deb87941 ("drm/format-helper: Add drm_fb_xrgb8888_to_mono_reversed()")
	Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
	Acked-by: Javier Martinez Canillas <javierm@redhat.com>
	Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
	Signed-off-by: Javier Martinez Canillas <javierm@redhat.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20220317081830.1211400-2-geert@linux-m68k.org
(cherry picked from commit 9b13a3fcd35fc24045d2fd0f0e13ddd8d7985b4b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/drm_format_helper.c
#	drivers/gpu/drm/solomon/ssd130x.c
#	drivers/gpu/drm/tiny/repaper.c
#	include/drm/drm_format_helper.h
diff --cc drivers/gpu/drm/drm_format_helper.c
index 0e885cd34107,5d9d0c695845..000000000000
--- a/drivers/gpu/drm/drm_format_helper.c
+++ b/drivers/gpu/drm/drm_format_helper.c
@@@ -398,36 -592,111 +398,145 @@@ int drm_fb_blit_rect_dstclip(void __iom
  
  	return -EINVAL;
  }
++<<<<<<< HEAD
 +EXPORT_SYMBOL(drm_fb_blit_rect_dstclip);
 +
 +/**
 + * drm_fb_blit_dstclip - Copy framebuffer to display memory
 + * @dst:	The display memory to copy to
 + * @dst_pitch:	Number of bytes between two consecutive scanlines within dst
 + * @dst_format:	FOURCC code of the display's color format
 + * @vmap:	The framebuffer memory to copy from
 + * @fb:		The framebuffer to copy from
++=======
+ EXPORT_SYMBOL(drm_fb_blit_toio);
+ 
+ static void drm_fb_gray8_to_mono_line(u8 *dst, const u8 *src, unsigned int pixels,
+ 				      unsigned int start_offset, unsigned int end_len)
+ {
+ 	unsigned int xb, i;
+ 
+ 	for (xb = 0; xb < pixels; xb++) {
+ 		unsigned int start = 0, end = 8;
+ 		u8 byte = 0x00;
+ 
+ 		if (xb == 0 && start_offset)
+ 			start = start_offset;
+ 
+ 		if (xb == pixels - 1 && end_len)
+ 			end = end_len;
+ 
+ 		for (i = start; i < end; i++) {
+ 			unsigned int x = xb * 8 + i;
+ 
+ 			byte >>= 1;
+ 			if (src[x] >> 7)
+ 				byte |= BIT(7);
+ 		}
+ 		*dst++ = byte;
+ 	}
+ }
+ 
+ /**
+  * drm_fb_xrgb8888_to_mono - Convert XRGB8888 to monochrome
+  * @dst: monochrome destination buffer (0=black, 1=white)
+  * @dst_pitch: Number of bytes between two consecutive scanlines within dst
+  * @src: XRGB8888 source buffer
+  * @fb: DRM framebuffer
+  * @clip: Clip rectangle area to copy
++>>>>>>> 9b13a3fcd35f (drm/format-helper: Rename drm_fb_xrgb8888_to_mono_reversed())
   *
 - * DRM doesn't have native monochrome support.
 - * Such drivers can announce the commonly supported XR24 format to userspace
 - * and use this function to convert to the native format.
 + * This function copies a full framebuffer to display memory. If the formats
 + * of the display and the framebuffer mismatch, the copy function will
 + * attempt to convert between them.
   *
++<<<<<<< HEAD
 + * See drm_fb_blit_rect_dstclip() for more inforamtion.
 + *
 + * Returns:
 + * 0 on success, or a negative error code otherwise.
 + */
 +int drm_fb_blit_dstclip(void __iomem *dst, unsigned int dst_pitch,
 +			uint32_t dst_format, void *vmap,
 +			struct drm_framebuffer *fb)
 +{
 +	struct drm_rect fullscreen = {
 +		.x1 = 0,
 +		.x2 = fb->width,
 +		.y1 = 0,
 +		.y2 = fb->height,
 +	};
 +	return drm_fb_blit_rect_dstclip(dst, dst_pitch, dst_format, vmap, fb,
 +					&fullscreen);
 +}
 +EXPORT_SYMBOL(drm_fb_blit_dstclip);
++=======
+  * This function uses drm_fb_xrgb8888_to_gray8() to convert to grayscale and
+  * then the result is converted from grayscale to monochrome.
+  */
+ void drm_fb_xrgb8888_to_mono(void *dst, unsigned int dst_pitch, const void *vaddr,
+ 			     const struct drm_framebuffer *fb, const struct drm_rect *clip)
+ {
+ 	unsigned int linepixels = drm_rect_width(clip);
+ 	unsigned int lines = clip->y2 - clip->y1;
+ 	unsigned int cpp = fb->format->cpp[0];
+ 	unsigned int len_src32 = linepixels * cpp;
+ 	struct drm_device *dev = fb->dev;
+ 	unsigned int start_offset, end_len;
+ 	unsigned int y;
+ 	u8 *mono = dst, *gray8;
+ 	u32 *src32;
+ 
+ 	if (drm_WARN_ON(dev, fb->format->format != DRM_FORMAT_XRGB8888))
+ 		return;
+ 
+ 	/*
+ 	 * The mono destination buffer contains 1 bit per pixel and
+ 	 * destination scanlines have to be in multiple of 8 pixels.
+ 	 */
+ 	if (!dst_pitch)
+ 		dst_pitch = DIV_ROUND_UP(linepixels, 8);
+ 
+ 	drm_WARN_ONCE(dev, dst_pitch % 8 != 0, "dst_pitch is not a multiple of 8\n");
+ 
+ 	/*
+ 	 * The cma memory is write-combined so reads are uncached.
+ 	 * Speed up by fetching one line at a time.
+ 	 *
+ 	 * Also, format conversion from XR24 to monochrome are done
+ 	 * line-by-line but are converted to 8-bit grayscale as an
+ 	 * intermediate step.
+ 	 *
+ 	 * Allocate a buffer to be used for both copying from the cma
+ 	 * memory and to store the intermediate grayscale line pixels.
+ 	 */
+ 	src32 = kmalloc(len_src32 + linepixels, GFP_KERNEL);
+ 	if (!src32)
+ 		return;
+ 
+ 	gray8 = (u8 *)src32 + len_src32;
+ 
+ 	/*
+ 	 * For damage handling, it is possible that only parts of the source
+ 	 * buffer is copied and this could lead to start and end pixels that
+ 	 * are not aligned to multiple of 8.
+ 	 *
+ 	 * Calculate if the start and end pixels are not aligned and set the
+ 	 * offsets for the mono line conversion function to adjust.
+ 	 */
+ 	start_offset = clip->x1 % 8;
+ 	end_len = clip->x2 % 8;
+ 
+ 	vaddr += clip_offset(clip, fb->pitches[0], cpp);
+ 	for (y = 0; y < lines; y++) {
+ 		src32 = memcpy(src32, vaddr, len_src32);
+ 		drm_fb_xrgb8888_to_gray8_line(gray8, src32, linepixels);
+ 		drm_fb_gray8_to_mono_line(mono, gray8, dst_pitch, start_offset, end_len);
+ 		vaddr += fb->pitches[0];
+ 		mono += dst_pitch;
+ 	}
+ 
+ 	kfree(src32);
+ }
+ EXPORT_SYMBOL(drm_fb_xrgb8888_to_mono);
++>>>>>>> 9b13a3fcd35f (drm/format-helper: Rename drm_fb_xrgb8888_to_mono_reversed())
diff --cc drivers/gpu/drm/tiny/repaper.c
index 2cee07a2e00b,c7018dd1b831..000000000000
--- a/drivers/gpu/drm/tiny/repaper.c
+++ b/drivers/gpu/drm/tiny/repaper.c
@@@ -558,23 -536,13 +558,27 @@@ static int repaper_fb_dirty(struct drm_
  		goto out_exit;
  	}
  
 -	ret = drm_gem_fb_begin_cpu_access(fb, DMA_FROM_DEVICE);
 -	if (ret)
 -		goto out_free;
 +	if (import_attach) {
 +		ret = dma_buf_begin_cpu_access(import_attach->dmabuf,
 +					       DMA_FROM_DEVICE);
 +		if (ret)
 +			goto out_free;
 +	}
  
++<<<<<<< HEAD
 +	drm_fb_xrgb8888_to_gray8(buf, cma_obj->vaddr, fb, &clip);
++=======
+ 	drm_fb_xrgb8888_to_mono(buf, 0, cma_obj->vaddr, fb, &clip);
++>>>>>>> 9b13a3fcd35f (drm/format-helper: Rename drm_fb_xrgb8888_to_mono_reversed())
 +
 +	if (import_attach) {
 +		ret = dma_buf_end_cpu_access(import_attach->dmabuf,
 +					     DMA_FROM_DEVICE);
 +		if (ret)
 +			goto out_free;
 +	}
  
 -	drm_gem_fb_end_cpu_access(fb, DMA_FROM_DEVICE);
 +	repaper_gray8_to_mono_reversed(buf, fb->width, fb->height);
  
  	if (epd->partial) {
  		repaper_frame_data_repeat(epd, buf, epd->current_frame,
diff --cc include/drm/drm_format_helper.h
index 4e0258a61311,55145eca0782..000000000000
--- a/include/drm/drm_format_helper.h
+++ b/include/drm/drm_format_helper.h
@@@ -9,31 -9,41 +9,66 @@@
  struct drm_framebuffer;
  struct drm_rect;
  
 -unsigned int drm_fb_clip_offset(unsigned int pitch, const struct drm_format_info *format,
 -				const struct drm_rect *clip);
 +void drm_fb_memcpy(void *dst, void *vaddr, struct drm_framebuffer *fb,
 +		   struct drm_rect *clip);
 +void drm_fb_memcpy_dstclip(void __iomem *dst, unsigned int dst_pitch, void *vaddr,
 +			   struct drm_framebuffer *fb,
 +			   struct drm_rect *clip);
 +void drm_fb_swab(void *dst, void *src, struct drm_framebuffer *fb,
 +		 struct drm_rect *clip, bool cached);
 +void drm_fb_xrgb8888_to_rgb565(void *dst, void *vaddr,
 +			       struct drm_framebuffer *fb,
 +			       struct drm_rect *clip, bool swab);
 +void drm_fb_xrgb8888_to_rgb565_dstclip(void __iomem *dst, unsigned int dst_pitch,
 +				       void *vaddr, struct drm_framebuffer *fb,
 +				       struct drm_rect *clip, bool swab);
 +void drm_fb_xrgb8888_to_rgb888_dstclip(void __iomem *dst, unsigned int dst_pitch,
 +				       void *vaddr, struct drm_framebuffer *fb,
 +				       struct drm_rect *clip);
 +void drm_fb_xrgb8888_to_gray8(u8 *dst, void *vaddr, struct drm_framebuffer *fb,
 +			      struct drm_rect *clip);
  
++<<<<<<< HEAD
 +int drm_fb_blit_rect_dstclip(void __iomem *dst, unsigned int dst_pitch,
 +			     uint32_t dst_format, void *vmap,
 +			     struct drm_framebuffer *fb,
 +			     struct drm_rect *rect);
 +int drm_fb_blit_dstclip(void __iomem *dst, unsigned int dst_pitch,
 +			uint32_t dst_format, void *vmap,
 +			struct drm_framebuffer *fb);
++=======
+ void drm_fb_memcpy(void *dst, unsigned int dst_pitch, const void *vaddr,
+ 		   const struct drm_framebuffer *fb, const struct drm_rect *clip);
+ void drm_fb_memcpy_toio(void __iomem *dst, unsigned int dst_pitch, const void *vaddr,
+ 			const struct drm_framebuffer *fb, const struct drm_rect *clip);
+ void drm_fb_swab(void *dst, unsigned int dst_pitch, const void *src,
+ 		 const struct drm_framebuffer *fb, const struct drm_rect *clip,
+ 		 bool cached);
+ void drm_fb_xrgb8888_to_rgb332(void *dst, unsigned int dst_pitch, const void *vaddr,
+ 			       const struct drm_framebuffer *fb, const struct drm_rect *clip);
+ void drm_fb_xrgb8888_to_rgb565(void *dst, unsigned int dst_pitch, const void *vaddr,
+ 			       const struct drm_framebuffer *fb, const struct drm_rect *clip,
+ 			       bool swab);
+ void drm_fb_xrgb8888_to_rgb565_toio(void __iomem *dst, unsigned int dst_pitch,
+ 				    const void *vaddr, const struct drm_framebuffer *fb,
+ 				    const struct drm_rect *clip, bool swab);
+ void drm_fb_xrgb8888_to_rgb888(void *dst, unsigned int dst_pitch, const void *src,
+ 			       const struct drm_framebuffer *fb, const struct drm_rect *clip);
+ void drm_fb_xrgb8888_to_rgb888_toio(void __iomem *dst, unsigned int dst_pitch,
+ 				    const void *vaddr, const struct drm_framebuffer *fb,
+ 				    const struct drm_rect *clip);
+ void drm_fb_xrgb8888_to_xrgb2101010_toio(void __iomem *dst, unsigned int dst_pitch,
+ 					 const void *vaddr, const struct drm_framebuffer *fb,
+ 					 const struct drm_rect *clip);
+ void drm_fb_xrgb8888_to_gray8(void *dst, unsigned int dst_pitch, const void *vaddr,
+ 			      const struct drm_framebuffer *fb, const struct drm_rect *clip);
+ 
+ int drm_fb_blit_toio(void __iomem *dst, unsigned int dst_pitch, uint32_t dst_format,
+ 		     const void *vmap, const struct drm_framebuffer *fb,
+ 		     const struct drm_rect *rect);
+ 
+ void drm_fb_xrgb8888_to_mono(void *dst, unsigned int dst_pitch, const void *src,
+ 			     const struct drm_framebuffer *fb, const struct drm_rect *clip);
++>>>>>>> 9b13a3fcd35f (drm/format-helper: Rename drm_fb_xrgb8888_to_mono_reversed())
  
  #endif /* __LINUX_DRM_FORMAT_HELPER_H */
* Unmerged path drivers/gpu/drm/solomon/ssd130x.c
* Unmerged path drivers/gpu/drm/drm_format_helper.c
* Unmerged path drivers/gpu/drm/solomon/ssd130x.c
* Unmerged path drivers/gpu/drm/tiny/repaper.c
* Unmerged path include/drm/drm_format_helper.h
