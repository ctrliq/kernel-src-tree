PCI: vmd: Create IRQ Domain configuration helper

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-425.3.1.el8
commit-author Jon Derrick <jonathan.derrick@intel.com>
commit 1552b11ba15e93ee550c4672aa5acd8c1c5e8a82
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-425.3.1.el8/1552b11b.failed

Move the IRQ and MSI Domain configuration code to new helpers. No
functional changes.

Link: https://lore.kernel.org/r/20200728194945.14126-4-jonathan.derrick@intel.com
	Signed-off-by: Jon Derrick <jonathan.derrick@intel.com>
	Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
	Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
	Reviewed-by: Andy Shevchenko <andriy.shevchenko@intel.com>
(cherry picked from commit 1552b11ba15e93ee550c4672aa5acd8c1c5e8a82)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/pci/controller/vmd.c
diff --cc drivers/pci/controller/vmd.c
index c9d11101290f,703c48171993..000000000000
--- a/drivers/pci/controller/vmd.c
+++ b/drivers/pci/controller/vmd.c
@@@ -293,16 -298,46 +293,48 @@@ static struct msi_domain_info vmd_msi_d
  	.chip		= &vmd_msi_controller,
  };
  
++<<<<<<< HEAD
 +static void __iomem *vmd_cfg_addr(struct vmd_dev *vmd, struct pci_bus *bus,
++=======
+ static int vmd_create_irq_domain(struct vmd_dev *vmd)
+ {
+ 	struct fwnode_handle *fn;
+ 
+ 	fn = irq_domain_alloc_named_id_fwnode("VMD-MSI", vmd->sysdata.domain);
+ 	if (!fn)
+ 		return -ENODEV;
+ 
+ 	vmd->irq_domain = pci_msi_create_irq_domain(fn, &vmd_msi_domain_info,
+ 						    x86_vector_domain);
+ 	if (!vmd->irq_domain) {
+ 		irq_domain_free_fwnode(fn);
+ 		return -ENODEV;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static void vmd_remove_irq_domain(struct vmd_dev *vmd)
+ {
+ 	if (vmd->irq_domain) {
+ 		struct fwnode_handle *fn = vmd->irq_domain->fwnode;
+ 
+ 		irq_domain_remove(vmd->irq_domain);
+ 		irq_domain_free_fwnode(fn);
+ 	}
+ }
+ 
+ static char __iomem *vmd_cfg_addr(struct vmd_dev *vmd, struct pci_bus *bus,
++>>>>>>> 1552b11ba15e (PCI: vmd: Create IRQ Domain configuration helper)
  				  unsigned int devfn, int reg, int len)
  {
 -	char __iomem *addr = vmd->cfgbar +
 -			     ((bus->number - vmd->busn_start) << 20) +
 -			     (devfn << 12) + reg;
 +	unsigned int busnr_ecam = bus->number - vmd->busn_start;
 +	u32 offset = PCIE_ECAM_OFFSET(busnr_ecam, devfn, reg);
  
 -	if ((addr - vmd->cfgbar) + len >=
 -	    resource_size(&vmd->dev->resource[VMD_CFGBAR]))
 +	if (offset + len >= resource_size(&vmd->dev->resource[VMD_CFGBAR]))
  		return NULL;
  
 -	return addr;
 +	return vmd->cfgbar + offset;
  }
  
  /*
@@@ -641,23 -625,9 +672,29 @@@ static int vmd_enable_domain(struct vmd
  
  	sd->node = pcibus_to_node(vmd->dev->bus);
  
++<<<<<<< HEAD
 +	fn = irq_domain_alloc_named_id_fwnode("VMD-MSI", vmd->sysdata.domain);
 +	if (!fn)
 +		return -ENODEV;
 +
 +	vmd->irq_domain = pci_msi_create_irq_domain(fn, &vmd_msi_domain_info,
 +						    NULL);
 +
 +	if (!vmd->irq_domain) {
 +		irq_domain_free_fwnode(fn);
 +		return -ENODEV;
 +	}
++=======
+ 	ret = vmd_create_irq_domain(vmd);
+ 	if (ret)
+ 		return ret;
++>>>>>>> 1552b11ba15e (PCI: vmd: Create IRQ Domain configuration helper)
 +
 +	/*
 +	 * Override the irq domain bus token so the domain can be distinguished
 +	 * from a regular PCI/MSI domain.
 +	 */
 +	irq_domain_update_bus_token(vmd->irq_domain, DOMAIN_BUS_VMD_MSI);
  
  	pci_add_resource(&resources, &vmd->resources[0]);
  	pci_add_resource_offset(&resources, &vmd->resources[1], offset[0]);
@@@ -673,10 -642,9 +709,11 @@@
  	}
  
  	vmd_attach_resources(vmd);
- 	dev_set_msi_domain(&vmd->bus->dev, vmd->irq_domain);
+ 	if (vmd->irq_domain)
+ 		dev_set_msi_domain(&vmd->bus->dev, vmd->irq_domain);
  
 +	vmd_acpi_begin();
 +
  	pci_scan_child_bus(vmd->bus);
  	pci_assign_unassigned_bus_resources(vmd->bus);
  
* Unmerged path drivers/pci/controller/vmd.c
