driver core: Refactor sysfs and drv/bus remove hooks

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-425.3.1.el8
commit-author Rob Herring <robh@kernel.org>
commit 4b775aaf1ea9997f5eb1a792f357a7b81a1fc632
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-425.3.1.el8/4b775aaf.failed

There are 3 copies of the same device sysfs cleanup and drv/bus remove()
hooks used for probe failure, testing re-probing, and device unbinding.

Let's refactor the code to its own function.

	Signed-off-by: Rob Herring <robh@kernel.org>
Link: https://lore.kernel.org/r/20220223225257.1681968-3-robh@kernel.org
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 4b775aaf1ea9997f5eb1a792f357a7b81a1fc632)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/base/dd.c
diff --cc drivers/base/dd.c
index f665c7e7c258,dbf9f0ada713..000000000000
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@@ -555,7 -506,31 +555,18 @@@ static ssize_t state_synced_show(struc
  }
  static DEVICE_ATTR_RO(state_synced);
  
 -static void device_unbind_cleanup(struct device *dev)
 -{
 -	devres_release_all(dev);
 -	arch_teardown_dma_ops(dev);
 -	kfree(dev->dma_range_map);
 -	dev->dma_range_map = NULL;
 -	dev->driver = NULL;
 -	dev_set_drvdata(dev, NULL);
 -	if (dev->pm_domain && dev->pm_domain->dismiss)
 -		dev->pm_domain->dismiss(dev);
 -	pm_runtime_reinit(dev);
 -	dev_pm_set_driver_flags(dev, 0);
 -}
  
+ static void device_remove(struct device *dev)
+ {
+ 	device_remove_file(dev, &dev_attr_state_synced);
+ 	device_remove_groups(dev, dev->driver->dev_groups);
+ 
+ 	if (dev->bus && dev->bus->remove)
+ 		dev->bus->remove(dev);
+ 	else if (dev->driver->remove)
+ 		dev->driver->remove(dev);
+ }
+ 
  static int call_driver_probe(struct device *dev, struct device_driver *drv)
  {
  	int ret = 0;
@@@ -661,24 -644,9 +672,28 @@@ re_probe
  	if (test_remove) {
  		test_remove = false;
  
++<<<<<<< HEAD
 +		device_remove_file(dev, &dev_attr_state_synced);
 +		device_remove_groups(dev, drv->dev_groups);
 +
 +		if (dev->bus->remove)
 +			dev->bus->remove(dev);
 +		else if (drv->remove)
 +			drv->remove(dev);
 +
 +		devres_release_all(dev);
 +		arch_teardown_dma_ops(dev);
 +		kfree(dev->dma_range_map);
 +		dev->dma_range_map = NULL;
++=======
+ 		device_remove(dev);
++>>>>>>> 4b775aaf1ea9 (driver core: Refactor sysfs and drv/bus remove hooks)
  		driver_sysfs_remove(dev);
 -		device_unbind_cleanup(dev);
 +		dev->driver = NULL;
 +		dev_set_drvdata(dev, NULL);
 +		if (dev->pm_domain && dev->pm_domain->dismiss)
 +			dev->pm_domain->dismiss(dev);
 +		pm_runtime_reinit(dev);
  
  		goto re_probe;
  	}
@@@ -694,13 -662,11 +709,9 @@@
  	goto done;
  
  dev_sysfs_state_synced_failed:
- 	device_remove_groups(dev, drv->dev_groups);
  dev_groups_failed:
- 	if (dev->bus->remove)
- 		dev->bus->remove(dev);
- 	else if (drv->remove)
- 		drv->remove(dev);
+ 	device_remove(dev);
  probe_failed:
 -	driver_sysfs_remove(dev);
 -sysfs_failed:
  	if (dev->bus)
  		blocking_notifier_call_chain(&dev->bus->p->bus_notifier,
  					     BUS_NOTIFY_DRIVER_NOT_BOUND, dev);
@@@ -1195,26 -1196,10 +1206,20 @@@ static void __device_release_driver(str
  
  		pm_runtime_put_sync(dev);
  
- 		device_remove_file(dev, &dev_attr_state_synced);
- 		device_remove_groups(dev, drv->dev_groups);
- 
- 		if (dev->bus && dev->bus->remove)
- 			dev->bus->remove(dev);
- 		else if (drv->remove)
- 			drv->remove(dev);
+ 		device_remove(dev);
  
  		device_links_driver_cleanup(dev);
 -		device_unbind_cleanup(dev);
 +
 +		devres_release_all(dev);
 +		arch_teardown_dma_ops(dev);
 +		kfree(dev->dma_range_map);
 +		dev->dma_range_map = NULL;
 +		dev->driver = NULL;
 +		dev_set_drvdata(dev, NULL);
 +		if (dev->pm_domain && dev->pm_domain->dismiss)
 +			dev->pm_domain->dismiss(dev);
 +		pm_runtime_reinit(dev);
 +		dev_pm_set_driver_flags(dev, 0);
  
  		klist_remove(&dev->p->knode_driver);
  		device_pm_check_callbacks(dev);
* Unmerged path drivers/base/dd.c
