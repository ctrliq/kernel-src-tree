netfilter: conntrack: improve RST handling when tuple is re-used

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-425.3.1.el8
commit-author Ali Abdallah <aabdallah@suse.de>
commit c4edc3ccbc63947e697bd2e30afca8bfaa144998
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-425.3.1.el8/c4edc3cc.failed

If we receive a SYN packet in original direction on an existing
connection tracking entry, we let this SYN through because conntrack
might be out-of-sync.

Conntrack gets back in sync when server responds with SYN/ACK and state
gets updated accordingly.

However, if server replies with RST, this packet might be marked as
INVALID because td_maxack value reflects the *old* conntrack state
and not the state of the originator of the RST.

Avoid td_maxack-based checks if previous packet was a SYN.

Unfortunately that is not be enough: an out of order ACK in original
direction updates last_index, so we still end up marking valid RST.

Thus disable the sequence check when we are not in established state and
the received RST has a sequence of 0.

Because marking RSTs as invalid usually leads to unwanted timeouts,
also skip RST sequence checks if a conntrack entry is already closing.

Such entries can already be evicted via GC in case the table is full.

Co-developed-by: Florian Westphal <fw@strlen.de>
	Signed-off-by: Florian Westphal <fw@strlen.de>
	Signed-off-by: Ali Abdallah <aabdallah@suse.de>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit c4edc3ccbc63947e697bd2e30afca8bfaa144998)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/nf_conntrack_proto_tcp.c
diff --cc net/netfilter/nf_conntrack_proto_tcp.c
index f9bb6bbd54e2,b8ff67671e93..000000000000
--- a/net/netfilter/nf_conntrack_proto_tcp.c
+++ b/net/netfilter/nf_conntrack_proto_tcp.c
@@@ -853,14 -823,20 +853,31 @@@ static noinline bool tcp_new(struct nf_
  	return true;
  }
  
++<<<<<<< HEAD
 +static void nf_ct_tcp_state_reset(struct ip_ct_tcp_state *state)
 +{
 +	state->td_end		= 0;
 +	state->td_maxend	= 0;
 +	state->td_maxwin	= 0;
 +	state->td_maxack	= 0;
 +	state->td_scale		= 0;
 +	state->flags		&= IP_CT_TCP_FLAG_BE_LIBERAL;
++=======
+ static bool tcp_can_early_drop(const struct nf_conn *ct)
+ {
+ 	switch (ct->proto.tcp.state) {
+ 	case TCP_CONNTRACK_FIN_WAIT:
+ 	case TCP_CONNTRACK_LAST_ACK:
+ 	case TCP_CONNTRACK_TIME_WAIT:
+ 	case TCP_CONNTRACK_CLOSE:
+ 	case TCP_CONNTRACK_CLOSE_WAIT:
+ 		return true;
+ 	default:
+ 		break;
+ 	}
+ 
+ 	return false;
++>>>>>>> c4edc3ccbc63 (netfilter: conntrack: improve RST handling when tuple is re-used)
  }
  
  /* Returns verdict for packet, or -1 for invalid. */
* Unmerged path net/netfilter/nf_conntrack_proto_tcp.c
