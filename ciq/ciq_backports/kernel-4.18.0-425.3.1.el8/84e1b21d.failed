NFSD add ca_source_server<> to COPY

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-425.3.1.el8
commit-author Olga Kornievskaia <olga.kornievskaia@gmail.com>
commit 84e1b21d5ec4cc1b005586f32c67c046ea4ffb8a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-425.3.1.el8/84e1b21d.failed

Decode the ca_source_server list that's sent but only use the
first one. Presence of non-zero list indicates an "inter" copy.

	Signed-off-by: Andy Adamson <andros@netapp.com>
	Signed-off-by: Olga Kornievskaia <kolga@netapp.com>
(cherry picked from commit 84e1b21d5ec4cc1b005586f32c67c046ea4ffb8a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfsd/nfs4xdr.c
diff --cc fs/nfsd/nfs4xdr.c
index 26d3a2c1c5e6,a1d839406dc1..000000000000
--- a/fs/nfsd/nfs4xdr.c
+++ b/fs/nfsd/nfs4xdr.c
@@@ -40,8 -40,7 +40,12 @@@
  #include <linux/utsname.h>
  #include <linux/pagemap.h>
  #include <linux/sunrpc/svcauth_gss.h>
++<<<<<<< HEAD
 +#include <linux/xattr.h>
 +#include <uapi/linux/xattr.h>
++=======
+ #include <linux/sunrpc/addr.h>
++>>>>>>> 84e1b21d5ec4 (NFSD add ca_source_server<> to COPY)
  
  #include "idmap.h"
  #include "acl.h"
@@@ -1855,234 -1729,105 +1859,312 @@@ nfsd4_decode_fallocate(struct nfsd4_com
  static __be32
  nfsd4_decode_clone(struct nfsd4_compoundargs *argp, struct nfsd4_clone *clone)
  {
 -	DECODE_HEAD;
 +	__be32 status;
  
 -	status = nfsd4_decode_stateid(argp, &clone->cl_src_stateid);
 +	status = nfsd4_decode_stateid4(argp, &clone->cl_src_stateid);
  	if (status)
  		return status;
 -	status = nfsd4_decode_stateid(argp, &clone->cl_dst_stateid);
 +	status = nfsd4_decode_stateid4(argp, &clone->cl_dst_stateid);
  	if (status)
  		return status;
 +	if (xdr_stream_decode_u64(argp->xdr, &clone->cl_src_pos) < 0)
 +		return nfserr_bad_xdr;
 +	if (xdr_stream_decode_u64(argp->xdr, &clone->cl_dst_pos) < 0)
 +		return nfserr_bad_xdr;
 +	if (xdr_stream_decode_u64(argp->xdr, &clone->cl_count) < 0)
 +		return nfserr_bad_xdr;
  
 -	READ_BUF(8 + 8 + 8);
 -	p = xdr_decode_hyper(p, &clone->cl_src_pos);
 -	p = xdr_decode_hyper(p, &clone->cl_dst_pos);
 -	p = xdr_decode_hyper(p, &clone->cl_count);
 -	DECODE_TAIL;
 +	return nfs_ok;
  }
  
+ static __be32 nfsd4_decode_nl4_server(struct nfsd4_compoundargs *argp,
+ 				      struct nl4_server *ns)
+ {
+ 	DECODE_HEAD;
+ 	struct nfs42_netaddr *naddr;
+ 
+ 	READ_BUF(4);
+ 	ns->nl4_type = be32_to_cpup(p++);
+ 
+ 	/* currently support for 1 inter-server source server */
+ 	switch (ns->nl4_type) {
+ 	case NL4_NETADDR:
+ 		naddr = &ns->u.nl4_addr;
+ 
+ 		READ_BUF(4);
+ 		naddr->netid_len = be32_to_cpup(p++);
+ 		if (naddr->netid_len > RPCBIND_MAXNETIDLEN)
+ 			goto xdr_error;
+ 
+ 		READ_BUF(naddr->netid_len + 4); /* 4 for uaddr len */
+ 		COPYMEM(naddr->netid, naddr->netid_len);
+ 
+ 		naddr->addr_len = be32_to_cpup(p++);
+ 		if (naddr->addr_len > RPCBIND_MAXUADDRLEN)
+ 			goto xdr_error;
+ 
+ 		READ_BUF(naddr->addr_len);
+ 		COPYMEM(naddr->addr, naddr->addr_len);
+ 		break;
+ 	default:
+ 		goto xdr_error;
+ 	}
+ 	DECODE_TAIL;
+ }
+ 
  static __be32
  nfsd4_decode_copy(struct nfsd4_compoundargs *argp, struct nfsd4_copy *copy)
  {
++<<<<<<< HEAD
 +	u32 consecutive;
 +	__be32 status;
++=======
+ 	DECODE_HEAD;
+ 	struct nl4_server *ns_dummy;
+ 	int i, count;
++>>>>>>> 84e1b21d5ec4 (NFSD add ca_source_server<> to COPY)
 +
 +	status = nfsd4_decode_stateid4(argp, &copy->cp_src_stateid);
 +	if (status)
 +		return status;
 +	status = nfsd4_decode_stateid4(argp, &copy->cp_dst_stateid);
 +	if (status)
 +		return status;
 +	if (xdr_stream_decode_u64(argp->xdr, &copy->cp_src_pos) < 0)
 +		return nfserr_bad_xdr;
 +	if (xdr_stream_decode_u64(argp->xdr, &copy->cp_dst_pos) < 0)
 +		return nfserr_bad_xdr;
 +	if (xdr_stream_decode_u64(argp->xdr, &copy->cp_count) < 0)
 +		return nfserr_bad_xdr;
 +	/* ca_consecutive: we always do consecutive copies */
 +	if (xdr_stream_decode_u32(argp->xdr, &consecutive) < 0)
 +		return nfserr_bad_xdr;
 +	if (xdr_stream_decode_u32(argp->xdr, &copy->cp_synchronous) < 0)
 +		return nfserr_bad_xdr;
 +
++<<<<<<< HEAD
 +	return nfs_ok;
++=======
++	READ_BUF(8 + 8 + 8 + 4 + 4 + 4);
++	p = xdr_decode_hyper(p, &copy->cp_src_pos);
++	p = xdr_decode_hyper(p, &copy->cp_dst_pos);
++	p = xdr_decode_hyper(p, &copy->cp_count);
++	p++; /* ca_consecutive: we always do consecutive copies */
++	copy->cp_synchronous = be32_to_cpup(p++);
++
++	count = be32_to_cpup(p++);
++
++	copy->cp_intra = false;
++	if (count == 0) { /* intra-server copy */
++		copy->cp_intra = true;
++		goto intra;
++	}
++
++	/* decode all the supplied server addresses but use first */
++	status = nfsd4_decode_nl4_server(argp, &copy->cp_src);
++	if (status)
++		return status;
++
++	ns_dummy = kmalloc(sizeof(struct nl4_server), GFP_KERNEL);
++	if (ns_dummy == NULL)
++		return nfserrno(-ENOMEM);
++	for (i = 0; i < count - 1; i++) {
++		status = nfsd4_decode_nl4_server(argp, ns_dummy);
++		if (status) {
++			kfree(ns_dummy);
++			return status;
++		}
++	}
++	kfree(ns_dummy);
++intra:
++
++	DECODE_TAIL;
++>>>>>>> 84e1b21d5ec4 (NFSD add ca_source_server<> to COPY)
 +}
 +
 +static __be32
 +nfsd4_decode_offload_status(struct nfsd4_compoundargs *argp,
 +			    struct nfsd4_offload_status *os)
 +{
 +	return nfsd4_decode_stateid4(argp, &os->stateid);
 +}
 +
 +static __be32
 +nfsd4_decode_seek(struct nfsd4_compoundargs *argp, struct nfsd4_seek *seek)
 +{
 +	__be32 status;
 +
 +	status = nfsd4_decode_stateid4(argp, &seek->seek_stateid);
 +	if (status)
 +		return status;
 +	if (xdr_stream_decode_u64(argp->xdr, &seek->seek_offset) < 0)
 +		return nfserr_bad_xdr;
 +	if (xdr_stream_decode_u32(argp->xdr, &seek->seek_whence) < 0)
 +		return nfserr_bad_xdr;
 +
 +	return nfs_ok;
 +}
 +
 +/*
 + * XDR data that is more than PAGE_SIZE in size is normally part of a
 + * read or write. However, the size of extended attributes is limited
 + * by the maximum request size, and then further limited by the underlying
 + * filesystem limits. This can exceed PAGE_SIZE (currently, XATTR_SIZE_MAX
 + * is 64k). Since there is no kvec- or page-based interface to xattrs,
 + * and we're not dealing with contiguous pages, we need to do some copying.
 + */
 +
 +/*
 + * Decode data into buffer.
 + */
 +static __be32
 +nfsd4_vbuf_from_vector(struct nfsd4_compoundargs *argp, struct xdr_buf *xdr,
 +		       char **bufp, u32 buflen)
 +{
 +	struct page **pages = xdr->pages;
 +	struct kvec *head = xdr->head;
 +	char *tmp, *dp;
 +	u32 len;
 +
 +	if (buflen <= head->iov_len) {
 +		/*
 +		 * We're in luck, the head has enough space. Just return
 +		 * the head, no need for copying.
 +		 */
 +		*bufp = head->iov_base;
 +		return 0;
 +	}
 +
 +	tmp = svcxdr_tmpalloc(argp, buflen);
 +	if (tmp == NULL)
 +		return nfserr_jukebox;
 +
 +	dp = tmp;
 +	memcpy(dp, head->iov_base, head->iov_len);
 +	buflen -= head->iov_len;
 +	dp += head->iov_len;
 +
 +	while (buflen > 0) {
 +		len = min_t(u32, buflen, PAGE_SIZE);
 +		memcpy(dp, page_address(*pages), len);
 +
 +		buflen -= len;
 +		dp += len;
 +		pages++;
 +	}
 +
 +	*bufp = tmp;
 +	return 0;
 +}
 +
 +/*
 + * Get a user extended attribute name from the XDR buffer.
 + * It will not have the "user." prefix, so prepend it.
 + * Lastly, check for nul characters in the name.
 + */
 +static __be32
 +nfsd4_decode_xattr_name(struct nfsd4_compoundargs *argp, char **namep)
 +{
 +	char *name, *sp, *dp;
 +	u32 namelen, cnt;
 +	__be32 *p;
 +
 +	if (xdr_stream_decode_u32(argp->xdr, &namelen) < 0)
 +		return nfserr_bad_xdr;
 +	if (namelen > (XATTR_NAME_MAX - XATTR_USER_PREFIX_LEN))
 +		return nfserr_nametoolong;
 +	if (namelen == 0)
 +		return nfserr_bad_xdr;
 +	p = xdr_inline_decode(argp->xdr, namelen);
 +	if (!p)
 +		return nfserr_bad_xdr;
 +	name = svcxdr_tmpalloc(argp, namelen + XATTR_USER_PREFIX_LEN + 1);
 +	if (!name)
 +		return nfserr_jukebox;
 +	memcpy(name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN);
 +
 +	/*
 +	 * Copy the extended attribute name over while checking for 0
 +	 * characters.
 +	 */
 +	sp = (char *)p;
 +	dp = name + XATTR_USER_PREFIX_LEN;
 +	cnt = namelen;
 +
 +	while (cnt-- > 0) {
 +		if (*sp == '\0')
 +			return nfserr_bad_xdr;
 +		*dp++ = *sp++;
 +	}
 +	*dp = '\0';
 +
 +	*namep = name;
 +
 +	return nfs_ok;
 +}
 +
 +/*
 + * A GETXATTR op request comes without a length specifier. We just set the
 + * maximum length for the reply based on XATTR_SIZE_MAX and the maximum
 + * channel reply size. nfsd_getxattr will probe the length of the xattr,
 + * check it against getxa_len, and allocate + return the value.
 + */
 +static __be32
 +nfsd4_decode_getxattr(struct nfsd4_compoundargs *argp,
 +		      struct nfsd4_getxattr *getxattr)
 +{
 +	__be32 status;
 +	u32 maxcount;
 +
 +	status = nfsd4_decode_xattr_name(argp, &getxattr->getxa_name);
 +	if (status)
 +		return status;
 +
 +	maxcount = svc_max_payload(argp->rqstp);
 +	maxcount = min_t(u32, XATTR_SIZE_MAX, maxcount);
 +
 +	getxattr->getxa_len = maxcount;
 +
 +	return status;
 +}
 +
 +static __be32
 +nfsd4_decode_setxattr(struct nfsd4_compoundargs *argp,
 +		      struct nfsd4_setxattr *setxattr)
 +{
 +	u32 flags, maxcount, size;
 +	__be32 status;
 +
 +	if (xdr_stream_decode_u32(argp->xdr, &flags) < 0)
 +		return nfserr_bad_xdr;
 +
 +	if (flags > SETXATTR4_REPLACE)
 +		return nfserr_inval;
 +	setxattr->setxa_flags = flags;
  
 -	status = nfsd4_decode_stateid(argp, &copy->cp_src_stateid);
 +	status = nfsd4_decode_xattr_name(argp, &setxattr->setxa_name);
  	if (status)
  		return status;
 -	status = nfsd4_decode_stateid(argp, &copy->cp_dst_stateid);
 -	if (status)
 -		return status;
 -
 -	READ_BUF(8 + 8 + 8 + 4 + 4 + 4);
 -	p = xdr_decode_hyper(p, &copy->cp_src_pos);
 -	p = xdr_decode_hyper(p, &copy->cp_dst_pos);
 -	p = xdr_decode_hyper(p, &copy->cp_count);
 -	p++; /* ca_consecutive: we always do consecutive copies */
 -	copy->cp_synchronous = be32_to_cpup(p++);
  
 -	count = be32_to_cpup(p++);
 +	maxcount = svc_max_payload(argp->rqstp);
 +	maxcount = min_t(u32, XATTR_SIZE_MAX, maxcount);
  
 -	copy->cp_intra = false;
 -	if (count == 0) { /* intra-server copy */
 -		copy->cp_intra = true;
 -		goto intra;
 -	}
 +	if (xdr_stream_decode_u32(argp->xdr, &size) < 0)
 +		return nfserr_bad_xdr;
 +	if (size > maxcount)
 +		return nfserr_xattr2big;
  
 -	/* decode all the supplied server addresses but use first */
 -	status = nfsd4_decode_nl4_server(argp, &copy->cp_src);
 -	if (status)
 -		return status;
 +	setxattr->setxa_len = size;
 +	if (size > 0) {
 +		struct xdr_buf payload;
  
 -	ns_dummy = kmalloc(sizeof(struct nl4_server), GFP_KERNEL);
 -	if (ns_dummy == NULL)
 -		return nfserrno(-ENOMEM);
 -	for (i = 0; i < count - 1; i++) {
 -		status = nfsd4_decode_nl4_server(argp, ns_dummy);
 -		if (status) {
 -			kfree(ns_dummy);
 -			return status;
 -		}
 +		if (!xdr_stream_subsegment(argp->xdr, &payload, size))
 +			return nfserr_bad_xdr;
 +		status = nfsd4_vbuf_from_vector(argp, &payload,
 +						&setxattr->setxa_buf, size);
  	}
 -	kfree(ns_dummy);
 -intra:
  
 -	DECODE_TAIL;
 +	return nfs_ok;
  }
  
  static __be32
* Unmerged path fs/nfsd/nfs4xdr.c
diff --git a/fs/nfsd/xdr4.h b/fs/nfsd/xdr4.h
index 637ca6f30bd1..5ae44b707a07 100644
--- a/fs/nfsd/xdr4.h
+++ b/fs/nfsd/xdr4.h
@@ -533,11 +533,13 @@ struct nfsd42_write_res {
 
 struct nfsd4_copy {
 	/* request */
-	stateid_t	cp_src_stateid;
-	stateid_t	cp_dst_stateid;
-	u64		cp_src_pos;
-	u64		cp_dst_pos;
-	u64		cp_count;
+	stateid_t		cp_src_stateid;
+	stateid_t		cp_dst_stateid;
+	u64			cp_src_pos;
+	u64			cp_dst_pos;
+	u64			cp_count;
+	struct nl4_server	cp_src;
+	bool			cp_intra;
 
 	/* both */
 	u32			cp_synchronous;
