arm64: Use ELF fields defined in 'struct kimage'

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-425.3.1.el8
commit-author Lakshmi Ramasubramanian <nramas@linux.microsoft.com>
commit 7b558cc3564e6c9ab2047c82e4a555e1d771ea1b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-425.3.1.el8/7b558cc3.failed

ELF related fields elf_headers, elf_headers_sz, and elf_headers_mem
have been moved from 'struct kimage_arch' to 'struct kimage' as
elf_headers, elf_headers_sz, and elf_load_addr respectively.

Use the ELF fields defined in 'struct kimage'.

	Suggested-by: Rob Herring <robh@kernel.org>
	Reported-by: kernel test robot <lkp@intel.com>
	Signed-off-by: Lakshmi Ramasubramanian <nramas@linux.microsoft.com>
	Reviewed-by: Thiago Jung Bauermann <bauerman@linux.ibm.com>
	Signed-off-by: Rob Herring <robh@kernel.org>
Link: https://lore.kernel.org/r/20210221174930.27324-3-nramas@linux.microsoft.com
(cherry picked from commit 7b558cc3564e6c9ab2047c82e4a555e1d771ea1b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/arm64/include/asm/kexec.h
diff --cc arch/arm64/include/asm/kexec.h
index 660705515e33,00dbcc71aeb2..000000000000
--- a/arch/arm64/include/asm/kexec.h
+++ b/arch/arm64/include/asm/kexec.h
@@@ -98,13 -94,11 +98,18 @@@ static inline void crash_post_resume(vo
  
  struct kimage_arch {
  	void *dtb;
++<<<<<<< HEAD
 +	unsigned long dtb_mem;
 +	/* Core ELF header buffer */
 +	void *elf_headers;
 +	unsigned long elf_headers_mem;
 +	unsigned long elf_headers_sz;
++=======
+ 	phys_addr_t dtb_mem;
+ 	phys_addr_t kern_reloc;
++>>>>>>> 7b558cc3564e (arm64: Use ELF fields defined in 'struct kimage')
  };
  
 -#ifdef CONFIG_KEXEC_FILE
  extern const struct kexec_file_ops kexec_image_ops;
  
  struct kimage;
* Unmerged path arch/arm64/include/asm/kexec.h
diff --git a/arch/arm64/kernel/machine_kexec_file.c b/arch/arm64/kernel/machine_kexec_file.c
index ebbbd493d254..721e653b6ab2 100644
--- a/arch/arm64/kernel/machine_kexec_file.c
+++ b/arch/arm64/kernel/machine_kexec_file.c
@@ -41,9 +41,9 @@ int arch_kimage_file_post_load_cleanup(struct kimage *image)
 	vfree(image->arch.dtb);
 	image->arch.dtb = NULL;
 
-	vfree(image->arch.elf_headers);
-	image->arch.elf_headers = NULL;
-	image->arch.elf_headers_sz = 0;
+	vfree(image->elf_headers);
+	image->elf_headers = NULL;
+	image->elf_headers_sz = 0;
 
 	return kexec_image_post_load_cleanup_default(image);
 }
@@ -71,8 +71,8 @@ static int setup_dtb(struct kimage *image,
 		/* add linux,elfcorehdr */
 		ret = fdt_appendprop_addrrange(dtb, 0, off,
 				FDT_PROP_KEXEC_ELFHDR,
-				image->arch.elf_headers_mem,
-				image->arch.elf_headers_sz);
+				image->elf_load_addr,
+				image->elf_headers_sz);
 		if (ret)
 			return (ret == -FDT_ERR_NOSPACE ? -ENOMEM : -EINVAL);
 
@@ -264,12 +264,12 @@ int load_other_segments(struct kimage *image,
 			vfree(headers);
 			goto out_err;
 		}
-		image->arch.elf_headers = headers;
-		image->arch.elf_headers_mem = kbuf.mem;
-		image->arch.elf_headers_sz = headers_sz;
+		image->elf_headers = headers;
+		image->elf_load_addr = kbuf.mem;
+		image->elf_headers_sz = headers_sz;
 
 		pr_debug("Loaded elf core header at 0x%lx bufsz=0x%lx memsz=0x%lx\n",
-			 image->arch.elf_headers_mem, kbuf.bufsz, kbuf.memsz);
+			 image->elf_load_addr, kbuf.bufsz, kbuf.memsz);
 	}
 
 	/* load initrd */
