drm/ast: Fix black screen when getting out of suspend

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-425.3.1.el8
commit-author Jocelyn Falempe <jfalempe@redhat.com>
commit 5171660cbb14f3359e8a8bf7523afb0789fe1bcd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-425.3.1.el8/5171660c.failed

With an AST2600, the screen is garbage when going out of suspend.
This is because color settings are lost, and not restored on resume.
Force the color settings on DPMS_ON, to make sure the settings are correct.

I didn't write this code, it comes from the out-of-tree aspeed driver v1.13
https://www.aspeedtech.com/support_driver/

	Signed-off-by: Jocelyn Falempe <jfalempe@redhat.com>
	Tested-by: Venkat Tadikonda <venkateswara.rao@intel.com>
	Reviewed-by: Lyude Paul <lyude@redhat.com>
	Acked-by: Thomas Zimmermann <tzimmermann@suse.de>
	Tested-by: Thomas Zimmermann <tzimmermann@suse.de>
Link: https://patchwork.freedesktop.org/patch/msgid/20220622124815.356035-1-jfalempe@redhat.com
(cherry picked from commit 5171660cbb14f3359e8a8bf7523afb0789fe1bcd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/ast/ast_mode.c
diff --cc drivers/gpu/drm/ast/ast_mode.c
index 67c0e273b104,4a91605b4654..000000000000
--- a/drivers/gpu/drm/ast/ast_mode.c
+++ b/drivers/gpu/drm/ast/ast_mode.c
@@@ -989,22 -989,120 +989,55 @@@ err_drm_gem_vram_put
  static void ast_crtc_dpms(struct drm_crtc *crtc, int mode)
  {
  	struct ast_private *ast = to_ast_private(crtc->dev);
++<<<<<<< HEAD
++=======
+ 	u8 ch = AST_DPMS_VSYNC_OFF | AST_DPMS_HSYNC_OFF;
+ 	struct ast_crtc_state *ast_state;
+ 	const struct drm_format_info *format;
+ 	struct ast_vbios_mode_info *vbios_mode_info;
++>>>>>>> 5171660cbb14 (drm/ast: Fix black screen when getting out of suspend)
  
  	/* TODO: Maybe control display signal generation with
  	 *       Sync Enable (bit CR17.7).
  	 */
  	switch (mode) {
  	case DRM_MODE_DPMS_ON:
++<<<<<<< HEAD
++=======
+ 		ast_set_index_reg_mask(ast, AST_IO_SEQ_PORT,  0x01, 0xdf, 0);
+ 		ast_set_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xb6, 0xfc, 0);
+ 		if (ast->tx_chip_types & AST_TX_DP501_BIT)
+ 			ast_set_dp501_video_output(crtc->dev, 1);
+ 
+ 		if (ast->tx_chip_types & AST_TX_ASTDP_BIT) {
+ 			ast_dp_power_on_off(crtc->dev, AST_DP_POWER_ON);
+ 			ast_wait_for_vretrace(ast);
+ 			ast_dp_set_on_off(crtc->dev, 1);
+ 		}
+ 
+ 		ast_state = to_ast_crtc_state(crtc->state);
+ 		format = ast_state->format;
+ 
+ 		if (format) {
+ 			vbios_mode_info = &ast_state->vbios_mode_info;
+ 
+ 			ast_set_color_reg(ast, format);
+ 			ast_set_vbios_color_reg(ast, format, vbios_mode_info);
+ 		}
+ 
+ 		ast_crtc_load_lut(ast, crtc);
+ 		break;
++>>>>>>> 5171660cbb14 (drm/ast: Fix black screen when getting out of suspend)
  	case DRM_MODE_DPMS_STANDBY:
  	case DRM_MODE_DPMS_SUSPEND:
 +		if (ast->tx_chip_type == AST_TX_DP501)
 +			ast_set_dp501_video_output(crtc->dev, 1);
 +		break;
  	case DRM_MODE_DPMS_OFF:
 -		ch = mode;
 -		if (ast->tx_chip_types & AST_TX_DP501_BIT)
 +		if (ast->tx_chip_type == AST_TX_DP501)
  			ast_set_dp501_video_output(crtc->dev, 0);
 -
 -		if (ast->tx_chip_types & AST_TX_ASTDP_BIT) {
 -			ast_dp_set_on_off(crtc->dev, 0);
 -			ast_dp_power_on_off(crtc->dev, AST_DP_POWER_OFF);
 -		}
 -
 -		ast_set_index_reg_mask(ast, AST_IO_SEQ_PORT,  0x01, 0xdf, 0x20);
 -		ast_set_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xb6, 0xfc, ch);
 -		break;
 -	}
 -}
 -
 -static enum drm_mode_status
 -ast_crtc_helper_mode_valid(struct drm_crtc *crtc, const struct drm_display_mode *mode)
 -{
 -	struct ast_private *ast = to_ast_private(crtc->dev);
 -	enum drm_mode_status status;
 -	uint32_t jtemp;
 -
 -	if (ast->support_wide_screen) {
 -		if ((mode->hdisplay == 1680) && (mode->vdisplay == 1050))
 -			return MODE_OK;
 -		if ((mode->hdisplay == 1280) && (mode->vdisplay == 800))
 -			return MODE_OK;
 -		if ((mode->hdisplay == 1440) && (mode->vdisplay == 900))
 -			return MODE_OK;
 -		if ((mode->hdisplay == 1360) && (mode->vdisplay == 768))
 -			return MODE_OK;
 -		if ((mode->hdisplay == 1600) && (mode->vdisplay == 900))
 -			return MODE_OK;
 -
 -		if ((ast->chip == AST2100) || (ast->chip == AST2200) ||
 -		    (ast->chip == AST2300) || (ast->chip == AST2400) ||
 -		    (ast->chip == AST2500) || (ast->chip == AST2600)) {
 -			if ((mode->hdisplay == 1920) && (mode->vdisplay == 1080))
 -				return MODE_OK;
 -
 -			if ((mode->hdisplay == 1920) && (mode->vdisplay == 1200)) {
 -				jtemp = ast_get_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xd1, 0xff);
 -				if (jtemp & 0x01)
 -					return MODE_NOMODE;
 -				else
 -					return MODE_OK;
 -			}
 -		}
 -	}
 -
 -	status = MODE_NOMODE;
 -
 -	switch (mode->hdisplay) {
 -	case 640:
 -		if (mode->vdisplay == 480)
 -			status = MODE_OK;
 -		break;
 -	case 800:
 -		if (mode->vdisplay == 600)
 -			status = MODE_OK;
 -		break;
 -	case 1024:
 -		if (mode->vdisplay == 768)
 -			status = MODE_OK;
 -		break;
 -	case 1280:
 -		if (mode->vdisplay == 1024)
 -			status = MODE_OK;
 -		break;
 -	case 1600:
 -		if (mode->vdisplay == 1200)
 -			status = MODE_OK;
 -		break;
 -	default:
  		break;
  	}
 -
 -	return status;
  }
  
  static int ast_crtc_helper_atomic_check(struct drm_crtc *crtc,
* Unmerged path drivers/gpu/drm/ast/ast_mode.c
