net/mlx5: Fix rdma aux device on devlink reload

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-425.3.1.el8
commit-author Parav Pandit <parav@nvidia.com>
commit 897ae4b40e80be7dcbf2b3079d85fa6339a6b751
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-425.3.1.el8/897ae4b4.failed

RDMA auxdev parameter registration was skipped for eswitch manager PCI PF.
Due to this when devlink parameter is read, it reads as false in below
code flow.

$ devlink dev reload pci/0000:06:00.0
  devlink_reload()
    mlx5_load_one()
      mlx5_attach_device()
        is_ib_enabled()
          devlink_param_driverinit_value_get()

Due to this, is_ib_enabled() returns false for the RDMA auxiliary
device. This results into a skipping RDMA auxiliary device creation on
reload.

There is no need to check for eswitch manager capability to support RDMA
auxiliary device. Hence, fix it by skipping eswitch manager capability.

Fixes: 87158cedf00e ("net/mlx5: Support enable_rdma devlink dev param")
	Signed-off-by: Parav Pandit <parav@nvidia.com>
	Reviewed-by: Shay Drory <shayd@nvidia.com>
	Signed-off-by: Saeed Mahameed <saeedm@nvidia.com>
(cherry picked from commit 897ae4b40e80be7dcbf2b3079d85fa6339a6b751)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/devlink.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/devlink.c
index 9dee693eb638,dcf9f27ba2ef..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/devlink.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/devlink.c
@@@ -609,6 -604,154 +609,157 @@@ static void mlx5_devlink_set_params_ini
  #endif
  }
  
++<<<<<<< HEAD
++=======
+ static const struct devlink_param enable_eth_param =
+ 	DEVLINK_PARAM_GENERIC(ENABLE_ETH, BIT(DEVLINK_PARAM_CMODE_DRIVERINIT),
+ 			      NULL, NULL, NULL);
+ 
+ static int mlx5_devlink_eth_param_register(struct devlink *devlink)
+ {
+ 	struct mlx5_core_dev *dev = devlink_priv(devlink);
+ 	union devlink_param_value value;
+ 	int err;
+ 
+ 	if (!mlx5_eth_supported(dev))
+ 		return 0;
+ 
+ 	err = devlink_param_register(devlink, &enable_eth_param);
+ 	if (err)
+ 		return err;
+ 
+ 	value.vbool = true;
+ 	devlink_param_driverinit_value_set(devlink,
+ 					   DEVLINK_PARAM_GENERIC_ID_ENABLE_ETH,
+ 					   value);
+ 	devlink_param_publish(devlink, &enable_eth_param);
+ 	return 0;
+ }
+ 
+ static void mlx5_devlink_eth_param_unregister(struct devlink *devlink)
+ {
+ 	struct mlx5_core_dev *dev = devlink_priv(devlink);
+ 
+ 	if (!mlx5_eth_supported(dev))
+ 		return;
+ 
+ 	devlink_param_unpublish(devlink, &enable_eth_param);
+ 	devlink_param_unregister(devlink, &enable_eth_param);
+ }
+ 
+ static int mlx5_devlink_enable_rdma_validate(struct devlink *devlink, u32 id,
+ 					     union devlink_param_value val,
+ 					     struct netlink_ext_ack *extack)
+ {
+ 	struct mlx5_core_dev *dev = devlink_priv(devlink);
+ 	bool new_state = val.vbool;
+ 
+ 	if (new_state && !mlx5_rdma_supported(dev))
+ 		return -EOPNOTSUPP;
+ 	return 0;
+ }
+ 
+ static const struct devlink_param enable_rdma_param =
+ 	DEVLINK_PARAM_GENERIC(ENABLE_RDMA, BIT(DEVLINK_PARAM_CMODE_DRIVERINIT),
+ 			      NULL, NULL, mlx5_devlink_enable_rdma_validate);
+ 
+ static int mlx5_devlink_rdma_param_register(struct devlink *devlink)
+ {
+ 	union devlink_param_value value;
+ 	int err;
+ 
+ 	if (!IS_ENABLED(CONFIG_MLX5_INFINIBAND))
+ 		return 0;
+ 
+ 	err = devlink_param_register(devlink, &enable_rdma_param);
+ 	if (err)
+ 		return err;
+ 
+ 	value.vbool = true;
+ 	devlink_param_driverinit_value_set(devlink,
+ 					   DEVLINK_PARAM_GENERIC_ID_ENABLE_RDMA,
+ 					   value);
+ 	devlink_param_publish(devlink, &enable_rdma_param);
+ 	return 0;
+ }
+ 
+ static void mlx5_devlink_rdma_param_unregister(struct devlink *devlink)
+ {
+ 	if (!IS_ENABLED(CONFIG_MLX5_INFINIBAND))
+ 		return;
+ 
+ 	devlink_param_unpublish(devlink, &enable_rdma_param);
+ 	devlink_param_unregister(devlink, &enable_rdma_param);
+ }
+ 
+ static const struct devlink_param enable_vnet_param =
+ 	DEVLINK_PARAM_GENERIC(ENABLE_VNET, BIT(DEVLINK_PARAM_CMODE_DRIVERINIT),
+ 			      NULL, NULL, NULL);
+ 
+ static int mlx5_devlink_vnet_param_register(struct devlink *devlink)
+ {
+ 	struct mlx5_core_dev *dev = devlink_priv(devlink);
+ 	union devlink_param_value value;
+ 	int err;
+ 
+ 	if (!mlx5_vnet_supported(dev))
+ 		return 0;
+ 
+ 	err = devlink_param_register(devlink, &enable_vnet_param);
+ 	if (err)
+ 		return err;
+ 
+ 	value.vbool = true;
+ 	devlink_param_driverinit_value_set(devlink,
+ 					   DEVLINK_PARAM_GENERIC_ID_ENABLE_VNET,
+ 					   value);
+ 	devlink_param_publish(devlink, &enable_rdma_param);
+ 	return 0;
+ }
+ 
+ static void mlx5_devlink_vnet_param_unregister(struct devlink *devlink)
+ {
+ 	struct mlx5_core_dev *dev = devlink_priv(devlink);
+ 
+ 	if (!mlx5_vnet_supported(dev))
+ 		return;
+ 
+ 	devlink_param_unpublish(devlink, &enable_vnet_param);
+ 	devlink_param_unregister(devlink, &enable_vnet_param);
+ }
+ 
+ static int mlx5_devlink_auxdev_params_register(struct devlink *devlink)
+ {
+ 	int err;
+ 
+ 	err = mlx5_devlink_eth_param_register(devlink);
+ 	if (err)
+ 		return err;
+ 
+ 	err = mlx5_devlink_rdma_param_register(devlink);
+ 	if (err)
+ 		goto rdma_err;
+ 
+ 	err = mlx5_devlink_vnet_param_register(devlink);
+ 	if (err)
+ 		goto vnet_err;
+ 	return 0;
+ 
+ vnet_err:
+ 	mlx5_devlink_rdma_param_unregister(devlink);
+ rdma_err:
+ 	mlx5_devlink_eth_param_unregister(devlink);
+ 	return err;
+ }
+ 
+ static void mlx5_devlink_auxdev_params_unregister(struct devlink *devlink)
+ {
+ 	mlx5_devlink_vnet_param_unregister(devlink);
+ 	mlx5_devlink_rdma_param_unregister(devlink);
+ 	mlx5_devlink_eth_param_unregister(devlink);
+ }
+ 
++>>>>>>> 897ae4b40e80 (net/mlx5: Fix rdma aux device on devlink reload)
  #define MLX5_TRAP_DROP(_id, _group_id)					\
  	DEVLINK_TRAP_GENERIC(DROP, DROP, _id,				\
  			     DEVLINK_TRAP_GROUP_GENERIC_ID_##_group_id, \
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/devlink.c
