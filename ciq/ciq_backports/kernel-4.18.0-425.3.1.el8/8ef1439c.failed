ASoC: SOF: topology: Make widget binding IPC agnostic

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-425.3.1.el8
commit-author Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
commit 8ef1439c51048b9359a8d1be2360dd4cd9848a77
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-425.3.1.el8/8ef1439c.failed

Make widget binding in the topology parser IPC agnostic by introducing a
new op, bind_event, in struct ipc_tplg_widget_ops. Also set the op
for all widget types in the IPC3 topology ops.

	Signed-off-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
	Reviewed-by: Bard Liao <yung-chuan.liao@linux.intel.com>
	Reviewed-by: PÃ©ter Ujfalusi <peter.ujfalusi@linux.intel.com>
	Reviewed-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
Link: https://lore.kernel.org/r/20220314200520.1233427-19-ranjani.sridharan@linux.intel.com
	Signed-off-by: Mark Brown <broonie@kernel.org>
(cherry picked from commit 8ef1439c51048b9359a8d1be2360dd4cd9848a77)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/soc/sof/ipc3-topology.c
#	sound/soc/sof/topology.c
diff --cc sound/soc/sof/topology.c
index a127d3d2eab7,70677a36c304..000000000000
--- a/sound/soc/sof/topology.c
+++ b/sound/soc/sof/topology.c
@@@ -141,178 -134,6 +140,181 @@@ int sof_update_ipc_object(struct snd_so
  	return 0;
  }
  
++<<<<<<< HEAD
 +struct sof_widget_data {
 +	int ctrl_type;
 +	int ipc_cmd;
 +	struct sof_abi_hdr *pdata;
 +	struct snd_sof_control *control;
 +};
 +
 +/* send pcm params ipc */
 +static int ipc_pcm_params(struct snd_sof_widget *swidget, int dir)
 +{
 +	struct sof_ipc_pcm_params_reply ipc_params_reply;
 +	struct snd_soc_component *scomp = swidget->scomp;
 +	struct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);
 +	struct sof_ipc_pcm_params pcm;
 +	struct snd_pcm_hw_params *params;
 +	struct snd_sof_pcm *spcm;
 +	int ret;
 +
 +	memset(&pcm, 0, sizeof(pcm));
 +
 +	/* get runtime PCM params using widget's stream name */
 +	spcm = snd_sof_find_spcm_name(scomp, swidget->widget->sname);
 +	if (!spcm) {
 +		dev_err(scomp->dev, "error: cannot find PCM for %s\n",
 +			swidget->widget->name);
 +		return -EINVAL;
 +	}
 +
 +	params = &spcm->params[dir];
 +
 +	/* set IPC PCM params */
 +	pcm.hdr.size = sizeof(pcm);
 +	pcm.hdr.cmd = SOF_IPC_GLB_STREAM_MSG | SOF_IPC_STREAM_PCM_PARAMS;
 +	pcm.comp_id = swidget->comp_id;
 +	pcm.params.hdr.size = sizeof(pcm.params);
 +	pcm.params.direction = dir;
 +	pcm.params.sample_valid_bytes = params_width(params) >> 3;
 +	pcm.params.buffer_fmt = SOF_IPC_BUFFER_INTERLEAVED;
 +	pcm.params.rate = params_rate(params);
 +	pcm.params.channels = params_channels(params);
 +	pcm.params.host_period_bytes = params_period_bytes(params);
 +
 +	/* set format */
 +	switch (params_format(params)) {
 +	case SNDRV_PCM_FORMAT_S16:
 +		pcm.params.frame_fmt = SOF_IPC_FRAME_S16_LE;
 +		break;
 +	case SNDRV_PCM_FORMAT_S24:
 +		pcm.params.frame_fmt = SOF_IPC_FRAME_S24_4LE;
 +		break;
 +	case SNDRV_PCM_FORMAT_S32:
 +		pcm.params.frame_fmt = SOF_IPC_FRAME_S32_LE;
 +		break;
 +	default:
 +		return -EINVAL;
 +	}
 +
 +	/* send IPC to the DSP */
 +	ret = sof_ipc_tx_message(sdev->ipc, pcm.hdr.cmd, &pcm, sizeof(pcm),
 +				 &ipc_params_reply, sizeof(ipc_params_reply));
 +	if (ret < 0)
 +		dev_err(scomp->dev, "error: pcm params failed for %s\n",
 +			swidget->widget->name);
 +
 +	return ret;
 +}
 +
 + /* send stream trigger ipc */
 +static int ipc_trigger(struct snd_sof_widget *swidget, int cmd)
 +{
 +	struct snd_soc_component *scomp = swidget->scomp;
 +	struct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);
 +	struct sof_ipc_stream stream;
 +	struct sof_ipc_reply reply;
 +	int ret;
 +
 +	/* set IPC stream params */
 +	stream.hdr.size = sizeof(stream);
 +	stream.hdr.cmd = SOF_IPC_GLB_STREAM_MSG | cmd;
 +	stream.comp_id = swidget->comp_id;
 +
 +	/* send IPC to the DSP */
 +	ret = sof_ipc_tx_message(sdev->ipc, stream.hdr.cmd, &stream,
 +				 sizeof(stream), &reply, sizeof(reply));
 +	if (ret < 0)
 +		dev_err(scomp->dev, "error: failed to trigger %s\n",
 +			swidget->widget->name);
 +
 +	return ret;
 +}
 +
 +static int sof_keyword_dapm_event(struct snd_soc_dapm_widget *w,
 +				  struct snd_kcontrol *k, int event)
 +{
 +	struct snd_sof_widget *swidget = w->dobj.private;
 +	struct snd_soc_component *scomp;
 +	int stream = SNDRV_PCM_STREAM_CAPTURE;
 +	struct snd_sof_pcm *spcm;
 +	int ret = 0;
 +
 +	if (!swidget)
 +		return 0;
 +
 +	scomp = swidget->scomp;
 +
 +	dev_dbg(scomp->dev, "received event %d for widget %s\n",
 +		event, w->name);
 +
 +	/* get runtime PCM params using widget's stream name */
 +	spcm = snd_sof_find_spcm_name(scomp, swidget->widget->sname);
 +	if (!spcm) {
 +		dev_err(scomp->dev, "error: cannot find PCM for %s\n",
 +			swidget->widget->name);
 +		return -EINVAL;
 +	}
 +
 +	/* process events */
 +	switch (event) {
 +	case SND_SOC_DAPM_PRE_PMU:
 +		if (spcm->stream[stream].suspend_ignored) {
 +			dev_dbg(scomp->dev, "PRE_PMU event ignored, KWD pipeline is already RUNNING\n");
 +			return 0;
 +		}
 +
 +		/* set pcm params */
 +		ret = ipc_pcm_params(swidget, stream);
 +		if (ret < 0) {
 +			dev_err(scomp->dev,
 +				"error: failed to set pcm params for widget %s\n",
 +				swidget->widget->name);
 +			break;
 +		}
 +
 +		/* start trigger */
 +		ret = ipc_trigger(swidget, SOF_IPC_STREAM_TRIG_START);
 +		if (ret < 0)
 +			dev_err(scomp->dev,
 +				"error: failed to trigger widget %s\n",
 +				swidget->widget->name);
 +		break;
 +	case SND_SOC_DAPM_POST_PMD:
 +		if (spcm->stream[stream].suspend_ignored) {
 +			dev_dbg(scomp->dev, "POST_PMD even ignored, KWD pipeline will remain RUNNING\n");
 +			return 0;
 +		}
 +
 +		/* stop trigger */
 +		ret = ipc_trigger(swidget, SOF_IPC_STREAM_TRIG_STOP);
 +		if (ret < 0)
 +			dev_err(scomp->dev,
 +				"error: failed to trigger widget %s\n",
 +				swidget->widget->name);
 +
 +		/* pcm free */
 +		ret = ipc_trigger(swidget, SOF_IPC_STREAM_PCM_FREE);
 +		if (ret < 0)
 +			dev_err(scomp->dev,
 +				"error: failed to trigger widget %s\n",
 +				swidget->widget->name);
 +		break;
 +	default:
 +		break;
 +	}
 +
 +	return ret;
 +}
 +
 +/* event handlers for keyword detect component */
 +static const struct snd_soc_tplg_widget_events sof_kwd_events[] = {
 +	{SOF_KEYWORD_DETECT_DAPM_EVENT, sof_keyword_dapm_event},
 +};
 +
++=======
++>>>>>>> 8ef1439c5104 (ASoC: SOF: topology: Make widget binding IPC agnostic)
  static inline int get_tlv_data(const int *p, int tlv[TLV_ITEMS])
  {
  	/* we only support dB scale TLV type at the moment */
@@@ -1898,641 -1324,18 +1900,670 @@@ static int sof_widget_load_mux(struct s
  	return 0;
  }
  
 -static int sof_widget_unload(struct snd_soc_component *scomp,
 -			     struct snd_soc_dobj *dobj)
 +/*
 + * PGA Topology
 + */
 +
 +static int sof_widget_load_pga(struct snd_soc_component *scomp, int index,
 +			       struct snd_sof_widget *swidget,
 +			       struct snd_soc_tplg_dapm_widget *tw)
  {
  	struct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);
 -	const struct sof_ipc_tplg_ops *ipc_tplg_ops = sdev->ipc->ops->tplg;
 -	const struct sof_ipc_tplg_widget_ops *widget_ops = ipc_tplg_ops->widget;
 -	const struct snd_kcontrol_new *kc;
 -	struct snd_soc_dapm_widget *widget;
 +	struct snd_soc_tplg_private *private = &tw->priv;
 +	struct sof_ipc_comp_volume *volume;
  	struct snd_sof_control *scontrol;
 -	struct snd_sof_widget *swidget;
 -	struct soc_mixer_control *sm;
 -	struct soc_bytes_ext *sbe;
 +	size_t ipc_size = sizeof(*volume);
 +	int min_step;
 +	int max_step;
 +	int ret;
 +
 +	volume = (struct sof_ipc_comp_volume *)
 +		 sof_comp_alloc(swidget, &ipc_size, index);
 +	if (!volume)
 +		return -ENOMEM;
 +
 +	if (!le32_to_cpu(tw->num_kcontrols)) {
 +		dev_err(scomp->dev, "error: invalid kcontrol count %d for volume\n",
 +			tw->num_kcontrols);
 +		ret = -EINVAL;
 +		goto err;
 +	}
 +
 +	/* configure volume IPC message */
 +	volume->comp.type = SOF_COMP_VOLUME;
 +	volume->config.hdr.size = sizeof(volume->config);
 +
 +	ret = sof_parse_tokens(scomp, volume, volume_tokens,
 +			       ARRAY_SIZE(volume_tokens), private->array,
 +			       le32_to_cpu(private->size));
 +	if (ret != 0) {
 +		dev_err(scomp->dev, "error: parse volume tokens failed %d\n",
 +			private->size);
 +		goto err;
 +	}
 +	ret = sof_parse_tokens(scomp, &volume->config, comp_tokens,
 +			       ARRAY_SIZE(comp_tokens), private->array,
 +			       le32_to_cpu(private->size));
 +	if (ret != 0) {
 +		dev_err(scomp->dev, "error: parse volume.cfg tokens failed %d\n",
 +			le32_to_cpu(private->size));
 +		goto err;
 +	}
 +
 +	sof_dbg_comp_config(scomp, &volume->config);
 +
 +	swidget->private = volume;
 +
 +	list_for_each_entry(scontrol, &sdev->kcontrol_list, list) {
 +		if (scontrol->comp_id == swidget->comp_id &&
 +		    scontrol->volume_table) {
 +			min_step = scontrol->min_volume_step;
 +			max_step = scontrol->max_volume_step;
 +			volume->min_value = scontrol->volume_table[min_step];
 +			volume->max_value = scontrol->volume_table[max_step];
 +			volume->channels = scontrol->num_channels;
 +			break;
 +		}
 +	}
 +
 +	return 0;
 +err:
 +	kfree(volume);
 +	return ret;
 +}
 +
++<<<<<<< HEAD
 +/*
 + * SRC Topology
 + */
 +
 +static int sof_widget_load_src(struct snd_soc_component *scomp, int index,
 +			       struct snd_sof_widget *swidget,
 +			       struct snd_soc_tplg_dapm_widget *tw)
 +{
 +	struct snd_soc_tplg_private *private = &tw->priv;
 +	struct sof_ipc_comp_src *src;
 +	size_t ipc_size = sizeof(*src);
 +	int ret;
 +
 +	src = (struct sof_ipc_comp_src *)
 +	      sof_comp_alloc(swidget, &ipc_size, index);
 +	if (!src)
 +		return -ENOMEM;
 +
 +	/* configure src IPC message */
 +	src->comp.type = SOF_COMP_SRC;
 +	src->config.hdr.size = sizeof(src->config);
 +
 +	ret = sof_parse_tokens(scomp, src, src_tokens,
 +			       ARRAY_SIZE(src_tokens), private->array,
 +			       le32_to_cpu(private->size));
 +	if (ret != 0) {
 +		dev_err(scomp->dev, "error: parse src tokens failed %d\n",
 +			private->size);
 +		goto err;
 +	}
 +
 +	ret = sof_parse_tokens(scomp, &src->config, comp_tokens,
 +			       ARRAY_SIZE(comp_tokens), private->array,
 +			       le32_to_cpu(private->size));
 +	if (ret != 0) {
 +		dev_err(scomp->dev, "error: parse src.cfg tokens failed %d\n",
 +			le32_to_cpu(private->size));
 +		goto err;
 +	}
 +
 +	dev_dbg(scomp->dev, "src %s: source rate %d sink rate %d\n",
 +		swidget->widget->name, src->source_rate, src->sink_rate);
 +	sof_dbg_comp_config(scomp, &src->config);
 +
 +	swidget->private = src;
 +
 +	return 0;
 +err:
 +	kfree(src);
 +	return ret;
 +}
 +
 +/*
 + * ASRC Topology
 + */
 +
 +static int sof_widget_load_asrc(struct snd_soc_component *scomp, int index,
 +				struct snd_sof_widget *swidget,
 +				struct snd_soc_tplg_dapm_widget *tw)
 +{
 +	struct snd_soc_tplg_private *private = &tw->priv;
 +	struct sof_ipc_comp_asrc *asrc;
 +	size_t ipc_size = sizeof(*asrc);
 +	int ret;
 +
 +	asrc = (struct sof_ipc_comp_asrc *)
 +	       sof_comp_alloc(swidget, &ipc_size, index);
 +	if (!asrc)
 +		return -ENOMEM;
 +
 +	/* configure ASRC IPC message */
 +	asrc->comp.type = SOF_COMP_ASRC;
 +	asrc->config.hdr.size = sizeof(asrc->config);
 +
 +	ret = sof_parse_tokens(scomp, asrc, asrc_tokens,
 +			       ARRAY_SIZE(asrc_tokens), private->array,
 +			       le32_to_cpu(private->size));
 +	if (ret != 0) {
 +		dev_err(scomp->dev, "error: parse asrc tokens failed %d\n",
 +			private->size);
 +		goto err;
 +	}
 +
 +	ret = sof_parse_tokens(scomp, &asrc->config, comp_tokens,
 +			       ARRAY_SIZE(comp_tokens), private->array,
 +			       le32_to_cpu(private->size));
 +	if (ret != 0) {
 +		dev_err(scomp->dev, "error: parse asrc.cfg tokens failed %d\n",
 +			le32_to_cpu(private->size));
 +		goto err;
 +	}
 +
 +	dev_dbg(scomp->dev, "asrc %s: source rate %d sink rate %d "
 +		"asynch %d operation %d\n",
 +		swidget->widget->name, asrc->source_rate, asrc->sink_rate,
 +		asrc->asynchronous_mode, asrc->operation_mode);
 +	sof_dbg_comp_config(scomp, &asrc->config);
 +
 +	swidget->private = asrc;
 +
 +	return 0;
 +err:
 +	kfree(asrc);
 +	return ret;
 +}
 +
 +/*
 + * Signal Generator Topology
 + */
 +
 +static int sof_widget_load_siggen(struct snd_soc_component *scomp, int index,
 +				  struct snd_sof_widget *swidget,
 +				  struct snd_soc_tplg_dapm_widget *tw)
 +{
 +	struct snd_soc_tplg_private *private = &tw->priv;
 +	struct sof_ipc_comp_tone *tone;
 +	size_t ipc_size = sizeof(*tone);
 +	int ret;
 +
 +	tone = (struct sof_ipc_comp_tone *)
 +	       sof_comp_alloc(swidget, &ipc_size, index);
 +	if (!tone)
 +		return -ENOMEM;
 +
 +	/* configure siggen IPC message */
 +	tone->comp.type = SOF_COMP_TONE;
 +	tone->config.hdr.size = sizeof(tone->config);
 +
 +	ret = sof_parse_tokens(scomp, tone, tone_tokens,
 +			       ARRAY_SIZE(tone_tokens), private->array,
 +			       le32_to_cpu(private->size));
 +	if (ret != 0) {
 +		dev_err(scomp->dev, "error: parse tone tokens failed %d\n",
 +			le32_to_cpu(private->size));
 +		goto err;
 +	}
 +
 +	ret = sof_parse_tokens(scomp, &tone->config, comp_tokens,
 +			       ARRAY_SIZE(comp_tokens), private->array,
 +			       le32_to_cpu(private->size));
 +	if (ret != 0) {
 +		dev_err(scomp->dev, "error: parse tone.cfg tokens failed %d\n",
 +			le32_to_cpu(private->size));
 +		goto err;
 +	}
 +
 +	dev_dbg(scomp->dev, "tone %s: frequency %d amplitude %d\n",
 +		swidget->widget->name, tone->frequency, tone->amplitude);
 +	sof_dbg_comp_config(scomp, &tone->config);
 +
 +	swidget->private = tone;
 +
 +	return 0;
 +err:
 +	kfree(tone);
 +	return ret;
 +}
 +
 +static int sof_get_control_data(struct snd_soc_component *scomp,
 +				struct snd_soc_dapm_widget *widget,
 +				struct sof_widget_data *wdata,
 +				size_t *size)
 +{
 +	const struct snd_kcontrol_new *kc;
 +	struct soc_mixer_control *sm;
 +	struct soc_bytes_ext *sbe;
 +	struct soc_enum *se;
 +	int i;
 +
 +	*size = 0;
 +
 +	for (i = 0; i < widget->num_kcontrols; i++) {
 +		kc = &widget->kcontrol_news[i];
 +
 +		switch (widget->dobj.widget.kcontrol_type[i]) {
 +		case SND_SOC_TPLG_TYPE_MIXER:
 +			sm = (struct soc_mixer_control *)kc->private_value;
 +			wdata[i].control = sm->dobj.private;
 +			break;
 +		case SND_SOC_TPLG_TYPE_BYTES:
 +			sbe = (struct soc_bytes_ext *)kc->private_value;
 +			wdata[i].control = sbe->dobj.private;
 +			break;
 +		case SND_SOC_TPLG_TYPE_ENUM:
 +			se = (struct soc_enum *)kc->private_value;
 +			wdata[i].control = se->dobj.private;
 +			break;
 +		default:
 +			dev_err(scomp->dev, "error: unknown kcontrol type %u in widget %s\n",
 +				widget->dobj.widget.kcontrol_type[i],
 +				widget->name);
 +			return -EINVAL;
 +		}
 +
 +		if (!wdata[i].control) {
 +			dev_err(scomp->dev, "error: no scontrol for widget %s\n",
 +				widget->name);
 +			return -EINVAL;
 +		}
 +
 +		wdata[i].pdata = wdata[i].control->control_data->data;
 +		if (!wdata[i].pdata)
 +			return -EINVAL;
 +
 +		/* make sure data is valid - data can be updated at runtime */
 +		if (widget->dobj.widget.kcontrol_type[i] == SND_SOC_TPLG_TYPE_BYTES &&
 +		    wdata[i].pdata->magic != SOF_ABI_MAGIC)
 +			return -EINVAL;
 +
 +		*size += wdata[i].pdata->size;
 +
 +		/* get data type */
 +		switch (wdata[i].control->control_data->cmd) {
 +		case SOF_CTRL_CMD_VOLUME:
 +		case SOF_CTRL_CMD_ENUM:
 +		case SOF_CTRL_CMD_SWITCH:
 +			wdata[i].ipc_cmd = SOF_IPC_COMP_SET_VALUE;
 +			wdata[i].ctrl_type = SOF_CTRL_TYPE_VALUE_CHAN_SET;
 +			break;
 +		case SOF_CTRL_CMD_BINARY:
 +			wdata[i].ipc_cmd = SOF_IPC_COMP_SET_DATA;
 +			wdata[i].ctrl_type = SOF_CTRL_TYPE_DATA_SET;
 +			break;
 +		default:
 +			break;
 +		}
 +	}
 +
 +	return 0;
 +}
 +
 +static int sof_process_load(struct snd_soc_component *scomp, int index,
 +			    struct snd_sof_widget *swidget,
 +			    struct snd_soc_tplg_dapm_widget *tw,
 +			    int type)
 +{
 +	struct snd_soc_dapm_widget *widget = swidget->widget;
 +	struct snd_soc_tplg_private *private = &tw->priv;
 +	struct sof_ipc_comp_process *process;
 +	struct sof_widget_data *wdata = NULL;
 +	size_t ipc_data_size = 0;
 +	size_t ipc_size;
 +	int offset = 0;
 +	int ret;
 +	int i;
 +
 +	/* allocate struct for widget control data sizes and types */
 +	if (widget->num_kcontrols) {
 +		wdata = kcalloc(widget->num_kcontrols,
 +				sizeof(*wdata),
 +				GFP_KERNEL);
 +
 +		if (!wdata)
 +			return -ENOMEM;
 +
 +		/* get possible component controls and get size of all pdata */
 +		ret = sof_get_control_data(scomp, widget, wdata,
 +					   &ipc_data_size);
 +
 +		if (ret < 0)
 +			goto out;
 +	}
 +
 +	ipc_size = sizeof(struct sof_ipc_comp_process) + ipc_data_size;
 +
 +	/* we are exceeding max ipc size, config needs to be sent separately */
 +	if (ipc_size > SOF_IPC_MSG_MAX_SIZE) {
 +		ipc_size -= ipc_data_size;
 +		ipc_data_size = 0;
 +	}
 +
 +	process = (struct sof_ipc_comp_process *)
 +		  sof_comp_alloc(swidget, &ipc_size, index);
 +	if (!process) {
 +		ret = -ENOMEM;
 +		goto out;
 +	}
 +
 +	/* configure iir IPC message */
 +	process->comp.type = type;
 +	process->config.hdr.size = sizeof(process->config);
 +
 +	ret = sof_parse_tokens(scomp, &process->config, comp_tokens,
 +			       ARRAY_SIZE(comp_tokens), private->array,
 +			       le32_to_cpu(private->size));
 +	if (ret != 0) {
 +		dev_err(scomp->dev, "error: parse process.cfg tokens failed %d\n",
 +			le32_to_cpu(private->size));
 +		goto err;
 +	}
 +
 +	sof_dbg_comp_config(scomp, &process->config);
 +
 +	/*
 +	 * found private data in control, so copy it.
 +	 * get possible component controls - get size of all pdata,
 +	 * then memcpy with headers
 +	 */
 +	if (ipc_data_size) {
 +		for (i = 0; i < widget->num_kcontrols; i++) {
 +			memcpy(&process->data[offset],
 +			       wdata[i].pdata->data,
 +			       wdata[i].pdata->size);
 +			offset += wdata[i].pdata->size;
 +		}
 +	}
 +
 +	process->size = ipc_data_size;
 +	swidget->private = process;
 +err:
 +	if (ret < 0)
 +		kfree(process);
 +out:
 +	kfree(wdata);
 +	return ret;
 +}
 +
 +/*
 + * Processing Component Topology - can be "effect", "codec", or general
 + * "processing".
 + */
 +
 +static int sof_widget_load_process(struct snd_soc_component *scomp, int index,
 +				   struct snd_sof_widget *swidget,
 +				   struct snd_soc_tplg_dapm_widget *tw)
 +{
 +	struct snd_soc_tplg_private *private = &tw->priv;
 +	struct sof_ipc_comp_process config;
 +	int ret;
 +
 +	/* check we have some tokens - we need at least process type */
 +	if (le32_to_cpu(private->size) == 0) {
 +		dev_err(scomp->dev, "error: process tokens not found\n");
 +		return -EINVAL;
 +	}
 +
 +	memset(&config, 0, sizeof(config));
 +	config.comp.core = swidget->core;
 +
 +	/* get the process token */
 +	ret = sof_parse_tokens(scomp, &config, process_tokens,
 +			       ARRAY_SIZE(process_tokens), private->array,
 +			       le32_to_cpu(private->size));
 +	if (ret != 0) {
 +		dev_err(scomp->dev, "error: parse process tokens failed %d\n",
 +			le32_to_cpu(private->size));
 +		return ret;
 +	}
 +
 +	/* now load process specific data and send IPC */
 +	ret = sof_process_load(scomp, index, swidget, tw, find_process_comp_type(config.type));
 +	if (ret < 0) {
 +		dev_err(scomp->dev, "error: process loading failed\n");
 +		return ret;
 +	}
 +
 +	return 0;
 +}
 +
 +static int sof_widget_bind_event(struct snd_soc_component *scomp,
 +				 struct snd_sof_widget *swidget,
 +				 u16 event_type)
 +{
 +	struct sof_ipc_comp *ipc_comp;
 +
 +	/* validate widget event type */
 +	switch (event_type) {
 +	case SOF_KEYWORD_DETECT_DAPM_EVENT:
 +		/* only KEYWORD_DETECT comps should handle this */
 +		if (swidget->id != snd_soc_dapm_effect)
 +			break;
 +
 +		ipc_comp = swidget->private;
 +		if (ipc_comp && ipc_comp->type != SOF_COMP_KEYWORD_DETECT)
 +			break;
 +
 +		/* bind event to keyword detect comp */
 +		return snd_soc_tplg_widget_bind_event(swidget->widget,
 +						      sof_kwd_events,
 +						      ARRAY_SIZE(sof_kwd_events),
 +						      event_type);
 +	default:
 +		break;
 +	}
 +
 +	dev_err(scomp->dev,
 +		"error: invalid event type %d for widget %s\n",
 +		event_type, swidget->widget->name);
++=======
++static int sof_get_token_value(u32 token_id, struct snd_sof_tuple *tuples, int num_tuples)
++{
++	int i;
++
++	if (!tuples)
++		return -EINVAL;
++
++	for (i = 0; i < num_tuples; i++) {
++		if (tuples[i].token == token_id)
++			return tuples[i].value.v;
++	}
++
++>>>>>>> 8ef1439c5104 (ASoC: SOF: topology: Make widget binding IPC agnostic)
 +	return -EINVAL;
 +}
 +
 +/* external widget init - used for any driver specific init */
 +static int sof_widget_ready(struct snd_soc_component *scomp, int index,
 +			    struct snd_soc_dapm_widget *w,
 +			    struct snd_soc_tplg_dapm_widget *tw)
 +{
 +	struct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);
 +	struct snd_sof_widget *swidget;
 +	struct snd_sof_dai *dai;
 +	struct sof_ipc_comp comp = {
 +		.core = SOF_DSP_PRIMARY_CORE,
 +	};
 +	int ret = 0;
 +
 +	swidget = kzalloc(sizeof(*swidget), GFP_KERNEL);
 +	if (!swidget)
 +		return -ENOMEM;
 +
 +	swidget->scomp = scomp;
 +	swidget->widget = w;
 +	swidget->comp_id = sdev->next_comp_id++;
 +	swidget->complete = 0;
 +	swidget->id = w->id;
 +	swidget->pipeline_id = index;
 +	swidget->private = NULL;
 +
 +	dev_dbg(scomp->dev, "tplg: ready widget id %d pipe %d type %d name : %s stream %s\n",
 +		swidget->comp_id, index, swidget->id, tw->name,
 +		strnlen(tw->sname, SNDRV_CTL_ELEM_ID_NAME_MAXLEN) > 0
 +			? tw->sname : "none");
 +
 +	ret = sof_parse_tokens(scomp, &comp, core_tokens,
 +			       ARRAY_SIZE(core_tokens), tw->priv.array,
 +			       le32_to_cpu(tw->priv.size));
 +	if (ret != 0) {
 +		dev_err(scomp->dev, "error: parsing core tokens failed %d\n",
 +			ret);
 +		kfree(swidget);
 +		return ret;
 +	}
 +
 +	if (sof_debug_check_flag(SOF_DBG_DISABLE_MULTICORE))
 +		comp.core = SOF_DSP_PRIMARY_CORE;
 +
 +	swidget->core = comp.core;
 +
 +	ret = sof_parse_tokens(scomp, swidget, comp_ext_tokens, ARRAY_SIZE(comp_ext_tokens),
 +			       tw->priv.array, le32_to_cpu(tw->priv.size));
 +	if (ret != 0) {
 +		dev_err(scomp->dev, "error: parsing comp_ext_tokens failed %d\n",
 +			ret);
 +		kfree(swidget);
 +		return ret;
 +	}
 +
 +	/* handle any special case widgets */
 +	switch (w->id) {
 +	case snd_soc_dapm_dai_in:
 +	case snd_soc_dapm_dai_out:
 +		dai = kzalloc(sizeof(*dai), GFP_KERNEL);
 +		if (!dai) {
 +			kfree(swidget);
 +			return -ENOMEM;
 +		}
 +
 +		ret = sof_widget_load_dai(scomp, index, swidget, tw, dai);
 +		if (!ret)
 +			ret = sof_connect_dai_widget(scomp, w, tw, dai);
 +		if (ret < 0) {
 +			kfree(dai);
 +			break;
 +		}
 +		list_add(&dai->list, &sdev->dai_list);
 +		swidget->private = dai;
 +		break;
 +	case snd_soc_dapm_mixer:
 +		ret = sof_widget_load_mixer(scomp, index, swidget, tw);
 +		break;
 +	case snd_soc_dapm_pga:
 +		ret = sof_widget_load_pga(scomp, index, swidget, tw);
 +		break;
 +	case snd_soc_dapm_buffer:
 +		ret = sof_widget_load_buffer(scomp, index, swidget, tw);
 +		break;
 +	case snd_soc_dapm_scheduler:
 +		ret = sof_widget_load_pipeline(scomp, index, swidget, tw);
 +		break;
 +	case snd_soc_dapm_aif_out:
 +		ret = sof_widget_load_pcm(scomp, index, swidget,
 +					  SOF_IPC_STREAM_CAPTURE, tw);
 +		break;
 +	case snd_soc_dapm_aif_in:
 +		ret = sof_widget_load_pcm(scomp, index, swidget,
 +					  SOF_IPC_STREAM_PLAYBACK, tw);
 +		break;
 +	case snd_soc_dapm_src:
 +		ret = sof_widget_load_src(scomp, index, swidget, tw);
 +		break;
 +	case snd_soc_dapm_asrc:
 +		ret = sof_widget_load_asrc(scomp, index, swidget, tw);
 +		break;
 +	case snd_soc_dapm_siggen:
 +		ret = sof_widget_load_siggen(scomp, index, swidget, tw);
 +		break;
 +	case snd_soc_dapm_effect:
 +		ret = sof_widget_load_process(scomp, index, swidget, tw);
 +		break;
 +	case snd_soc_dapm_mux:
 +	case snd_soc_dapm_demux:
 +		ret = sof_widget_load_mux(scomp, index, swidget, tw);
 +		break;
 +	case snd_soc_dapm_switch:
 +	case snd_soc_dapm_dai_link:
 +	case snd_soc_dapm_kcontrol:
 +	default:
 +		dev_dbg(scomp->dev, "widget type %d name %s not handled\n", swidget->id, tw->name);
 +		break;
 +	}
 +
 +	/* check IPC reply */
 +	if (ret < 0) {
 +		dev_err(scomp->dev,
 +			"error: failed to add widget id %d type %d name : %s stream %s\n",
 +			tw->shift, swidget->id, tw->name,
 +			strnlen(tw->sname, SNDRV_CTL_ELEM_ID_NAME_MAXLEN) > 0
 +				? tw->sname : "none");
 +		kfree(swidget);
 +		return ret;
 +	}
 +
 +	/* bind widget to external event */
 +	if (tw->event_type) {
++<<<<<<< HEAD
 +		ret = sof_widget_bind_event(scomp, swidget,
 +					    le16_to_cpu(tw->event_type));
 +		if (ret) {
 +			dev_err(scomp->dev, "error: widget event binding failed\n");
 +			kfree(swidget->private);
 +			kfree(swidget);
 +			return ret;
++=======
++		if (widget_ops[w->id].bind_event) {
++			ret = widget_ops[w->id].bind_event(scomp, swidget,
++							   le16_to_cpu(tw->event_type));
++			if (ret) {
++				dev_err(scomp->dev, "widget event binding failed for %s\n",
++					swidget->widget->name);
++				kfree(swidget->private);
++				kfree(swidget->tuples);
++				kfree(swidget);
++				return ret;
++			}
++>>>>>>> 8ef1439c5104 (ASoC: SOF: topology: Make widget binding IPC agnostic)
 +		}
 +	}
 +
 +	w->dobj.private = swidget;
 +	list_add(&swidget->list, &sdev->widget_list);
 +	return ret;
 +}
 +
 +static int sof_route_unload(struct snd_soc_component *scomp,
 +			    struct snd_soc_dobj *dobj)
 +{
 +	struct snd_sof_route *sroute;
 +
 +	sroute = dobj->private;
 +	if (!sroute)
 +		return 0;
 +
 +	/* free sroute and its private data */
 +	kfree(sroute->private);
 +	list_del(&sroute->list);
 +	kfree(sroute);
 +
 +	return 0;
 +}
 +
 +static int sof_widget_unload(struct snd_soc_component *scomp,
 +			     struct snd_soc_dobj *dobj)
 +{
 +	const struct snd_kcontrol_new *kc;
 +	struct snd_soc_dapm_widget *widget;
 +	struct snd_sof_control *scontrol;
 +	struct snd_sof_widget *swidget;
 +	struct soc_mixer_control *sm;
 +	struct soc_bytes_ext *sbe;
  	struct snd_sof_dai *dai;
  	struct soc_enum *se;
  	int ret = 0;
* Unmerged path sound/soc/sof/ipc3-topology.c
* Unmerged path sound/soc/sof/ipc3-topology.c
* Unmerged path sound/soc/sof/topology.c
