cifs: fix path comparison and hash calc

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-425.3.1.el8
commit-author Paulo Alcantara <pc@cjr.nz>
commit 42caeba713b12ee0dfc085f6fb2f7cde2a64f91a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-425.3.1.el8/42caeba7.failed

Fix cache lookup and hash calculations when handling paths with
different cases.

	Signed-off-by: Paulo Alcantara (SUSE) <pc@cjr.nz>
	Reviewed-by: Aurelien Aptel <aaptel@suse.com>
	Signed-off-by: Steve French <stfrench@microsoft.com>
(cherry picked from commit 42caeba713b12ee0dfc085f6fb2f7cde2a64f91a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/cifs/dfs_cache.c
diff --cc fs/cifs/dfs_cache.c
index d4a72c7183f5,66be23975aec..000000000000
--- a/fs/cifs/dfs_cache.c
+++ b/fs/cifs/dfs_cache.c
@@@ -403,25 -424,26 +403,37 @@@ out_destroy_wq
  	return rc;
  }
  
- static inline unsigned int cache_entry_hash(const void *data, int size)
+ static int cache_entry_hash(const void *data, int size, unsigned int *hash)
  {
- 	unsigned int h;
- 
- 	h = jhash(data, size, 0);
- 	return h & (CACHE_HTABLE_SIZE - 1);
+ 	int i, clen;
+ 	const unsigned char *s = data;
+ 	wchar_t c;
+ 	unsigned int h = 0;
+ 
+ 	for (i = 0; i < size; i += clen) {
+ 		clen = cache_cp->char2uni(&s[i], size - i, &c);
+ 		if (unlikely(clen < 0)) {
+ 			cifs_dbg(VFS, "%s: can't convert char\n", __func__);
+ 			return clen;
+ 		}
+ 		c = cifs_toupper(c);
+ 		h = jhash(&c, sizeof(c), h);
+ 	}
+ 	*hash = h % CACHE_HTABLE_SIZE;
+ 	return 0;
  }
  
 +/* Check whether second path component of @path is SYSVOL or NETLOGON */
 +static inline bool is_sysvol_or_netlogon(const char *path)
 +{
 +	const char *s;
 +	char sep = path[0];
 +
 +	s = strchr(path + 1, sep) + 1;
 +	return !strncasecmp(s, "sysvol", strlen("sysvol")) ||
 +		!strncasecmp(s, "netlogon", strlen("netlogon"));
 +}
 +
  /* Return target hint of a DFS cache entry */
  static inline char *get_tgt_name(const struct cache_entry *ce)
  {
@@@ -745,11 -772,9 +764,10 @@@ static int get_dfs_referral(const unsig
   * For interlinks, cifs_mount() and expand_dfs_referral() are supposed to
   * handle them properly.
   */
 -static int cache_refresh_path(const unsigned int xid, struct cifs_ses *ses, const char *path)
 +static int cache_refresh_path(const unsigned int xid, struct cifs_ses *ses,
 +			      const struct nls_table *nls_codepage, int remap, const char *path)
  {
  	int rc;
- 	unsigned int hash;
  	struct cache_entry *ce;
  	struct dfs_info3_param *refs = NULL;
  	int numrefs = 0;
@@@ -976,7 -994,7 +994,11 @@@ int dfs_cache_noreq_find(const char *pa
  
  	down_read(&htable_rw_lock);
  
++<<<<<<< HEAD
 +	ce = lookup_cache_entry(npath, NULL);
++=======
+ 	ce = lookup_cache_entry(path);
++>>>>>>> 42caeba713b1 (cifs: fix path comparison and hash calc)
  	if (IS_ERR(ce)) {
  		rc = PTR_ERR(ce);
  		goto out_unlock;
@@@ -1097,7 -1105,7 +1119,11 @@@ int dfs_cache_noreq_update_tgthint(cons
  
  	down_write(&htable_rw_lock);
  
++<<<<<<< HEAD
 +	ce = lookup_cache_entry(npath, NULL);
++=======
+ 	ce = lookup_cache_entry(path);
++>>>>>>> 42caeba713b1 (cifs: fix path comparison and hash calc)
  	if (IS_ERR(ce)) {
  		rc = PTR_ERR(ce);
  		goto out_unlock;
@@@ -1154,7 -1154,7 +1180,11 @@@ int dfs_cache_get_tgt_referral(const ch
  
  	down_read(&htable_rw_lock);
  
++<<<<<<< HEAD
 +	ce = lookup_cache_entry(npath, NULL);
++=======
+ 	ce = lookup_cache_entry(path);
++>>>>>>> 42caeba713b1 (cifs: fix path comparison and hash calc)
  	if (IS_ERR(ce)) {
  		rc = PTR_ERR(ce);
  		goto out_unlock;
* Unmerged path fs/cifs/dfs_cache.c
