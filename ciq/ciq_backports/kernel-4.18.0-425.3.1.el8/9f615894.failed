lib/math: move int_pow() from pwm_bl.c for wider use

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-425.3.1.el8
commit-author Andy Shevchenko <andriy.shevchenko@linux.intel.com>
commit 9f6158946987a5ce3f16da097d18f240a89db417
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-425.3.1.el8/9f615894.failed

The integer exponentiation is used in few places and might be used in
the future by other call sites.  Move it to wider use.

Link: http://lkml.kernel.org/r/20190323172531.80025-2-andriy.shevchenko@linux.intel.com
	Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
	Cc: Daniel Thompson <daniel.thompson@linaro.org>
	Cc: Lee Jones <lee.jones@linaro.org>
	Cc: Ray Jui <rjui@broadcom.com>
	Cc: Thierry Reding <thierry.reding@gmail.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 9f6158946987a5ce3f16da097d18f240a89db417)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/video/backlight/pwm_bl.c
diff --cc drivers/video/backlight/pwm_bl.c
index 44ac5bde4e9d,fb45f866b923..000000000000
--- a/drivers/video/backlight/pwm_bl.c
+++ b/drivers/video/backlight/pwm_bl.c
@@@ -143,6 -153,92 +143,95 @@@ static const struct backlight_ops pwm_b
  };
  
  #ifdef CONFIG_OF
++<<<<<<< HEAD
++=======
+ #define PWM_LUMINANCE_SCALE	10000 /* luminance scale */
+ 
+ /*
+  * CIE lightness to PWM conversion.
+  *
+  * The CIE 1931 lightness formula is what actually describes how we perceive
+  * light:
+  *          Y = (L* / 902.3)           if L* â‰¤ 0.08856
+  *          Y = ((L* + 16) / 116)^3    if L* > 0.08856
+  *
+  * Where Y is the luminance, the amount of light coming out of the screen, and
+  * is a number between 0.0 and 1.0; and L* is the lightness, how bright a human
+  * perceives the screen to be, and is a number between 0 and 100.
+  *
+  * The following function does the fixed point maths needed to implement the
+  * above formula.
+  */
+ static u64 cie1931(unsigned int lightness, unsigned int scale)
+ {
+ 	u64 retval;
+ 
+ 	lightness *= 100;
+ 	if (lightness <= (8 * scale)) {
+ 		retval = DIV_ROUND_CLOSEST_ULL(lightness * 10, 9023);
+ 	} else {
+ 		retval = int_pow((lightness + (16 * scale)) / 116, 3);
+ 		retval = DIV_ROUND_CLOSEST_ULL(retval, (scale * scale));
+ 	}
+ 
+ 	return retval;
+ }
+ 
+ /*
+  * Create a default correction table for PWM values to create linear brightness
+  * for LED based backlights using the CIE1931 algorithm.
+  */
+ static
+ int pwm_backlight_brightness_default(struct device *dev,
+ 				     struct platform_pwm_backlight_data *data,
+ 				     unsigned int period)
+ {
+ 	unsigned int counter = 0;
+ 	unsigned int i, n;
+ 	u64 retval;
+ 
+ 	/*
+ 	 * Count the number of bits needed to represent the period number. The
+ 	 * number of bits is used to calculate the number of levels used for the
+ 	 * brightness-levels table, the purpose of this calculation is have a
+ 	 * pre-computed table with enough levels to get linear brightness
+ 	 * perception. The period is divided by the number of bits so for a
+ 	 * 8-bit PWM we have 255 / 8 = 32 brightness levels or for a 16-bit PWM
+ 	 * we have 65535 / 16 = 4096 brightness levels.
+ 	 *
+ 	 * Note that this method is based on empirical testing on different
+ 	 * devices with PWM of 8 and 16 bits of resolution.
+ 	 */
+ 	n = period;
+ 	while (n) {
+ 		counter += n % 2;
+ 		n >>= 1;
+ 	}
+ 
+ 	data->max_brightness = DIV_ROUND_UP(period, counter);
+ 	data->levels = devm_kcalloc(dev, data->max_brightness,
+ 				    sizeof(*data->levels), GFP_KERNEL);
+ 	if (!data->levels)
+ 		return -ENOMEM;
+ 
+ 	/* Fill the table using the cie1931 algorithm */
+ 	for (i = 0; i < data->max_brightness; i++) {
+ 		retval = cie1931((i * PWM_LUMINANCE_SCALE) /
+ 				 data->max_brightness, PWM_LUMINANCE_SCALE) *
+ 				 period;
+ 		retval = DIV_ROUND_CLOSEST_ULL(retval, PWM_LUMINANCE_SCALE);
+ 		if (retval > UINT_MAX)
+ 			return -EINVAL;
+ 		data->levels[i] = (unsigned int)retval;
+ 	}
+ 
+ 	data->dft_brightness = data->max_brightness / 2;
+ 	data->max_brightness--;
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> 9f6158946987 (lib/math: move int_pow() from pwm_bl.c for wider use)
  static int pwm_backlight_parse_dt(struct device *dev,
  				  struct platform_pwm_backlight_data *data)
  {
* Unmerged path drivers/video/backlight/pwm_bl.c
diff --git a/include/linux/kernel.h b/include/linux/kernel.h
index 789939329a6b..ba7ca9367dd1 100644
--- a/include/linux/kernel.h
+++ b/include/linux/kernel.h
@@ -542,6 +542,7 @@ extern int __kernel_text_address(unsigned long addr);
 extern int kernel_text_address(unsigned long addr);
 extern int func_ptr_is_kernel_text(void *ptr);
 
+u64 int_pow(u64 base, unsigned int exp);
 unsigned long int_sqrt(unsigned long);
 
 #if BITS_PER_LONG < 64
diff --git a/lib/math/Makefile b/lib/math/Makefile
index b75878420da6..583bbfebfc09 100644
--- a/lib/math/Makefile
+++ b/lib/math/Makefile
@@ -1,4 +1,4 @@
-obj-y += div64.o gcd.o lcm.o int_sqrt.o reciprocal_div.o
+obj-y += div64.o gcd.o lcm.o int_pow.o int_sqrt.o reciprocal_div.o
 
 obj-$(CONFIG_CORDIC)		+= cordic.o
 obj-$(CONFIG_PRIME_NUMBERS)	+= prime_numbers.o
diff --git a/lib/math/int_pow.c b/lib/math/int_pow.c
new file mode 100644
index 000000000000..622fc1ab3c74
--- /dev/null
+++ b/lib/math/int_pow.c
@@ -0,0 +1,32 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * An integer based power function
+ *
+ * Derived from drivers/video/backlight/pwm_bl.c
+ */
+
+#include <linux/export.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+
+/**
+ * int_pow - computes the exponentiation of the given base and exponent
+ * @base: base which will be raised to the given power
+ * @exp: power to be raised to
+ *
+ * Computes: pow(base, exp), i.e. @base raised to the @exp power
+ */
+u64 int_pow(u64 base, unsigned int exp)
+{
+	u64 result = 1;
+
+	while (exp) {
+		if (exp & 1)
+			result *= base;
+		exp >>= 1;
+		base *= base;
+	}
+
+	return result;
+}
+EXPORT_SYMBOL_GPL(int_pow);
