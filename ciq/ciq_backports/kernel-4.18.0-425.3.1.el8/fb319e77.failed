of: fdt: Add memory for devices by DT property "linux,usable-memory-range"

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-425.3.1.el8
commit-author Chen Zhou <chenzhou10@huawei.com>
commit fb319e77a0e70b9ccfef87827d34b10d6bc2ccce
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-425.3.1.el8/fb319e77.failed

When reserving crashkernel in high memory, some low memory is reserved
for crash dump kernel devices and never mapped by the first kernel.
This memory range is advertised to crash dump kernel via DT property
under /chosen,
        linux,usable-memory-range = <BASE1 SIZE1 [BASE2 SIZE2]>

We reused the DT property linux,usable-memory-range and made the low
memory region as the second range "BASE2 SIZE2", which keeps compatibility
with existing user-space and older kdump kernels.

Crash dump kernel reads this property at boot time and call memblock_add()
to add the low memory region after memblock_cap_memory_range() has been
called.

	Signed-off-by: Chen Zhou <chenzhou10@huawei.com>
Co-developed-by: Zhen Lei <thunder.leizhen@huawei.com>
	Signed-off-by: Zhen Lei <thunder.leizhen@huawei.com>
	Reviewed-by: Rob Herring <robh@kernel.org>
	Tested-by: Dave Kleikamp <dave.kleikamp@oracle.com>
	Acked-by: Baoquan He <bhe@redhat.com>
Link: https://lore.kernel.org/r/20220506114402.365-5-thunder.leizhen@huawei.com
	Signed-off-by: Catalin Marinas <catalin.marinas@arm.com>
(cherry picked from commit fb319e77a0e70b9ccfef87827d34b10d6bc2ccce)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/of/fdt.c
diff --cc drivers/of/fdt.c
index 3a485143751f,2f248d0acc04..000000000000
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@@ -924,15 -939,82 +924,80 @@@ static void __init early_init_dt_check_
  	end = of_read_number(prop, len/4);
  
  	__early_init_dt_declare_initrd(start, end);
 -	phys_initrd_start = start;
 -	phys_initrd_size = end - start;
  
 -	pr_debug("initrd_start=0x%llx  initrd_end=0x%llx\n", start, end);
 +	pr_debug("initrd_start=0x%llx  initrd_end=0x%llx\n",
 +		 (unsigned long long)start, (unsigned long long)end);
  }
 -
 -/**
 - * early_init_dt_check_for_elfcorehdr - Decode elfcorehdr location from flat
 - * tree
 - * @node: reference to node containing elfcorehdr location ('chosen')
 - */
 -static void __init early_init_dt_check_for_elfcorehdr(unsigned long node)
 +#else
 +static inline void early_init_dt_check_for_initrd(unsigned long node)
  {
++<<<<<<< HEAD
++=======
+ 	const __be32 *prop;
+ 	int len;
+ 
+ 	if (!IS_ENABLED(CONFIG_CRASH_DUMP))
+ 		return;
+ 
+ 	pr_debug("Looking for elfcorehdr property... ");
+ 
+ 	prop = of_get_flat_dt_prop(node, "linux,elfcorehdr", &len);
+ 	if (!prop || (len < (dt_root_addr_cells + dt_root_size_cells)))
+ 		return;
+ 
+ 	elfcorehdr_addr = dt_mem_next_cell(dt_root_addr_cells, &prop);
+ 	elfcorehdr_size = dt_mem_next_cell(dt_root_size_cells, &prop);
+ 
+ 	pr_debug("elfcorehdr_start=0x%llx elfcorehdr_size=0x%llx\n",
+ 		 elfcorehdr_addr, elfcorehdr_size);
+ }
+ 
+ static unsigned long chosen_node_offset = -FDT_ERR_NOTFOUND;
+ 
+ /*
+  * The main usage of linux,usable-memory-range is for crash dump kernel.
+  * Originally, the number of usable-memory regions is one. Now there may
+  * be two regions, low region and high region.
+  * To make compatibility with existing user-space and older kdump, the low
+  * region is always the last range of linux,usable-memory-range if exist.
+  */
+ #define MAX_USABLE_RANGES		2
+ 
+ /**
+  * early_init_dt_check_for_usable_mem_range - Decode usable memory range
+  * location from flat tree
+  */
+ void __init early_init_dt_check_for_usable_mem_range(void)
+ {
+ 	struct memblock_region rgn[MAX_USABLE_RANGES] = {0};
+ 	const __be32 *prop, *endp;
+ 	int len, i;
+ 	unsigned long node = chosen_node_offset;
+ 
+ 	if ((long)node < 0)
+ 		return;
+ 
+ 	pr_debug("Looking for usable-memory-range property... ");
+ 
+ 	prop = of_get_flat_dt_prop(node, "linux,usable-memory-range", &len);
+ 	if (!prop || (len % (dt_root_addr_cells + dt_root_size_cells)))
+ 		return;
+ 
+ 	endp = prop + (len / sizeof(__be32));
+ 	for (i = 0; i < MAX_USABLE_RANGES && prop < endp; i++) {
+ 		rgn[i].base = dt_mem_next_cell(dt_root_addr_cells, &prop);
+ 		rgn[i].size = dt_mem_next_cell(dt_root_size_cells, &prop);
+ 
+ 		pr_debug("cap_mem_regions[%d]: base=%pa, size=%pa\n",
+ 			 i, &rgn[i].base, &rgn[i].size);
+ 	}
+ 
+ 	memblock_cap_memory_range(rgn[0].base, rgn[0].size);
+ 	for (i = 1; i < MAX_USABLE_RANGES && rgn[i].size; i++)
+ 		memblock_add(rgn[i].base, rgn[i].size);
++>>>>>>> fb319e77a0e7 (of: fdt: Add memory for devices by DT property "linux,usable-memory-range")
  }
 +#endif /* CONFIG_BLK_DEV_INITRD */
  
  #ifdef CONFIG_SERIAL_EARLYCON
  
* Unmerged path drivers/of/fdt.c
