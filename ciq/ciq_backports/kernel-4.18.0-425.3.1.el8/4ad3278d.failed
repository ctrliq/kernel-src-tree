x86/speculation: Disable RRSBA behavior

jira LE-1907
cve CVE-2022-29901
cve CVE-2022-29900
cve CVE-2022-23825
cve CVE-2022-23816
Rebuild_History Non-Buildable kernel-4.18.0-425.3.1.el8
commit-author Pawan Gupta <pawan.kumar.gupta@linux.intel.com>
commit 4ad3278df6fe2b0852b00d5757fc2ccd8e92c26e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-425.3.1.el8/4ad3278d.failed

Some Intel processors may use alternate predictors for RETs on
RSB-underflow. This condition may be vulnerable to Branch History
Injection (BHI) and intramode-BTI.

Kernel earlier added spectre_v2 mitigation modes (eIBRS+Retpolines,
eIBRS+LFENCE, Retpolines) which protect indirect CALLs and JMPs against
such attacks. However, on RSB-underflow, RET target prediction may
fallback to alternate predictors. As a result, RET's predicted target
may get influenced by branch history.

A new MSR_IA32_SPEC_CTRL bit (RRSBA_DIS_S) controls this fallback
behavior when in kernel mode. When set, RETs will not take predictions
from alternate predictors, hence mitigating RETs as well. Support for
this is enumerated by CPUID.7.2.EDX[RRSBA_CTRL] (bit2).

For spectre v2 mitigation, when a user selects a mitigation that
protects indirect CALLs and JMPs against BHI and intramode-BTI, set
RRSBA_DIS_S also to protect RETs for RSB-underflow case.

	Signed-off-by: Pawan Gupta <pawan.kumar.gupta@linux.intel.com>
	Signed-off-by: Borislav Petkov <bp@suse.de>
(cherry picked from commit 4ad3278df6fe2b0852b00d5757fc2ccd8e92c26e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/cpufeatures.h
#	arch/x86/include/asm/msr-index.h
#	arch/x86/kernel/cpu/scattered.c
#	tools/arch/x86/include/asm/msr-index.h
diff --cc arch/x86/include/asm/cpufeatures.h
index 05564117439b,00f5227c8459..000000000000
--- a/arch/x86/include/asm/cpufeatures.h
+++ b/arch/x86/include/asm/cpufeatures.h
@@@ -292,10 -296,12 +292,15 @@@
  #define X86_FEATURE_PER_THREAD_MBA	(11*32+ 7) /* "" Per-thread Memory Bandwidth Allocation */
  #define X86_FEATURE_SGX1		(11*32+ 8) /* "" Basic SGX */
  #define X86_FEATURE_SGX2		(11*32+ 9) /* "" SGX Enclave Dynamic Memory Management (EDMM) */
++<<<<<<< HEAD
 +/* FREE!				(11*32+10) */
 +/* FREE!				(11*32+11) */
++=======
+ #define X86_FEATURE_ENTRY_IBPB		(11*32+10) /* "" Issue an IBPB on kernel entry */
+ #define X86_FEATURE_RRSBA_CTRL		(11*32+11) /* "" RET prediction control */
++>>>>>>> 4ad3278df6fe (x86/speculation: Disable RRSBA behavior)
  #define X86_FEATURE_RETPOLINE		(11*32+12) /* "" Generic Retpoline mitigation for Spectre variant 2 */
  #define X86_FEATURE_RETPOLINE_LFENCE	(11*32+13) /* "" Use LFENCE for Spectre variant 2 */
 -#define X86_FEATURE_RETHUNK		(11*32+14) /* "" Use REturn THUNK */
 -#define X86_FEATURE_UNRET		(11*32+15) /* "" AMD BTB untrain return */
  
  /* Intel-defined CPU features, CPUID level 0x00000007:1 (EAX), word 12 */
  #define X86_FEATURE_AVX_VNNI		(12*32+ 4) /* AVX VNNI instructions */
diff --cc arch/x86/include/asm/msr-index.h
index 2cbe3c8c6165,cc615be27a54..000000000000
--- a/arch/x86/include/asm/msr-index.h
+++ b/arch/x86/include/asm/msr-index.h
@@@ -114,6 -119,37 +116,40 @@@
  						 * Not susceptible to
  						 * TSX Async Abort (TAA) vulnerabilities.
  						 */
++<<<<<<< HEAD
++=======
+ #define ARCH_CAP_SBDR_SSDP_NO		BIT(13)	/*
+ 						 * Not susceptible to SBDR and SSDP
+ 						 * variants of Processor MMIO stale data
+ 						 * vulnerabilities.
+ 						 */
+ #define ARCH_CAP_FBSDP_NO		BIT(14)	/*
+ 						 * Not susceptible to FBSDP variant of
+ 						 * Processor MMIO stale data
+ 						 * vulnerabilities.
+ 						 */
+ #define ARCH_CAP_PSDP_NO		BIT(15)	/*
+ 						 * Not susceptible to PSDP variant of
+ 						 * Processor MMIO stale data
+ 						 * vulnerabilities.
+ 						 */
+ #define ARCH_CAP_FB_CLEAR		BIT(17)	/*
+ 						 * VERW clears CPU fill buffer
+ 						 * even on MDS_NO CPUs.
+ 						 */
+ #define ARCH_CAP_FB_CLEAR_CTRL		BIT(18)	/*
+ 						 * MSR_IA32_MCU_OPT_CTRL[FB_CLEAR_DIS]
+ 						 * bit available to control VERW
+ 						 * behavior.
+ 						 */
+ #define ARCH_CAP_RRSBA			BIT(19)	/*
+ 						 * Indicates RET may use predictors
+ 						 * other than the RSB. With eIBRS
+ 						 * enabled predictions in kernel mode
+ 						 * are restricted to targets in
+ 						 * kernel.
+ 						 */
++>>>>>>> 4ad3278df6fe (x86/speculation: Disable RRSBA behavior)
  
  #define MSR_IA32_FLUSH_CMD		0x0000010b
  #define L1D_FLUSH			BIT(0)	/*
diff --cc arch/x86/kernel/cpu/scattered.c
index 2a683fcece5e,fd44b54c90d5..000000000000
--- a/arch/x86/kernel/cpu/scattered.c
+++ b/arch/x86/kernel/cpu/scattered.c
@@@ -24,6 -26,8 +24,11 @@@ struct cpuid_bit 
  static const struct cpuid_bit cpuid_bits[] = {
  	{ X86_FEATURE_APERFMPERF,       CPUID_ECX,  0, 0x00000006, 0 },
  	{ X86_FEATURE_EPB,		CPUID_ECX,  3, 0x00000006, 0 },
++<<<<<<< HEAD
++=======
+ 	{ X86_FEATURE_INTEL_PPIN,	CPUID_EBX,  0, 0x00000007, 1 },
+ 	{ X86_FEATURE_RRSBA_CTRL,	CPUID_EDX,  2, 0x00000007, 2 },
++>>>>>>> 4ad3278df6fe (x86/speculation: Disable RRSBA behavior)
  	{ X86_FEATURE_CQM_LLC,		CPUID_EDX,  1, 0x0000000f, 0 },
  	{ X86_FEATURE_CQM_OCCUP_LLC,	CPUID_EDX,  0, 0x0000000f, 1 },
  	{ X86_FEATURE_CQM_MBM_TOTAL,	CPUID_EDX,  1, 0x0000000f, 1 },
diff --cc tools/arch/x86/include/asm/msr-index.h
index 103d077010a4,2eab6a3a8a8c..000000000000
--- a/tools/arch/x86/include/asm/msr-index.h
+++ b/tools/arch/x86/include/asm/msr-index.h
@@@ -114,6 -118,37 +116,40 @@@
  						 * Not susceptible to
  						 * TSX Async Abort (TAA) vulnerabilities.
  						 */
++<<<<<<< HEAD
++=======
+ #define ARCH_CAP_SBDR_SSDP_NO		BIT(13)	/*
+ 						 * Not susceptible to SBDR and SSDP
+ 						 * variants of Processor MMIO stale data
+ 						 * vulnerabilities.
+ 						 */
+ #define ARCH_CAP_FBSDP_NO		BIT(14)	/*
+ 						 * Not susceptible to FBSDP variant of
+ 						 * Processor MMIO stale data
+ 						 * vulnerabilities.
+ 						 */
+ #define ARCH_CAP_PSDP_NO		BIT(15)	/*
+ 						 * Not susceptible to PSDP variant of
+ 						 * Processor MMIO stale data
+ 						 * vulnerabilities.
+ 						 */
+ #define ARCH_CAP_FB_CLEAR		BIT(17)	/*
+ 						 * VERW clears CPU fill buffer
+ 						 * even on MDS_NO CPUs.
+ 						 */
+ #define ARCH_CAP_FB_CLEAR_CTRL		BIT(18)	/*
+ 						 * MSR_IA32_MCU_OPT_CTRL[FB_CLEAR_DIS]
+ 						 * bit available to control VERW
+ 						 * behavior.
+ 						 */
+ #define ARCH_CAP_RRSBA			BIT(19)	/*
+ 						 * Indicates RET may use predictors
+ 						 * other than the RSB. With eIBRS
+ 						 * enabled predictions in kernel mode
+ 						 * are restricted to targets in
+ 						 * kernel.
+ 						 */
++>>>>>>> 4ad3278df6fe (x86/speculation: Disable RRSBA behavior)
  
  #define MSR_IA32_FLUSH_CMD		0x0000010b
  #define L1D_FLUSH			BIT(0)	/*
* Unmerged path arch/x86/include/asm/cpufeatures.h
* Unmerged path arch/x86/include/asm/msr-index.h
diff --git a/arch/x86/kernel/cpu/bugs.c b/arch/x86/kernel/cpu/bugs.c
index 951579a17911..c9ad8392f20a 100644
--- a/arch/x86/kernel/cpu/bugs.c
+++ b/arch/x86/kernel/cpu/bugs.c
@@ -969,6 +969,22 @@ static enum spectre_v2_mitigation __init spectre_v2_select_retpoline(void)
 	return SPECTRE_V2_RETPOLINE;
 }
 
+/* Disable in-kernel use of non-RSB RET predictors */
+static void __init spec_ctrl_disable_kernel_rrsba(void)
+{
+	u64 ia32_cap;
+
+	if (!boot_cpu_has(X86_FEATURE_RRSBA_CTRL))
+		return;
+
+	ia32_cap = x86_read_arch_cap_msr();
+
+	if (ia32_cap & ARCH_CAP_RRSBA) {
+		x86_spec_ctrl_base |= SPEC_CTRL_RRSBA_DIS_S;
+		write_spec_ctrl_current(x86_spec_ctrl_base, true);
+	}
+}
+
 static void __init spectre_v2_select_mitigation(void)
 {
 	enum spectre_v2_mitigation_cmd cmd = spectre_v2_parse_cmdline();
@@ -1085,6 +1101,16 @@ static void __init spectre_v2_select_mitigation(void)
 		break;
 	}
 
+	/*
+	 * Disable alternate RSB predictions in kernel when indirect CALLs and
+	 * JMPs gets protection against BHI and Intramode-BTI, but RET
+	 * prediction from a non-RSB predictor is still a risk.
+	 */
+	if (mode == SPECTRE_V2_EIBRS_LFENCE ||
+	    mode == SPECTRE_V2_EIBRS_RETPOLINE ||
+	    mode == SPECTRE_V2_RETPOLINE)
+		spec_ctrl_disable_kernel_rrsba();
+
 	spectre_v2_enabled = mode;
 	pr_info("%s\n", spectre_v2_strings[mode]);
 
* Unmerged path arch/x86/kernel/cpu/scattered.c
* Unmerged path tools/arch/x86/include/asm/msr-index.h
