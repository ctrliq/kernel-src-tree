ASoC: SOF: topology: Make mux/demux widget parsing IPC agnostic

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-425.3.1.el8
commit-author Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
commit 683b54ef603825328859d867aabf9a6d973238a2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-425.3.1.el8/683b54ef.failed

Define the list of tokens pertaining to the mux/demux widgets, parse and
save them as part of the swidget tuples array. Once topology parsing is
complete, these tokens will be applied to create the IPC structure for the
mux/demux component based on the topology widget_setup op in ipc3_tplg_ops.

	Signed-off-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
	Reviewed-by: Bard Liao <yung-chuan.liao@linux.intel.com>
	Reviewed-by: PÃ©ter Ujfalusi <peter.ujfalusi@linux.intel.com>
	Reviewed-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
Link: https://lore.kernel.org/r/20220314200520.1233427-11-ranjani.sridharan@linux.intel.com
	Signed-off-by: Mark Brown <broonie@kernel.org>
(cherry picked from commit 683b54ef603825328859d867aabf9a6d973238a2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/soc/sof/ipc3-topology.c
#	sound/soc/sof/topology.c
diff --cc sound/soc/sof/topology.c
index b825b9e56fa9,42da7b8e7180..000000000000
--- a/sound/soc/sof/topology.c
+++ b/sound/soc/sof/topology.c
@@@ -1693,274 -1723,66 +1693,275 @@@ static int spcm_bind(struct snd_soc_com
  	return 0;
  }
  
 -static int sof_widget_parse_tokens(struct snd_soc_component *scomp, struct snd_sof_widget *swidget,
 -				   struct snd_soc_tplg_dapm_widget *tw,
 -				   enum sof_tokens *object_token_list, int count)
 +/*
 + * PCM Topology
 + */
 +
 +static int sof_widget_load_pcm(struct snd_soc_component *scomp, int index,
 +			       struct snd_sof_widget *swidget,
 +			       enum sof_ipc_stream_direction dir,
 +			       struct snd_soc_tplg_dapm_widget *tw)
  {
 -	struct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);
 -	const struct sof_ipc_tplg_ops *ipc_tplg_ops = sdev->ipc->ops->tplg;
 -	const struct sof_token_info *token_list = ipc_tplg_ops->token_list;
  	struct snd_soc_tplg_private *private = &tw->priv;
 -	int num_tuples = 0;
 -	size_t size;
 -	int ret, i;
 +	struct sof_ipc_comp_host *host;
 +	size_t ipc_size = sizeof(*host);
 +	int ret;
  
 -	if (count > 0 && !object_token_list) {
 -		dev_err(scomp->dev, "No token list for widget %s\n", swidget->widget->name);
 -		return -EINVAL;
 +	host = (struct sof_ipc_comp_host *)
 +	       sof_comp_alloc(swidget, &ipc_size, index);
 +	if (!host)
 +		return -ENOMEM;
 +
 +	/* configure host comp IPC message */
 +	host->comp.type = SOF_COMP_HOST;
 +	host->direction = dir;
 +	host->config.hdr.size = sizeof(host->config);
 +
 +	ret = sof_parse_tokens(scomp, host, pcm_tokens,
 +			       ARRAY_SIZE(pcm_tokens), private->array,
 +			       le32_to_cpu(private->size));
 +	if (ret != 0) {
 +		dev_err(scomp->dev, "error: parse host tokens failed %d\n",
 +			private->size);
 +		goto err;
  	}
  
 -	/* calculate max size of tuples array */
 -	for (i = 0; i < count; i++)
 -		num_tuples += token_list[object_token_list[i]].count;
 +	ret = sof_parse_tokens(scomp, &host->config, comp_tokens,
 +			       ARRAY_SIZE(comp_tokens), private->array,
 +			       le32_to_cpu(private->size));
 +	if (ret != 0) {
 +		dev_err(scomp->dev, "error: parse host.cfg tokens failed %d\n",
 +			le32_to_cpu(private->size));
 +		goto err;
 +	}
  
 -	/* allocate memory for tuples array */
 -	size = sizeof(struct snd_sof_tuple) * num_tuples;
 -	swidget->tuples = kzalloc(size, GFP_KERNEL);
 -	if (!swidget->tuples)
 +	dev_dbg(scomp->dev, "loaded host %s\n", swidget->widget->name);
 +	sof_dbg_comp_config(scomp, &host->config);
 +
 +	swidget->private = host;
 +
 +	return 0;
 +err:
 +	kfree(host);
 +	return ret;
 +}
 +
 +/*
++<<<<<<< HEAD
 + * Pipeline Topology
 + */
 +static int sof_widget_load_pipeline(struct snd_soc_component *scomp, int index,
 +				    struct snd_sof_widget *swidget,
 +				    struct snd_soc_tplg_dapm_widget *tw)
 +{
 +	struct snd_soc_tplg_private *private = &tw->priv;
 +	struct sof_ipc_pipe_new *pipeline;
 +	struct snd_sof_widget *comp_swidget;
 +	int ret;
 +
 +	pipeline = kzalloc(sizeof(*pipeline), GFP_KERNEL);
 +	if (!pipeline)
  		return -ENOMEM;
  
 -	/* parse token list for widget */
 -	for (i = 0; i < count; i++) {
 -		if (object_token_list[i] >= SOF_TOKEN_COUNT) {
 -			dev_err(scomp->dev, "Invalid token id %d for widget %s\n",
 -				object_token_list[i], swidget->widget->name);
 -			ret = -EINVAL;
 -			goto err;
 -		}
 +	/* configure dai IPC message */
 +	pipeline->hdr.size = sizeof(*pipeline);
 +	pipeline->hdr.cmd = SOF_IPC_GLB_TPLG_MSG | SOF_IPC_TPLG_PIPE_NEW;
 +	pipeline->pipeline_id = index;
 +	pipeline->comp_id = swidget->comp_id;
 +
 +	/* component at start of pipeline is our stream id */
 +	comp_swidget = snd_sof_find_swidget(scomp, tw->sname);
 +	if (!comp_swidget) {
 +		dev_err(scomp->dev, "error: widget %s refers to non existent widget %s\n",
 +			tw->name, tw->sname);
 +		ret = -EINVAL;
 +		goto err;
 +	}
  
 -		/* parse and save UUID in swidget */
 -		if (object_token_list[i] == SOF_COMP_EXT_TOKENS) {
 -			ret = sof_parse_tokens(scomp, swidget,
 -					       token_list[object_token_list[i]].tokens,
 -					       token_list[object_token_list[i]].count,
 -					       private->array, le32_to_cpu(private->size));
 -			if (ret < 0) {
 -				dev_err(scomp->dev, "Failed parsing %s for widget %s\n",
 -					token_list[object_token_list[i]].name,
 -					swidget->widget->name);
 -				goto err;
 -			}
 +	pipeline->sched_id = comp_swidget->comp_id;
  
 -			continue;
 -		}
 +	dev_dbg(scomp->dev, "tplg: pipeline id %d comp %d scheduling comp id %d\n",
 +		pipeline->pipeline_id, pipeline->comp_id, pipeline->sched_id);
  
 -		/* copy one set of tuples per token ID into swidget->tuples */
 -		ret = sof_copy_tuples(sdev, private->array, le32_to_cpu(private->size),
 -				      object_token_list[i], 1, swidget->tuples,
 -				      num_tuples, &swidget->num_tuples);
 -		if (ret < 0) {
 -			dev_err(scomp->dev, "Failed parsing %s for widget %s err: %d\n",
 -				token_list[object_token_list[i]].name, swidget->widget->name, ret);
 -			goto err;
 +	ret = sof_parse_tokens(scomp, pipeline, sched_tokens,
 +			       ARRAY_SIZE(sched_tokens), private->array,
 +			       le32_to_cpu(private->size));
 +	if (ret != 0) {
 +		dev_err(scomp->dev, "error: parse pipeline tokens failed %d\n",
 +			private->size);
 +		goto err;
 +	}
 +
 +	ret = sof_parse_tokens(scomp, swidget, pipeline_tokens,
 +			       ARRAY_SIZE(pipeline_tokens), private->array,
 +			       le32_to_cpu(private->size));
 +	if (ret != 0) {
 +		dev_err(scomp->dev, "error: parse dynamic pipeline token failed %d\n",
 +			private->size);
 +		goto err;
 +	}
 +
 +	if (sof_debug_check_flag(SOF_DBG_DISABLE_MULTICORE))
 +		pipeline->core = SOF_DSP_PRIMARY_CORE;
 +
 +	if (sof_debug_check_flag(SOF_DBG_DYNAMIC_PIPELINES_OVERRIDE))
 +		swidget->dynamic_pipeline_widget =
 +			sof_debug_check_flag(SOF_DBG_DYNAMIC_PIPELINES_ENABLE);
 +
 +	dev_dbg(scomp->dev, "pipeline %s: period %d pri %d mips %d core %d frames %d dynamic %d\n",
 +		swidget->widget->name, pipeline->period, pipeline->priority,
 +		pipeline->period_mips, pipeline->core, pipeline->frames_per_sched,
 +		swidget->dynamic_pipeline_widget);
 +
 +	swidget->core = pipeline->core;
 +	swidget->private = pipeline;
 +
 +	return 0;
 +err:
 +	kfree(pipeline);
 +	return ret;
 +}
 +
 +/*
 + * Mixer topology
 + */
 +
 +static int sof_widget_load_mixer(struct snd_soc_component *scomp, int index,
 +				 struct snd_sof_widget *swidget,
 +				 struct snd_soc_tplg_dapm_widget *tw)
 +{
 +	struct snd_soc_tplg_private *private = &tw->priv;
 +	struct sof_ipc_comp_mixer *mixer;
 +	size_t ipc_size = sizeof(*mixer);
 +	int ret;
 +
 +	mixer = (struct sof_ipc_comp_mixer *)
 +		sof_comp_alloc(swidget, &ipc_size, index);
 +	if (!mixer)
 +		return -ENOMEM;
 +
 +	/* configure mixer IPC message */
 +	mixer->comp.type = SOF_COMP_MIXER;
 +	mixer->config.hdr.size = sizeof(mixer->config);
 +
 +	ret = sof_parse_tokens(scomp, &mixer->config, comp_tokens,
 +			       ARRAY_SIZE(comp_tokens), private->array,
 +			       le32_to_cpu(private->size));
 +	if (ret != 0) {
 +		dev_err(scomp->dev, "error: parse mixer.cfg tokens failed %d\n",
 +			private->size);
 +		kfree(mixer);
 +		return ret;
 +	}
 +
 +	sof_dbg_comp_config(scomp, &mixer->config);
 +
 +	swidget->private = mixer;
 +
 +	return 0;
 +}
 +
 +/*
 + * Mux topology
 + */
 +static int sof_widget_load_mux(struct snd_soc_component *scomp, int index,
 +			       struct snd_sof_widget *swidget,
 +			       struct snd_soc_tplg_dapm_widget *tw)
 +{
 +	struct snd_soc_tplg_private *private = &tw->priv;
 +	struct sof_ipc_comp_mux *mux;
 +	size_t ipc_size = sizeof(*mux);
 +	int ret;
 +
 +	mux = (struct sof_ipc_comp_mux *)
 +	      sof_comp_alloc(swidget, &ipc_size, index);
 +	if (!mux)
 +		return -ENOMEM;
 +
 +	/* configure mux IPC message */
 +	mux->comp.type = SOF_COMP_MUX;
 +	mux->config.hdr.size = sizeof(mux->config);
 +
 +	ret = sof_parse_tokens(scomp, &mux->config, comp_tokens,
 +			       ARRAY_SIZE(comp_tokens), private->array,
 +			       le32_to_cpu(private->size));
 +	if (ret != 0) {
 +		dev_err(scomp->dev, "error: parse mux.cfg tokens failed %d\n",
 +			private->size);
 +		kfree(mux);
 +		return ret;
 +	}
 +
 +	sof_dbg_comp_config(scomp, &mux->config);
 +
 +	swidget->private = mux;
 +
 +	return 0;
 +}
 +
 +/*
 + * PGA Topology
 + */
 +
 +static int sof_widget_load_pga(struct snd_soc_component *scomp, int index,
 +			       struct snd_sof_widget *swidget,
 +			       struct snd_soc_tplg_dapm_widget *tw)
 +{
 +	struct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);
 +	struct snd_soc_tplg_private *private = &tw->priv;
 +	struct sof_ipc_comp_volume *volume;
 +	struct snd_sof_control *scontrol;
 +	size_t ipc_size = sizeof(*volume);
 +	int min_step;
 +	int max_step;
 +	int ret;
 +
 +	volume = (struct sof_ipc_comp_volume *)
 +		 sof_comp_alloc(swidget, &ipc_size, index);
 +	if (!volume)
 +		return -ENOMEM;
 +
 +	if (!le32_to_cpu(tw->num_kcontrols)) {
 +		dev_err(scomp->dev, "error: invalid kcontrol count %d for volume\n",
 +			tw->num_kcontrols);
 +		ret = -EINVAL;
 +		goto err;
 +	}
 +
 +	/* configure volume IPC message */
 +	volume->comp.type = SOF_COMP_VOLUME;
 +	volume->config.hdr.size = sizeof(volume->config);
 +
 +	ret = sof_parse_tokens(scomp, volume, volume_tokens,
 +			       ARRAY_SIZE(volume_tokens), private->array,
 +			       le32_to_cpu(private->size));
 +	if (ret != 0) {
 +		dev_err(scomp->dev, "error: parse volume tokens failed %d\n",
 +			private->size);
 +		goto err;
 +	}
 +	ret = sof_parse_tokens(scomp, &volume->config, comp_tokens,
 +			       ARRAY_SIZE(comp_tokens), private->array,
 +			       le32_to_cpu(private->size));
 +	if (ret != 0) {
 +		dev_err(scomp->dev, "error: parse volume.cfg tokens failed %d\n",
 +			le32_to_cpu(private->size));
 +		goto err;
 +	}
 +
 +	sof_dbg_comp_config(scomp, &volume->config);
 +
 +	swidget->private = volume;
 +
 +	list_for_each_entry(scontrol, &sdev->kcontrol_list, list) {
 +		if (scontrol->comp_id == swidget->comp_id &&
 +		    scontrol->volume_table) {
 +			min_step = scontrol->min_volume_step;
 +			max_step = scontrol->max_volume_step;
 +			volume->min_value = scontrol->volume_table[min_step];
 +			volume->max_value = scontrol->volume_table[max_step];
 +			volume->channels = scontrol->num_channels;
 +			break;
  		}
  	}
  
@@@ -1971,6 -1793,6 +1972,8 @@@ err
  }
  
  /*
++=======
++>>>>>>> 683b54ef6038 (ASoC: SOF: topology: Make mux/demux widget parsing IPC agnostic)
   * SRC Topology
   */
  
@@@ -2435,25 -2264,23 +2438,31 @@@ static int sof_widget_ready(struct snd_
  		list_add(&dai->list, &sdev->dai_list);
  		swidget->private = dai;
  		break;
 -	case snd_soc_dapm_pga:
 -		if (!le32_to_cpu(tw->num_kcontrols)) {
 -			dev_err(scomp->dev, "invalid kcontrol count %d for volume\n",
 -				tw->num_kcontrols);
 -			ret = -EINVAL;
 -			break;
 -		}
 -
 -		fallthrough;
  	case snd_soc_dapm_mixer:
 +		ret = sof_widget_load_mixer(scomp, index, swidget, tw);
 +		break;
 +	case snd_soc_dapm_pga:
 +		ret = sof_widget_load_pga(scomp, index, swidget, tw);
 +		break;
  	case snd_soc_dapm_buffer:
 +		ret = sof_widget_load_buffer(scomp, index, swidget, tw);
 +		break;
  	case snd_soc_dapm_scheduler:
 +		ret = sof_widget_load_pipeline(scomp, index, swidget, tw);
 +		break;
  	case snd_soc_dapm_aif_out:
 +		ret = sof_widget_load_pcm(scomp, index, swidget,
 +					  SOF_IPC_STREAM_CAPTURE, tw);
 +		break;
  	case snd_soc_dapm_aif_in:
++<<<<<<< HEAD
 +		ret = sof_widget_load_pcm(scomp, index, swidget,
 +					  SOF_IPC_STREAM_PLAYBACK, tw);
++=======
+ 	case snd_soc_dapm_mux:
+ 	case snd_soc_dapm_demux:
+ 		ret = sof_widget_parse_tokens(scomp, swidget, tw,  token_list, token_list_size);
++>>>>>>> 683b54ef6038 (ASoC: SOF: topology: Make mux/demux widget parsing IPC agnostic)
  		break;
  	case snd_soc_dapm_src:
  		ret = sof_widget_load_src(scomp, index, swidget, tw);
* Unmerged path sound/soc/sof/ipc3-topology.c
* Unmerged path sound/soc/sof/ipc3-topology.c
* Unmerged path sound/soc/sof/topology.c
