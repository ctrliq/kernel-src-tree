mptcp: fix subflow accounting on close

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-425.3.1.el8
commit-author Paolo Abeni <pabeni@redhat.com>
commit 95d686517884a403412b000361cee2b08b2ed1e6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-425.3.1.el8/95d68651.failed

If the PM closes a fully established MPJ subflow or the subflow
creation errors out in it's early stage the subflows counter is
not bumped accordingly.

This change adds the missing accounting, additionally taking care
of updating accordingly the 'accept_subflow' flag.

Fixes: a88c9e496937 ("mptcp: do not block subflows creation on errors")
	Signed-off-by: Paolo Abeni <pabeni@redhat.com>
	Signed-off-by: Mat Martineau <mathew.j.martineau@linux.intel.com>
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit 95d686517884a403412b000361cee2b08b2ed1e6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/mptcp/pm.c
diff --cc net/mptcp/pm.c
index d550692d3374,aa51b100e033..000000000000
--- a/net/mptcp/pm.c
+++ b/net/mptcp/pm.c
@@@ -172,9 -172,27 +172,30 @@@ void mptcp_pm_subflow_established(struc
  	spin_unlock_bh(&pm->lock);
  }
  
 -void mptcp_pm_subflow_check_next(struct mptcp_sock *msk, const struct sock *ssk,
 -				 const struct mptcp_subflow_context *subflow)
 +void mptcp_pm_subflow_closed(struct mptcp_sock *msk, u8 id)
  {
++<<<<<<< HEAD
 +	pr_debug("msk=%p", msk);
++=======
+ 	struct mptcp_pm_data *pm = &msk->pm;
+ 	bool update_subflows;
+ 
+ 	update_subflows = subflow->request_join || subflow->mp_join;
+ 	if (!READ_ONCE(pm->work_pending) && !update_subflows)
+ 		return;
+ 
+ 	spin_lock_bh(&pm->lock);
+ 	if (update_subflows)
+ 		__mptcp_pm_close_subflow(msk);
+ 
+ 	/* Even if this subflow is not really established, tell the PM to try
+ 	 * to pick the next ones, if possible.
+ 	 */
+ 	if (mptcp_pm_nl_check_work_pending(msk))
+ 		mptcp_pm_schedule_work(msk, MPTCP_PM_SUBFLOW_ESTABLISHED);
+ 
+ 	spin_unlock_bh(&pm->lock);
++>>>>>>> 95d686517884 (mptcp: fix subflow accounting on close)
  }
  
  void mptcp_pm_add_addr_received(struct mptcp_sock *msk,
* Unmerged path net/mptcp/pm.c
diff --git a/net/mptcp/protocol.h b/net/mptcp/protocol.h
index eedb890af3bd..637c9b12baa5 100644
--- a/net/mptcp/protocol.h
+++ b/net/mptcp/protocol.h
@@ -782,6 +782,20 @@ unsigned int mptcp_pm_get_add_addr_accept_max(struct mptcp_sock *msk);
 unsigned int mptcp_pm_get_subflows_max(struct mptcp_sock *msk);
 unsigned int mptcp_pm_get_local_addr_max(struct mptcp_sock *msk);
 
+/* called under PM lock */
+static inline void __mptcp_pm_close_subflow(struct mptcp_sock *msk)
+{
+	if (--msk->pm.subflows < mptcp_pm_get_subflows_max(msk))
+		WRITE_ONCE(msk->pm.accept_subflow, true);
+}
+
+static inline void mptcp_pm_close_subflow(struct mptcp_sock *msk)
+{
+	spin_lock_bh(&msk->pm.lock);
+	__mptcp_pm_close_subflow(msk);
+	spin_unlock_bh(&msk->pm.lock);
+}
+
 void mptcp_sockopt_sync(struct mptcp_sock *msk, struct sock *ssk);
 void mptcp_sockopt_sync_all(struct mptcp_sock *msk);
 
diff --git a/net/mptcp/subflow.c b/net/mptcp/subflow.c
index e3b8c16e14c9..51b3f763fb6c 100644
--- a/net/mptcp/subflow.c
+++ b/net/mptcp/subflow.c
@@ -1264,20 +1264,20 @@ int __mptcp_subflow_connect(struct sock *sk, const struct mptcp_addr_info *loc,
 	struct sockaddr_storage addr;
 	int remote_id = remote->id;
 	int local_id = loc->id;
+	int err = -ENOTCONN;
 	struct socket *sf;
 	struct sock *ssk;
 	u32 remote_token;
 	int addrlen;
 	int ifindex;
 	u8 flags;
-	int err;
 
 	if (!mptcp_is_fully_established(sk))
-		return -ENOTCONN;
+		goto err_out;
 
 	err = mptcp_subflow_create_socket(sk, &sf);
 	if (err)
-		return err;
+		goto err_out;
 
 	ssk = sf->sk;
 	subflow = mptcp_subflow_ctx(ssk);
@@ -1340,6 +1340,12 @@ int __mptcp_subflow_connect(struct sock *sk, const struct mptcp_addr_info *loc,
 failed:
 	subflow->disposable = 1;
 	sock_release(sf);
+
+err_out:
+	/* we account subflows before the creation, and this failures will not
+	 * be caught by sk_state_change()
+	 */
+	mptcp_pm_close_subflow(msk);
 	return err;
 }
 
