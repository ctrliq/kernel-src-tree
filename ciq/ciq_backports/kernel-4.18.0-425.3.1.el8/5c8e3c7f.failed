ice: Fix VSIs unable to share unicast MAC

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-425.3.1.el8
commit-author Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
commit 5c8e3c7ff3e7bd7b938659be704f75cc746b697f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-425.3.1.el8/5c8e3c7f.failed

The driver currently does not allow two VSIs in the same PF domain
to have the same unicast MAC address. This is incorrect in the sense
that a policy decision is being made in the driver when it must be
left to the user. This approach was causing issues when rebooting
the system with VFs spawned not being able to change their MAC addresses.
Such errors were present in dmesg:

[ 7921.068237] ice 0000:b6:00.2 ens2f2: Unicast MAC 6a:0d:e4:70:ca:d1 already
exists on this PF. Preventing setting VF 7 unicast MAC address to 6a:0d:e4:70:ca:d1

Fix that by removing this restriction. Doing this also allows
us to remove some additional code that's checking if a unicast MAC
filter already exists.

Fixes: 47ebc7b02485 ("ice: Check if unicast MAC exists before setting VF MAC")
	Signed-off-by: Anirudh Venkataramanan <anirudh.venkataramanan@intel.com>
	Signed-off-by: Sylwester Dziedziuch <sylwesterx.dziedziuch@intel.com>
	Signed-off-by: Mateusz Palczewski <mateusz.palczewski@intel.com>
	Signed-off-by: Jedrzej Jagielski <jedrzej.jagielski@intel.com>
	Tested-by: Marek Szlosek <marek.szlosek@intel.com>
	Signed-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>
(cherry picked from commit 5c8e3c7ff3e7bd7b938659be704f75cc746b697f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/ice/ice_sriov.c
diff --cc drivers/net/ethernet/intel/ice/ice_sriov.c
index 52c6bac41bf7,f4907a3c2d19..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_sriov.c
+++ b/drivers/net/ethernet/intel/ice/ice_sriov.c
@@@ -40,181 -1202,219 +40,210 @@@ ice_aq_send_msg_to_vf(struct ice_hw *hw
  }
  
  /**
 - * ice_set_vf_spoofchk
 - * @netdev: network interface device structure
 - * @vf_id: VF identifier
 - * @ena: flag to enable or disable feature
++<<<<<<< HEAD
 + * ice_conv_link_speed_to_virtchnl
 + * @adv_link_support: determines the format of the returned link speed
 + * @link_speed: variable containing the link_speed to be converted
   *
 - * Enable or disable VF spoof checking
 + * Convert link speed supported by HW to link speed supported by virtchnl.
 + * If adv_link_support is true, then return link speed in Mbps. Else return
 + * link speed as a VIRTCHNL_LINK_SPEED_* casted to a u32. Note that the caller
 + * needs to cast back to an enum virtchnl_link_speed in the case where
 + * adv_link_support is false, but when adv_link_support is true the caller can
 + * expect the speed in Mbps.
   */
 -int ice_set_vf_spoofchk(struct net_device *netdev, int vf_id, bool ena)
 +u32 ice_conv_link_speed_to_virtchnl(bool adv_link_support, u16 link_speed)
  {
 -	struct ice_netdev_priv *np = netdev_priv(netdev);
 -	struct ice_pf *pf = np->vsi->back;
 -	struct ice_vsi *vf_vsi;
 -	struct device *dev;
 -	struct ice_vf *vf;
 -	int ret;
 -
 -	dev = ice_pf_to_dev(pf);
 -
 -	vf = ice_get_vf_by_id(pf, vf_id);
 -	if (!vf)
 -		return -EINVAL;
 -
 -	ret = ice_check_vf_ready_for_cfg(vf);
 -	if (ret)
 -		goto out_put_vf;
 -
 -	vf_vsi = ice_get_vf_vsi(vf);
 -	if (!vf_vsi) {
 -		netdev_err(netdev, "VSI %d for VF %d is null\n",
 -			   vf->lan_vsi_idx, vf->vf_id);
 -		ret = -EINVAL;
 -		goto out_put_vf;
 -	}
 -
 -	if (vf_vsi->type != ICE_VSI_VF) {
 -		netdev_err(netdev, "Type %d of VSI %d for VF %d is no ICE_VSI_VF\n",
 -			   vf_vsi->type, vf_vsi->vsi_num, vf->vf_id);
 -		ret = -ENODEV;
 -		goto out_put_vf;
 -	}
 -
 -	if (ena == vf->spoofchk) {
 -		dev_dbg(dev, "VF spoofchk already %s\n", ena ? "ON" : "OFF");
 -		ret = 0;
 -		goto out_put_vf;
 -	}
 +	u32 speed;
  
 -	ret = ice_vsi_apply_spoofchk(vf_vsi, ena);
 -	if (ret)
 -		dev_err(dev, "Failed to set spoofchk %s for VF %d VSI %d\n error %d\n",
 -			ena ? "ON" : "OFF", vf->vf_id, vf_vsi->vsi_num, ret);
 +	if (adv_link_support)
 +		switch (link_speed) {
 +		case ICE_AQ_LINK_SPEED_10MB:
 +			speed = ICE_LINK_SPEED_10MBPS;
 +			break;
 +		case ICE_AQ_LINK_SPEED_100MB:
 +			speed = ICE_LINK_SPEED_100MBPS;
 +			break;
 +		case ICE_AQ_LINK_SPEED_1000MB:
 +			speed = ICE_LINK_SPEED_1000MBPS;
 +			break;
 +		case ICE_AQ_LINK_SPEED_2500MB:
 +			speed = ICE_LINK_SPEED_2500MBPS;
 +			break;
 +		case ICE_AQ_LINK_SPEED_5GB:
 +			speed = ICE_LINK_SPEED_5000MBPS;
 +			break;
 +		case ICE_AQ_LINK_SPEED_10GB:
 +			speed = ICE_LINK_SPEED_10000MBPS;
 +			break;
 +		case ICE_AQ_LINK_SPEED_20GB:
 +			speed = ICE_LINK_SPEED_20000MBPS;
 +			break;
 +		case ICE_AQ_LINK_SPEED_25GB:
 +			speed = ICE_LINK_SPEED_25000MBPS;
 +			break;
 +		case ICE_AQ_LINK_SPEED_40GB:
 +			speed = ICE_LINK_SPEED_40000MBPS;
 +			break;
 +		case ICE_AQ_LINK_SPEED_50GB:
 +			speed = ICE_LINK_SPEED_50000MBPS;
 +			break;
 +		case ICE_AQ_LINK_SPEED_100GB:
 +			speed = ICE_LINK_SPEED_100000MBPS;
 +			break;
 +		default:
 +			speed = ICE_LINK_SPEED_UNKNOWN;
 +			break;
 +		}
  	else
 -		vf->spoofchk = ena;
 +		/* Virtchnl speeds are not defined for every speed supported in
 +		 * the hardware. To maintain compatibility with older AVF
 +		 * drivers, while reporting the speed the new speed values are
 +		 * resolved to the closest known virtchnl speeds
 +		 */
 +		switch (link_speed) {
 +		case ICE_AQ_LINK_SPEED_10MB:
 +		case ICE_AQ_LINK_SPEED_100MB:
 +			speed = (u32)VIRTCHNL_LINK_SPEED_100MB;
 +			break;
 +		case ICE_AQ_LINK_SPEED_1000MB:
 +		case ICE_AQ_LINK_SPEED_2500MB:
 +		case ICE_AQ_LINK_SPEED_5GB:
 +			speed = (u32)VIRTCHNL_LINK_SPEED_1GB;
 +			break;
 +		case ICE_AQ_LINK_SPEED_10GB:
 +			speed = (u32)VIRTCHNL_LINK_SPEED_10GB;
 +			break;
 +		case ICE_AQ_LINK_SPEED_20GB:
 +			speed = (u32)VIRTCHNL_LINK_SPEED_20GB;
 +			break;
 +		case ICE_AQ_LINK_SPEED_25GB:
 +			speed = (u32)VIRTCHNL_LINK_SPEED_25GB;
 +			break;
 +		case ICE_AQ_LINK_SPEED_40GB:
 +		case ICE_AQ_LINK_SPEED_50GB:
 +		case ICE_AQ_LINK_SPEED_100GB:
 +			speed = (u32)VIRTCHNL_LINK_SPEED_40GB;
 +			break;
 +		default:
 +			speed = (u32)VIRTCHNL_LINK_SPEED_UNKNOWN;
 +			break;
 +		}
  
 -out_put_vf:
 -	ice_put_vf(vf);
 -	return ret;
 +	return speed;
  }
  
 -/**
 - * ice_get_vf_cfg
 +/* The mailbox overflow detection algorithm helps to check if there
 + * is a possibility of a malicious VF transmitting too many MBX messages to the
 + * PF.
 + * 1. The mailbox snapshot structure, ice_mbx_snapshot, is initialized during
 + * driver initialization in ice_init_hw() using ice_mbx_init_snapshot().
 + * The struct ice_mbx_snapshot helps to track and traverse a static window of
 + * messages within the mailbox queue while looking for a malicious VF.
++=======
++ * ice_set_vf_mac
+  * @netdev: network interface device structure
+  * @vf_id: VF identifier
 - * @ivi: VF configuration structure
++ * @mac: MAC address
++>>>>>>> 5c8e3c7ff3e7 (ice: Fix VSIs unable to share unicast MAC)
 + *
 + * 2. When the caller starts processing its mailbox queue in response to an
 + * interrupt, the structure ice_mbx_snapshot is expected to be cleared before
 + * the algorithm can be run for the first time for that interrupt. This can be
 + * done via ice_mbx_reset_snapshot().
 + *
 + * 3. For every message read by the caller from the MBX Queue, the caller must
 + * call the detection algorithm's entry function ice_mbx_vf_state_handler().
 + * Before every call to ice_mbx_vf_state_handler() the struct ice_mbx_data is
 + * filled as it is required to be passed to the algorithm.
 + *
 + * 4. Every time a message is read from the MBX queue, a VFId is received which
 + * is passed to the state handler. The boolean output is_malvf of the state
 + * handler ice_mbx_vf_state_handler() serves as an indicator to the caller
 + * whether this VF is malicious or not.
   *
 - * return VF configuration
 + * 5. When a VF is identified to be malicious, the caller can send a message
 + * to the system administrator. The caller can invoke ice_mbx_report_malvf()
 + * to help determine if a malicious VF is to be reported or not. This function
 + * requires the caller to maintain a global bitmap to track all malicious VFs
 + * and pass that to ice_mbx_report_malvf() along with the VFID which was identified
 + * to be malicious by ice_mbx_vf_state_handler().
 + *
 + * 6. The global bitmap maintained by PF can be cleared completely if PF is in
 + * reset or the bit corresponding to a VF can be cleared if that VF is in reset.
 + * When a VF is shut down and brought back up, we assume that the new VF
 + * brought up is not malicious and hence report it if found malicious.
 + *
 + * 7. The function ice_mbx_reset_snapshot() is called to reset the information
 + * in ice_mbx_snapshot for every new mailbox interrupt handled.
 + *
 + * 8. The memory allocated for variables in ice_mbx_snapshot is de-allocated
 + * when driver is unloaded.
   */
 -int
 -ice_get_vf_cfg(struct net_device *netdev, int vf_id, struct ifla_vf_info *ivi)
 -{
 -	struct ice_pf *pf = ice_netdev_to_pf(netdev);
 -	struct ice_vf *vf;
 -	int ret;
 -
 -	vf = ice_get_vf_by_id(pf, vf_id);
 -	if (!vf)
 -		return -EINVAL;
 -
 -	ret = ice_check_vf_ready_for_cfg(vf);
 -	if (ret)
 -		goto out_put_vf;
 -
 -	ivi->vf = vf_id;
 -	ether_addr_copy(ivi->mac, vf->hw_lan_addr.addr);
 -
 -	/* VF configuration for VLAN and applicable QoS */
 -	ivi->vlan = ice_vf_get_port_vlan_id(vf);
 -	ivi->qos = ice_vf_get_port_vlan_prio(vf);
 -	if (ice_vf_is_port_vlan_ena(vf))
 -		ivi->vlan_proto = cpu_to_be16(ice_vf_get_port_vlan_tpid(vf));
 -
 -	ivi->trusted = vf->trusted;
 -	ivi->spoofchk = vf->spoofchk;
 -	if (!vf->link_forced)
 -		ivi->linkstate = IFLA_VF_LINK_STATE_AUTO;
 -	else if (vf->link_up)
 -		ivi->linkstate = IFLA_VF_LINK_STATE_ENABLE;
 -	else
 -		ivi->linkstate = IFLA_VF_LINK_STATE_DISABLE;
 -	ivi->max_tx_rate = vf->max_tx_rate;
 -	ivi->min_tx_rate = vf->min_tx_rate;
 -
 -out_put_vf:
 -	ice_put_vf(vf);
 -	return ret;
 -}
 +#define ICE_RQ_DATA_MASK(rq_data) ((rq_data) & PF_MBX_ARQH_ARQH_M)
 +/* Using the highest value for an unsigned 16-bit value 0xFFFF to indicate that
 + * the max messages check must be ignored in the algorithm
 + */
 +#define ICE_IGNORE_MAX_MSG_CNT	0xFFFF
  
  /**
 - * ice_set_vf_mac
 - * @netdev: network interface device structure
 - * @vf_id: VF identifier
 - * @mac: MAC address
 + * ice_mbx_traverse - Pass through mailbox snapshot
 + * @hw: pointer to the HW struct
 + * @new_state: new algorithm state
   *
 - * program VF MAC address
 + * Traversing the mailbox static snapshot without checking
 + * for malicious VFs.
   */
 -int ice_set_vf_mac(struct net_device *netdev, int vf_id, u8 *mac)
 +static void
 +ice_mbx_traverse(struct ice_hw *hw,
 +		 enum ice_mbx_snapshot_state *new_state)
  {
 -	struct ice_pf *pf = ice_netdev_to_pf(netdev);
 -	struct ice_vf *vf;
 -	int ret;
 +	struct ice_mbx_snap_buffer_data *snap_buf;
 +	u32 num_iterations;
  
 -	if (is_multicast_ether_addr(mac)) {
 -		netdev_err(netdev, "%pM not a valid unicast address\n", mac);
 -		return -EINVAL;
 -	}
 +	snap_buf = &hw->mbx_snapshot.mbx_buf;
  
++<<<<<<< HEAD
 +	/* As mailbox buffer is circular, applying a mask
 +	 * on the incremented iteration count.
++=======
+ 	vf = ice_get_vf_by_id(pf, vf_id);
+ 	if (!vf)
+ 		return -EINVAL;
+ 
+ 	/* nothing left to do, unicast MAC already set */
+ 	if (ether_addr_equal(vf->dev_lan_addr.addr, mac) &&
+ 	    ether_addr_equal(vf->hw_lan_addr.addr, mac)) {
+ 		ret = 0;
+ 		goto out_put_vf;
+ 	}
+ 
+ 	ret = ice_check_vf_ready_for_cfg(vf);
+ 	if (ret)
+ 		goto out_put_vf;
+ 
+ 	mutex_lock(&vf->cfg_lock);
+ 
+ 	/* VF is notified of its new MAC via the PF's response to the
+ 	 * VIRTCHNL_OP_GET_VF_RESOURCES message after the VF has been reset
++>>>>>>> 5c8e3c7ff3e7 (ice: Fix VSIs unable to share unicast MAC)
  	 */
 -	ether_addr_copy(vf->dev_lan_addr.addr, mac);
 -	ether_addr_copy(vf->hw_lan_addr.addr, mac);
 -	if (is_zero_ether_addr(mac)) {
 -		/* VF will send VIRTCHNL_OP_ADD_ETH_ADDR message with its MAC */
 -		vf->pf_set_mac = false;
 -		netdev_info(netdev, "Removing MAC on VF %d. VF driver will be reinitialized\n",
 -			    vf->vf_id);
 -	} else {
 -		/* PF will add MAC rule for the VF */
 -		vf->pf_set_mac = true;
 -		netdev_info(netdev, "Setting MAC %pM on VF %d. VF driver will be reinitialized\n",
 -			    mac, vf_id);
 -	}
 -
 -	ice_reset_vf(vf, ICE_VF_RESET_NOTIFY);
 -	mutex_unlock(&vf->cfg_lock);
 -
 -out_put_vf:
 -	ice_put_vf(vf);
 -	return ret;
 -}
 -
 -/**
 - * ice_set_vf_trust
 - * @netdev: network interface device structure
 - * @vf_id: VF identifier
 - * @trusted: Boolean value to enable/disable trusted VF
 - *
 - * Enable or disable a given VF as trusted
 - */
 -int ice_set_vf_trust(struct net_device *netdev, int vf_id, bool trusted)
 -{
 -	struct ice_pf *pf = ice_netdev_to_pf(netdev);
 -	struct ice_vf *vf;
 -	int ret;
 -
 -	if (ice_is_eswitch_mode_switchdev(pf)) {
 -		dev_info(ice_pf_to_dev(pf), "Trusted VF is forbidden in switchdev mode\n");
 -		return -EOPNOTSUPP;
 -	}
 -
 -	vf = ice_get_vf_by_id(pf, vf_id);
 -	if (!vf)
 -		return -EINVAL;
 -
 -	ret = ice_check_vf_ready_for_cfg(vf);
 -	if (ret)
 -		goto out_put_vf;
 -
 -	/* Check if already trusted */
 -	if (trusted == vf->trusted) {
 -		ret = 0;
 -		goto out_put_vf;
 -	}
 -
 -	mutex_lock(&vf->cfg_lock);
 -
 -	vf->trusted = trusted;
 -	ice_reset_vf(vf, ICE_VF_RESET_NOTIFY);
 -	dev_info(ice_pf_to_dev(pf), "VF %u is now %strusted\n",
 -		 vf_id, trusted ? "" : "un");
 -
 -	mutex_unlock(&vf->cfg_lock);
 -
 -out_put_vf:
 -	ice_put_vf(vf);
 -	return ret;
 +	num_iterations = ICE_RQ_DATA_MASK(++snap_buf->num_iterations);
 +
 +	/* Checking either of the below conditions to exit snapshot traversal:
 +	 * Condition-1: If the number of iterations in the mailbox is equal to
 +	 * the mailbox head which would indicate that we have reached the end
 +	 * of the static snapshot.
 +	 * Condition-2: If the maximum messages serviced in the mailbox for a
 +	 * given interrupt is the highest possible value then there is no need
 +	 * to check if the number of messages processed is equal to it. If not
 +	 * check if the number of messages processed is greater than or equal
 +	 * to the maximum number of mailbox entries serviced in current work item.
 +	 */
 +	if (num_iterations == snap_buf->head ||
 +	    (snap_buf->max_num_msgs_mbx < ICE_IGNORE_MAX_MSG_CNT &&
 +	     ++snap_buf->num_msg_proc >= snap_buf->max_num_msgs_mbx))
 +		*new_state = ICE_MAL_VF_DETECT_STATE_NEW_SNAPSHOT;
  }
  
  /**
diff --git a/drivers/net/ethernet/intel/ice/ice_main.c b/drivers/net/ethernet/intel/ice/ice_main.c
index 32835373cc4b..c5be644ffdb6 100644
--- a/drivers/net/ethernet/intel/ice/ice_main.c
+++ b/drivers/net/ethernet/intel/ice/ice_main.c
@@ -4604,6 +4604,8 @@ ice_probe(struct pci_dev *pdev, const struct pci_device_id __always_unused *ent)
 		ice_set_safe_mode_caps(hw);
 	}
 
+	hw->ucast_shared = true;
+
 	err = ice_init_pf(pf);
 	if (err) {
 		dev_err(dev, "ice_init_pf failed: %d\n", err);
* Unmerged path drivers/net/ethernet/intel/ice/ice_sriov.c
