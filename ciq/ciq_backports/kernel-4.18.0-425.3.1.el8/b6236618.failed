cifs: support share failover when remounting

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-425.3.1.el8
commit-author Paulo Alcantara <pc@cjr.nz>
commit b62366181a5e9473e9c10e98f400049491c55876
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-425.3.1.el8/b6236618.failed

When remouting a DFS share, force a new DFS referral of the path and
if the currently cached targets do not match any of the new targets or
there was no cached targets, then mark it for reconnect.

For example:

    $ mount //dom/dfs/link /mnt -o username=foo,password=bar
    $ ls /mnt
    oldfile.txt

    change target share of 'link' in server settings

    $ mount /mnt -o remount,username=foo,password=bar
    $ ls /mnt
    newfile.txt

	Signed-off-by: Paulo Alcantara (SUSE) <pc@cjr.nz>
	Signed-off-by: Steve French <stfrench@microsoft.com>
(cherry picked from commit b62366181a5e9473e9c10e98f400049491c55876)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/cifs/connect.c
#	fs/cifs/dfs_cache.c
#	fs/cifs/dfs_cache.h
diff --cc fs/cifs/connect.c
index bd85f05ebccd,3781eee9360a..000000000000
--- a/fs/cifs/connect.c
+++ b/fs/cifs/connect.c
@@@ -3045,7 -3129,8 +3045,12 @@@ static int do_dfs_failover(const char *
  			   struct cifs_ses **ses, struct cifs_tcon **tcon)
  {
  	int rc;
++<<<<<<< HEAD
 +	struct dfs_cache_tgt_list tgt_list = {0};
++=======
+ 	char *npath = NULL;
+ 	struct dfs_cache_tgt_list tgt_list = DFS_CACHE_TGT_LIST_INIT(tgt_list);
++>>>>>>> b62366181a5e (cifs: support share failover when remounting)
  	struct dfs_cache_tgt_iterator *tgt_it = NULL;
  	struct smb3_fs_context tmp_ctx = {NULL};
  
diff --cc fs/cifs/dfs_cache.c
index d4a72c7183f5,283745592844..000000000000
--- a/fs/cifs/dfs_cache.c
+++ b/fs/cifs/dfs_cache.c
@@@ -1313,16 -1510,8 +1502,21 @@@ static void refresh_mounts(struct cifs_
  	spin_unlock(&cifs_tcp_ses_lock);
  
  	list_for_each_entry_safe(tcon, ntcon, &tcons, ulist) {
++<<<<<<< HEAD
 +		const char *path = tcon->dfs_path + 1;
 +		int rc = 0;
 +
 +		list_del_init(&tcon->ulist);
 +		ses = find_ipc_from_server_path(sessions, path);
 +		if (!IS_ERR(ses)) {
 +			xid = get_xid();
 +			cache_refresh_path(xid, ses, cache_nlsc, tcon->remap, path);
 +			free_xid(xid);
 +		}
++=======
+ 		list_del_init(&tcon->ulist);
+ 		refresh_tcon(sessions, tcon, false);
++>>>>>>> b62366181a5e (cifs: support share failover when remounting)
  		cifs_put_tcon(tcon);
  	}
  }
diff --cc fs/cifs/dfs_cache.h
index a9bd0d7e7ca2,52070d1df189..000000000000
--- a/fs/cifs/dfs_cache.h
+++ b/fs/cifs/dfs_cache.h
@@@ -24,31 -26,27 +26,36 @@@ struct dfs_cache_tgt_iterator 
  	struct list_head it_list;
  };
  
 -int dfs_cache_init(void);
 -void dfs_cache_destroy(void);
 -extern const struct proc_ops dfscache_proc_ops;
 -
 -int dfs_cache_find(const unsigned int xid, struct cifs_ses *ses, const struct nls_table *cp,
 -		   int remap, const char *path, struct dfs_info3_param *ref,
 -		   struct dfs_cache_tgt_list *tgt_list);
 -int dfs_cache_noreq_find(const char *path, struct dfs_info3_param *ref,
 -			 struct dfs_cache_tgt_list *tgt_list);
 -int dfs_cache_update_tgthint(const unsigned int xid, struct cifs_ses *ses,
 -			     const struct nls_table *cp, int remap, const char *path,
 -			     const struct dfs_cache_tgt_iterator *it);
 -int dfs_cache_noreq_update_tgthint(const char *path, const struct dfs_cache_tgt_iterator *it);
 -int dfs_cache_get_tgt_referral(const char *path, const struct dfs_cache_tgt_iterator *it,
 -			       struct dfs_info3_param *ref);
 -int dfs_cache_get_tgt_share(char *path, const struct dfs_cache_tgt_iterator *it, char **share,
 -			    char **prefix);
 +extern int dfs_cache_init(void);
 +extern void dfs_cache_destroy(void);
 +extern const struct file_operations dfscache_proc_fops;
 +
 +extern int dfs_cache_find(const unsigned int xid, struct cifs_ses *ses,
 +			  const struct nls_table *nls_codepage, int remap,
 +			  const char *path, struct dfs_info3_param *ref,
 +			  struct dfs_cache_tgt_list *tgt_list);
 +extern int dfs_cache_noreq_find(const char *path, struct dfs_info3_param *ref,
 +				struct dfs_cache_tgt_list *tgt_list);
 +extern int dfs_cache_update_tgthint(const unsigned int xid,
 +				    struct cifs_ses *ses,
 +				    const struct nls_table *nls_codepage,
 +				    int remap, const char *path,
 +				    const struct dfs_cache_tgt_iterator *it);
 +extern int
 +dfs_cache_noreq_update_tgthint(const char *path,
 +			       const struct dfs_cache_tgt_iterator *it);
 +extern int dfs_cache_get_tgt_referral(const char *path,
 +				      const struct dfs_cache_tgt_iterator *it,
 +				      struct dfs_info3_param *ref);
 +extern int dfs_cache_get_tgt_share(char *path, const struct dfs_cache_tgt_iterator *it,
 +				   char **share, char **prefix);
  void dfs_cache_put_refsrv_sessions(const uuid_t *mount_id);
  void dfs_cache_add_refsrv_session(const uuid_t *mount_id, struct cifs_ses *ses);
++<<<<<<< HEAD
++=======
+ char *dfs_cache_canonical_path(const char *path, const struct nls_table *cp, int remap);
+ int dfs_cache_remount_fs(struct cifs_sb_info *cifs_sb);
++>>>>>>> b62366181a5e (cifs: support share failover when remounting)
  
  static inline struct dfs_cache_tgt_iterator *
  dfs_cache_get_next_tgt(struct dfs_cache_tgt_list *tl,
* Unmerged path fs/cifs/connect.c
* Unmerged path fs/cifs/dfs_cache.c
* Unmerged path fs/cifs/dfs_cache.h
diff --git a/fs/cifs/fs_context.c b/fs/cifs/fs_context.c
index 145da6c50254..ba4dc25a2659 100644
--- a/fs/cifs/fs_context.c
+++ b/fs/cifs/fs_context.c
@@ -13,6 +13,9 @@
 #include <linux/magic.h>
 #include <linux/security.h>
 #include <net/net_namespace.h>
+#ifdef CONFIG_CIFS_DFS_UPCALL
+#include "dfs_cache.h"
+#endif
 */
 
 #include <linux/ctype.h>
@@ -833,6 +836,10 @@ static int smb3_reconfigure(struct fs_context *fc)
 	smb3_cleanup_fs_context_contents(cifs_sb->ctx);
 	rc = smb3_fs_context_dup(cifs_sb->ctx, ctx);
 	smb3_update_mnt_flags(cifs_sb);
+#ifdef CONFIG_CIFS_DFS_UPCALL
+	if (!rc)
+		rc = dfs_cache_remount_fs(cifs_sb);
+#endif
 
 	return rc;
 }
