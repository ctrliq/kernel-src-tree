net/mlx5e: TC, Pass attr to tc_act can_offload()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-425.3.1.el8
commit-author Roi Dayan <roid@nvidia.com>
commit 8be9686d2479a12f986dfce2f792e33ab747ac0f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-425.3.1.el8/8be9686d.failed

In later commit we are going to instantiate multiple attr instances
for flow instead of single attr.
Make sure the parsing using correct attr and not flow->attr.

	Signed-off-by: Roi Dayan <roid@nvidia.com>
	Reviewed-by: Oz Shlomo <ozsh@nvidia.com>
	Signed-off-by: Saeed Mahameed <saeedm@nvidia.com>
(cherry picked from commit 8be9686d2479a12f986dfce2f792e33ab747ac0f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/accept.c
#	drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/act.h
#	drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/csum.c
#	drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/ct.c
#	drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/drop.c
#	drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/goto.c
#	drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/mark.c
#	drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/mirred.c
#	drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/mirred_nic.c
#	drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/mpls.c
#	drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/pedit.c
#	drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/ptype.c
#	drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/redirect_ingress.c
#	drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/sample.c
#	drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/trap.c
#	drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/tun.c
#	drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/vlan.c
#	drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/vlan_mangle.c
#	drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
index d73114e91e9a,de07ccd6ac7b..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
@@@ -3463,126 -3280,45 +3463,142 @@@ static bool same_hw_devs(struct mlx5e_p
  	return (fsystem_guid == psystem_guid);
  }
  
 -static int
 -parse_tc_actions(struct mlx5e_tc_act_parse_state *parse_state,
 -		 struct flow_action *flow_action)
 +static bool same_vf_reps(struct mlx5e_priv *priv,
 +			 struct net_device *out_dev)
  {
 -	struct netlink_ext_ack *extack = parse_state->extack;
 -	struct mlx5e_tc_flow *flow = parse_state->flow;
 -	struct mlx5_flow_attr *attr = flow->attr;
 -	enum mlx5_flow_namespace_type ns_type;
 -	struct mlx5e_priv *priv = flow->priv;
 -	const struct flow_action_entry *act;
 -	struct mlx5e_tc_act *tc_act;
 -	int err, i;
 +	return mlx5e_eswitch_vf_rep(priv->netdev) &&
 +	       priv->netdev == out_dev;
 +}
  
 -	ns_type = mlx5e_get_flow_namespace(flow);
 +static int add_vlan_rewrite_action(struct mlx5e_priv *priv, int namespace,
 +				   const struct flow_action_entry *act,
 +				   struct mlx5e_tc_flow_parse_attr *parse_attr,
 +				   struct pedit_headers_action *hdrs,
 +				   u32 *action, struct netlink_ext_ack *extack)
 +{
 +	u16 mask16 = VLAN_VID_MASK;
 +	u16 val16 = act->vlan.vid & VLAN_VID_MASK;
 +	const struct flow_action_entry pedit_act = {
 +		.id = FLOW_ACTION_MANGLE,
 +		.mangle.htype = FLOW_ACT_MANGLE_HDR_TYPE_ETH,
 +		.mangle.offset = offsetof(struct vlan_ethhdr, h_vlan_TCI),
 +		.mangle.mask = ~(u32)be16_to_cpu(*(__be16 *)&mask16),
 +		.mangle.val = (u32)be16_to_cpu(*(__be16 *)&val16),
 +	};
 +	u8 match_prio_mask, match_prio_val;
 +	void *headers_c, *headers_v;
 +	int err;
  
 -	flow_action_for_each(i, act, flow_action) {
 -		tc_act = mlx5e_tc_act_get(act->id, ns_type);
 -		if (!tc_act) {
 -			NL_SET_ERR_MSG_MOD(extack, "Not implemented offload action");
 -			return -EOPNOTSUPP;
 -		}
 +	headers_c = get_match_headers_criteria(*action, &parse_attr->spec);
 +	headers_v = get_match_headers_value(*action, &parse_attr->spec);
  
++<<<<<<< HEAD
 +	if (!(MLX5_GET(fte_match_set_lyr_2_4, headers_c, cvlan_tag) &&
 +	      MLX5_GET(fte_match_set_lyr_2_4, headers_v, cvlan_tag))) {
 +		NL_SET_ERR_MSG_MOD(extack,
 +				   "VLAN rewrite action must have VLAN protocol match");
 +		return -EOPNOTSUPP;
 +	}
 +
 +	match_prio_mask = MLX5_GET(fte_match_set_lyr_2_4, headers_c, first_prio);
 +	match_prio_val = MLX5_GET(fte_match_set_lyr_2_4, headers_v, first_prio);
 +	if (act->vlan.prio != (match_prio_val & match_prio_mask)) {
 +		NL_SET_ERR_MSG_MOD(extack,
 +				   "Changing VLAN prio is not supported");
 +		return -EOPNOTSUPP;
 +	}
++=======
+ 		if (!tc_act->can_offload(parse_state, act, i, attr))
+ 			return -EOPNOTSUPP;
+ 
+ 		err = tc_act->parse_action(parse_state, act, priv, attr);
+ 		if (err)
+ 			return err;
+ 	}
+ 
+ 	flow_action_for_each(i, act, flow_action) {
+ 		tc_act = mlx5e_tc_act_get(act->id, ns_type);
+ 		if (!tc_act || !tc_act->post_parse ||
+ 		    !tc_act->can_offload(parse_state, act, i, attr))
+ 			continue;
++>>>>>>> 8be9686d2479 (net/mlx5e: TC, Pass attr to tc_act can_offload())
  
 -		err = tc_act->post_parse(parse_state, priv, attr);
 -		if (err)
 -			return err;
 +	err = parse_tc_pedit_action(priv, &pedit_act, namespace, parse_attr, hdrs, NULL, extack);
 +	*action |= MLX5_FLOW_CONTEXT_ACTION_MOD_HDR;
 +
 +	return err;
 +}
 +
 +static int
 +add_vlan_prio_tag_rewrite_action(struct mlx5e_priv *priv,
 +				 struct mlx5e_tc_flow_parse_attr *parse_attr,
 +				 struct pedit_headers_action *hdrs,
 +				 u32 *action, struct netlink_ext_ack *extack)
 +{
 +	const struct flow_action_entry prio_tag_act = {
 +		.vlan.vid = 0,
 +		.vlan.prio =
 +			MLX5_GET(fte_match_set_lyr_2_4,
 +				 get_match_headers_value(*action,
 +							 &parse_attr->spec),
 +				 first_prio) &
 +			MLX5_GET(fte_match_set_lyr_2_4,
 +				 get_match_headers_criteria(*action,
 +							    &parse_attr->spec),
 +				 first_prio),
 +	};
 +
 +	return add_vlan_rewrite_action(priv, MLX5_FLOW_NAMESPACE_FDB,
 +				       &prio_tag_act, parse_attr, hdrs, action,
 +				       extack);
 +}
 +
 +static int validate_goto_chain(struct mlx5e_priv *priv,
 +			       struct mlx5e_tc_flow *flow,
 +			       const struct flow_action_entry *act,
 +			       u32 actions,
 +			       struct netlink_ext_ack *extack)
 +{
 +	bool is_esw = mlx5e_is_eswitch_flow(flow);
 +	struct mlx5_flow_attr *attr = flow->attr;
 +	bool ft_flow = mlx5e_is_ft_flow(flow);
 +	u32 dest_chain = act->chain_index;
 +	struct mlx5_fs_chains *chains;
 +	struct mlx5_eswitch *esw;
 +	u32 reformat_and_fwd;
 +	u32 max_chain;
 +
 +	esw = priv->mdev->priv.eswitch;
 +	chains = is_esw ? esw_chains(esw) : nic_chains(priv);
 +	max_chain = mlx5_chains_get_chain_range(chains);
 +	reformat_and_fwd = is_esw ?
 +			   MLX5_CAP_ESW_FLOWTABLE_FDB(priv->mdev, reformat_and_fwd_to_table) :
 +			   MLX5_CAP_FLOWTABLE_NIC_RX(priv->mdev, reformat_and_fwd_to_table);
 +
 +	if (ft_flow) {
 +		NL_SET_ERR_MSG_MOD(extack, "Goto action is not supported");
 +		return -EOPNOTSUPP;
 +	}
 +
 +	if (!mlx5_chains_backwards_supported(chains) &&
 +	    dest_chain <= attr->chain) {
 +		NL_SET_ERR_MSG_MOD(extack,
 +				   "Goto lower numbered chain isn't supported");
 +		return -EOPNOTSUPP;
 +	}
 +
 +	if (dest_chain > max_chain) {
 +		NL_SET_ERR_MSG_MOD(extack,
 +				   "Requested destination chain is out of supported range");
 +		return -EOPNOTSUPP;
 +	}
 +
 +	if (actions & (MLX5_FLOW_CONTEXT_ACTION_PACKET_REFORMAT |
 +		       MLX5_FLOW_CONTEXT_ACTION_DECAP) &&
 +	    !reformat_and_fwd) {
 +		NL_SET_ERR_MSG_MOD(extack,
 +				   "Goto chain is not allowed if action has reformat or decap");
 +		return -EOPNOTSUPP;
  	}
  
  	return 0;
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/accept.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/act.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/csum.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/ct.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/drop.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/goto.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/mark.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/mirred.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/mirred_nic.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/mpls.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/pedit.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/ptype.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/redirect_ingress.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/sample.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/trap.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/tun.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/vlan.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/vlan_mangle.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/accept.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/act.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/csum.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/ct.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/drop.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/goto.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/mark.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/mirred.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/mirred_nic.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/mpls.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/pedit.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/ptype.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/redirect_ingress.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/sample.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/trap.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/tun.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/vlan.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/vlan_mangle.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
