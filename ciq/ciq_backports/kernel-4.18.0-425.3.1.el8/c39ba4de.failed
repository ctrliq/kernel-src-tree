netfilter: nf_tables: replace BUG_ON by element length check

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-425.3.1.el8
commit-author Pablo Neira Ayuso <pablo@netfilter.org>
commit c39ba4de6b0a843bec5d46c2b6f2064428dada5e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-425.3.1.el8/c39ba4de.failed

BUG_ON can be triggered from userspace with an element with a large
userdata area. Replace it by length check and return EINVAL instead.
Over time extensions have been growing in size.

Pick a sufficiently old Fixes: tag to propagate this fix.

Fixes: 7d7402642eaf ("netfilter: nf_tables: variable sized set element keys / data")
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit c39ba4de6b0a843bec5d46c2b6f2064428dada5e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/nf_tables_api.c
diff --cc net/netfilter/nf_tables_api.c
index cbb745cabd11,646d5fd53604..000000000000
--- a/net/netfilter/nf_tables_api.c
+++ b/net/netfilter/nf_tables_api.c
@@@ -5207,8 -5829,15 +5207,20 @@@ static int nft_add_set_elem(struct nft_
  	err = nft_setelem_parse_flags(set, nla[NFTA_SET_ELEM_FLAGS], &flags);
  	if (err < 0)
  		return err;
++<<<<<<< HEAD
 +	if (flags != 0)
 +		nft_set_ext_add(&tmpl, NFT_SET_EXT_FLAGS);
++=======
+ 
+ 	if (!nla[NFTA_SET_ELEM_KEY] && !(flags & NFT_SET_ELEM_CATCHALL))
+ 		return -EINVAL;
+ 
+ 	if (flags != 0) {
+ 		err = nft_set_ext_add(&tmpl, NFT_SET_EXT_FLAGS);
+ 		if (err < 0)
+ 			return err;
+ 	}
++>>>>>>> c39ba4de6b0a (netfilter: nf_tables: replace BUG_ON by element length check)
  
  	if (set->flags & NFT_SET_MAP) {
  		if (nla[NFTA_SET_ELEM_DATA] == NULL &&
@@@ -5311,12 -5940,16 +5323,19 @@@
  		num_exprs = set->num_exprs;
  	}
  
 -	if (nla[NFTA_SET_ELEM_KEY]) {
 -		err = nft_setelem_parse_key(ctx, set, &elem.key.val,
 -					    nla[NFTA_SET_ELEM_KEY]);
 -		if (err < 0)
 -			goto err_set_elem_expr;
 +	err = nft_setelem_parse_key(ctx, set, &elem.key.val,
 +				    nla[NFTA_SET_ELEM_KEY]);
 +	if (err < 0)
 +		goto err_set_elem_expr;
  
++<<<<<<< HEAD
 +	nft_set_ext_add_length(&tmpl, NFT_SET_EXT_KEY, set->klen);
++=======
+ 		err = nft_set_ext_add_length(&tmpl, NFT_SET_EXT_KEY, set->klen);
+ 		if (err < 0)
+ 			goto err_parse_key;
+ 	}
++>>>>>>> c39ba4de6b0a (netfilter: nf_tables: replace BUG_ON by element length check)
  
  	if (nla[NFTA_SET_ELEM_KEY_END]) {
  		err = nft_setelem_parse_key(ctx, set, &elem.key_end.val,
@@@ -5602,18 -6277,22 +5637,33 @@@ static int nft_del_setelem(struct nft_c
  
  	nft_set_ext_prepare(&tmpl);
  
++<<<<<<< HEAD
 +	err = nft_setelem_parse_flags(set, nla[NFTA_SET_ELEM_FLAGS], &flags);
 +	if (err < 0)
 +		return err;
 +	if (flags != 0)
 +		nft_set_ext_add(&tmpl, NFT_SET_EXT_FLAGS);
++=======
+ 	if (flags != 0) {
+ 		err = nft_set_ext_add(&tmpl, NFT_SET_EXT_FLAGS);
+ 		if (err < 0)
+ 			return err;
+ 	}
++>>>>>>> c39ba4de6b0a (netfilter: nf_tables: replace BUG_ON by element length check)
  
 -	if (nla[NFTA_SET_ELEM_KEY]) {
 -		err = nft_setelem_parse_key(ctx, set, &elem.key.val,
 -					    nla[NFTA_SET_ELEM_KEY]);
 -		if (err < 0)
 -			return err;
 +	err = nft_setelem_parse_key(ctx, set, &elem.key.val,
 +				    nla[NFTA_SET_ELEM_KEY]);
 +	if (err < 0)
 +		return err;
  
++<<<<<<< HEAD
 +	nft_set_ext_add_length(&tmpl, NFT_SET_EXT_KEY, set->klen);
++=======
+ 		err = nft_set_ext_add_length(&tmpl, NFT_SET_EXT_KEY, set->klen);
+ 		if (err < 0)
+ 			goto fail_elem;
+ 	}
++>>>>>>> c39ba4de6b0a (netfilter: nf_tables: replace BUG_ON by element length check)
  
  	if (nla[NFTA_SET_ELEM_KEY_END]) {
  		err = nft_setelem_parse_key(ctx, set, &elem.key_end.val,
@@@ -5626,10 -6307,10 +5678,10 @@@
  
  	err = -ENOMEM;
  	elem.priv = nft_set_elem_init(set, &tmpl, elem.key.val.data,
 -				      elem.key_end.val.data, NULL, 0, 0,
 -				      GFP_KERNEL_ACCOUNT);
 +				      elem.key_end.val.data, NULL, 0,
 +				      0, GFP_KERNEL);
  	if (elem.priv == NULL)
- 		goto fail_elem;
+ 		goto fail_elem_key_end;
  
  	ext = nft_set_elem_ext(set, elem.priv);
  	if (flags)
diff --git a/include/net/netfilter/nf_tables.h b/include/net/netfilter/nf_tables.h
index 0a1aaa626fe7..92509a89f440 100644
--- a/include/net/netfilter/nf_tables.h
+++ b/include/net/netfilter/nf_tables.h
@@ -623,18 +623,22 @@ static inline void nft_set_ext_prepare(struct nft_set_ext_tmpl *tmpl)
 	tmpl->len = sizeof(struct nft_set_ext);
 }
 
-static inline void nft_set_ext_add_length(struct nft_set_ext_tmpl *tmpl, u8 id,
-					  unsigned int len)
+static inline int nft_set_ext_add_length(struct nft_set_ext_tmpl *tmpl, u8 id,
+					 unsigned int len)
 {
 	tmpl->len	 = ALIGN(tmpl->len, nft_set_ext_types[id].align);
-	BUG_ON(tmpl->len > U8_MAX);
+	if (tmpl->len > U8_MAX)
+		return -EINVAL;
+
 	tmpl->offset[id] = tmpl->len;
 	tmpl->len	+= nft_set_ext_types[id].len + len;
+
+	return 0;
 }
 
-static inline void nft_set_ext_add(struct nft_set_ext_tmpl *tmpl, u8 id)
+static inline int nft_set_ext_add(struct nft_set_ext_tmpl *tmpl, u8 id)
 {
-	nft_set_ext_add_length(tmpl, id, 0);
+	return nft_set_ext_add_length(tmpl, id, 0);
 }
 
 static inline void nft_set_ext_init(struct nft_set_ext *ext,
* Unmerged path net/netfilter/nf_tables_api.c
