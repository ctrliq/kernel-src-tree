ice: Use the proto argument for VLAN ops

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-425.3.1.el8
commit-author Brett Creeley <brett.creeley@intel.com>
commit 2bfefa2dab6bb4c8596778e3ccb011d1f0e13975
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-425.3.1.el8/2bfefa2d.failed

Currently the proto argument is unused. This is because the driver only
supports 802.1Q VLAN filtering. This policy is enforced via netdev
features that the driver sets up when configuring the netdev, so the
proto argument won't ever be anything other than 802.1Q. However, this
will allow for future iterations of the driver to seemlessly support
802.1ad filtering. Begin using the proto argument and extend the related
structures to support its use.

	Signed-off-by: Brett Creeley <brett.creeley@intel.com>
	Tested-by: Gurucharan G <gurucharanx.g@intel.com>
	Signed-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>
(cherry picked from commit 2bfefa2dab6bb4c8596778e3ccb011d1f0e13975)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/ice/ice_fltr.c
#	drivers/net/ethernet/intel/ice/ice_lib.c
#	drivers/net/ethernet/intel/ice/ice_main.c
#	drivers/net/ethernet/intel/ice/ice_virtchnl_pf.c
#	drivers/net/ethernet/intel/ice/ice_virtchnl_pf.h
#	drivers/net/ethernet/intel/ice/ice_vlan.h
#	drivers/net/ethernet/intel/ice/ice_vsi_vlan_lib.c
#	drivers/net/ethernet/intel/ice/ice_vsi_vlan_lib.h
#	drivers/net/ethernet/intel/ice/ice_vsi_vlan_ops.h
diff --cc drivers/net/ethernet/intel/ice/ice_fltr.c
index 6a04cc548457,af57eb114966..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_fltr.c
+++ b/drivers/net/ethernet/intel/ice/ice_fltr.c
@@@ -251,9 -214,11 +251,15 @@@ ice_fltr_add_vlan_to_list(struct ice_vs
  	info.flag = ICE_FLTR_TX;
  	info.src_id = ICE_SRC_ID_VSI;
  	info.lkup_type = ICE_SW_LKUP_VLAN;
 -	info.fltr_act = ICE_FWD_TO_VSI;
 +	info.fltr_act = action;
  	info.vsi_handle = vsi->idx;
++<<<<<<< HEAD
 +	info.l_data.vlan.vlan_id = vlan_id;
++=======
+ 	info.l_data.vlan.vlan_id = vlan->vid;
+ 	info.l_data.vlan.tpid = vlan->tpid;
+ 	info.l_data.vlan.tpid_valid = true;
++>>>>>>> 2bfefa2dab6b (ice: Use the proto argument for VLAN ops)
  
  	return ice_fltr_add_entry_to_list(ice_pf_to_dev(vsi->back), &info,
  					  list);
diff --cc drivers/net/ethernet/intel/ice/ice_lib.c
index 737ccd2dacf6,08539c966b18..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_lib.c
+++ b/drivers/net/ethernet/intel/ice/ice_lib.c
@@@ -4144,7 -3921,10 +4144,14 @@@ int ice_set_link(struct ice_vsi *vsi, b
   */
  int ice_vsi_add_vlan_zero(struct ice_vsi *vsi)
  {
++<<<<<<< HEAD
 +	return ice_vsi_add_vlan(vsi, 0, ICE_FWD_TO_VSI);
++=======
+ 	struct ice_vlan vlan;
+ 
+ 	vlan = ICE_VLAN(0, 0, 0);
+ 	return vsi->vlan_ops.add_vlan(vsi, &vlan);
++>>>>>>> 2bfefa2dab6b (ice: Use the proto argument for VLAN ops)
  }
  
  /**
diff --cc drivers/net/ethernet/intel/ice/ice_main.c
index 313426d16765,8ec36bd87a48..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_main.c
+++ b/drivers/net/ethernet/intel/ice/ice_main.c
@@@ -3484,23 -3429,10 +3483,30 @@@ ice_vlan_rx_add_vid(struct net_device *
  	/* Add a switch rule for this VLAN ID so its corresponding VLAN tagged
  	 * packets aren't pruned by the device's internal switch on Rx
  	 */
++<<<<<<< HEAD
 +	ret = ice_vsi_add_vlan(vsi, vid, ICE_FWD_TO_VSI);
 +	if (ret)
 +		goto finish;
 +
 +	/* If all-multicast is currently enabled and this VLAN ID is only one
 +	 * besides VLAN-0 we have to update look-up type of multicast promisc
 +	 * rule for VLAN-0 from ICE_SW_LKUP_PROMISC to ICE_SW_LKUP_PROMISC_VLAN.
 +	 */
 +	if ((vsi->current_netdev_flags & IFF_ALLMULTI) && vsi->num_vlan == 2) {
 +		ice_fltr_clear_vsi_promisc(&vsi->back->hw, vsi->idx,
 +					   ICE_MCAST_PROMISC_BITS, 0);
 +		ice_fltr_set_vsi_promisc(&vsi->back->hw, vsi->idx,
 +					 ICE_MCAST_VLAN_PROMISC_BITS, 0);
 +	}
 +
 +finish:
 +	clear_bit(ICE_CFG_BUSY, vsi->state);
++=======
+ 	vlan = ICE_VLAN(be16_to_cpu(proto), vid, 0);
+ 	ret = vsi->vlan_ops.add_vlan(vsi, &vlan);
+ 	if (!ret)
+ 		set_bit(ICE_VSI_VLAN_FLTR_CHANGED, vsi->state);
++>>>>>>> 2bfefa2dab6b (ice: Use the proto argument for VLAN ops)
  
  	return ret;
  }
@@@ -3525,44 -3457,19 +3530,49 @@@ ice_vlan_rx_kill_vid(struct net_device 
  	if (!vid)
  		return 0;
  
 -	/* Make sure VLAN delete is successful before updating VLAN
 +	while (test_and_set_bit(ICE_CFG_BUSY, vsi->state))
 +		usleep_range(1000, 2000);
 +
 +	/* Make sure ice_vsi_kill_vlan is successful before updating VLAN
  	 * information
  	 */
++<<<<<<< HEAD
 +	ret = ice_vsi_kill_vlan(vsi, vid);
++=======
+ 	vlan = ICE_VLAN(be16_to_cpu(proto), vid, 0);
+ 	ret = vsi->vlan_ops.del_vlan(vsi, &vlan);
++>>>>>>> 2bfefa2dab6b (ice: Use the proto argument for VLAN ops)
  	if (ret)
 -		return ret;
 +		goto finish;
 +
 +	/* Remove multicast promisc rule for the removed VLAN ID if
 +	 * all-multicast is enabled.
 +	 */
 +	if (vsi->current_netdev_flags & IFF_ALLMULTI)
 +		ice_fltr_clear_vsi_promisc(&vsi->back->hw, vsi->idx,
 +					   ICE_MCAST_VLAN_PROMISC_BITS, vid);
 +
 +	if (vsi->num_vlan == 1) {
 +		/* Disable pruning when VLAN 0 is the only VLAN rule */
 +		if (ice_vsi_is_vlan_pruning_ena(vsi))
 +			ice_cfg_vlan_pruning(vsi, false);
 +
 +		/* Update look-up type of multicast promisc rule for VLAN 0
 +		 * from ICE_SW_LKUP_PROMISC_VLAN to ICE_SW_LKUP_PROMISC when
 +		 * all-multicast is enabled and VLAN 0 is the only VLAN rule.
 +		 */
 +		if (vsi->current_netdev_flags & IFF_ALLMULTI) {
 +			ice_fltr_clear_vsi_promisc(&vsi->back->hw, vsi->idx,
 +						   ICE_MCAST_VLAN_PROMISC_BITS,
 +						   0);
 +			ice_fltr_set_vsi_promisc(&vsi->back->hw, vsi->idx,
 +						 ICE_MCAST_PROMISC_BITS, 0);
 +		}
 +	}
  
 -	/* Disable pruning when VLAN 0 is the only VLAN rule */
 -	if (vsi->num_vlan == 1 && ice_vsi_is_vlan_pruning_ena(vsi))
 -		vsi->vlan_ops.dis_rx_filtering(vsi);
 +finish:
 +	clear_bit(ICE_CFG_BUSY, vsi->state);
  
 -	set_bit(ICE_VSI_VLAN_FLTR_CHANGED, vsi->state);
  	return ret;
  }
  
@@@ -5697,17 -5606,17 +5707,25 @@@ ice_set_features(struct net_device *net
  
  	if ((features & NETIF_F_HW_VLAN_CTAG_RX) &&
  	    !(netdev->features & NETIF_F_HW_VLAN_CTAG_RX))
++<<<<<<< HEAD
 +		ret = ice_vsi_manage_vlan_stripping(vsi, true);
++=======
+ 		ret = vsi->vlan_ops.ena_stripping(vsi, ETH_P_8021Q);
++>>>>>>> 2bfefa2dab6b (ice: Use the proto argument for VLAN ops)
  	else if (!(features & NETIF_F_HW_VLAN_CTAG_RX) &&
  		 (netdev->features & NETIF_F_HW_VLAN_CTAG_RX))
 -		ret = vsi->vlan_ops.dis_stripping(vsi);
 +		ret = ice_vsi_manage_vlan_stripping(vsi, false);
  
  	if ((features & NETIF_F_HW_VLAN_CTAG_TX) &&
  	    !(netdev->features & NETIF_F_HW_VLAN_CTAG_TX))
++<<<<<<< HEAD
 +		ret = ice_vsi_manage_vlan_insertion(vsi);
++=======
+ 		ret = vsi->vlan_ops.ena_insertion(vsi, ETH_P_8021Q);
++>>>>>>> 2bfefa2dab6b (ice: Use the proto argument for VLAN ops)
  	else if (!(features & NETIF_F_HW_VLAN_CTAG_TX) &&
  		 (netdev->features & NETIF_F_HW_VLAN_CTAG_TX))
 -		ret = vsi->vlan_ops.dis_insertion(vsi);
 +		ret = ice_vsi_manage_vlan_insertion(vsi);
  
  	if ((features & NETIF_F_HW_VLAN_CTAG_FILTER) &&
  	    !(netdev->features & NETIF_F_HW_VLAN_CTAG_FILTER))
@@@ -5750,9 -5659,9 +5768,15 @@@ static int ice_vsi_vlan_setup(struct ic
  	int ret = 0;
  
  	if (vsi->netdev->features & NETIF_F_HW_VLAN_CTAG_RX)
++<<<<<<< HEAD
 +		ret = ice_vsi_manage_vlan_stripping(vsi, true);
 +	if (vsi->netdev->features & NETIF_F_HW_VLAN_CTAG_TX)
 +		ret = ice_vsi_manage_vlan_insertion(vsi);
++=======
+ 		ret = vsi->vlan_ops.ena_stripping(vsi, ETH_P_8021Q);
+ 	if (vsi->netdev->features & NETIF_F_HW_VLAN_CTAG_TX)
+ 		ret = vsi->vlan_ops.ena_insertion(vsi, ETH_P_8021Q);
++>>>>>>> 2bfefa2dab6b (ice: Use the proto argument for VLAN ops)
  
  	return ret;
  }
diff --cc drivers/net/ethernet/intel/ice/ice_virtchnl_pf.c
index e5875fdaaf40,ce168307f005..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_virtchnl_pf.c
+++ b/drivers/net/ethernet/intel/ice/ice_virtchnl_pf.c
@@@ -4136,10 -4140,9 +4136,16 @@@ ice_set_vf_port_vlan(struct net_device 
  
  	mutex_lock(&vf->cfg_lock);
  
++<<<<<<< HEAD
 +	vf->port_vlan_info = vlanprio;
 +
 +	if (vf->port_vlan_info)
 +		dev_info(dev, "Setting VLAN %d, QoS 0x%x on VF %d\n",
++=======
+ 	vf->port_vlan_info = ICE_VLAN(ETH_P_8021Q, vlan_id, qos);
+ 	if (ice_vf_is_port_vlan_ena(vf))
+ 		dev_info(dev, "Setting VLAN %u, QoS %u on VF %d\n",
++>>>>>>> 2bfefa2dab6b (ice: Use the proto argument for VLAN ops)
  			 vlan_id, qos, vf_id);
  	else
  		dev_info(dev, "Clearing port VLAN on VF %d\n", vf_id);
@@@ -4257,7 -4261,8 +4263,12 @@@ static int ice_vc_process_vlan_msg(stru
  			if (!vid)
  				continue;
  
++<<<<<<< HEAD
 +			status = ice_vsi_add_vlan(vsi, vid, ICE_FWD_TO_VSI);
++=======
+ 			vlan = ICE_VLAN(ETH_P_8021Q, vid, 0);
+ 			status = vsi->vlan_ops.add_vlan(vsi, &vlan);
++>>>>>>> 2bfefa2dab6b (ice: Use the proto argument for VLAN ops)
  			if (status) {
  				v_ret = VIRTCHNL_STATUS_ERR_PARAM;
  				goto error_param;
@@@ -4308,10 -4314,8 +4319,15 @@@
  			if (!vid)
  				continue;
  
++<<<<<<< HEAD
 +			/* Make sure ice_vsi_kill_vlan is successful before
 +			 * updating VLAN information
 +			 */
 +			status = ice_vsi_kill_vlan(vsi, vid);
++=======
+ 			vlan = ICE_VLAN(ETH_P_8021Q, vid, 0);
+ 			status = vsi->vlan_ops.del_vlan(vsi, &vlan);
++>>>>>>> 2bfefa2dab6b (ice: Use the proto argument for VLAN ops)
  			if (status) {
  				v_ret = VIRTCHNL_STATUS_ERR_PARAM;
  				goto error_param;
@@@ -4389,7 -4393,7 +4405,11 @@@ static int ice_vc_ena_vlan_stripping(st
  	}
  
  	vsi = ice_get_vf_vsi(vf);
++<<<<<<< HEAD
 +	if (ice_vsi_manage_vlan_stripping(vsi, true))
++=======
+ 	if (vsi->vlan_ops.ena_stripping(vsi, ETH_P_8021Q))
++>>>>>>> 2bfefa2dab6b (ice: Use the proto argument for VLAN ops)
  		v_ret = VIRTCHNL_STATUS_ERR_PARAM;
  
  error_param:
@@@ -4454,9 -4458,9 +4474,13 @@@ static int ice_vf_init_vlan_stripping(s
  		return 0;
  
  	if (ice_vf_vlan_offload_ena(vf->driver_caps))
++<<<<<<< HEAD
 +		return ice_vsi_manage_vlan_stripping(vsi, true);
++=======
+ 		return vsi->vlan_ops.ena_stripping(vsi, ETH_P_8021Q);
++>>>>>>> 2bfefa2dab6b (ice: Use the proto argument for VLAN ops)
  	else
 -		return vsi->vlan_ops.dis_stripping(vsi);
 +		return ice_vsi_manage_vlan_stripping(vsi, false);
  }
  
  static struct ice_vc_vf_ops ice_vc_vf_dflt_ops = {
diff --cc drivers/net/ethernet/intel/ice/ice_virtchnl_pf.h
index 8f27255cc0cc,b06ca1f97833..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_virtchnl_pf.h
+++ b/drivers/net/ethernet/intel/ice/ice_virtchnl_pf.h
@@@ -118,7 -120,7 +118,11 @@@ struct ice_vf 
  	struct ice_time_mac legacy_last_added_umac;
  	DECLARE_BITMAP(txq_ena, ICE_MAX_RSS_QS_PER_VF);
  	DECLARE_BITMAP(rxq_ena, ICE_MAX_RSS_QS_PER_VF);
++<<<<<<< HEAD
 +	u16 port_vlan_info;		/* Port VLAN ID and QoS */
++=======
+ 	struct ice_vlan port_vlan_info;	/* Port VLAN ID, QoS, and TPID */
++>>>>>>> 2bfefa2dab6b (ice: Use the proto argument for VLAN ops)
  	u8 pf_set_mac:1;		/* VF MAC address set by VMM admin */
  	u8 trusted:1;
  	u8 spoofchk:1;
* Unmerged path drivers/net/ethernet/intel/ice/ice_vlan.h
* Unmerged path drivers/net/ethernet/intel/ice/ice_vsi_vlan_lib.c
* Unmerged path drivers/net/ethernet/intel/ice/ice_vsi_vlan_lib.h
* Unmerged path drivers/net/ethernet/intel/ice/ice_vsi_vlan_ops.h
* Unmerged path drivers/net/ethernet/intel/ice/ice_fltr.c
* Unmerged path drivers/net/ethernet/intel/ice/ice_lib.c
* Unmerged path drivers/net/ethernet/intel/ice/ice_main.c
diff --git a/drivers/net/ethernet/intel/ice/ice_switch.c b/drivers/net/ethernet/intel/ice/ice_switch.c
index 475ec2afa210..0c9224738966 100644
--- a/drivers/net/ethernet/intel/ice/ice_switch.c
+++ b/drivers/net/ethernet/intel/ice/ice_switch.c
@@ -1539,6 +1539,7 @@ ice_fill_sw_rule(struct ice_hw *hw, struct ice_fltr_info *f_info,
 		 struct ice_aqc_sw_rules_elem *s_rule, enum ice_adminq_opc opc)
 {
 	u16 vlan_id = ICE_MAX_VLAN_ID + 1;
+	u16 vlan_tpid = ETH_P_8021Q;
 	void *daddr = NULL;
 	u16 eth_hdr_sz;
 	u8 *eth_hdr;
@@ -1611,6 +1612,8 @@ ice_fill_sw_rule(struct ice_hw *hw, struct ice_fltr_info *f_info,
 		break;
 	case ICE_SW_LKUP_VLAN:
 		vlan_id = f_info->l_data.vlan.vlan_id;
+		if (f_info->l_data.vlan.tpid_valid)
+			vlan_tpid = f_info->l_data.vlan.tpid;
 		if (f_info->fltr_act == ICE_FWD_TO_VSI ||
 		    f_info->fltr_act == ICE_FWD_TO_VSI_LIST) {
 			act |= ICE_SINGLE_ACT_PRUNE;
@@ -1653,6 +1656,8 @@ ice_fill_sw_rule(struct ice_hw *hw, struct ice_fltr_info *f_info,
 	if (!(vlan_id > ICE_MAX_VLAN_ID)) {
 		off = (__force __be16 *)(eth_hdr + ICE_ETH_VLAN_TCI_OFFSET);
 		*off = cpu_to_be16(vlan_id);
+		off = (__force __be16 *)(eth_hdr + ICE_ETH_ETHTYPE_OFFSET);
+		*off = cpu_to_be16(vlan_tpid);
 	}
 
 	/* Create the switch rule with the final dummy Ethernet header */
diff --git a/drivers/net/ethernet/intel/ice/ice_switch.h b/drivers/net/ethernet/intel/ice/ice_switch.h
index d8334beaaa8a..43c8968162a3 100644
--- a/drivers/net/ethernet/intel/ice/ice_switch.h
+++ b/drivers/net/ethernet/intel/ice/ice_switch.h
@@ -86,6 +86,8 @@ struct ice_fltr_info {
 		} mac_vlan;
 		struct {
 			u16 vlan_id;
+			u16 tpid;
+			u8 tpid_valid;
 		} vlan;
 		/* Set lkup_type as ICE_SW_LKUP_ETHERTYPE
 		 * if just using ethertype as filter. Set lkup_type as
* Unmerged path drivers/net/ethernet/intel/ice/ice_virtchnl_pf.c
* Unmerged path drivers/net/ethernet/intel/ice/ice_virtchnl_pf.h
* Unmerged path drivers/net/ethernet/intel/ice/ice_vlan.h
* Unmerged path drivers/net/ethernet/intel/ice/ice_vsi_vlan_lib.c
* Unmerged path drivers/net/ethernet/intel/ice/ice_vsi_vlan_lib.h
* Unmerged path drivers/net/ethernet/intel/ice/ice_vsi_vlan_ops.h
