EDAC/ghes: Set the DIMM label unconditionally

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-425.3.1.el8
commit-author Toshi Kani <toshi.kani@hpe.com>
commit 5e2805d5379619c4a2e3ae4994e73b36439f4bad
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-425.3.1.el8/5e2805d5.failed

The commit

  cb51a371d08e ("EDAC/ghes: Setup DIMM label from DMI and use it in error reports")

enforced that both the bank and device strings passed to
dimm_setup_label() are not NULL.

However, there are BIOSes, for example on a

  HPE ProLiant DL360 Gen10/ProLiant DL360 Gen10, BIOS U32 03/15/2019

which don't populate both strings:

  Handle 0x0020, DMI type 17, 84 bytes
  Memory Device
          Array Handle: 0x0013
          Error Information Handle: Not Provided
          Total Width: 72 bits
          Data Width: 64 bits
          Size: 32 GB
          Form Factor: DIMM
          Set: None
          Locator: PROC 1 DIMM 1        <===== device
          Bank Locator: Not Specified   <===== bank

This results in a buffer overflow because ghes_edac_register() calls
strlen() on an uninitialized label, which had non-zero values left over
from krealloc_array():

  detected buffer overflow in __fortify_strlen
   ------------[ cut here ]------------
   kernel BUG at lib/string_helpers.c:983!
   invalid opcode: 0000 [#1] PREEMPT SMP NOPTI
   CPU: 1 PID: 1 Comm: swapper/0 Tainted: G          I       5.18.6-200.fc36.x86_64 #1
   Hardware name: HPE ProLiant DL360 Gen10/ProLiant DL360 Gen10, BIOS U32 03/15/2019
   RIP: 0010:fortify_panic
   ...
   Call Trace:
    <TASK>
    ghes_edac_register.cold
    ghes_probe
    platform_probe
    really_probe
    __driver_probe_device
    driver_probe_device
    __driver_attach
    ? __device_attach_driver
    bus_for_each_dev
    bus_add_driver
    driver_register
    acpi_ghes_init
    acpi_init
    ? acpi_sleep_proc_init
    do_one_initcall

The label contains garbage because the commit in Fixes reallocs the
DIMMs array while scanning the system but doesn't clear the newly
allocated memory.

Change dimm_setup_label() to always initialize the label to fix the
issue. Set it to the empty string in case BIOS does not provide both
bank and device so that ghes_edac_register() can keep the default label
given by edac_mc_alloc_dimms().

  [ bp: Rewrite commit message. ]

Fixes: b9cae27728d1f ("EDAC/ghes: Scan the system once on driver init")
Co-developed-by: Robert Richter <rric@kernel.org>
	Signed-off-by: Robert Richter <rric@kernel.org>
	Signed-off-by: Toshi Kani <toshi.kani@hpe.com>
	Signed-off-by: Borislav Petkov <bp@suse.de>
	Tested-by: Robert Elliott <elliott@hpe.com>
	Cc: <stable@vger.kernel.org>
Link: https://lore.kernel.org/r/20220719220124.760359-1-toshi.kani@hpe.com
(cherry picked from commit 5e2805d5379619c4a2e3ae4994e73b36439f4bad)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/edac/ghes_edac.c
diff --cc drivers/edac/ghes_edac.c
index db581f20aadb,c8fa7dcfdbd0..000000000000
--- a/drivers/edac/ghes_edac.c
+++ b/drivers/edac/ghes_edac.c
@@@ -107,111 -103,168 +107,122 @@@ static void dimm_setup_label(struct dim
  
  	dmi_memdev_name(handle, &bank, &device);
  
++<<<<<<< HEAD
 +	/* both strings must be non-zero */
 +	if (bank && *bank && device && *device) {
 +		snprintf(dimm->label, sizeof(dimm->label),
 +			"%s %s", bank, device);
 +	}
++=======
+ 	/*
+ 	 * Set to a NULL string when both bank and device are zero. In this case,
+ 	 * the label assigned by default will be preserved.
+ 	 */
+ 	snprintf(dimm->label, sizeof(dimm->label), "%s%s%s",
+ 		 (bank && *bank) ? bank : "",
+ 		 (bank && *bank && device && *device) ? " " : "",
+ 		 (device && *device) ? device : "");
++>>>>>>> 5e2805d53796 (EDAC/ghes: Set the DIMM label unconditionally)
  }
  
 -static void assign_dmi_dimm_info(struct dimm_info *dimm, struct memdev_dmi_entry *entry)
 +static void ghes_edac_dmidecode(const struct dmi_header *dh, void *arg)
  {
 -	u16 rdr_mask = BIT(7) | BIT(13);
 +	struct ghes_edac_dimm_fill *dimm_fill = arg;
 +	struct mem_ctl_info *mci = dimm_fill->mci;
 +
 +	if (dh->type == DMI_ENTRY_MEM_DEVICE) {
 +		struct memdev_dmi_entry *entry = (struct memdev_dmi_entry *)dh;
 +		struct dimm_info *dimm = EDAC_DIMM_PTR(mci->layers, mci->dimms,
 +						       mci->n_layers,
 +						       dimm_fill->count, 0, 0);
 +		u16 rdr_mask = BIT(7) | BIT(13);
 +
 +		if (entry->size == 0xffff) {
 +			pr_info("Can't get DIMM%i size\n",
 +				dimm_fill->count);
 +			dimm->nr_pages = MiB_TO_PAGES(32);/* Unknown */
 +		} else if (entry->size == 0x7fff) {
 +			dimm->nr_pages = MiB_TO_PAGES(entry->extended_size);
 +		} else {
 +			if (entry->size & BIT(15))
 +				dimm->nr_pages = MiB_TO_PAGES((entry->size & 0x7fff) << 10);
 +			else
 +				dimm->nr_pages = MiB_TO_PAGES(entry->size);
 +		}
  
 -	if (entry->size == 0xffff) {
 -		pr_info("Can't get DIMM%i size\n", dimm->idx);
 -		dimm->nr_pages = MiB_TO_PAGES(32);/* Unknown */
 -	} else if (entry->size == 0x7fff) {
 -		dimm->nr_pages = MiB_TO_PAGES(entry->extended_size);
 -	} else {
 -		if (entry->size & BIT(15))
 -			dimm->nr_pages = MiB_TO_PAGES((entry->size & 0x7fff) << 10);
 -		else
 -			dimm->nr_pages = MiB_TO_PAGES(entry->size);
 -	}
 +		switch (entry->memory_type) {
 +		case 0x12:
 +			if (entry->type_detail & BIT(13))
 +				dimm->mtype = MEM_RDDR;
 +			else
 +				dimm->mtype = MEM_DDR;
 +			break;
 +		case 0x13:
 +			if (entry->type_detail & BIT(13))
 +				dimm->mtype = MEM_RDDR2;
 +			else
 +				dimm->mtype = MEM_DDR2;
 +			break;
 +		case 0x14:
 +			dimm->mtype = MEM_FB_DDR2;
 +			break;
 +		case 0x18:
 +			if (entry->type_detail & BIT(12))
 +				dimm->mtype = MEM_NVDIMM;
 +			else if (entry->type_detail & BIT(13))
 +				dimm->mtype = MEM_RDDR3;
 +			else
 +				dimm->mtype = MEM_DDR3;
 +			break;
 +		case 0x1a:
 +			if (entry->type_detail & BIT(12))
 +				dimm->mtype = MEM_NVDIMM;
 +			else if (entry->type_detail & BIT(13))
 +				dimm->mtype = MEM_RDDR4;
 +			else
 +				dimm->mtype = MEM_DDR4;
 +			break;
 +		default:
 +			if (entry->type_detail & BIT(6))
 +				dimm->mtype = MEM_RMBS;
 +			else if ((entry->type_detail & rdr_mask) == rdr_mask)
 +				dimm->mtype = MEM_RDR;
 +			else if (entry->type_detail & BIT(7))
 +				dimm->mtype = MEM_SDR;
 +			else if (entry->type_detail & BIT(9))
 +				dimm->mtype = MEM_EDO;
 +			else
 +				dimm->mtype = MEM_UNKNOWN;
 +		}
  
 -	switch (entry->memory_type) {
 -	case 0x12:
 -		if (entry->type_detail & BIT(13))
 -			dimm->mtype = MEM_RDDR;
 +		/*
 +		 * Actually, we can only detect if the memory has bits for
 +		 * checksum or not
 +		 */
 +		if (entry->total_width == entry->data_width)
 +			dimm->edac_mode = EDAC_NONE;
  		else
 -			dimm->mtype = MEM_DDR;
 -		break;
 -	case 0x13:
 -		if (entry->type_detail & BIT(13))
 -			dimm->mtype = MEM_RDDR2;
 -		else
 -			dimm->mtype = MEM_DDR2;
 -		break;
 -	case 0x14:
 -		dimm->mtype = MEM_FB_DDR2;
 -		break;
 -	case 0x18:
 -		if (entry->type_detail & BIT(12))
 -			dimm->mtype = MEM_NVDIMM;
 -		else if (entry->type_detail & BIT(13))
 -			dimm->mtype = MEM_RDDR3;
 -		else
 -			dimm->mtype = MEM_DDR3;
 -		break;
 -	case 0x1a:
 -		if (entry->type_detail & BIT(12))
 -			dimm->mtype = MEM_NVDIMM;
 -		else if (entry->type_detail & BIT(13))
 -			dimm->mtype = MEM_RDDR4;
 -		else
 -			dimm->mtype = MEM_DDR4;
 -		break;
 -	default:
 -		if (entry->type_detail & BIT(6))
 -			dimm->mtype = MEM_RMBS;
 -		else if ((entry->type_detail & rdr_mask) == rdr_mask)
 -			dimm->mtype = MEM_RDR;
 -		else if (entry->type_detail & BIT(7))
 -			dimm->mtype = MEM_SDR;
 -		else if (entry->type_detail & BIT(9))
 -			dimm->mtype = MEM_EDO;
 -		else
 -			dimm->mtype = MEM_UNKNOWN;
 -	}
 -
 -	/*
 -	 * Actually, we can only detect if the memory has bits for
 -	 * checksum or not
 -	 */
 -	if (entry->total_width == entry->data_width)
 -		dimm->edac_mode = EDAC_NONE;
 -	else
 -		dimm->edac_mode = EDAC_SECDED;
 -
 -	dimm->dtype = DEV_UNKNOWN;
 -	dimm->grain = 128;		/* Likely, worse case */
 -
 -	dimm_setup_label(dimm, entry->handle);
 -
 -	if (dimm->nr_pages) {
 -		edac_dbg(1, "DIMM%i: %s size = %d MB%s\n",
 -			dimm->idx, edac_mem_types[dimm->mtype],
 -			PAGES_TO_MiB(dimm->nr_pages),
 -			(dimm->edac_mode != EDAC_NONE) ? "(ECC)" : "");
 -		edac_dbg(2, "\ttype %d, detail 0x%02x, width %d(total %d)\n",
 -			entry->memory_type, entry->type_detail,
 -			entry->total_width, entry->data_width);
 -	}
 -
 -	dimm->smbios_handle = entry->handle;
 -}
 +			dimm->edac_mode = EDAC_SECDED;
  
 -static void enumerate_dimms(const struct dmi_header *dh, void *arg)
 -{
 -	struct memdev_dmi_entry *entry = (struct memdev_dmi_entry *)dh;
 -	struct ghes_hw_desc *hw = (struct ghes_hw_desc *)arg;
 -	struct dimm_info *d;
 -
 -	if (dh->type != DMI_ENTRY_MEM_DEVICE)
 -		return;
 -
 -	/* Enlarge the array with additional 16 */
 -	if (!hw->num_dimms || !(hw->num_dimms % 16)) {
 -		struct dimm_info *new;
 -
 -		new = krealloc_array(hw->dimms, hw->num_dimms + 16,
 -				     sizeof(struct dimm_info), GFP_KERNEL);
 -		if (!new) {
 -			WARN_ON_ONCE(1);
 -			return;
 +		dimm->dtype = DEV_UNKNOWN;
 +		dimm->grain = 128;		/* Likely, worse case */
 +
 +		dimm_setup_label(dimm, entry->handle);
 +
 +		if (dimm->nr_pages) {
 +			edac_dbg(1, "DIMM%i: %s size = %d MB%s\n",
 +				dimm_fill->count, edac_mem_types[dimm->mtype],
 +				PAGES_TO_MiB(dimm->nr_pages),
 +				(dimm->edac_mode != EDAC_NONE) ? "(ECC)" : "");
 +			edac_dbg(2, "\ttype %d, detail 0x%02x, width %d(total %d)\n",
 +				entry->memory_type, entry->type_detail,
 +				entry->total_width, entry->data_width);
  		}
  
 -		hw->dimms = new;
 -	}
 -
 -	d = &hw->dimms[hw->num_dimms];
 -	d->idx = hw->num_dimms;
 -
 -	assign_dmi_dimm_info(d, entry);
 -
 -	hw->num_dimms++;
 -}
 -
 -static void ghes_scan_system(void)
 -{
 -	if (system_scanned)
 -		return;
 -
 -	dmi_walk(enumerate_dimms, &ghes_hw);
 -
 -	system_scanned = true;
 -}
 -
 -static int print_mem_error_other_detail(const struct cper_sec_mem_err *mem, char *msg,
 -					const char *location, unsigned int len)
 -{
 -	u32 n;
 -
 -	if (!msg)
 -		return 0;
 +		dimm->smbios_handle = entry->handle;
  
 -	n = 0;
 -	len -= 1;
 -
 -	n += scnprintf(msg + n, len - n, "APEI location: %s ", location);
 -
 -	if (!(mem->validation_bits & CPER_MEM_VALID_ERROR_STATUS))
 -		goto out;
 -
 -	n += scnprintf(msg + n, len - n, "status(0x%016llx): ", mem->error_status);
 -	n += scnprintf(msg + n, len - n, "%s ", cper_mem_err_status_str(mem->error_status));
 -
 -out:
 -	msg[n] = '\0';
 -
 -	return n;
 +		dimm_fill->count++;
 +	}
  }
  
  void ghes_edac_report_mem_error(int sev, struct cper_sec_mem_err *mem_err)
* Unmerged path drivers/edac/ghes_edac.c
