spi: Support selection of the index of the ACPI Spi Resource before alloc

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-425.3.1.el8
commit-author Stefan Binding <sbinding@opensource.cirrus.com>
commit 92640f98a78c6a3ea1ca32143144241eceb129bd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-425.3.1.el8/92640f98.failed

If a node contains more than one SPI resource it may be necessary to
use an index to select which one you want to allocate a spi device for.

	Signed-off-by: Stefan Binding <sbinding@opensource.cirrus.com>
	Reviewed-by: Hans de Goede <hdegoede@redhat.com>
Link: https://lore.kernel.org/r/20220121172431.6876-4-sbinding@opensource.cirrus.com
	Signed-off-by: Mark Brown <broonie@kernel.org>
(cherry picked from commit 92640f98a78c6a3ea1ca32143144241eceb129bd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/spi/spi.c
#	include/linux/spi/spi.h
diff --cc drivers/spi/spi.c
index 1b9b6e0668b9,06c0a308b38b..000000000000
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@@ -1895,8 -2435,25 +1920,30 @@@ static int acpi_spi_add_resource(struc
  	return 1;
  }
  
++<<<<<<< HEAD
 +static acpi_status acpi_register_spi_device(struct spi_controller *ctlr,
 +					    struct acpi_device *adev)
++=======
+ /**
+  * acpi_spi_device_alloc - Allocate a spi device, and fill it in with ACPI information
+  * @ctlr: controller to which the spi device belongs
+  * @adev: ACPI Device for the spi device
+  * @index: Index of the spi resource inside the ACPI Node
+  *
+  * This should be used to allocate a new spi device from and ACPI Node.
+  * The caller is responsible for calling spi_add_device to register the spi device.
+  *
+  * If ctlr is set to NULL, the Controller for the spi device will be looked up
+  * using the resource.
+  * If index is set to -1, index is not used.
+  * Note: If index is -1, ctlr must be set.
+  *
+  * Return: a pointer to the new device, or ERR_PTR on error.
+  */
+ struct spi_device *acpi_spi_device_alloc(struct spi_controller *ctlr,
+ 					 struct acpi_device *adev,
+ 					 int index)
++>>>>>>> 92640f98a78c (spi: Support selection of the index of the ACPI Spi Resource before alloc)
  {
  	acpi_handle parent_handle = NULL;
  	struct list_head resource_list;
@@@ -1904,14 -2461,13 +1951,21 @@@
  	struct spi_device *spi;
  	int ret;
  
++<<<<<<< HEAD
 +	if (acpi_bus_get_status(adev) || !adev->status.present ||
 +	    acpi_device_enumerated(adev))
 +		return AE_OK;
++=======
+ 	if (!ctlr && index == -1)
+ 		return ERR_PTR(-EINVAL);
++>>>>>>> 92640f98a78c (spi: Support selection of the index of the ACPI Spi Resource before alloc)
  
  	lookup.ctlr		= ctlr;
 +	lookup.mode		= 0;
 +	lookup.bits_per_word	= 0;
  	lookup.irq		= -1;
+ 	lookup.index		= index;
+ 	lookup.n		= 0;
  
  	INIT_LIST_HEAD(&resource_list);
  	ret = acpi_dev_get_resources(adev, &resource_list,
@@@ -1920,23 -2476,23 +1974,28 @@@
  
  	if (ret < 0)
  		/* found SPI in _CRS but it points to another controller */
 -		return ERR_PTR(-ENODEV);
 +		return AE_OK;
  
  	if (!lookup.max_speed_hz &&
++<<<<<<< HEAD
 +	    !ACPI_FAILURE(acpi_get_parent(adev->handle, &parent_handle)) &&
 +	    ACPI_HANDLE(ctlr->dev.parent) == parent_handle) {
++=======
+ 	    ACPI_SUCCESS(acpi_get_parent(adev->handle, &parent_handle)) &&
+ 	    ACPI_HANDLE(lookup.ctlr->dev.parent) == parent_handle) {
++>>>>>>> 92640f98a78c (spi: Support selection of the index of the ACPI Spi Resource before alloc)
  		/* Apple does not use _CRS but nested devices for SPI slaves */
  		acpi_spi_parse_apple_properties(adev, &lookup);
  	}
  
  	if (!lookup.max_speed_hz)
 -		return ERR_PTR(-ENODEV);
 +		return AE_OK;
  
- 	spi = spi_alloc_device(ctlr);
+ 	spi = spi_alloc_device(lookup.ctlr);
  	if (!spi) {
- 		dev_err(&ctlr->dev, "failed to allocate SPI device for %s\n",
+ 		dev_err(&lookup.ctlr->dev, "failed to allocate SPI device for %s\n",
  			dev_name(&adev->dev));
 -		return ERR_PTR(-ENOMEM);
 +		return AE_NO_MEMORY;
  	}
  
  	ACPI_COMPANION_SET(&spi->dev, adev);
@@@ -1946,6 -2502,27 +2005,30 @@@
  	spi->bits_per_word	= lookup.bits_per_word;
  	spi->chip_select	= lookup.chip_select;
  
++<<<<<<< HEAD
++=======
+ 	return spi;
+ }
+ EXPORT_SYMBOL_GPL(acpi_spi_device_alloc);
+ 
+ static acpi_status acpi_register_spi_device(struct spi_controller *ctlr,
+ 					    struct acpi_device *adev)
+ {
+ 	struct spi_device *spi;
+ 
+ 	if (acpi_bus_get_status(adev) || !adev->status.present ||
+ 	    acpi_device_enumerated(adev))
+ 		return AE_OK;
+ 
+ 	spi = acpi_spi_device_alloc(ctlr, adev, -1);
+ 	if (IS_ERR(spi)) {
+ 		if (PTR_ERR(spi) == -ENOMEM)
+ 			return AE_NO_MEMORY;
+ 		else
+ 			return AE_OK;
+ 	}
+ 
++>>>>>>> 92640f98a78c (spi: Support selection of the index of the ACPI Spi Resource before alloc)
  	acpi_set_modalias(adev, acpi_device_hid(adev), spi->modalias,
  			  sizeof(spi->modalias));
  
diff --cc include/linux/spi/spi.h
index 79184c5b5147,e5bbb9cbd3d7..000000000000
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@@ -660,7 -760,11 +660,15 @@@ extern int devm_spi_register_controller
  					struct spi_controller *ctlr);
  extern void spi_unregister_controller(struct spi_controller *ctlr);
  
++<<<<<<< HEAD
 +extern struct spi_controller *spi_busnum_to_master(u16 busnum);
++=======
+ #if IS_ENABLED(CONFIG_ACPI)
+ extern struct spi_device *acpi_spi_device_alloc(struct spi_controller *ctlr,
+ 						struct acpi_device *adev,
+ 						int index);
+ #endif
++>>>>>>> 92640f98a78c (spi: Support selection of the index of the ACPI Spi Resource before alloc)
  
  /*
   * SPI resource management while processing a SPI message
* Unmerged path drivers/spi/spi.c
* Unmerged path include/linux/spi/spi.h
