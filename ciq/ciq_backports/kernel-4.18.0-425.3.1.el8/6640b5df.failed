Drivers: hv: vmbus: Don't assign VMbus channel interrupts to isolated CPUs

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-425.3.1.el8
commit-author Saurabh Sengar <ssengar@linux.microsoft.com>
commit 6640b5df1a38801be6d0595c8cd2177d968d7ee0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-425.3.1.el8/6640b5df.failed

When initially assigning a VMbus channel interrupt to a CPU, donâ€™t choose
a managed IRQ isolated CPU (as specified on the kernel boot line with
parameter 'isolcpus=managed_irq,<#cpu>'). Also, when using sysfs to change
the CPU that a VMbus channel will interrupt, don't allow changing to a
managed IRQ isolated CPU.

	Signed-off-by: Saurabh Sengar <ssengar@linux.microsoft.com>
	Reviewed-by: Michael Kelley <mikelley@microsoft.com>
Link: https://lore.kernel.org/r/1653637439-23060-1-git-send-email-ssengar@linux.microsoft.com
	Signed-off-by: Wei Liu <wei.liu@kernel.org>
(cherry picked from commit 6640b5df1a38801be6d0595c8cd2177d968d7ee0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/hv/channel_mgmt.c
diff --cc drivers/hv/channel_mgmt.c
index 5c9a4197e630,280b52927758..000000000000
--- a/drivers/hv/channel_mgmt.c
+++ b/drivers/hv/channel_mgmt.c
@@@ -739,8 -728,9 +740,14 @@@ static void init_vp_index(struct vmbus_
  	bool perf_chn = hv_is_perf_channel(channel);
  	u32 i, ncpu = num_online_cpus();
  	cpumask_var_t available_mask;
++<<<<<<< HEAD
 +	struct cpumask *alloced_mask;
 +	u32 target_cpu = 0;
++=======
+ 	struct cpumask *allocated_mask;
+ 	const struct cpumask *hk_mask = housekeeping_cpumask(HK_TYPE_MANAGED_IRQ);
+ 	u32 target_cpu;
++>>>>>>> 6640b5df1a38 (Drivers: hv: vmbus: Don't assign VMbus channel interrupts to isolated CPUs)
  	int numa_node;
  
  	if (!perf_chn ||
@@@ -768,22 -761,23 +778,37 @@@
  				continue;
  			break;
  		}
 -		allocated_mask = &hv_context.hv_numa_map[numa_node];
 +		alloced_mask = &hv_context.hv_numa_map[numa_node];
  
++<<<<<<< HEAD
 +		if (cpumask_weight(alloced_mask) ==
 +		    cpumask_weight(cpumask_of_node(numa_node))) {
++=======
+ retry:
+ 		cpumask_xor(available_mask, allocated_mask, cpumask_of_node(numa_node));
+ 		cpumask_and(available_mask, available_mask, hk_mask);
+ 
+ 		if (cpumask_empty(available_mask)) {
++>>>>>>> 6640b5df1a38 (Drivers: hv: vmbus: Don't assign VMbus channel interrupts to isolated CPUs)
  			/*
  			 * We have cycled through all the CPUs in the node;
 -			 * reset the allocated map.
 +			 * reset the alloced map.
  			 */
++<<<<<<< HEAD
 +			cpumask_clear(alloced_mask);
 +		}
 +
 +		cpumask_xor(available_mask, alloced_mask,
 +			    cpumask_of_node(numa_node));
 +
++=======
+ 			cpumask_clear(allocated_mask);
+ 			goto retry;
+ 		}
+ 
++>>>>>>> 6640b5df1a38 (Drivers: hv: vmbus: Don't assign VMbus channel interrupts to isolated CPUs)
  		target_cpu = cpumask_first(available_mask);
 -		cpumask_set_cpu(target_cpu, allocated_mask);
 +		cpumask_set_cpu(target_cpu, alloced_mask);
  
  		if (channel->offermsg.offer.sub_channel_index >= ncpu ||
  		    i > ncpu || !hv_cpuself_used(target_cpu, channel))
* Unmerged path drivers/hv/channel_mgmt.c
diff --git a/drivers/hv/vmbus_drv.c b/drivers/hv/vmbus_drv.c
index e1c4392357d0..493a4d0c7eae 100644
--- a/drivers/hv/vmbus_drv.c
+++ b/drivers/hv/vmbus_drv.c
@@ -34,6 +34,7 @@
 #include <linux/kernel_stat.h>
 #include <linux/clockchips.h>
 #include <linux/cpu.h>
+#include <linux/sched/isolation.h>
 #include <linux/sched/task_stack.h>
 
 #include <linux/delay.h>
@@ -1805,6 +1806,9 @@ static ssize_t target_cpu_store(struct vmbus_channel *channel,
 	if (target_cpu >= nr_cpumask_bits)
 		return -EINVAL;
 
+	if (!cpumask_test_cpu(target_cpu, housekeeping_cpumask(HK_TYPE_MANAGED_IRQ)))
+		return -EINVAL;
+
 	/* No CPUs should come up or down during this. */
 	cpus_read_lock();
 
