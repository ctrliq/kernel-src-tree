drivers/base/arch_topology.c: remove superfluous header

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-425.3.1.el8
commit-author Mianhan Liu <liumh1@shanghaitech.edu.cn>
commit b39214911a548746e7375985c87cdaa8e1a0dfde
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-425.3.1.el8/b3921491.failed

arch_topology.c hasn't use any macro or function declared in linux/percpu.h,
linux/smp.h and linux/string.h.
Thus, these files can be removed from arch_topology.c safely without
affecting the compilation of the drivers/base/ module

	Signed-off-by: Mianhan Liu <liumh1@shanghaitech.edu.cn>
Link: https://lore.kernel.org/r/20210928193138.24192-1-liumh1@shanghaitech.edu.cn
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit b39214911a548746e7375985c87cdaa8e1a0dfde)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/base/arch_topology.c
diff --cc drivers/base/arch_topology.c
index 1e7dea2bc614,92200873bd50..000000000000
--- a/drivers/base/arch_topology.c
+++ b/drivers/base/arch_topology.c
@@@ -17,14 -16,114 +16,17 @@@
  #include <linux/cpuset.h>
  #include <linux/cpumask.h>
  #include <linux/init.h>
++<<<<<<< HEAD
 +#include <linux/percpu.h>
++=======
+ #include <linux/rcupdate.h>
++>>>>>>> b39214911a54 (drivers/base/arch_topology.c: remove superfluous header)
  #include <linux/sched.h>
- #include <linux/smp.h>
  
 -static DEFINE_PER_CPU(struct scale_freq_data __rcu *, sft_data);
 -static struct cpumask scale_freq_counters_mask;
 -static bool scale_freq_invariant;
 +DEFINE_PER_CPU(unsigned long, freq_scale) = SCHED_CAPACITY_SCALE;
  
 -static bool supports_scale_freq_counters(const struct cpumask *cpus)
 -{
 -	return cpumask_subset(cpus, &scale_freq_counters_mask);
 -}
 -
 -bool topology_scale_freq_invariant(void)
 -{
 -	return cpufreq_supports_freq_invariance() ||
 -	       supports_scale_freq_counters(cpu_online_mask);
 -}
 -
 -static void update_scale_freq_invariant(bool status)
 -{
 -	if (scale_freq_invariant == status)
 -		return;
 -
 -	/*
 -	 * Task scheduler behavior depends on frequency invariance support,
 -	 * either cpufreq or counter driven. If the support status changes as
 -	 * a result of counter initialisation and use, retrigger the build of
 -	 * scheduling domains to ensure the information is propagated properly.
 -	 */
 -	if (topology_scale_freq_invariant() == status) {
 -		scale_freq_invariant = status;
 -		rebuild_sched_domains_energy();
 -	}
 -}
 -
 -void topology_set_scale_freq_source(struct scale_freq_data *data,
 -				    const struct cpumask *cpus)
 -{
 -	struct scale_freq_data *sfd;
 -	int cpu;
 -
 -	/*
 -	 * Avoid calling rebuild_sched_domains() unnecessarily if FIE is
 -	 * supported by cpufreq.
 -	 */
 -	if (cpumask_empty(&scale_freq_counters_mask))
 -		scale_freq_invariant = topology_scale_freq_invariant();
 -
 -	rcu_read_lock();
 -
 -	for_each_cpu(cpu, cpus) {
 -		sfd = rcu_dereference(*per_cpu_ptr(&sft_data, cpu));
 -
 -		/* Use ARCH provided counters whenever possible */
 -		if (!sfd || sfd->source != SCALE_FREQ_SOURCE_ARCH) {
 -			rcu_assign_pointer(per_cpu(sft_data, cpu), data);
 -			cpumask_set_cpu(cpu, &scale_freq_counters_mask);
 -		}
 -	}
 -
 -	rcu_read_unlock();
 -
 -	update_scale_freq_invariant(true);
 -}
 -EXPORT_SYMBOL_GPL(topology_set_scale_freq_source);
 -
 -void topology_clear_scale_freq_source(enum scale_freq_source source,
 -				      const struct cpumask *cpus)
 -{
 -	struct scale_freq_data *sfd;
 -	int cpu;
 -
 -	rcu_read_lock();
 -
 -	for_each_cpu(cpu, cpus) {
 -		sfd = rcu_dereference(*per_cpu_ptr(&sft_data, cpu));
 -
 -		if (sfd && sfd->source == source) {
 -			rcu_assign_pointer(per_cpu(sft_data, cpu), NULL);
 -			cpumask_clear_cpu(cpu, &scale_freq_counters_mask);
 -		}
 -	}
 -
 -	rcu_read_unlock();
 -
 -	/*
 -	 * Make sure all references to previous sft_data are dropped to avoid
 -	 * use-after-free races.
 -	 */
 -	synchronize_rcu();
 -
 -	update_scale_freq_invariant(false);
 -}
 -EXPORT_SYMBOL_GPL(topology_clear_scale_freq_source);
 -
 -void topology_scale_freq_tick(void)
 -{
 -	struct scale_freq_data *sfd = rcu_dereference_sched(*this_cpu_ptr(&sft_data));
 -
 -	if (sfd)
 -		sfd->set_freq_scale();
 -}
 -
 -DEFINE_PER_CPU(unsigned long, arch_freq_scale) = SCHED_CAPACITY_SCALE;
 -EXPORT_PER_CPU_SYMBOL_GPL(arch_freq_scale);
 -
 -void topology_set_freq_scale(const struct cpumask *cpus, unsigned long cur_freq,
 -			     unsigned long max_freq)
 +void arch_set_freq_scale(struct cpumask *cpus, unsigned long cur_freq,
 +			 unsigned long max_freq)
  {
  	unsigned long scale;
  	int i;
* Unmerged path drivers/base/arch_topology.c
