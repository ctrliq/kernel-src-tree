PCI: vmd: Assign VMD IRQ domain before enumeration

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-425.3.1.el8
commit-author Nirmal Patel <nirmal.patel@linux.intel.com>
commit 886e67100b904cb1b106ed1dfa8a60696aff519a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-425.3.1.el8/886e6710.failed

During the boot process all the PCI devices are assigned default PCI-MSI
IRQ domain including VMD endpoint devices. If interrupt-remapping is
enabled by IOMMU, the PCI devices except VMD get new INTEL-IR-MSI IRQ
domain. And VMD is supposed to create and assign a separate VMD-MSI IRQ
domain for its child devices in order to support MSI-X remapping
capabilities.

Now when MSI-X remapping in VMD is disabled in order to improve
performance, VMD skips VMD-MSI IRQ domain assignment process to its
child devices. Thus the devices behind VMD get default PCI-MSI IRQ
domain instead of INTEL-IR-MSI IRQ domain when VMD creates root bus and
configures child devices.

As a result host OS fails to boot and DMAR errors were observed when
interrupt remapping was enabled on Intel Icelake CPUs. For instance:

  DMAR: DRHD: handling fault status reg 2
  DMAR: [INTR-REMAP] Request device [0xe2:0x00.0] fault index 0xa00 [fault reason 0x25] Blocked a compatibility format interrupt request

To fix this issue, dev_msi_info struct in dev struct maintains correct
value of IRQ domain. VMD will use this information to assign proper IRQ
domain to its child devices when it doesn't create a separate IRQ domain.

Link: https://lore.kernel.org/r/20220511095707.25403-2-nirmal.patel@linux.intel.com
	Signed-off-by: Nirmal Patel <nirmal.patel@linux.intel.com>
	Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
(cherry picked from commit 886e67100b904cb1b106ed1dfa8a60696aff519a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/pci/controller/vmd.c
diff --cc drivers/pci/controller/vmd.c
index 6e122dfa3c2f,5015adc04d19..000000000000
--- a/drivers/pci/controller/vmd.c
+++ b/drivers/pci/controller/vmd.c
@@@ -706,8 -847,15 +706,16 @@@ static int vmd_enable_domain(struct vmd
  		return -ENODEV;
  	}
  
 -	vmd_copy_host_bridge_flags(pci_find_host_bridge(vmd->dev->bus),
 -				   to_pci_host_bridge(vmd->bus->bridge));
 -
  	vmd_attach_resources(vmd);
++<<<<<<< HEAD
 +	dev_set_msi_domain(&vmd->bus->dev, vmd->irq_domain);
++=======
+ 	if (vmd->irq_domain)
+ 		dev_set_msi_domain(&vmd->bus->dev, vmd->irq_domain);
+ 	else
+ 		dev_set_msi_domain(&vmd->bus->dev,
+ 				   dev_get_msi_domain(&vmd->dev->dev));
++>>>>>>> 886e67100b90 (PCI: vmd: Assign VMD IRQ domain before enumeration)
  
  	vmd_acpi_begin();
  
* Unmerged path drivers/pci/controller/vmd.c
