net/mlx5e: Add vlan push/pop/mangle to tc action infra

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-425.3.1.el8
commit-author Roi Dayan <roid@nvidia.com>
commit 8ee72638347c81f8029d19ac93a797a6be6f3ae8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-425.3.1.el8/8ee72638.failed

Add parsing support by implementing struct mlx5e_tc_act
for this action.

	Signed-off-by: Roi Dayan <roid@nvidia.com>
	Reviewed-by: Oz Shlomo <ozsh@nvidia.com>
	Signed-off-by: Saeed Mahameed <saeedm@nvidia.com>
(cherry picked from commit 8ee72638347c81f8029d19ac93a797a6be6f3ae8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/Makefile
#	drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/act.c
#	drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/act.h
#	drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/Makefile
index 478a0ab6470d,074482b5bc96..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/Makefile
+++ b/drivers/net/ethernet/mellanox/mlx5/core/Makefile
@@@ -46,6 -46,12 +46,15 @@@ mlx5_core-$(CONFIG_MLX5_CLS_ACT)     +
  					en/tc_tun_vxlan.o en/tc_tun_gre.o en/tc_tun_geneve.o \
  					en/tc_tun_mplsoudp.o diag/en_tc_tracepoint.o \
  					en/tc/post_act.o en/tc/int_port.o
++<<<<<<< HEAD
++=======
+ 
+ mlx5_core-$(CONFIG_MLX5_CLS_ACT)     += en/tc/act/act.o en/tc/act/drop.o en/tc/act/trap.o \
+ 					en/tc/act/accept.o en/tc/act/mark.o en/tc/act/goto.o \
+ 					en/tc/act/tun.o en/tc/act/csum.o en/tc/act/pedit.o \
+ 					en/tc/act/vlan.o en/tc/act/vlan_mangle.o
+ 
++>>>>>>> 8ee72638347c (net/mlx5e: Add vlan push/pop/mangle to tc action infra)
  mlx5_core-$(CONFIG_MLX5_TC_CT)	     += en/tc_ct.o
  mlx5_core-$(CONFIG_MLX5_TC_SAMPLE)   += en/tc/sample.o
  
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
index abcf89c03680,6e1b02b8eda6..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
@@@ -62,6 -60,8 +62,11 @@@
  #include "en/mod_hdr.h"
  #include "en/tc_tun_encap.h"
  #include "en/tc/sample.h"
++<<<<<<< HEAD
++=======
+ #include "en/tc/act/act.h"
+ #include "en/tc/act/vlan.h"
++>>>>>>> 8ee72638347c (net/mlx5e: Add vlan push/pop/mangle to tc action infra)
  #include "lib/devcom.h"
  #include "lib/geneve.h"
  #include "lib/fs_chains.h"
@@@ -3297,49 -3125,6 +3300,52 @@@ static bool same_vf_reps(struct mlx5e_p
  	       priv->netdev == out_dev;
  }
  
++<<<<<<< HEAD
 +static int add_vlan_rewrite_action(struct mlx5e_priv *priv, int namespace,
 +				   const struct flow_action_entry *act,
 +				   struct mlx5e_tc_flow_parse_attr *parse_attr,
 +				   struct pedit_headers_action *hdrs,
 +				   u32 *action, struct netlink_ext_ack *extack)
 +{
 +	u16 mask16 = VLAN_VID_MASK;
 +	u16 val16 = act->vlan.vid & VLAN_VID_MASK;
 +	const struct flow_action_entry pedit_act = {
 +		.id = FLOW_ACTION_MANGLE,
 +		.mangle.htype = FLOW_ACT_MANGLE_HDR_TYPE_ETH,
 +		.mangle.offset = offsetof(struct vlan_ethhdr, h_vlan_TCI),
 +		.mangle.mask = ~(u32)be16_to_cpu(*(__be16 *)&mask16),
 +		.mangle.val = (u32)be16_to_cpu(*(__be16 *)&val16),
 +	};
 +	u8 match_prio_mask, match_prio_val;
 +	void *headers_c, *headers_v;
 +	int err;
 +
 +	headers_c = get_match_headers_criteria(*action, &parse_attr->spec);
 +	headers_v = get_match_headers_value(*action, &parse_attr->spec);
 +
 +	if (!(MLX5_GET(fte_match_set_lyr_2_4, headers_c, cvlan_tag) &&
 +	      MLX5_GET(fte_match_set_lyr_2_4, headers_v, cvlan_tag))) {
 +		NL_SET_ERR_MSG_MOD(extack,
 +				   "VLAN rewrite action must have VLAN protocol match");
 +		return -EOPNOTSUPP;
 +	}
 +
 +	match_prio_mask = MLX5_GET(fte_match_set_lyr_2_4, headers_c, first_prio);
 +	match_prio_val = MLX5_GET(fte_match_set_lyr_2_4, headers_v, first_prio);
 +	if (act->vlan.prio != (match_prio_val & match_prio_mask)) {
 +		NL_SET_ERR_MSG_MOD(extack,
 +				   "Changing VLAN prio is not supported");
 +		return -EOPNOTSUPP;
 +	}
 +
 +	err = parse_tc_pedit_action(priv, &pedit_act, namespace, parse_attr, hdrs, NULL, extack);
 +	*action |= MLX5_FLOW_CONTEXT_ACTION_MOD_HDR;
 +
 +	return err;
 +}
 +
++=======
++>>>>>>> 8ee72638347c (net/mlx5e: Add vlan push/pop/mangle to tc action infra)
  static int
  add_vlan_prio_tag_rewrite_action(struct mlx5e_priv *priv,
  				 struct mlx5e_tc_flow_parse_attr *parse_attr,
@@@ -3359,62 -3144,11 +3365,62 @@@
  				 first_prio),
  	};
  
- 	return add_vlan_rewrite_action(priv, MLX5_FLOW_NAMESPACE_FDB,
- 				       &prio_tag_act, parse_attr, hdrs, action,
- 				       extack);
+ 	return mlx5e_tc_act_vlan_add_rewrite_action(priv, MLX5_FLOW_NAMESPACE_FDB,
+ 						    &prio_tag_act, parse_attr, hdrs, action,
+ 						    extack);
  }
  
 +static int validate_goto_chain(struct mlx5e_priv *priv,
 +			       struct mlx5e_tc_flow *flow,
 +			       const struct flow_action_entry *act,
 +			       u32 actions,
 +			       struct netlink_ext_ack *extack)
 +{
 +	bool is_esw = mlx5e_is_eswitch_flow(flow);
 +	struct mlx5_flow_attr *attr = flow->attr;
 +	bool ft_flow = mlx5e_is_ft_flow(flow);
 +	u32 dest_chain = act->chain_index;
 +	struct mlx5_fs_chains *chains;
 +	struct mlx5_eswitch *esw;
 +	u32 reformat_and_fwd;
 +	u32 max_chain;
 +
 +	esw = priv->mdev->priv.eswitch;
 +	chains = is_esw ? esw_chains(esw) : nic_chains(priv);
 +	max_chain = mlx5_chains_get_chain_range(chains);
 +	reformat_and_fwd = is_esw ?
 +			   MLX5_CAP_ESW_FLOWTABLE_FDB(priv->mdev, reformat_and_fwd_to_table) :
 +			   MLX5_CAP_FLOWTABLE_NIC_RX(priv->mdev, reformat_and_fwd_to_table);
 +
 +	if (ft_flow) {
 +		NL_SET_ERR_MSG_MOD(extack, "Goto action is not supported");
 +		return -EOPNOTSUPP;
 +	}
 +
 +	if (!mlx5_chains_backwards_supported(chains) &&
 +	    dest_chain <= attr->chain) {
 +		NL_SET_ERR_MSG_MOD(extack,
 +				   "Goto lower numbered chain isn't supported");
 +		return -EOPNOTSUPP;
 +	}
 +
 +	if (dest_chain > max_chain) {
 +		NL_SET_ERR_MSG_MOD(extack,
 +				   "Requested destination chain is out of supported range");
 +		return -EOPNOTSUPP;
 +	}
 +
 +	if (actions & (MLX5_FLOW_CONTEXT_ACTION_PACKET_REFORMAT |
 +		       MLX5_FLOW_CONTEXT_ACTION_DECAP) &&
 +	    !reformat_and_fwd) {
 +		NL_SET_ERR_MSG_MOD(extack,
 +				   "Goto chain is not allowed if action has reformat or decap");
 +		return -EOPNOTSUPP;
 +	}
 +
 +	return 0;
 +}
 +
  static int
  actions_prepare_mod_hdr_actions(struct mlx5e_priv *priv,
  				struct mlx5e_tc_flow *flow,
@@@ -3497,39 -3230,10 +3503,42 @@@ parse_tc_nic_actions(struct mlx5e_priv 
  
  	flow_action_for_each(i, act, flow_action) {
  		switch (act->id) {
++<<<<<<< HEAD
 +		case FLOW_ACTION_ACCEPT:
 +			action |= MLX5_FLOW_CONTEXT_ACTION_FWD_DEST |
 +				  MLX5_FLOW_CONTEXT_ACTION_COUNT;
 +			break;
 +		case FLOW_ACTION_DROP:
 +			action |= MLX5_FLOW_CONTEXT_ACTION_DROP |
 +				  MLX5_FLOW_CONTEXT_ACTION_COUNT;
 +			break;
 +		case FLOW_ACTION_MANGLE:
 +		case FLOW_ACTION_ADD:
 +			err = parse_tc_pedit_action(priv, act, MLX5_FLOW_NAMESPACE_KERNEL,
 +						    parse_attr, hdrs, NULL, extack);
 +			if (err)
 +				return err;
 +
 +			action |= MLX5_FLOW_CONTEXT_ACTION_MOD_HDR;
 +			break;
 +		case FLOW_ACTION_VLAN_MANGLE:
 +			err = add_vlan_rewrite_action(priv,
 +						      MLX5_FLOW_NAMESPACE_KERNEL,
 +						      act, parse_attr, hdrs,
 +						      &action, extack);
 +			if (err)
 +				return err;
 +
 +			break;
 +		case FLOW_ACTION_CSUM:
 +			if (csum_offload_supported(priv, action,
 +						   act->csum_flags,
 +						   extack))
 +				break;
 +
 +			return -EOPNOTSUPP;
++=======
++>>>>>>> 8ee72638347c (net/mlx5e: Add vlan push/pop/mangle to tc action infra)
  		case FLOW_ACTION_REDIRECT: {
  			struct net_device *peer_dev = act->dev;
  
@@@ -3712,58 -3329,6 +3655,61 @@@ static struct net_device *get_fdb_out_d
  	return fdb_out_dev;
  }
  
++<<<<<<< HEAD
 +static int add_vlan_push_action(struct mlx5e_priv *priv,
 +				struct mlx5_flow_attr *attr,
 +				struct net_device **out_dev,
 +				u32 *action,
 +				struct netlink_ext_ack *extack)
 +{
 +	struct net_device *vlan_dev = *out_dev;
 +	struct flow_action_entry vlan_act = {
 +		.id = FLOW_ACTION_VLAN_PUSH,
 +		.vlan.vid = vlan_dev_vlan_id(vlan_dev),
 +		.vlan.proto = vlan_dev_vlan_proto(vlan_dev),
 +		.vlan.prio = 0,
 +	};
 +	int err;
 +
 +	err = parse_tc_vlan_action(priv, &vlan_act, attr->esw_attr, action, extack);
 +	if (err)
 +		return err;
 +
 +	rcu_read_lock();
 +	*out_dev = dev_get_by_index_rcu(dev_net(vlan_dev), dev_get_iflink(vlan_dev));
 +	rcu_read_unlock();
 +	if (!*out_dev)
 +		return -ENODEV;
 +
 +	if (is_vlan_dev(*out_dev))
 +		err = add_vlan_push_action(priv, attr, out_dev, action, extack);
 +
 +	return err;
 +}
 +
 +static int add_vlan_pop_action(struct mlx5e_priv *priv,
 +			       struct mlx5_flow_attr *attr,
 +			       u32 *action,
 +			       struct netlink_ext_ack *extack)
 +{
 +	struct flow_action_entry vlan_act = {
 +		.id = FLOW_ACTION_VLAN_POP,
 +	};
 +	int nest_level, err = 0;
 +
 +	nest_level = attr->parse_attr->filter_dev->lower_level -
 +						priv->netdev->lower_level;
 +	while (nest_level--) {
 +		err = parse_tc_vlan_action(priv, &vlan_act, attr->esw_attr, action, extack);
 +		if (err)
 +			return err;
 +	}
 +
 +	return err;
 +}
 +
++=======
++>>>>>>> 8ee72638347c (net/mlx5e: Add vlan push/pop/mangle to tc action infra)
  static bool same_hw_reps(struct mlx5e_priv *priv,
  			 struct net_device *peer_netdev)
  {
@@@ -4112,16 -3652,16 +4058,27 @@@ static int parse_tc_fdb_actions(struct 
  					return -ENODEV;
  
  				if (is_vlan_dev(out_dev)) {
++<<<<<<< HEAD
 +					err = add_vlan_push_action(priv, attr,
 +								   &out_dev,
 +								   &action, extack);
++=======
+ 					err = mlx5e_tc_act_vlan_add_push_action(priv, attr,
+ 										&out_dev,
+ 										extack);
++>>>>>>> 8ee72638347c (net/mlx5e: Add vlan push/pop/mangle to tc action infra)
  					if (err)
  						return err;
  				}
  
  				if (is_vlan_dev(parse_attr->filter_dev)) {
++<<<<<<< HEAD
 +					err = add_vlan_pop_action(priv, attr,
 +								  &action, extack);
++=======
+ 					err = mlx5e_tc_act_vlan_add_pop_action(priv, attr,
+ 									       extack);
++>>>>>>> 8ee72638347c (net/mlx5e: Add vlan push/pop/mangle to tc action infra)
  					if (err)
  						return err;
  				}
@@@ -4170,62 -3710,14 +4127,65 @@@
  			} else {
  				NL_SET_ERR_MSG_MOD(extack,
  						   "devices are not on same switch HW, can't offload forwarding");
 -				netdev_warn(priv->netdev,
 -					    "devices %s %s not on same switch HW, can't offload forwarding\n",
 -					    priv->netdev->name,
 -					    out_dev->name);
 +				return -EINVAL;
 +			}
 +			}
 +			break;
 +		case FLOW_ACTION_TUNNEL_ENCAP:
 +			info = act->tunnel;
 +			if (info) {
 +				encap = true;
 +			} else {
 +				NL_SET_ERR_MSG_MOD(extack,
 +						   "Zero tunnel attributes is not supported");
  				return -EOPNOTSUPP;
  			}
 +
 +			break;
++<<<<<<< HEAD
 +		case FLOW_ACTION_VLAN_PUSH:
 +		case FLOW_ACTION_VLAN_POP:
 +			if (act->id == FLOW_ACTION_VLAN_PUSH &&
 +			    (action & MLX5_FLOW_CONTEXT_ACTION_VLAN_POP)) {
 +				/* Replace vlan pop+push with vlan modify */
 +				action &= ~MLX5_FLOW_CONTEXT_ACTION_VLAN_POP;
 +				err = add_vlan_rewrite_action(priv,
 +							      MLX5_FLOW_NAMESPACE_FDB,
 +							      act, parse_attr, hdrs,
 +							      &action, extack);
 +			} else {
 +				err = parse_tc_vlan_action(priv, act, esw_attr, &action, extack);
  			}
 +			if (err)
 +				return err;
 +
 +			esw_attr->split_count = esw_attr->out_count;
 +			break;
 +		case FLOW_ACTION_VLAN_MANGLE:
 +			err = add_vlan_rewrite_action(priv,
 +						      MLX5_FLOW_NAMESPACE_FDB,
 +						      act, parse_attr, hdrs,
 +						      &action, extack);
 +			if (err)
 +				return err;
 +
 +			esw_attr->split_count = esw_attr->out_count;
 +			break;
 +		case FLOW_ACTION_TUNNEL_DECAP:
 +			decap = true;
 +			break;
 +		case FLOW_ACTION_GOTO:
 +			err = validate_goto_chain(priv, flow, act, action,
 +						  extack);
 +			if (err)
 +				return err;
 +
 +			action |= MLX5_FLOW_CONTEXT_ACTION_FWD_DEST |
 +				  MLX5_FLOW_CONTEXT_ACTION_COUNT;
 +			attr->dest_chain = act->chain_index;
  			break;
++=======
++>>>>>>> 8ee72638347c (net/mlx5e: Add vlan push/pop/mangle to tc action infra)
  		case FLOW_ACTION_CT:
  			if (flow_flag_test(flow, SAMPLE)) {
  				NL_SET_ERR_MSG_MOD(extack, "Sample action with connection tracking is not supported");
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/act.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/act.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/Makefile
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/act.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/act.h
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/vlan.c b/drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/vlan.c
new file mode 100644
index 000000000000..5a80eaeb90dc
--- /dev/null
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/vlan.c
@@ -0,0 +1,167 @@
+// SPDX-License-Identifier: GPL-2.0 OR Linux-OpenIB
+// Copyright (c) 2021, NVIDIA CORPORATION & AFFILIATES. All rights reserved.
+
+#include <linux/if_vlan.h>
+#include "act.h"
+#include "vlan.h"
+#include "en/tc_priv.h"
+
+static int
+parse_tc_vlan_action(struct mlx5e_priv *priv,
+		     const struct flow_action_entry *act,
+		     struct mlx5_esw_flow_attr *attr,
+		     u32 *action,
+		     struct netlink_ext_ack *extack)
+{
+	u8 vlan_idx = attr->total_vlan;
+
+	if (vlan_idx >= MLX5_FS_VLAN_DEPTH) {
+		NL_SET_ERR_MSG_MOD(extack, "Total vlans used is greater than supported");
+		return -EOPNOTSUPP;
+	}
+
+	switch (act->id) {
+	case FLOW_ACTION_VLAN_POP:
+		if (vlan_idx) {
+			if (!mlx5_eswitch_vlan_actions_supported(priv->mdev,
+								 MLX5_FS_VLAN_DEPTH)) {
+				NL_SET_ERR_MSG_MOD(extack, "vlan pop action is not supported");
+				return -EOPNOTSUPP;
+			}
+
+			*action |= MLX5_FLOW_CONTEXT_ACTION_VLAN_POP_2;
+		} else {
+			*action |= MLX5_FLOW_CONTEXT_ACTION_VLAN_POP;
+		}
+		break;
+	case FLOW_ACTION_VLAN_PUSH:
+		attr->vlan_vid[vlan_idx] = act->vlan.vid;
+		attr->vlan_prio[vlan_idx] = act->vlan.prio;
+		attr->vlan_proto[vlan_idx] = act->vlan.proto;
+		if (!attr->vlan_proto[vlan_idx])
+			attr->vlan_proto[vlan_idx] = htons(ETH_P_8021Q);
+
+		if (vlan_idx) {
+			if (!mlx5_eswitch_vlan_actions_supported(priv->mdev,
+								 MLX5_FS_VLAN_DEPTH)) {
+				NL_SET_ERR_MSG_MOD(extack,
+						   "vlan push action is not supported for vlan depth > 1");
+				return -EOPNOTSUPP;
+			}
+
+			*action |= MLX5_FLOW_CONTEXT_ACTION_VLAN_PUSH_2;
+		} else {
+			if (!mlx5_eswitch_vlan_actions_supported(priv->mdev, 1) &&
+			    (act->vlan.proto != htons(ETH_P_8021Q) ||
+			     act->vlan.prio)) {
+				NL_SET_ERR_MSG_MOD(extack, "vlan push action is not supported");
+				return -EOPNOTSUPP;
+			}
+
+			*action |= MLX5_FLOW_CONTEXT_ACTION_VLAN_PUSH;
+		}
+		break;
+	default:
+		NL_SET_ERR_MSG_MOD(extack, "Unexpected action id for VLAN");
+		return -EINVAL;
+	}
+
+	attr->total_vlan = vlan_idx + 1;
+
+	return 0;
+}
+
+int
+mlx5e_tc_act_vlan_add_push_action(struct mlx5e_priv *priv,
+				  struct mlx5_flow_attr *attr,
+				  struct net_device **out_dev,
+				  struct netlink_ext_ack *extack)
+{
+	struct net_device *vlan_dev = *out_dev;
+	struct flow_action_entry vlan_act = {
+		.id = FLOW_ACTION_VLAN_PUSH,
+		.vlan.vid = vlan_dev_vlan_id(vlan_dev),
+		.vlan.proto = vlan_dev_vlan_proto(vlan_dev),
+		.vlan.prio = 0,
+	};
+	int err;
+
+	err = parse_tc_vlan_action(priv, &vlan_act, attr->esw_attr, &attr->action, extack);
+	if (err)
+		return err;
+
+	rcu_read_lock();
+	*out_dev = dev_get_by_index_rcu(dev_net(vlan_dev), dev_get_iflink(vlan_dev));
+	rcu_read_unlock();
+	if (!*out_dev)
+		return -ENODEV;
+
+	if (is_vlan_dev(*out_dev))
+		err = mlx5e_tc_act_vlan_add_push_action(priv, attr, out_dev, extack);
+
+	return err;
+}
+
+int
+mlx5e_tc_act_vlan_add_pop_action(struct mlx5e_priv *priv,
+				 struct mlx5_flow_attr *attr,
+				 struct netlink_ext_ack *extack)
+{
+	struct flow_action_entry vlan_act = {
+		.id = FLOW_ACTION_VLAN_POP,
+	};
+	int nest_level, err = 0;
+
+	nest_level = attr->parse_attr->filter_dev->lower_level -
+						priv->netdev->lower_level;
+	while (nest_level--) {
+		err = parse_tc_vlan_action(priv, &vlan_act, attr->esw_attr, &attr->action,
+					   extack);
+		if (err)
+			return err;
+	}
+
+	return err;
+}
+
+static bool
+tc_act_can_offload_vlan(struct mlx5e_tc_act_parse_state *parse_state,
+			const struct flow_action_entry *act,
+			int act_index)
+{
+	return true;
+}
+
+static int
+tc_act_parse_vlan(struct mlx5e_tc_act_parse_state *parse_state,
+		  const struct flow_action_entry *act,
+		  struct mlx5e_priv *priv,
+		  struct mlx5_flow_attr *attr)
+{
+	struct mlx5_esw_flow_attr *esw_attr = attr->esw_attr;
+	int err;
+
+	if (act->id == FLOW_ACTION_VLAN_PUSH &&
+	    (attr->action & MLX5_FLOW_CONTEXT_ACTION_VLAN_POP)) {
+		/* Replace vlan pop+push with vlan modify */
+		attr->action &= ~MLX5_FLOW_CONTEXT_ACTION_VLAN_POP;
+		err = mlx5e_tc_act_vlan_add_rewrite_action(priv, MLX5_FLOW_NAMESPACE_FDB, act,
+							   attr->parse_attr, parse_state->hdrs,
+							   &attr->action, parse_state->extack);
+	} else {
+		err = parse_tc_vlan_action(priv, act, esw_attr, &attr->action,
+					   parse_state->extack);
+	}
+
+	if (err)
+		return err;
+
+	esw_attr->split_count = esw_attr->out_count;
+
+	return 0;
+}
+
+struct mlx5e_tc_act mlx5e_tc_act_vlan = {
+	.can_offload = tc_act_can_offload_vlan,
+	.parse_action = tc_act_parse_vlan,
+};
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/vlan.h b/drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/vlan.h
new file mode 100644
index 000000000000..3d62f13ab61f
--- /dev/null
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/vlan.h
@@ -0,0 +1,30 @@
+/* SPDX-License-Identifier: GPL-2.0 OR Linux-OpenIB */
+/* Copyright (c) 2021, NVIDIA CORPORATION & AFFILIATES. All rights reserved. */
+
+#ifndef __MLX5_EN_TC_ACT_VLAN_H__
+#define __MLX5_EN_TC_ACT_VLAN_H__
+
+#include <net/flow_offload.h>
+#include "en/tc_priv.h"
+
+struct pedit_headers_action;
+
+int
+mlx5e_tc_act_vlan_add_push_action(struct mlx5e_priv *priv,
+				  struct mlx5_flow_attr *attr,
+				  struct net_device **out_dev,
+				  struct netlink_ext_ack *extack);
+
+int
+mlx5e_tc_act_vlan_add_pop_action(struct mlx5e_priv *priv,
+				 struct mlx5_flow_attr *attr,
+				 struct netlink_ext_ack *extack);
+
+int
+mlx5e_tc_act_vlan_add_rewrite_action(struct mlx5e_priv *priv, int namespace,
+				     const struct flow_action_entry *act,
+				     struct mlx5e_tc_flow_parse_attr *parse_attr,
+				     struct pedit_headers_action *hdrs,
+				     u32 *action, struct netlink_ext_ack *extack);
+
+#endif /* __MLX5_EN_TC_ACT_VLAN_H__ */
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/vlan_mangle.c b/drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/vlan_mangle.c
new file mode 100644
index 000000000000..63e36e7f53e3
--- /dev/null
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en/tc/act/vlan_mangle.c
@@ -0,0 +1,87 @@
+// SPDX-License-Identifier: GPL-2.0 OR Linux-OpenIB
+// Copyright (c) 2021, NVIDIA CORPORATION & AFFILIATES. All rights reserved.
+
+#include <linux/if_vlan.h>
+#include "act.h"
+#include "vlan.h"
+#include "en/tc_priv.h"
+
+struct pedit_headers_action;
+
+int
+mlx5e_tc_act_vlan_add_rewrite_action(struct mlx5e_priv *priv, int namespace,
+				     const struct flow_action_entry *act,
+				     struct mlx5e_tc_flow_parse_attr *parse_attr,
+				     struct pedit_headers_action *hdrs,
+				     u32 *action, struct netlink_ext_ack *extack)
+{
+	u16 mask16 = VLAN_VID_MASK;
+	u16 val16 = act->vlan.vid & VLAN_VID_MASK;
+	const struct flow_action_entry pedit_act = {
+		.id = FLOW_ACTION_MANGLE,
+		.mangle.htype = FLOW_ACT_MANGLE_HDR_TYPE_ETH,
+		.mangle.offset = offsetof(struct vlan_ethhdr, h_vlan_TCI),
+		.mangle.mask = ~(u32)be16_to_cpu(*(__be16 *)&mask16),
+		.mangle.val = (u32)be16_to_cpu(*(__be16 *)&val16),
+	};
+	u8 match_prio_mask, match_prio_val;
+	void *headers_c, *headers_v;
+	int err;
+
+	headers_c = mlx5e_get_match_headers_criteria(*action, &parse_attr->spec);
+	headers_v = mlx5e_get_match_headers_value(*action, &parse_attr->spec);
+
+	if (!(MLX5_GET(fte_match_set_lyr_2_4, headers_c, cvlan_tag) &&
+	      MLX5_GET(fte_match_set_lyr_2_4, headers_v, cvlan_tag))) {
+		NL_SET_ERR_MSG_MOD(extack, "VLAN rewrite action must have VLAN protocol match");
+		return -EOPNOTSUPP;
+	}
+
+	match_prio_mask = MLX5_GET(fte_match_set_lyr_2_4, headers_c, first_prio);
+	match_prio_val = MLX5_GET(fte_match_set_lyr_2_4, headers_v, first_prio);
+	if (act->vlan.prio != (match_prio_val & match_prio_mask)) {
+		NL_SET_ERR_MSG_MOD(extack, "Changing VLAN prio is not supported");
+		return -EOPNOTSUPP;
+	}
+
+	err = mlx5e_tc_act_pedit_parse_action(priv, &pedit_act, namespace, parse_attr, hdrs,
+					      NULL, extack);
+	*action |= MLX5_FLOW_CONTEXT_ACTION_MOD_HDR;
+
+	return err;
+}
+
+static bool
+tc_act_can_offload_vlan_mangle(struct mlx5e_tc_act_parse_state *parse_state,
+			       const struct flow_action_entry *act,
+			       int act_index)
+{
+	return true;
+}
+
+static int
+tc_act_parse_vlan_mangle(struct mlx5e_tc_act_parse_state *parse_state,
+			 const struct flow_action_entry *act,
+			 struct mlx5e_priv *priv,
+			 struct mlx5_flow_attr *attr)
+{
+	enum mlx5_flow_namespace_type ns_type;
+	int err;
+
+	ns_type = mlx5e_get_flow_namespace(parse_state->flow);
+	err = mlx5e_tc_act_vlan_add_rewrite_action(priv, ns_type, act,
+						   attr->parse_attr, parse_state->hdrs,
+						   &attr->action, parse_state->extack);
+	if (err)
+		return err;
+
+	if (ns_type == MLX5_FLOW_NAMESPACE_FDB)
+		attr->esw_attr->split_count = attr->esw_attr->out_count;
+
+	return 0;
+}
+
+struct mlx5e_tc_act mlx5e_tc_act_vlan_mangle = {
+	.can_offload = tc_act_can_offload_vlan_mangle,
+	.parse_action = tc_act_parse_vlan_mangle,
+};
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en/tc_priv.h b/drivers/net/ethernet/mellanox/mlx5/core/en/tc_priv.h
index b689701ac7d8..5d4f4090e478 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en/tc_priv.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en/tc_priv.h
@@ -176,4 +176,8 @@ struct mlx5_fc *mlx5e_tc_get_counter(struct mlx5e_tc_flow *flow);
 
 struct mlx5e_tc_int_port_priv *
 mlx5e_get_int_port_priv(struct mlx5e_priv *priv);
+
+void *mlx5e_get_match_headers_value(u32 flags, struct mlx5_flow_spec *spec);
+void *mlx5e_get_match_headers_criteria(u32 flags, struct mlx5_flow_spec *spec);
+
 #endif /* __MLX5_EN_TC_PRIV_H__ */
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
