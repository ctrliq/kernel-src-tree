soundwire: intel: add link power management callbacks in hw_ops

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-499.el8
commit-author Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
commit 49c9ff45991a5a62e040c8b43c89a9ab38a0a91f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-499.el8/49c9ff45.failed

No functionality change, only add indirection for link power
management helpers.

	Signed-off-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
	Reviewed-by: Rander Wang <rander.wang@intel.com>
	Signed-off-by: Bard Liao <yung-chuan.liao@linux.intel.com>
Link: https://lore.kernel.org/r/20221111013135.38289-6-yung-chuan.liao@linux.intel.com
	Signed-off-by: Vinod Koul <vkoul@kernel.org>
(cherry picked from commit 49c9ff45991a5a62e040c8b43c89a9ab38a0a91f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/soundwire/intel.c
#	drivers/soundwire/intel.h
#	include/linux/soundwire/sdw_intel.h
diff --cc drivers/soundwire/intel.c
index b9cb7e31ddb3,2320f1b8a2d1..000000000000
--- a/drivers/soundwire/intel.c
+++ b/drivers/soundwire/intel.c
@@@ -1422,6 -1422,42 +1422,45 @@@ static int intel_stop_bus(struct sdw_in
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ const struct sdw_intel_hw_ops sdw_intel_cnl_hw_ops = {
+ 	.debugfs_init = intel_debugfs_init,
+ 	.debugfs_exit = intel_debugfs_exit,
+ 
+ 	.register_dai = intel_register_dai,
+ 
+ 	.check_clock_stop = intel_check_clock_stop,
+ 	.start_bus = intel_start_bus,
+ 	.start_bus_after_reset = intel_start_bus_after_reset,
+ 	.start_bus_after_clock_stop = intel_start_bus_after_clock_stop,
+ 	.stop_bus = intel_stop_bus,
+ 
+ 	.link_power_up = intel_link_power_up,
+ 	.link_power_down = intel_link_power_down,
+ 
+ 	.pre_bank_switch = intel_pre_bank_switch,
+ 	.post_bank_switch = intel_post_bank_switch,
+ };
+ EXPORT_SYMBOL_NS(sdw_intel_cnl_hw_ops, SOUNDWIRE_INTEL);
+ 
+ static int generic_pre_bank_switch(struct sdw_bus *bus)
+ {
+ 	struct sdw_cdns *cdns = bus_to_cdns(bus);
+ 	struct sdw_intel *sdw = cdns_to_intel(cdns);
+ 
+ 	return sdw->link_res->hw_ops->pre_bank_switch(sdw);
+ }
+ 
+ static int generic_post_bank_switch(struct sdw_bus *bus)
+ {
+ 	struct sdw_cdns *cdns = bus_to_cdns(bus);
+ 	struct sdw_intel *sdw = cdns_to_intel(cdns);
+ 
+ 	return sdw->link_res->hw_ops->post_bank_switch(sdw);
+ }
+ 
++>>>>>>> 49c9ff45991a (soundwire: intel: add link power management callbacks in hw_ops)
  static int sdw_master_read_intel_prop(struct sdw_bus *bus)
  {
  	struct sdw_master_prop *prop = &bus->prop;
@@@ -1914,10 -1950,10 +1953,10 @@@ static int __maybe_unused intel_resume(
  	 */
  	sdw_clear_slave_status(bus, SDW_UNATTACH_REQUEST_MASTER_RESET);
  
 -	ret = sdw_intel_start_bus(sdw);
 +	ret = intel_start_bus(sdw);
  	if (ret < 0) {
  		dev_err(dev, "cannot start bus during resume\n");
- 		intel_link_power_down(sdw);
+ 		sdw_intel_link_power_down(sdw);
  		return ret;
  	}
  
@@@ -1968,10 -2004,10 +2007,10 @@@ static int __maybe_unused intel_resume_
  		 */
  		sdw_clear_slave_status(bus, SDW_UNATTACH_REQUEST_MASTER_RESET);
  
 -		ret = sdw_intel_start_bus(sdw);
 +		ret = intel_start_bus(sdw);
  		if (ret < 0) {
  			dev_err(dev, "%s: cannot start bus after teardown: %d\n", __func__, ret);
- 			intel_link_power_down(sdw);
+ 			sdw_intel_link_power_down(sdw);
  			return ret;
  		}
  
@@@ -1983,26 -2019,26 +2022,26 @@@
  			return ret;
  		}
  
 -		ret = sdw_intel_start_bus_after_reset(sdw);
 +		ret = intel_start_bus_after_reset(sdw);
  		if (ret < 0) {
  			dev_err(dev, "%s: cannot start bus after reset: %d\n", __func__, ret);
- 			intel_link_power_down(sdw);
+ 			sdw_intel_link_power_down(sdw);
  			return ret;
  		}
  	} else if (!clock_stop_quirks) {
  
 -		sdw_intel_check_clock_stop(sdw);
 +		intel_check_clock_stop(sdw);
  
- 		ret = intel_link_power_up(sdw);
+ 		ret = sdw_intel_link_power_up(sdw);
  		if (ret) {
  			dev_err(dev, "%s: power_up failed: %d\n", __func__, ret);
  			return ret;
  		}
  
 -		ret = sdw_intel_start_bus_after_clock_stop(sdw);
 +		ret = intel_start_bus_after_clock_stop(sdw);
  		if (ret < 0) {
  			dev_err(dev, "%s: cannot start bus after clock stop: %d\n", __func__, ret);
- 			intel_link_power_down(sdw);
+ 			sdw_intel_link_power_down(sdw);
  			return ret;
  		}
  	} else {
diff --cc drivers/soundwire/intel.h
index cd93a44dba9a,0f63e7584132..000000000000
--- a/drivers/soundwire/intel.h
+++ b/drivers/soundwire/intel.h
@@@ -58,4 -61,75 +58,78 @@@ struct sdw_intel_link_dev 
  #define auxiliary_dev_to_sdw_intel_link_dev(auxiliary_dev) \
  	container_of(auxiliary_dev, struct sdw_intel_link_dev, auxdev)
  
++<<<<<<< HEAD
++=======
+ #define SDW_INTEL_CHECK_OPS(sdw, cb)	((sdw) && (sdw)->link_res && (sdw)->link_res->hw_ops && \
+ 					 (sdw)->link_res->hw_ops->cb)
+ #define SDW_INTEL_OPS(sdw, cb)		((sdw)->link_res->hw_ops->cb)
+ 
+ static inline void sdw_intel_debugfs_init(struct sdw_intel *sdw)
+ {
+ 	if (SDW_INTEL_CHECK_OPS(sdw, debugfs_init))
+ 		SDW_INTEL_OPS(sdw, debugfs_init)(sdw);
+ }
+ 
+ static inline void sdw_intel_debugfs_exit(struct sdw_intel *sdw)
+ {
+ 	if (SDW_INTEL_CHECK_OPS(sdw, debugfs_exit))
+ 		SDW_INTEL_OPS(sdw, debugfs_exit)(sdw);
+ }
+ 
+ static inline int sdw_intel_register_dai(struct sdw_intel *sdw)
+ {
+ 	if (SDW_INTEL_CHECK_OPS(sdw, register_dai))
+ 		return SDW_INTEL_OPS(sdw, register_dai)(sdw);
+ 	return -ENOTSUPP;
+ }
+ 
+ static inline void sdw_intel_check_clock_stop(struct sdw_intel *sdw)
+ {
+ 	if (SDW_INTEL_CHECK_OPS(sdw, check_clock_stop))
+ 		SDW_INTEL_OPS(sdw, check_clock_stop)(sdw);
+ }
+ 
+ static inline int sdw_intel_start_bus(struct sdw_intel *sdw)
+ {
+ 	if (SDW_INTEL_CHECK_OPS(sdw, start_bus))
+ 		return SDW_INTEL_OPS(sdw, start_bus)(sdw);
+ 	return -ENOTSUPP;
+ }
+ 
+ static inline int sdw_intel_start_bus_after_reset(struct sdw_intel *sdw)
+ {
+ 	if (SDW_INTEL_CHECK_OPS(sdw, start_bus_after_reset))
+ 		return SDW_INTEL_OPS(sdw, start_bus_after_reset)(sdw);
+ 	return -ENOTSUPP;
+ }
+ 
+ static inline int sdw_intel_start_bus_after_clock_stop(struct sdw_intel *sdw)
+ {
+ 	if (SDW_INTEL_CHECK_OPS(sdw, start_bus_after_clock_stop))
+ 		return SDW_INTEL_OPS(sdw, start_bus_after_clock_stop)(sdw);
+ 	return -ENOTSUPP;
+ }
+ 
+ static inline int sdw_intel_stop_bus(struct sdw_intel *sdw, bool clock_stop)
+ {
+ 	if (SDW_INTEL_CHECK_OPS(sdw, stop_bus))
+ 		return SDW_INTEL_OPS(sdw, stop_bus)(sdw, clock_stop);
+ 	return -ENOTSUPP;
+ }
+ 
+ static inline int sdw_intel_link_power_up(struct sdw_intel *sdw)
+ {
+ 	if (SDW_INTEL_CHECK_OPS(sdw, link_power_up))
+ 		return SDW_INTEL_OPS(sdw, link_power_up)(sdw);
+ 	return -ENOTSUPP;
+ }
+ 
+ static inline int sdw_intel_link_power_down(struct sdw_intel *sdw)
+ {
+ 	if (SDW_INTEL_CHECK_OPS(sdw, link_power_down))
+ 		return SDW_INTEL_OPS(sdw, link_power_down)(sdw);
+ 	return -ENOTSUPP;
+ }
+ 
++>>>>>>> 49c9ff45991a (soundwire: intel: add link power management callbacks in hw_ops)
  #endif /* __SDW_INTEL_LOCAL_H */
diff --cc include/linux/soundwire/sdw_intel.h
index 2e9fd91572d4,81430201b8b9..000000000000
--- a/include/linux/soundwire/sdw_intel.h
+++ b/include/linux/soundwire/sdw_intel.h
@@@ -292,4 -294,41 +292,44 @@@ irqreturn_t sdw_intel_thread(int irq, v
  
  #define SDW_INTEL_QUIRK_MASK_BUS_DISABLE      BIT(1)
  
++<<<<<<< HEAD
++=======
+ struct sdw_intel;
+ 
+ /* struct intel_sdw_hw_ops - SoundWire ops for Intel platforms.
+  * @debugfs_init: initialize all debugfs capabilities
+  * @debugfs_exit: close and cleanup debugfs capabilities
+  * @register_dai: read all PDI information and register DAIs
+  * @check_clock_stop: throw error message if clock is not stopped.
+  * @start_bus: normal start
+  * @start_bus_after_reset: start after reset
+  * @start_bus_after_clock_stop: start after mode0 clock stop
+  * @stop_bus: stop all bus
+  * @link_power_up: power-up using chip-specific helpers
+  * @link_power_down: power-down with chip-specific helpers
+  * @pre_bank_switch: helper for bus management
+  * @post_bank_switch: helper for bus management
+  */
+ struct sdw_intel_hw_ops {
+ 	void (*debugfs_init)(struct sdw_intel *sdw);
+ 	void (*debugfs_exit)(struct sdw_intel *sdw);
+ 
+ 	int (*register_dai)(struct sdw_intel *sdw);
+ 
+ 	void (*check_clock_stop)(struct sdw_intel *sdw);
+ 	int (*start_bus)(struct sdw_intel *sdw);
+ 	int (*start_bus_after_reset)(struct sdw_intel *sdw);
+ 	int (*start_bus_after_clock_stop)(struct sdw_intel *sdw);
+ 	int (*stop_bus)(struct sdw_intel *sdw, bool clock_stop);
+ 
+ 	int (*link_power_up)(struct sdw_intel *sdw);
+ 	int (*link_power_down)(struct sdw_intel *sdw);
+ 
+ 	int (*pre_bank_switch)(struct sdw_intel *sdw);
+ 	int (*post_bank_switch)(struct sdw_intel *sdw);
+ };
+ 
+ extern const struct sdw_intel_hw_ops sdw_intel_cnl_hw_ops;
+ 
++>>>>>>> 49c9ff45991a (soundwire: intel: add link power management callbacks in hw_ops)
  #endif
* Unmerged path drivers/soundwire/intel.c
* Unmerged path drivers/soundwire/intel.h
* Unmerged path include/linux/soundwire/sdw_intel.h
