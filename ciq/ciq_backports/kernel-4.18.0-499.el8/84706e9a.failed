soundwire: intel: add sync_arm/sync_go to ops

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-499.el8
commit-author Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
commit 84706e9a75ffc3c950424bdfea06cabb4101a6b4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-499.el8/84706e9a.failed

The bus start/stop sequences can be reused between platforms if we add
a couple of new callbacks. In following patches the code will be moved to
a shared file.

	Signed-off-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
	Reviewed-by: Rander Wang <rander.wang@intel.com>
	Signed-off-by: Bard Liao <yung-chuan.liao@linux.intel.com>
Link: https://lore.kernel.org/r/20230314015410.487311-7-yung-chuan.liao@linux.intel.com
	Signed-off-by: Vinod Koul <vkoul@kernel.org>
(cherry picked from commit 84706e9a75ffc3c950424bdfea06cabb4101a6b4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/soundwire/intel.c
#	include/linux/soundwire/sdw_intel.h
diff --cc drivers/soundwire/intel.c
index 0708857504dc,902934cbb27b..000000000000
--- a/drivers/soundwire/intel.c
+++ b/drivers/soundwire/intel.c
@@@ -1378,620 -1322,30 +1378,627 @@@ static int intel_stop_bus(struct sdw_in
  	return 0;
  }
  
 -const struct sdw_intel_hw_ops sdw_intel_cnl_hw_ops = {
 -	.debugfs_init = intel_debugfs_init,
 -	.debugfs_exit = intel_debugfs_exit,
 +static int sdw_master_read_intel_prop(struct sdw_bus *bus)
 +{
 +	struct sdw_master_prop *prop = &bus->prop;
 +	struct fwnode_handle *link;
 +	char name[32];
 +	u32 quirk_mask;
  
 -	.register_dai = intel_register_dai,
 +	/* Find master handle */
 +	snprintf(name, sizeof(name),
 +		 "mipi-sdw-link-%d-subproperties", bus->link_id);
  
 -	.check_clock_stop = intel_check_clock_stop,
 -	.start_bus = intel_start_bus,
 -	.start_bus_after_reset = intel_start_bus_after_reset,
 -	.start_bus_after_clock_stop = intel_start_bus_after_clock_stop,
 -	.stop_bus = intel_stop_bus,
 +	link = device_get_named_child_node(bus->dev, name);
 +	if (!link) {
 +		dev_err(bus->dev, "Master node %s not found\n", name);
 +		return -EIO;
 +	}
  
 -	.link_power_up = intel_link_power_up,
 -	.link_power_down = intel_link_power_down,
 +	fwnode_property_read_u32(link,
 +				 "intel-sdw-ip-clock",
 +				 &prop->mclk_freq);
  
 -	.shim_check_wake = intel_shim_check_wake,
 -	.shim_wake = intel_shim_wake,
 +	/* the values reported by BIOS are the 2x clock, not the bus clock */
 +	prop->mclk_freq /= 2;
  
 +	fwnode_property_read_u32(link,
 +				 "intel-quirk-mask",
 +				 &quirk_mask);
 +
 +	if (quirk_mask & SDW_INTEL_QUIRK_MASK_BUS_DISABLE)
 +		prop->hw_disabled = true;
 +
 +	prop->quirks = SDW_MASTER_QUIRKS_CLEAR_INITIAL_CLASH |
 +		SDW_MASTER_QUIRKS_CLEAR_INITIAL_PARITY;
 +
 +	return 0;
 +}
 +
 +static int intel_prop_read(struct sdw_bus *bus)
 +{
 +	/* Initialize with default handler to read all DisCo properties */
 +	sdw_master_read_prop(bus);
 +
 +	/* read Intel-specific properties */
 +	sdw_master_read_intel_prop(bus);
 +
 +	return 0;
 +}
 +
 +static struct sdw_master_ops sdw_intel_ops = {
 +	.read_prop = intel_prop_read,
 +	.override_adr = sdw_dmi_override_adr,
 +	.xfer_msg = cdns_xfer_msg,
 +	.xfer_msg_defer = cdns_xfer_msg_defer,
 +	.reset_page_addr = cdns_reset_page_addr,
 +	.set_bus_conf = cdns_bus_conf,
  	.pre_bank_switch = intel_pre_bank_switch,
  	.post_bank_switch = intel_post_bank_switch,
++<<<<<<< HEAD
 +	.read_ping_status = cdns_read_ping_status,
++=======
+ 
+ 	.sync_arm = intel_shim_sync_arm,
+ 	.sync_go_unlocked = intel_shim_sync_go_unlocked,
+ 	.sync_go = intel_shim_sync_go,
++>>>>>>> 84706e9a75ff (soundwire: intel: add sync_arm/sync_go to ops)
 +};
 +
 +/*
 + * probe and init (aux_dev_id argument is required by function prototype but not used)
 + */
 +static int intel_link_probe(struct auxiliary_device *auxdev,
 +			    const struct auxiliary_device_id *aux_dev_id)
 +
 +{
 +	struct device *dev = &auxdev->dev;
 +	struct sdw_intel_link_dev *ldev = auxiliary_dev_to_sdw_intel_link_dev(auxdev);
 +	struct sdw_intel *sdw;
 +	struct sdw_cdns *cdns;
 +	struct sdw_bus *bus;
 +	int ret;
 +
 +	sdw = devm_kzalloc(dev, sizeof(*sdw), GFP_KERNEL);
 +	if (!sdw)
 +		return -ENOMEM;
 +
 +	cdns = &sdw->cdns;
 +	bus = &cdns->bus;
 +
 +	sdw->instance = auxdev->id;
 +	sdw->link_res = &ldev->link_res;
 +	cdns->dev = dev;
 +	cdns->registers = sdw->link_res->registers;
 +	cdns->instance = sdw->instance;
 +	cdns->msg_count = 0;
 +
 +	bus->link_id = auxdev->id;
 +	bus->dev_num_ida_min = INTEL_DEV_NUM_IDA_MIN;
 +	bus->clk_stop_timeout = 1;
 +
 +	sdw_cdns_probe(cdns);
 +
 +	/* Set ops */
 +	bus->ops = &sdw_intel_ops;
 +
 +	/* set driver data, accessed by snd_soc_dai_get_drvdata() */
 +	auxiliary_set_drvdata(auxdev, cdns);
 +
 +	/* use generic bandwidth allocation algorithm */
 +	sdw->cdns.bus.compute_params = sdw_compute_params;
 +
 +	/* avoid resuming from pm_runtime suspend if it's not required */
 +	dev_pm_set_driver_flags(dev, DPM_FLAG_SMART_SUSPEND);
 +
 +	ret = sdw_bus_master_add(bus, dev, dev->fwnode);
 +	if (ret) {
 +		dev_err(dev, "sdw_bus_master_add fail: %d\n", ret);
 +		return ret;
 +	}
 +
 +	if (bus->prop.hw_disabled)
 +		dev_info(dev,
 +			 "SoundWire master %d is disabled, will be ignored\n",
 +			 bus->link_id);
 +	/*
 +	 * Ignore BIOS err_threshold, it's a really bad idea when dealing
 +	 * with multiple hardware synchronized links
 +	 */
 +	bus->prop.err_threshold = 0;
 +
 +	return 0;
 +}
 +
 +int intel_link_startup(struct auxiliary_device *auxdev)
 +{
 +	struct device *dev = &auxdev->dev;
 +	struct sdw_cdns *cdns = auxiliary_get_drvdata(auxdev);
 +	struct sdw_intel *sdw = cdns_to_intel(cdns);
 +	struct sdw_bus *bus = &cdns->bus;
 +	int link_flags;
 +	bool multi_link;
 +	u32 clock_stop_quirks;
 +	int ret;
 +
 +	if (bus->prop.hw_disabled) {
 +		dev_info(dev,
 +			 "SoundWire master %d is disabled, ignoring\n",
 +			 sdw->instance);
 +		return 0;
 +	}
 +
 +	link_flags = md_flags >> (bus->link_id * 8);
 +	multi_link = !(link_flags & SDW_INTEL_MASTER_DISABLE_MULTI_LINK);
 +	if (!multi_link) {
 +		dev_dbg(dev, "Multi-link is disabled\n");
 +	} else {
 +		/*
 +		 * hardware-based synchronization is required regardless
 +		 * of the number of segments used by a stream: SSP-based
 +		 * synchronization is gated by gsync when the multi-master
 +		 * mode is set.
 +		 */
 +		bus->hw_sync_min_links = 1;
 +	}
 +	bus->multi_link = multi_link;
 +
 +	/* Initialize shim, controller */
 +	ret = intel_link_power_up(sdw);
 +	if (ret)
 +		goto err_init;
 +
 +	/* Register DAIs */
 +	ret = intel_register_dai(sdw);
 +	if (ret) {
 +		dev_err(dev, "DAI registration failed: %d\n", ret);
 +		goto err_power_up;
 +	}
 +
 +	intel_debugfs_init(sdw);
 +
 +	/* start bus */
 +	ret = intel_start_bus(sdw);
 +	if (ret) {
 +		dev_err(dev, "bus start failed: %d\n", ret);
 +		goto err_power_up;
 +	}
 +
 +	/* Enable runtime PM */
 +	if (!(link_flags & SDW_INTEL_MASTER_DISABLE_PM_RUNTIME)) {
 +		pm_runtime_set_autosuspend_delay(dev,
 +						 INTEL_MASTER_SUSPEND_DELAY_MS);
 +		pm_runtime_use_autosuspend(dev);
 +		pm_runtime_mark_last_busy(dev);
 +
 +		pm_runtime_set_active(dev);
 +		pm_runtime_enable(dev);
 +	}
 +
 +	clock_stop_quirks = sdw->link_res->clock_stop_quirks;
 +	if (clock_stop_quirks & SDW_INTEL_CLK_STOP_NOT_ALLOWED) {
 +		/*
 +		 * To keep the clock running we need to prevent
 +		 * pm_runtime suspend from happening by increasing the
 +		 * reference count.
 +		 * This quirk is specified by the parent PCI device in
 +		 * case of specific latency requirements. It will have
 +		 * no effect if pm_runtime is disabled by the user via
 +		 * a module parameter for testing purposes.
 +		 */
 +		pm_runtime_get_noresume(dev);
 +	}
 +
 +	/*
 +	 * The runtime PM status of Slave devices is "Unsupported"
 +	 * until they report as ATTACHED. If they don't, e.g. because
 +	 * there are no Slave devices populated or if the power-on is
 +	 * delayed or dependent on a power switch, the Master will
 +	 * remain active and prevent its parent from suspending.
 +	 *
 +	 * Conditionally force the pm_runtime core to re-evaluate the
 +	 * Master status in the absence of any Slave activity. A quirk
 +	 * is provided to e.g. deal with Slaves that may be powered on
 +	 * with a delay. A more complete solution would require the
 +	 * definition of Master properties.
 +	 */
 +	if (!(link_flags & SDW_INTEL_MASTER_DISABLE_PM_RUNTIME_IDLE))
 +		pm_runtime_idle(dev);
 +
 +	sdw->startup_done = true;
 +	return 0;
 +
 +err_power_up:
 +	intel_link_power_down(sdw);
 +err_init:
 +	return ret;
 +}
 +
 +static void intel_link_remove(struct auxiliary_device *auxdev)
 +{
 +	struct sdw_cdns *cdns = auxiliary_get_drvdata(auxdev);
 +	struct sdw_intel *sdw = cdns_to_intel(cdns);
 +	struct sdw_bus *bus = &cdns->bus;
 +
 +	/*
 +	 * Since pm_runtime is already disabled, we don't decrease
 +	 * the refcount when the clock_stop_quirk is
 +	 * SDW_INTEL_CLK_STOP_NOT_ALLOWED
 +	 */
 +	if (!bus->prop.hw_disabled) {
 +		intel_debugfs_exit(sdw);
 +		sdw_cdns_enable_interrupt(cdns, false);
 +	}
 +	sdw_bus_master_delete(bus);
 +}
 +
 +int intel_link_process_wakeen_event(struct auxiliary_device *auxdev)
 +{
 +	struct device *dev = &auxdev->dev;
 +	struct sdw_intel *sdw;
 +	struct sdw_bus *bus;
 +
 +	sdw = auxiliary_get_drvdata(auxdev);
 +	bus = &sdw->cdns.bus;
 +
 +	if (bus->prop.hw_disabled || !sdw->startup_done) {
 +		dev_dbg(dev, "SoundWire master %d is disabled or not-started, ignoring\n",
 +			bus->link_id);
 +		return 0;
 +	}
 +
 +	if (!intel_shim_check_wake(sdw))
 +		return 0;
 +
 +	/* disable WAKEEN interrupt ASAP to prevent interrupt flood */
 +	intel_shim_wake(sdw, false);
 +
 +	/*
 +	 * resume the Master, which will generate a bus reset and result in
 +	 * Slaves re-attaching and be re-enumerated. The SoundWire physical
 +	 * device which generated the wake will trigger an interrupt, which
 +	 * will in turn cause the corresponding Linux Slave device to be
 +	 * resumed and the Slave codec driver to check the status.
 +	 */
 +	pm_request_resume(dev);
 +
 +	return 0;
 +}
 +
 +/*
 + * PM calls
 + */
 +
 +static int intel_resume_child_device(struct device *dev, void *data)
 +{
 +	int ret;
 +	struct sdw_slave *slave = dev_to_sdw_dev(dev);
 +
 +	if (!slave->probed) {
 +		dev_dbg(dev, "skipping device, no probed driver\n");
 +		return 0;
 +	}
 +	if (!slave->dev_num_sticky) {
 +		dev_dbg(dev, "skipping device, never detected on bus\n");
 +		return 0;
 +	}
 +
 +	ret = pm_request_resume(dev);
 +	if (ret < 0)
 +		dev_err(dev, "%s: pm_request_resume failed: %d\n", __func__, ret);
 +
 +	return ret;
 +}
 +
 +static int __maybe_unused intel_pm_prepare(struct device *dev)
 +{
 +	struct sdw_cdns *cdns = dev_get_drvdata(dev);
 +	struct sdw_intel *sdw = cdns_to_intel(cdns);
 +	struct sdw_bus *bus = &cdns->bus;
 +	u32 clock_stop_quirks;
 +	int ret;
 +
 +	if (bus->prop.hw_disabled || !sdw->startup_done) {
 +		dev_dbg(dev, "SoundWire master %d is disabled or not-started, ignoring\n",
 +			bus->link_id);
 +		return 0;
 +	}
 +
 +	clock_stop_quirks = sdw->link_res->clock_stop_quirks;
 +
 +	if (pm_runtime_suspended(dev) &&
 +	    pm_runtime_suspended(dev->parent) &&
 +	    ((clock_stop_quirks & SDW_INTEL_CLK_STOP_BUS_RESET) ||
 +	     !clock_stop_quirks)) {
 +		/*
 +		 * if we've enabled clock stop, and the parent is suspended, the SHIM registers
 +		 * are not accessible and the shim wake cannot be disabled.
 +		 * The only solution is to resume the entire bus to full power
 +		 */
 +
 +		/*
 +		 * If any operation in this block fails, we keep going since we don't want
 +		 * to prevent system suspend from happening and errors should be recoverable
 +		 * on resume.
 +		 */
 +
 +		/*
 +		 * first resume the device for this link. This will also by construction
 +		 * resume the PCI parent device.
 +		 */
 +		ret = pm_request_resume(dev);
 +		if (ret < 0) {
 +			dev_err(dev, "%s: pm_request_resume failed: %d\n", __func__, ret);
 +			return 0;
 +		}
 +
 +		/*
 +		 * Continue resuming the entire bus (parent + child devices) to exit
 +		 * the clock stop mode. If there are no devices connected on this link
 +		 * this is a no-op.
 +		 * The resume to full power could have been implemented with a .prepare
 +		 * step in SoundWire codec drivers. This would however require a lot
 +		 * of code to handle an Intel-specific corner case. It is simpler in
 +		 * practice to add a loop at the link level.
 +		 */
 +		ret = device_for_each_child(bus->dev, NULL, intel_resume_child_device);
 +
 +		if (ret < 0)
 +			dev_err(dev, "%s: intel_resume_child_device failed: %d\n", __func__, ret);
 +	}
 +
 +	return 0;
 +}
 +
 +static int __maybe_unused intel_suspend(struct device *dev)
 +{
 +	struct sdw_cdns *cdns = dev_get_drvdata(dev);
 +	struct sdw_intel *sdw = cdns_to_intel(cdns);
 +	struct sdw_bus *bus = &cdns->bus;
 +	u32 clock_stop_quirks;
 +	int ret;
 +
 +	if (bus->prop.hw_disabled || !sdw->startup_done) {
 +		dev_dbg(dev, "SoundWire master %d is disabled or not-started, ignoring\n",
 +			bus->link_id);
 +		return 0;
 +	}
 +
 +	if (pm_runtime_suspended(dev)) {
 +		dev_dbg(dev, "pm_runtime status: suspended\n");
 +
 +		clock_stop_quirks = sdw->link_res->clock_stop_quirks;
 +
 +		if ((clock_stop_quirks & SDW_INTEL_CLK_STOP_BUS_RESET) ||
 +		    !clock_stop_quirks) {
 +
 +			if (pm_runtime_suspended(dev->parent)) {
 +				/*
 +				 * paranoia check: this should not happen with the .prepare
 +				 * resume to full power
 +				 */
 +				dev_err(dev, "%s: invalid config: parent is suspended\n", __func__);
 +			} else {
 +				intel_shim_wake(sdw, false);
 +			}
 +		}
 +
 +		return 0;
 +	}
 +
 +	ret = intel_stop_bus(sdw, false);
 +	if (ret < 0) {
 +		dev_err(dev, "%s: cannot stop bus: %d\n", __func__, ret);
 +		return ret;
 +	}
 +
 +	return 0;
 +}
 +
 +static int __maybe_unused intel_suspend_runtime(struct device *dev)
 +{
 +	struct sdw_cdns *cdns = dev_get_drvdata(dev);
 +	struct sdw_intel *sdw = cdns_to_intel(cdns);
 +	struct sdw_bus *bus = &cdns->bus;
 +	u32 clock_stop_quirks;
 +	int ret;
 +
 +	if (bus->prop.hw_disabled || !sdw->startup_done) {
 +		dev_dbg(dev, "SoundWire master %d is disabled or not-started, ignoring\n",
 +			bus->link_id);
 +		return 0;
 +	}
 +
 +	clock_stop_quirks = sdw->link_res->clock_stop_quirks;
 +
 +	if (clock_stop_quirks & SDW_INTEL_CLK_STOP_TEARDOWN) {
 +		ret = intel_stop_bus(sdw, false);
 +		if (ret < 0) {
 +			dev_err(dev, "%s: cannot stop bus during teardown: %d\n",
 +				__func__, ret);
 +			return ret;
 +		}
 +	} else if (clock_stop_quirks & SDW_INTEL_CLK_STOP_BUS_RESET || !clock_stop_quirks) {
 +		ret = intel_stop_bus(sdw, true);
 +		if (ret < 0) {
 +			dev_err(dev, "%s: cannot stop bus during clock_stop: %d\n",
 +				__func__, ret);
 +			return ret;
 +		}
 +	} else {
 +		dev_err(dev, "%s clock_stop_quirks %x unsupported\n",
 +			__func__, clock_stop_quirks);
 +		ret = -EINVAL;
 +	}
 +
 +	return ret;
 +}
 +
 +static int __maybe_unused intel_resume(struct device *dev)
 +{
 +	struct sdw_cdns *cdns = dev_get_drvdata(dev);
 +	struct sdw_intel *sdw = cdns_to_intel(cdns);
 +	struct sdw_bus *bus = &cdns->bus;
 +	int link_flags;
 +	int ret;
 +
 +	if (bus->prop.hw_disabled || !sdw->startup_done) {
 +		dev_dbg(dev, "SoundWire master %d is disabled or not-started, ignoring\n",
 +			bus->link_id);
 +		return 0;
 +	}
 +
 +	link_flags = md_flags >> (bus->link_id * 8);
 +
 +	if (pm_runtime_suspended(dev)) {
 +		dev_dbg(dev, "pm_runtime status was suspended, forcing active\n");
 +
 +		/* follow required sequence from runtime_pm.rst */
 +		pm_runtime_disable(dev);
 +		pm_runtime_set_active(dev);
 +		pm_runtime_mark_last_busy(dev);
 +		pm_runtime_enable(dev);
 +
 +		link_flags = md_flags >> (bus->link_id * 8);
 +
 +		if (!(link_flags & SDW_INTEL_MASTER_DISABLE_PM_RUNTIME_IDLE))
 +			pm_runtime_idle(dev);
 +	}
 +
 +	ret = intel_link_power_up(sdw);
 +	if (ret) {
 +		dev_err(dev, "%s failed: %d\n", __func__, ret);
 +		return ret;
 +	}
 +
 +	/*
 +	 * make sure all Slaves are tagged as UNATTACHED and provide
 +	 * reason for reinitialization
 +	 */
 +	sdw_clear_slave_status(bus, SDW_UNATTACH_REQUEST_MASTER_RESET);
 +
 +	ret = intel_start_bus(sdw);
 +	if (ret < 0) {
 +		dev_err(dev, "cannot start bus during resume\n");
 +		intel_link_power_down(sdw);
 +		return ret;
 +	}
 +
 +	/*
 +	 * after system resume, the pm_runtime suspend() may kick in
 +	 * during the enumeration, before any children device force the
 +	 * master device to remain active.  Using pm_runtime_get()
 +	 * routines is not really possible, since it'd prevent the
 +	 * master from suspending.
 +	 * A reasonable compromise is to update the pm_runtime
 +	 * counters and delay the pm_runtime suspend by several
 +	 * seconds, by when all enumeration should be complete.
 +	 */
 +	pm_runtime_mark_last_busy(dev);
 +
 +	return 0;
 +}
 +
 +static int __maybe_unused intel_resume_runtime(struct device *dev)
 +{
 +	struct sdw_cdns *cdns = dev_get_drvdata(dev);
 +	struct sdw_intel *sdw = cdns_to_intel(cdns);
 +	struct sdw_bus *bus = &cdns->bus;
 +	u32 clock_stop_quirks;
 +	int ret;
 +
 +	if (bus->prop.hw_disabled || !sdw->startup_done) {
 +		dev_dbg(dev, "SoundWire master %d is disabled or not-started, ignoring\n",
 +			bus->link_id);
 +		return 0;
 +	}
 +
 +	/* unconditionally disable WAKEEN interrupt */
 +	intel_shim_wake(sdw, false);
 +
 +	clock_stop_quirks = sdw->link_res->clock_stop_quirks;
 +
 +	if (clock_stop_quirks & SDW_INTEL_CLK_STOP_TEARDOWN) {
 +		ret = intel_link_power_up(sdw);
 +		if (ret) {
 +			dev_err(dev, "%s: power_up failed after teardown: %d\n", __func__, ret);
 +			return ret;
 +		}
 +
 +		/*
 +		 * make sure all Slaves are tagged as UNATTACHED and provide
 +		 * reason for reinitialization
 +		 */
 +		sdw_clear_slave_status(bus, SDW_UNATTACH_REQUEST_MASTER_RESET);
 +
 +		ret = intel_start_bus(sdw);
 +		if (ret < 0) {
 +			dev_err(dev, "%s: cannot start bus after teardown: %d\n", __func__, ret);
 +			intel_link_power_down(sdw);
 +			return ret;
 +		}
 +
 +
 +	} else if (clock_stop_quirks & SDW_INTEL_CLK_STOP_BUS_RESET) {
 +		ret = intel_link_power_up(sdw);
 +		if (ret) {
 +			dev_err(dev, "%s: power_up failed after bus reset: %d\n", __func__, ret);
 +			return ret;
 +		}
 +
 +		ret = intel_start_bus_after_reset(sdw);
 +		if (ret < 0) {
 +			dev_err(dev, "%s: cannot start bus after reset: %d\n", __func__, ret);
 +			intel_link_power_down(sdw);
 +			return ret;
 +		}
 +	} else if (!clock_stop_quirks) {
 +
 +		intel_check_clock_stop(sdw);
 +
 +		ret = intel_link_power_up(sdw);
 +		if (ret) {
 +			dev_err(dev, "%s: power_up failed: %d\n", __func__, ret);
 +			return ret;
 +		}
 +
 +		ret = intel_start_bus_after_clock_stop(sdw);
 +		if (ret < 0) {
 +			dev_err(dev, "%s: cannot start bus after clock stop: %d\n", __func__, ret);
 +			intel_link_power_down(sdw);
 +			return ret;
 +		}
 +	} else {
 +		dev_err(dev, "%s: clock_stop_quirks %x unsupported\n",
 +			__func__, clock_stop_quirks);
 +		ret = -EINVAL;
 +	}
 +
 +	return ret;
 +}
 +
 +static const struct dev_pm_ops intel_pm = {
 +	.prepare = intel_pm_prepare,
 +	SET_SYSTEM_SLEEP_PM_OPS(intel_suspend, intel_resume)
 +	SET_RUNTIME_PM_OPS(intel_suspend_runtime, intel_resume_runtime, NULL)
 +};
 +
 +static const struct auxiliary_device_id intel_link_id_table[] = {
 +	{ .name = "soundwire_intel.link" },
 +	{},
 +};
 +MODULE_DEVICE_TABLE(auxiliary, intel_link_id_table);
 +
 +static struct auxiliary_driver sdw_intel_drv = {
 +	.probe = intel_link_probe,
 +	.remove = intel_link_remove,
 +	.driver = {
 +		/* auxiliary_driver_register() sets .name to be the modname */
 +		.pm = &intel_pm,
 +	},
 +	.id_table = intel_link_id_table
  };
 -EXPORT_SYMBOL_NS(sdw_intel_cnl_hw_ops, SOUNDWIRE_INTEL);
 +module_auxiliary_driver(sdw_intel_drv);
  
 +MODULE_LICENSE("Dual BSD/GPL");
 +MODULE_DESCRIPTION("Intel Soundwire Link Driver");
diff --cc include/linux/soundwire/sdw_intel.h
index 2e9fd91572d4,06fa30929ebd..000000000000
--- a/include/linux/soundwire/sdw_intel.h
+++ b/include/linux/soundwire/sdw_intel.h
@@@ -292,4 -292,54 +292,57 @@@ irqreturn_t sdw_intel_thread(int irq, v
  
  #define SDW_INTEL_QUIRK_MASK_BUS_DISABLE      BIT(1)
  
++<<<<<<< HEAD
++=======
+ struct sdw_intel;
+ 
+ /* struct intel_sdw_hw_ops - SoundWire ops for Intel platforms.
+  * @debugfs_init: initialize all debugfs capabilities
+  * @debugfs_exit: close and cleanup debugfs capabilities
+  * @register_dai: read all PDI information and register DAIs
+  * @check_clock_stop: throw error message if clock is not stopped.
+  * @start_bus: normal start
+  * @start_bus_after_reset: start after reset
+  * @start_bus_after_clock_stop: start after mode0 clock stop
+  * @stop_bus: stop all bus
+  * @link_power_up: power-up using chip-specific helpers
+  * @link_power_down: power-down with chip-specific helpers
+  * @shim_check_wake: check if a wake was received
+  * @shim_wake: enable/disable in-band wake management
+  * @pre_bank_switch: helper for bus management
+  * @post_bank_switch: helper for bus management
+  * @sync_arm: helper for multi-link synchronization
+  * @sync_go_unlocked: helper for multi-link synchronization -
+  * shim_lock is assumed to be locked at higher level
+  * @sync_go: helper for multi-link synchronization
+  */
+ struct sdw_intel_hw_ops {
+ 	void (*debugfs_init)(struct sdw_intel *sdw);
+ 	void (*debugfs_exit)(struct sdw_intel *sdw);
+ 
+ 	int (*register_dai)(struct sdw_intel *sdw);
+ 
+ 	void (*check_clock_stop)(struct sdw_intel *sdw);
+ 	int (*start_bus)(struct sdw_intel *sdw);
+ 	int (*start_bus_after_reset)(struct sdw_intel *sdw);
+ 	int (*start_bus_after_clock_stop)(struct sdw_intel *sdw);
+ 	int (*stop_bus)(struct sdw_intel *sdw, bool clock_stop);
+ 
+ 	int (*link_power_up)(struct sdw_intel *sdw);
+ 	int (*link_power_down)(struct sdw_intel *sdw);
+ 
+ 	int  (*shim_check_wake)(struct sdw_intel *sdw);
+ 	void (*shim_wake)(struct sdw_intel *sdw, bool wake_enable);
+ 
+ 	int (*pre_bank_switch)(struct sdw_intel *sdw);
+ 	int (*post_bank_switch)(struct sdw_intel *sdw);
+ 
+ 	void (*sync_arm)(struct sdw_intel *sdw);
+ 	int (*sync_go_unlocked)(struct sdw_intel *sdw);
+ 	int (*sync_go)(struct sdw_intel *sdw);
+ };
+ 
+ extern const struct sdw_intel_hw_ops sdw_intel_cnl_hw_ops;
+ 
++>>>>>>> 84706e9a75ff (soundwire: intel: add sync_arm/sync_go to ops)
  #endif
* Unmerged path drivers/soundwire/intel.c
diff --git a/drivers/soundwire/intel.h b/drivers/soundwire/intel.h
index cd93a44dba9a..1d8a31eba138 100644
--- a/drivers/soundwire/intel.h
+++ b/drivers/soundwire/intel.h
@@ -58,4 +58,24 @@ struct sdw_intel_link_dev {
 #define auxiliary_dev_to_sdw_intel_link_dev(auxiliary_dev) \
 	container_of(auxiliary_dev, struct sdw_intel_link_dev, auxdev)
 
+static inline void sdw_intel_sync_arm(struct sdw_intel *sdw)
+{
+	if (SDW_INTEL_CHECK_OPS(sdw, sync_arm))
+		SDW_INTEL_OPS(sdw, sync_arm)(sdw);
+}
+
+static inline int sdw_intel_sync_go_unlocked(struct sdw_intel *sdw)
+{
+	if (SDW_INTEL_CHECK_OPS(sdw, sync_go_unlocked))
+		return SDW_INTEL_OPS(sdw, sync_go_unlocked)(sdw);
+	return -ENOTSUPP;
+}
+
+static inline int sdw_intel_sync_go(struct sdw_intel *sdw)
+{
+	if (SDW_INTEL_CHECK_OPS(sdw, sync_go))
+		return SDW_INTEL_OPS(sdw, sync_go)(sdw);
+	return -ENOTSUPP;
+}
+
 #endif /* __SDW_INTEL_LOCAL_H */
* Unmerged path include/linux/soundwire/sdw_intel.h
