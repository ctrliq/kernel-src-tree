ipv6: icmp6: add drop reason support to ndisc_rcv()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-499.el8
commit-author Eric Dumazet <edumazet@google.com>
commit 545dbcd124b02c9dc93c8a5894c71d682effc3e6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-499.el8/545dbcd1.failed

Creates three new drop reasons:

SKB_DROP_REASON_IPV6_NDISC_FRAG: invalid frag (suppress_frag_ndisc).

SKB_DROP_REASON_IPV6_NDISC_HOP_LIMIT: invalid hop limit.

SKB_DROP_REASON_IPV6_NDISC_BAD_CODE: invalid NDISC icmp6 code.

	Signed-off-by: Eric Dumazet <edumazet@google.com>
	Reviewed-by: David Ahern <dsahern@kernel.org>
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit 545dbcd124b02c9dc93c8a5894c71d682effc3e6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/dropreason.h
diff --cc include/net/dropreason.h
index 70539288f995,ef3f65d135d3..000000000000
--- a/include/net/dropreason.h
+++ b/include/net/dropreason.h
@@@ -71,6 -71,11 +71,14 @@@
  	FN(DUP_FRAG)			\
  	FN(FRAG_REASM_TIMEOUT)		\
  	FN(FRAG_TOO_FAR)		\
++<<<<<<< HEAD
++=======
+ 	FN(TCP_MINTTL)			\
+ 	FN(IPV6_BAD_EXTHDR)		\
+ 	FN(IPV6_NDISC_FRAG)		\
+ 	FN(IPV6_NDISC_HOP_LIMIT)	\
+ 	FN(IPV6_NDISC_BAD_CODE)		\
++>>>>>>> 545dbcd124b0 (ipv6: icmp6: add drop reason support to ndisc_rcv())
  	FNe(MAX)
  
  /**
@@@ -313,6 -318,19 +321,22 @@@ enum skb_drop_reason 
  	 */
  	SKB_DROP_REASON_FRAG_TOO_FAR,
  	/**
++<<<<<<< HEAD
++=======
+ 	 * @SKB_DROP_REASON_TCP_MINTTL: ipv4 ttl or ipv6 hoplimit below
+ 	 * the threshold (IP_MINTTL or IPV6_MINHOPCOUNT).
+ 	 */
+ 	SKB_DROP_REASON_TCP_MINTTL,
+ 	/** @SKB_DROP_REASON_IPV6_BAD_EXTHDR: Bad IPv6 extension header. */
+ 	SKB_DROP_REASON_IPV6_BAD_EXTHDR,
+ 	/** @SKB_DROP_REASON_IPV6_NDISC_FRAG: invalid frag (suppress_frag_ndisc). */
+ 	SKB_DROP_REASON_IPV6_NDISC_FRAG,
+ 	/** @SKB_DROP_REASON_IPV6_NDISC_HOP_LIMIT: invalid hop limit. */
+ 	SKB_DROP_REASON_IPV6_NDISC_HOP_LIMIT,
+ 	/** @SKB_DROP_REASON_IPV6_NDISC_BAD_CODE: invalid NDISC icmp6 code. */
+ 	SKB_DROP_REASON_IPV6_NDISC_BAD_CODE,
+ 	/**
++>>>>>>> 545dbcd124b0 (ipv6: icmp6: add drop reason support to ndisc_rcv())
  	 * @SKB_DROP_REASON_MAX: the maximum of drop reason, which shouldn't be
  	 * used as a real 'reason'
  	 */
* Unmerged path include/net/dropreason.h
diff --git a/include/net/ndisc.h b/include/net/ndisc.h
index b2f715ca0567..418103032602 100644
--- a/include/net/ndisc.h
+++ b/include/net/ndisc.h
@@ -456,7 +456,7 @@ int ndisc_late_init(void);
 void ndisc_late_cleanup(void);
 void ndisc_cleanup(void);
 
-int ndisc_rcv(struct sk_buff *skb);
+enum skb_drop_reason ndisc_rcv(struct sk_buff *skb);
 
 void ndisc_send_ns(struct net_device *dev, const struct in6_addr *solicit,
 		   const struct in6_addr *daddr, const struct in6_addr *saddr,
diff --git a/net/ipv6/icmp.c b/net/ipv6/icmp.c
index 58b7804d918a..005d0480cc80 100644
--- a/net/ipv6/icmp.c
+++ b/net/ipv6/icmp.c
@@ -887,7 +887,7 @@ static int icmpv6_rcv(struct sk_buff *skb)
 	case NDISC_NEIGHBOUR_SOLICITATION:
 	case NDISC_NEIGHBOUR_ADVERTISEMENT:
 	case NDISC_REDIRECT:
-		ndisc_rcv(skb);
+		reason = ndisc_rcv(skb);
 		break;
 
 	case ICMPV6_MGM_QUERY:
diff --git a/net/ipv6/ndisc.c b/net/ipv6/ndisc.c
index 2e7413496065..47750671bc04 100644
--- a/net/ipv6/ndisc.c
+++ b/net/ipv6/ndisc.c
@@ -1714,15 +1714,16 @@ static bool ndisc_suppress_frag_ndisc(struct sk_buff *skb)
 	return false;
 }
 
-int ndisc_rcv(struct sk_buff *skb)
+enum skb_drop_reason ndisc_rcv(struct sk_buff *skb)
 {
 	struct nd_msg *msg;
+	SKB_DR(reason);
 
 	if (ndisc_suppress_frag_ndisc(skb))
-		return 0;
+		return SKB_DROP_REASON_IPV6_NDISC_FRAG;
 
 	if (skb_linearize(skb))
-		return 0;
+		return SKB_DROP_REASON_NOMEM;
 
 	msg = (struct nd_msg *)skb_transport_header(skb);
 
@@ -1731,13 +1732,13 @@ int ndisc_rcv(struct sk_buff *skb)
 	if (ipv6_hdr(skb)->hop_limit != 255) {
 		ND_PRINTK(2, warn, "NDISC: invalid hop-limit: %d\n",
 			  ipv6_hdr(skb)->hop_limit);
-		return 0;
+		return SKB_DROP_REASON_IPV6_NDISC_HOP_LIMIT;
 	}
 
 	if (msg->icmph.icmp6_code != 0) {
 		ND_PRINTK(2, warn, "NDISC: invalid ICMPv6 code: %d\n",
 			  msg->icmph.icmp6_code);
-		return 0;
+		return SKB_DROP_REASON_IPV6_NDISC_BAD_CODE;
 	}
 
 	switch (msg->icmph.icmp6_type) {
@@ -1763,7 +1764,7 @@ int ndisc_rcv(struct sk_buff *skb)
 		break;
 	}
 
-	return 0;
+	return reason;
 }
 
 static int ndisc_netdev_event(struct notifier_block *this, unsigned long event, void *ptr)
