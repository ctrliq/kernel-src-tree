net: fix call location in kfree_skb_list_reason

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-499.el8
commit-author Jesper Dangaard Brouer <brouer@redhat.com>
commit a4650da2a2d6150a8ff1ea36fde9f6a26cf5fda3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-499.el8/a4650da2.failed

The SKB drop reason uses __builtin_return_address(0) to give the call
"location" to trace_kfree_skb() tracepoint skb:kfree_skb.

To keep this stable for compilers kfree_skb_reason() is annotated with
__fix_address (noinline __noclone) as fixed in commit c205cc7534a9
("net: skb: prevent the split of kfree_skb_reason() by gcc").

The function kfree_skb_list_reason() invoke kfree_skb_reason(), which
cause the __builtin_return_address(0) "location" to report the
unexpected address of kfree_skb_list_reason.

Example output from 'perf script':
 kpktgend_0  1337 [000]    81.002597: skb:kfree_skb: skbaddr=0xffff888144824700 protocol=2048 location=kfree_skb_list_reason+0x1e reason: QDISC_DROP

Patch creates an __always_inline __kfree_skb_reason() helper call that
is called from both kfree_skb_list() and kfree_skb_list_reason().
Suggestions for solutions that shares code better are welcome.

As preparation for next patch move __kfree_skb() invocation out of
this helper function.

	Reviewed-by: Saeed Mahameed <saeed@kernel.org>
	Signed-off-by: Jesper Dangaard Brouer <brouer@redhat.com>
	Signed-off-by: Paolo Abeni <pabeni@redhat.com>
(cherry picked from commit a4650da2a2d6150a8ff1ea36fde9f6a26cf5fda3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/core/skbuff.c
diff --cc net/core/skbuff.c
index 78546ad33c63,ca2b4d6f9c9a..000000000000
--- a/net/core/skbuff.c
+++ b/net/core/skbuff.c
@@@ -838,19 -930,21 +838,34 @@@ void __kfree_skb(struct sk_buff *skb
  }
  EXPORT_SYMBOL(__kfree_skb);
  
+ static __always_inline
+ bool __kfree_skb_reason(struct sk_buff *skb, enum skb_drop_reason reason)
+ {
+ 	if (unlikely(!skb_unref(skb)))
+ 		return false;
+ 
+ 	DEBUG_NET_WARN_ON_ONCE(reason <= 0 || reason >= SKB_DROP_REASON_MAX);
+ 
+ 	if (reason == SKB_CONSUMED)
+ 		trace_consume_skb(skb);
+ 	else
+ 		trace_kfree_skb(skb, __builtin_return_address(0), reason);
+ 	return true;
+ }
+ 
 +/**
 + *	kfree_skb - free an sk_buff with special reason
 + *	@skb: buffer to free
 + *
 + *	Drop a reference to the buffer and free it if the usage count has
 + *	hit zero.
 + */
 +void kfree_skb(struct sk_buff *skb)
 +{
 +	kfree_skb_reason(skb, SKB_DROP_REASON_NOT_SPECIFIED);
 +}
 +EXPORT_SYMBOL(kfree_skb);
 +
  /**
   *	kfree_skb_reason - free an sk_buff with special reason
   *	@skb: buffer to free
@@@ -863,27 -957,13 +878,37 @@@
  void __fix_address
  kfree_skb_reason(struct sk_buff *skb, enum skb_drop_reason reason)
  {
++<<<<<<< HEAD
 +	if (unlikely(!skb_unref(skb)))
 +		return;
 +
 +	BUILD_BUG_ON_INVALID(reason <= 0 || reason >= SKB_DROP_REASON_MAX);
 +
 +	if (reason == SKB_CONSUMED)
 +		trace_consume_skb(skb);
 +	else
 +		trace_kfree_skb(skb, __builtin_return_address(0), reason);
 +	__kfree_skb(skb);
 +}
 +EXPORT_SYMBOL(kfree_skb_reason);
 +
 +void kfree_skb_list(struct sk_buff *segs)
 +{
 +	kfree_skb_list_reason(segs, SKB_DROP_REASON_NOT_SPECIFIED);
 +}
 +EXPORT_SYMBOL(kfree_skb_list);
 +
 +void kfree_skb_list_reason(struct sk_buff *segs,
 +			   enum skb_drop_reason reason)
++=======
+ 	if (__kfree_skb_reason(skb, reason))
+ 		__kfree_skb(skb);
+ }
+ EXPORT_SYMBOL(kfree_skb_reason);
+ 
+ void __fix_address
+ kfree_skb_list_reason(struct sk_buff *segs, enum skb_drop_reason reason)
++>>>>>>> a4650da2a2d6 (net: fix call location in kfree_skb_list_reason)
  {
  	while (segs) {
  		struct sk_buff *next = segs->next;
* Unmerged path net/core/skbuff.c
