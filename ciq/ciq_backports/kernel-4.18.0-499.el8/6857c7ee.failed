ASoC: SOF: Intel: hda-mlink: add helper to return sublink count

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-499.el8
commit-author Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
commit 6857c7ee202cf4b8224882bcee8e3b97c26b6484
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-499.el8/6857c7ee.failed

This is needed for SoundWire integration.

	Signed-off-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
	Reviewed-by: Rander Wang <rander.wang@intel.com>
	Reviewed-by: PÃ©ter Ujfalusi <peter.ujfalusi@linux.intel.com>
	Reviewed-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
	Signed-off-by: Peter Ujfalusi <peter.ujfalusi@linux.intel.com>
	Reviewed-by: Takashi Iwai <tiwai@suse.de>
Link: https://lore.kernel.org/r/20230404104127.5629-11-peter.ujfalusi@linux.intel.com
	Signed-off-by: Mark Brown <broonie@kernel.org>
(cherry picked from commit 6857c7ee202cf4b8224882bcee8e3b97c26b6484)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/sound/hda-mlink.h
#	sound/soc/sof/intel/hda-mlink.c
diff --cc sound/soc/sof/intel/hda-mlink.c
index 2f512ba2a874,02743c342f28..000000000000
--- a/sound/soc/sof/intel/hda-mlink.c
+++ b/sound/soc/sof/intel/hda-mlink.c
@@@ -44,9 -305,138 +44,138 @@@ void hda_bus_ml_free(struct hdac_bus *b
  
  	list_for_each_entry_safe(hlink, _h, &bus->hlink_list, list) {
  		list_del(&hlink->list);
 -		h2link = hdac_ext_link_to_ext2(hlink);
 -
 -		mutex_destroy(&h2link->eml_lock);
 -		kfree(h2link);
 +		kfree(hlink);
  	}
  }
++<<<<<<< HEAD
++=======
+ EXPORT_SYMBOL_NS(hda_bus_ml_free, SND_SOC_SOF_HDA_MLINK);
+ 
+ static struct hdac_ext2_link *
+ find_ext2_link(struct hdac_bus *bus, bool alt, int elid)
+ {
+ 	struct hdac_ext_link *hlink;
+ 
+ 	list_for_each_entry(hlink, &bus->hlink_list, list) {
+ 		struct hdac_ext2_link *h2link = hdac_ext_link_to_ext2(hlink);
+ 
+ 		if (h2link->alt == alt && h2link->elid == elid)
+ 			return h2link;
+ 	}
+ 
+ 	return NULL;
+ }
+ 
+ int hdac_bus_eml_get_count(struct hdac_bus *bus, bool alt, int elid)
+ {
+ 	struct hdac_ext2_link *h2link;
+ 
+ 	h2link = find_ext2_link(bus, alt, elid);
+ 	if (!h2link)
+ 		return 0;
+ 
+ 	return h2link->slcount;
+ }
+ EXPORT_SYMBOL_NS(hdac_bus_eml_get_count, SND_SOC_SOF_HDA_MLINK);
+ 
+ static int hdac_bus_eml_power_up_base(struct hdac_bus *bus, bool alt, int elid, int sublink,
+ 				      bool eml_lock)
+ {
+ 	struct hdac_ext2_link *h2link;
+ 	struct hdac_ext_link *hlink;
+ 	int ret = 0;
+ 
+ 	h2link = find_ext2_link(bus, alt, elid);
+ 	if (!h2link)
+ 		return -ENODEV;
+ 
+ 	if (sublink >= h2link->slcount)
+ 		return -EINVAL;
+ 
+ 	hlink = &h2link->hext_link;
+ 
+ 	if (eml_lock)
+ 		mutex_lock(&h2link->eml_lock);
+ 
+ 	if (++hlink->ref_count > 1)
+ 		goto skip_init;
+ 
+ 	ret = hdaml_link_init(hlink->ml_addr + AZX_REG_ML_LCTL, sublink);
+ 
+ skip_init:
+ 	if (eml_lock)
+ 		mutex_unlock(&h2link->eml_lock);
+ 
+ 	return ret;
+ }
+ 
+ int hdac_bus_eml_power_up(struct hdac_bus *bus, bool alt, int elid, int sublink)
+ {
+ 	return hdac_bus_eml_power_up_base(bus, alt, elid, sublink, true);
+ }
+ EXPORT_SYMBOL_NS(hdac_bus_eml_power_up, SND_SOC_SOF_HDA_MLINK);
+ 
+ int hdac_bus_eml_power_up_unlocked(struct hdac_bus *bus, bool alt, int elid, int sublink)
+ {
+ 	return hdac_bus_eml_power_up_base(bus, alt, elid, sublink, false);
+ }
+ EXPORT_SYMBOL_NS(hdac_bus_eml_power_up_unlocked, SND_SOC_SOF_HDA_MLINK);
+ 
+ static int hdac_bus_eml_power_down_base(struct hdac_bus *bus, bool alt, int elid, int sublink,
+ 					bool eml_lock)
+ {
+ 	struct hdac_ext2_link *h2link;
+ 	struct hdac_ext_link *hlink;
+ 	int ret = 0;
+ 
+ 	h2link = find_ext2_link(bus, alt, elid);
+ 	if (!h2link)
+ 		return -ENODEV;
+ 
+ 	if (sublink >= h2link->slcount)
+ 		return -EINVAL;
+ 
+ 	hlink = &h2link->hext_link;
+ 
+ 	if (eml_lock)
+ 		mutex_lock(&h2link->eml_lock);
+ 
+ 	if (--hlink->ref_count > 0)
+ 		goto skip_shutdown;
+ 
+ 	ret = hdaml_link_shutdown(hlink->ml_addr + AZX_REG_ML_LCTL, sublink);
+ 
+ skip_shutdown:
+ 	if (eml_lock)
+ 		mutex_unlock(&h2link->eml_lock);
+ 
+ 	return ret;
+ }
+ 
+ int hdac_bus_eml_power_down(struct hdac_bus *bus, bool alt, int elid, int sublink)
+ {
+ 	return hdac_bus_eml_power_down_base(bus, alt, elid, sublink, true);
+ }
+ EXPORT_SYMBOL_NS(hdac_bus_eml_power_down, SND_SOC_SOF_HDA_MLINK);
+ 
+ int hdac_bus_eml_power_down_unlocked(struct hdac_bus *bus, bool alt, int elid, int sublink)
+ {
+ 	return hdac_bus_eml_power_down_base(bus, alt, elid, sublink, false);
+ }
+ EXPORT_SYMBOL_NS(hdac_bus_eml_power_down_unlocked, SND_SOC_SOF_HDA_MLINK);
+ 
+ int hdac_bus_eml_sdw_power_up_unlocked(struct hdac_bus *bus, int sublink)
+ {
+ 	return hdac_bus_eml_power_up_unlocked(bus, true, AZX_REG_ML_LEPTR_ID_SDW, sublink);
+ }
+ EXPORT_SYMBOL_NS(hdac_bus_eml_sdw_power_up_unlocked, SND_SOC_SOF_HDA_MLINK);
+ 
+ int hdac_bus_eml_sdw_power_down_unlocked(struct hdac_bus *bus, int sublink)
+ {
+ 	return hdac_bus_eml_power_down_unlocked(bus, true, AZX_REG_ML_LEPTR_ID_SDW, sublink);
+ }
+ EXPORT_SYMBOL_NS(hdac_bus_eml_sdw_power_down_unlocked, SND_SOC_SOF_HDA_MLINK);
++>>>>>>> 6857c7ee202c (ASoC: SOF: Intel: hda-mlink: add helper to return sublink count)
  
  void hda_bus_ml_put_all(struct hdac_bus *bus)
  {
* Unmerged path include/sound/hda-mlink.h
* Unmerged path include/sound/hda-mlink.h
* Unmerged path sound/soc/sof/intel/hda-mlink.c
