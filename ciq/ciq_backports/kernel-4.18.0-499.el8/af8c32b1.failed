ASoC: SOF: Intel: hda-mlink: fix base_ptr computation

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-499.el8
commit-author Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
commit af8c32b1a3d55f9b42294aee7e7c7eca85ee3bd2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-499.el8/af8c32b1.failed

The base_ptr value needs to be derived from the remap_addr pointer,
not the ml_addr. This base_ptr was used only in debug logs that were
so far not contributed upstream so the issue was not detected. It
needs to be fixed for SoundWire support on LunarLake.

Fixes: 17c9b6ec35c0 ("ASoC: SOF: Intel: hda-mlink: add structures to parse ALT links")
	Signed-off-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com
	Reviewed-by: Bard Liao <yung-chuan.liao@linux.intel.com
	Reviewed-by: Rander Wang <rander.wang@intel.com
	Reviewed-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com
Link: https://lore.kernel.org/r/20230512174611.84372-4-pierre-louis.bossart@linux.intel.com
	Signed-off-by: Mark Brown <broonie@kernel.org
(cherry picked from commit af8c32b1a3d55f9b42294aee7e7c7eca85ee3bd2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/soc/sof/intel/hda-mlink.c
diff --cc sound/soc/sof/intel/hda-mlink.c
index 2f512ba2a874,7f5d0ea4abeb..000000000000
--- a/sound/soc/sof/intel/hda-mlink.c
+++ b/sound/soc/sof/intel/hda-mlink.c
@@@ -12,29 -12,407 +12,426 @@@
  
  #include <sound/hdaudio_ext.h>
  #include <sound/hda_register.h>
 -#include <sound/hda-mlink.h>
  
 -#include <linux/bitfield.h>
 +#include <linux/acpi.h>
  #include <linux/module.h>
 +#include <linux/soundwire/sdw.h>
 +#include <linux/soundwire/sdw_intel.h>
 +#include <sound/intel-dsp-config.h>
 +#include <sound/intel-nhlt.h>
 +#include <sound/sof.h>
 +#include <sound/sof/xtensa.h>
 +#include "../sof-audio.h"
 +#include "../sof-pci-dev.h"
 +#include "../ops.h"
 +#include "hda.h"
 +
 +#if IS_ENABLED(CONFIG_SND_SOC_SOF_HDA)
 +
++<<<<<<< HEAD
 +int hda_bus_ml_get_capabilities(struct hdac_bus *bus)
 +{
 +	if (bus->mlcap)
 +		return snd_hdac_ext_bus_get_ml_capabilities(bus);
 +	return 0;
 +}
  
 -#if IS_ENABLED(CONFIG_SND_SOC_SOF_HDA_MLINK)
 -
++=======
+ /* worst-case number of sublinks is used for sublink refcount array allocation only */
+ #define HDAML_MAX_SUBLINKS (AZX_ML_LCTL_CPA_SHIFT - AZX_ML_LCTL_SPA_SHIFT)
+ 
+ /**
+  * struct hdac_ext2_link - HDAudio extended+alternate link
+  *
+  * @hext_link:		hdac_ext_link
+  * @alt:		flag set for alternate extended links
+  * @intc:		boolean for interrupt capable
+  * @ofls:		boolean for offload support
+  * @lss:		boolean for link synchronization capabilities
+  * @slcount:		sublink count
+  * @elid:		extended link ID (AZX_REG_ML_LEPTR_ID_ defines)
+  * @elver:		extended link version
+  * @leptr:		extended link pointer
+  * @eml_lock:		mutual exclusion to access shared registers e.g. CPA/SPA bits
+  * in LCTL register
+  * @sublink_ref_count:	array of refcounts, required to power-manage sublinks independently
+  * @base_ptr:		pointer to shim/ip/shim_vs space
+  * @instance_offset:	offset between each of @slcount instances managed by link
+  * @shim_offset:	offset to SHIM register base
+  * @ip_offset:		offset to IP register base
+  * @shim_vs_offset:	offset to vendor-specific (VS) SHIM base
+  */
+ struct hdac_ext2_link {
+ 	struct hdac_ext_link hext_link;
+ 
+ 	/* read directly from LCAP register */
+ 	bool alt;
+ 	bool intc;
+ 	bool ofls;
+ 	bool lss;
+ 	int slcount;
+ 	int elid;
+ 	int elver;
+ 	u32 leptr;
+ 
+ 	struct mutex eml_lock; /* prevent concurrent access to e.g. CPA/SPA */
+ 	int sublink_ref_count[HDAML_MAX_SUBLINKS];
+ 
+ 	/* internal values computed from LCAP contents */
+ 	void __iomem *base_ptr;
+ 	u32 instance_offset;
+ 	u32 shim_offset;
+ 	u32 ip_offset;
+ 	u32 shim_vs_offset;
+ };
+ 
+ #define hdac_ext_link_to_ext2(h) container_of(h, struct hdac_ext2_link, hext_link)
+ 
+ #define AZX_REG_SDW_INSTANCE_OFFSET			0x8000
+ #define AZX_REG_SDW_SHIM_OFFSET				0x0
+ #define AZX_REG_SDW_IP_OFFSET				0x100
+ #define AZX_REG_SDW_VS_SHIM_OFFSET			0x6000
+ 
+ /* only one instance supported */
+ #define AZX_REG_INTEL_DMIC_SHIM_OFFSET			0x0
+ #define AZX_REG_INTEL_DMIC_IP_OFFSET			0x100
+ #define AZX_REG_INTEL_DMIC_VS_SHIM_OFFSET		0x6000
+ 
+ #define AZX_REG_INTEL_SSP_INSTANCE_OFFSET		0x1000
+ #define AZX_REG_INTEL_SSP_SHIM_OFFSET			0x0
+ #define AZX_REG_INTEL_SSP_IP_OFFSET			0x100
+ #define AZX_REG_INTEL_SSP_VS_SHIM_OFFSET		0xC00
+ 
+ /* only one instance supported */
+ #define AZX_REG_INTEL_UAOL_SHIM_OFFSET			0x0
+ #define AZX_REG_INTEL_UAOL_IP_OFFSET			0x100
+ #define AZX_REG_INTEL_UAOL_VS_SHIM_OFFSET		0xC00
+ 
+ /* HDAML section - this part follows sequences in the hardware specification,
+  * including naming conventions and the use of the hdaml_ prefix.
+  * The code is intentionally minimal with limited dependencies on frameworks or
+  * helpers. Locking and scanning lists is handled at a higher level
+  */
+ 
+ static int hdaml_lnk_enum(struct device *dev, struct hdac_ext2_link *h2link,
+ 			  void __iomem *remap_addr, void __iomem *ml_addr, int link_idx)
+ {
+ 	struct hdac_ext_link *hlink = &h2link->hext_link;
+ 	u32 base_offset;
+ 
+ 	hlink->lcaps  = readl(ml_addr + AZX_REG_ML_LCAP);
+ 
+ 	h2link->alt = FIELD_GET(AZX_ML_HDA_LCAP_ALT, hlink->lcaps);
+ 
+ 	/* handle alternate extensions */
+ 	if (!h2link->alt) {
+ 		h2link->slcount = 1;
+ 
+ 		/*
+ 		 * LSDIID is initialized by hardware for HDaudio link,
+ 		 * it needs to be setup by software for alternate links
+ 		 */
+ 		hlink->lsdiid = readw(ml_addr + AZX_REG_ML_LSDIID);
+ 
+ 		dev_dbg(dev, "Link %d: HDAudio - lsdiid=%d\n",
+ 			link_idx, hlink->lsdiid);
+ 
+ 		return 0;
+ 	}
+ 
+ 	h2link->intc = FIELD_GET(AZX_ML_HDA_LCAP_INTC, hlink->lcaps);
+ 	h2link->ofls = FIELD_GET(AZX_ML_HDA_LCAP_OFLS, hlink->lcaps);
+ 	h2link->lss = FIELD_GET(AZX_ML_HDA_LCAP_LSS, hlink->lcaps);
+ 
+ 	/* read slcount (increment due to zero-based hardware representation */
+ 	h2link->slcount = FIELD_GET(AZX_ML_HDA_LCAP_SLCOUNT, hlink->lcaps) + 1;
+ 	dev_dbg(dev, "Link %d: HDAudio extended - sublink count %d\n",
+ 		link_idx, h2link->slcount);
+ 
+ 	/* find IP ID and offsets */
+ 	h2link->leptr = readl(hlink->ml_addr + AZX_REG_ML_LEPTR);
+ 
+ 	h2link->elid = FIELD_GET(AZX_REG_ML_LEPTR_ID, h2link->leptr);
+ 
+ 	base_offset = FIELD_GET(AZX_REG_ML_LEPTR_PTR, h2link->leptr);
+ 	h2link->base_ptr = remap_addr + base_offset;
+ 
+ 	switch (h2link->elid) {
+ 	case AZX_REG_ML_LEPTR_ID_SDW:
+ 		h2link->shim_offset = AZX_REG_SDW_SHIM_OFFSET;
+ 		h2link->ip_offset = AZX_REG_SDW_IP_OFFSET;
+ 		h2link->shim_vs_offset = AZX_REG_SDW_VS_SHIM_OFFSET;
+ 		dev_dbg(dev, "Link %d: HDAudio extended - SoundWire alternate link, leptr.ptr %#x\n",
+ 			link_idx, base_offset);
+ 		break;
+ 	case AZX_REG_ML_LEPTR_ID_INTEL_DMIC:
+ 		h2link->shim_offset = AZX_REG_INTEL_DMIC_SHIM_OFFSET;
+ 		h2link->ip_offset = AZX_REG_INTEL_DMIC_IP_OFFSET;
+ 		h2link->shim_vs_offset = AZX_REG_INTEL_DMIC_VS_SHIM_OFFSET;
+ 		dev_dbg(dev, "Link %d: HDAudio extended - INTEL DMIC alternate link, leptr.ptr %#x\n",
+ 			link_idx, base_offset);
+ 		break;
+ 	case AZX_REG_ML_LEPTR_ID_INTEL_SSP:
+ 		h2link->shim_offset = AZX_REG_INTEL_SSP_SHIM_OFFSET;
+ 		h2link->ip_offset = AZX_REG_INTEL_SSP_IP_OFFSET;
+ 		h2link->shim_vs_offset = AZX_REG_INTEL_SSP_VS_SHIM_OFFSET;
+ 		dev_dbg(dev, "Link %d: HDAudio extended - INTEL SSP alternate link, leptr.ptr %#x\n",
+ 			link_idx, base_offset);
+ 		break;
+ 	case AZX_REG_ML_LEPTR_ID_INTEL_UAOL:
+ 		h2link->shim_offset = AZX_REG_INTEL_UAOL_SHIM_OFFSET;
+ 		h2link->ip_offset = AZX_REG_INTEL_UAOL_IP_OFFSET;
+ 		h2link->shim_vs_offset = AZX_REG_INTEL_UAOL_VS_SHIM_OFFSET;
+ 		dev_dbg(dev, "Link %d: HDAudio extended - INTEL UAOL alternate link, leptr.ptr %#x\n",
+ 			link_idx, base_offset);
+ 		break;
+ 	default:
+ 		dev_err(dev, "Link %d: HDAudio extended - Unsupported alternate link, leptr.id=%#02x value\n",
+ 			link_idx, h2link->elid);
+ 		return -EINVAL;
+ 	}
+ 	return 0;
+ }
+ 
+ /*
+  * Hardware recommendations are to wait ~10us before checking any hardware transition
+  * reported by bits changing status.
+  * This value does not need to be super-precise, a slack of 5us is perfectly acceptable.
+  * The worst-case is about 1ms before reporting an issue
+  */
+ #define HDAML_POLL_DELAY_MIN_US 10
+ #define HDAML_POLL_DELAY_SLACK_US 5
+ #define HDAML_POLL_DELAY_RETRY  100
+ 
+ static int check_sublink_power(u32 __iomem *lctl, int sublink, bool enabled)
+ {
+ 	int mask = BIT(sublink) << AZX_ML_LCTL_CPA_SHIFT;
+ 	int retry = HDAML_POLL_DELAY_RETRY;
+ 	u32 val;
+ 
+ 	usleep_range(HDAML_POLL_DELAY_MIN_US,
+ 		     HDAML_POLL_DELAY_MIN_US + HDAML_POLL_DELAY_SLACK_US);
+ 	do {
+ 		val = readl(lctl);
+ 		if (enabled) {
+ 			if (val & mask)
+ 				return 0;
+ 		} else {
+ 			if (!(val & mask))
+ 				return 0;
+ 		}
+ 		usleep_range(HDAML_POLL_DELAY_MIN_US,
+ 			     HDAML_POLL_DELAY_MIN_US + HDAML_POLL_DELAY_SLACK_US);
+ 
+ 	} while (--retry);
+ 
+ 	return -EIO;
+ }
+ 
+ static int hdaml_link_init(u32 __iomem *lctl, int sublink)
+ {
+ 	u32 val;
+ 	u32 mask = BIT(sublink) << AZX_ML_LCTL_SPA_SHIFT;
+ 
+ 	val = readl(lctl);
+ 	val |= mask;
+ 
+ 	writel(val, lctl);
+ 
+ 	return check_sublink_power(lctl, sublink, true);
+ }
+ 
+ static int hdaml_link_shutdown(u32 __iomem *lctl, int sublink)
+ {
+ 	u32 val;
+ 	u32 mask;
+ 
+ 	val = readl(lctl);
+ 	mask = BIT(sublink) << AZX_ML_LCTL_SPA_SHIFT;
+ 	val &= ~mask;
+ 
+ 	writel(val, lctl);
+ 
+ 	return check_sublink_power(lctl, sublink, false);
+ }
+ 
+ static void hdaml_link_enable_interrupt(u32 __iomem *lctl, bool enable)
+ {
+ 	u32 val;
+ 
+ 	val = readl(lctl);
+ 	if (enable)
+ 		val |= AZX_ML_LCTL_INTEN;
+ 	else
+ 		val &= ~AZX_ML_LCTL_INTEN;
+ 
+ 	writel(val, lctl);
+ }
+ 
+ static bool hdaml_link_check_interrupt(u32 __iomem *lctl)
+ {
+ 	u32 val;
+ 
+ 	val = readl(lctl);
+ 
+ 	return val & AZX_ML_LCTL_INTSTS;
+ }
+ 
+ static int hdaml_wait_bit(void __iomem *base, int offset, u32 mask, u32 target)
+ {
+ 	int timeout = HDAML_POLL_DELAY_RETRY;
+ 	u32 reg_read;
+ 
+ 	do {
+ 		reg_read = readl(base + offset);
+ 		if ((reg_read & mask) == target)
+ 			return 0;
+ 
+ 		timeout--;
+ 		usleep_range(HDAML_POLL_DELAY_MIN_US,
+ 			     HDAML_POLL_DELAY_MIN_US + HDAML_POLL_DELAY_SLACK_US);
+ 	} while (timeout != 0);
+ 
+ 	return -EAGAIN;
+ }
+ 
+ static void hdaml_link_set_syncprd(u32 __iomem *lsync, u32 syncprd)
+ {
+ 	u32 val;
+ 
+ 	val = readl(lsync);
+ 	val &= ~AZX_REG_ML_LSYNC_SYNCPRD;
+ 	val |= (syncprd & AZX_REG_ML_LSYNC_SYNCPRD);
+ 
+ 	/*
+ 	 * set SYNCPU but do not wait. The bit is cleared by hardware when
+ 	 * the link becomes active.
+ 	 */
+ 	val |= AZX_REG_ML_LSYNC_SYNCPU;
+ 
+ 	writel(val, lsync);
+ }
+ 
+ static int hdaml_link_wait_syncpu(u32 __iomem *lsync)
+ {
+ 	return hdaml_wait_bit(lsync, 0, AZX_REG_ML_LSYNC_SYNCPU, 0);
+ }
+ 
+ static void hdaml_link_sync_arm(u32 __iomem *lsync, int sublink)
+ {
+ 	u32 val;
+ 
+ 	val = readl(lsync);
+ 	val |= (AZX_REG_ML_LSYNC_CMDSYNC << sublink);
+ 
+ 	writel(val, lsync);
+ }
+ 
+ static void hdaml_link_sync_go(u32 __iomem *lsync)
+ {
+ 	u32 val;
+ 
+ 	val = readl(lsync);
+ 	val |= AZX_REG_ML_LSYNC_SYNCGO;
+ 
+ 	writel(val, lsync);
+ }
+ 
+ static bool hdaml_link_check_cmdsync(u32 __iomem *lsync, u32 cmdsync_mask)
+ {
+ 	u32 val;
+ 
+ 	val = readl(lsync);
+ 
+ 	return !!(val & cmdsync_mask);
+ }
+ 
+ static void hdaml_link_set_lsdiid(u32 __iomem *lsdiid, int dev_num)
+ {
+ 	u32 val;
+ 
+ 	val = readl(lsdiid);
+ 	val |= BIT(dev_num);
+ 
+ 	writel(val, lsdiid);
+ }
+ 
+ static void hdaml_lctl_offload_enable(u32 __iomem *lctl, bool enable)
+ {
+ 	u32 val = readl(lctl);
+ 
+ 	if (enable)
+ 		val |=  AZX_ML_LCTL_OFLEN;
+ 	else
+ 		val &=  ~AZX_ML_LCTL_OFLEN;
+ 
+ 	writel(val, lctl);
+ }
+ 
+ /* END HDAML section */
+ 
+ static int hda_ml_alloc_h2link(struct hdac_bus *bus, int index)
+ {
+ 	struct hdac_ext2_link *h2link;
+ 	struct hdac_ext_link *hlink;
+ 	int ret;
+ 
+ 	h2link  = kzalloc(sizeof(*h2link), GFP_KERNEL);
+ 	if (!h2link)
+ 		return -ENOMEM;
+ 
+ 	/* basic initialization */
+ 	hlink = &h2link->hext_link;
+ 
+ 	hlink->index = index;
+ 	hlink->bus = bus;
+ 	hlink->ml_addr = bus->mlcap + AZX_ML_BASE + (AZX_ML_INTERVAL * index);
+ 
+ 	ret = hdaml_lnk_enum(bus->dev, h2link, bus->remap_addr, hlink->ml_addr, index);
+ 	if (ret < 0) {
+ 		kfree(h2link);
+ 		return ret;
+ 	}
+ 
+ 	mutex_init(&h2link->eml_lock);
+ 
+ 	list_add_tail(&hlink->list, &bus->hlink_list);
+ 
+ 	/*
+ 	 * HDaudio regular links are powered-on by default, the
+ 	 * refcount needs to be initialized.
+ 	 */
+ 	if (!h2link->alt)
+ 		hlink->ref_count = 1;
+ 
+ 	return 0;
+ }
+ 
+ int hda_bus_ml_init(struct hdac_bus *bus)
+ {
+ 	u32 link_count;
+ 	int ret;
+ 	int i;
+ 
+ 	if (!bus->mlcap)
+ 		return 0;
+ 
+ 	link_count = readl(bus->mlcap + AZX_REG_ML_MLCD) + 1;
+ 
+ 	dev_dbg(bus->dev, "HDAudio Multi-Link count: %d\n", link_count);
+ 
+ 	for (i = 0; i < link_count; i++) {
+ 		ret = hda_ml_alloc_h2link(bus, i);
+ 		if (ret < 0) {
+ 			hda_bus_ml_free(bus);
+ 			return ret;
+ 		}
+ 	}
+ 	return 0;
+ }
+ EXPORT_SYMBOL_NS(hda_bus_ml_init, SND_SOC_SOF_HDA_MLINK);
+ 
++>>>>>>> af8c32b1a3d5 (ASoC: SOF: Intel: hda-mlink: fix base_ptr computation)
  void hda_bus_ml_free(struct hdac_bus *bus)
  {
  	struct hdac_ext_link *hlink, *_h;
* Unmerged path sound/soc/sof/intel/hda-mlink.c
