ipv6: icmp6: add drop reason support to icmpv6_notify()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-499.el8
commit-author Eric Dumazet <edumazet@google.com>
commit 30c89bad3ea2ef7a2d4686f9c3cc08420fe627bc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-499.el8/30c89bad.failed

Accurately reports what happened in icmpv6_notify() when handling
a packet.

This makes use of the new IPV6_BAD_EXTHDR drop reason.

	Signed-off-by: Eric Dumazet <edumazet@google.com>
	Reviewed-by: David Ahern <dsahern@kernel.org>
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit 30c89bad3ea2ef7a2d4686f9c3cc08420fe627bc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv6/icmp.c
diff --cc net/ipv6/icmp.c
index 58b7804d918a,40bb5dedac09..000000000000
--- a/net/ipv6/icmp.c
+++ b/net/ipv6/icmp.c
@@@ -753,17 -813,23 +753,24 @@@ out_bh_enable
  	local_bh_enable();
  }
  
- void icmpv6_notify(struct sk_buff *skb, u8 type, u8 code, __be32 info)
+ enum skb_drop_reason icmpv6_notify(struct sk_buff *skb, u8 type,
+ 				   u8 code, __be32 info)
  {
++<<<<<<< HEAD
++=======
+ 	struct inet6_skb_parm *opt = IP6CB(skb);
+ 	struct net *net = dev_net(skb->dev);
++>>>>>>> 30c89bad3ea2 (ipv6: icmp6: add drop reason support to icmpv6_notify())
  	const struct inet6_protocol *ipprot;
+ 	enum skb_drop_reason reason;
  	int inner_offset;
  	__be16 frag_off;
  	u8 nexthdr;
- 	struct net *net = dev_net(skb->dev);
  
- 	if (!pskb_may_pull(skb, sizeof(struct ipv6hdr)))
+ 	reason = pskb_may_pull_reason(skb, sizeof(struct ipv6hdr));
+ 	if (reason != SKB_NOT_DROPPED_YET)
  		goto out;
  
 -	seg6_icmp_srh(skb, opt);
 -
  	nexthdr = ((struct ipv6hdr *)skb->data)->nexthdr;
  	if (ipv6_ext_hdr(nexthdr)) {
  		/* now skip over extension headers */
@@@ -788,10 -857,10 +798,10 @@@
  
  	ipprot = rcu_dereference(inet6_protos[nexthdr]);
  	if (ipprot && ipprot->err_handler)
 -		ipprot->err_handler(skb, opt, type, code, inner_offset, info);
 +		ipprot->err_handler(skb, NULL, type, code, inner_offset, info);
  
  	raw6_icmp_error(skb, nexthdr, type, code, inner_offset, info);
- 	return;
+ 	return SKB_CONSUMED;
  
  out:
  	__ICMP6_INC_STATS(net, __in6_dev_get(skb->dev), ICMP6_MIB_INERRORS);
diff --git a/include/net/ipv6.h b/include/net/ipv6.h
index 6b8f14cdb8d0..221b8dba5955 100644
--- a/include/net/ipv6.h
+++ b/include/net/ipv6.h
@@ -361,7 +361,8 @@ static inline void fl6_sock_release(struct ip6_flowlabel *fl)
 		atomic_dec(&fl->users);
 }
 
-void icmpv6_notify(struct sk_buff *skb, u8 type, u8 code, __be32 info);
+enum skb_drop_reason icmpv6_notify(struct sk_buff *skb, u8 type,
+				   u8 code, __be32 info);
 
 void icmpv6_push_pending_frames(struct sock *sk, struct flowi6 *fl6,
 				struct icmp6hdr *thdr, int len);
* Unmerged path net/ipv6/icmp.c
