ASoC: SOF: amd: Fix for handling spurious interrupts from DSP

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-499.el8
commit-author V sujith kumar Reddy <Vsujithkumar.Reddy@amd.com>
commit 2e7c6652f9b86c01cbd4e988057a746a3a461969
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-499.el8/2e7c6652.failed

As interrupts are Level-triggered,unless and until we deassert the register
the interrupts are generated which causes spurious interrupts unhandled.

Now we deasserted the interrupt at top half which solved the below
"nobody cared" warning.

warning reported in dmesg:
	irq 80: nobody cared (try booting with the "irqpoll" option)
	CPU: 5 PID: 2735 Comm: irq/80-AudioDSP
		Not tainted 5.15.86-15817-g4c19f3e06d49 #1 1bd3fd932cf58caacc95b0504d6ea1e3eab22289
	Hardware name: Google Skyrim/Skyrim, BIOS Google_Skyrim.15303.0.0 01/03/2023
	Call Trace:
	<IRQ>
	dump_stack_lvl+0x69/0x97
	 __report_bad_irq+0x3a/0xae
	note_interrupt+0x1a9/0x1e3
	handle_irq_event_percpu+0x4b/0x6e
	handle_irq_event+0x36/0x5b
	handle_fasteoi_irq+0xae/0x171
	 __common_interrupt+0x48/0xc4
	</IRQ>

	handlers:
	acp_irq_handler [snd_sof_amd_acp] threaded [<000000007e089f34>] acp_irq_thread [snd_sof_amd_acp]
	Disabling IRQ #80

	Signed-off-by: V sujith kumar Reddy <Vsujithkumar.Reddy@amd.com>
Link: https://lore.kernel.org/r/20230203123254.1898794-1-Vsujithkumar.Reddy@amd.com
	Signed-off-by: Mark Brown <broonie@kernel.org>
(cherry picked from commit 2e7c6652f9b86c01cbd4e988057a746a3a461969)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/soc/sof/amd/acp.c
diff --cc sound/soc/sof/amd/acp.c
index 83a24c932849,d5ccd4d09278..000000000000
--- a/sound/soc/sof/amd/acp.c
+++ b/sound/soc/sof/amd/acp.c
@@@ -313,47 -317,45 +313,73 @@@ static int acp_memory_init(struct snd_s
  static irqreturn_t acp_irq_thread(int irq, void *context)
  {
  	struct snd_sof_dev *sdev = context;
++<<<<<<< HEAD
++=======
+ 	const struct sof_amd_acp_desc *desc = get_chip_info(sdev->pdata);
++>>>>>>> 2e7c6652f9b8 (ASoC: SOF: amd: Fix for handling spurious interrupts from DSP)
  	unsigned int val, count = ACP_HW_SEM_RETRY_COUNT;
  
 -	val = snd_sof_dsp_read(sdev, ACP_DSP_BAR, desc->ext_intr_stat);
 +	val = snd_sof_dsp_read(sdev, ACP_DSP_BAR, ACP_EXTERNAL_INTR_STAT);
  	if (val & ACP_SHA_STAT) {
  		/* Clear SHA interrupt raised by PSP */
 -		snd_sof_dsp_write(sdev, ACP_DSP_BAR, desc->ext_intr_stat, val);
 +		snd_sof_dsp_write(sdev, ACP_DSP_BAR, ACP_EXTERNAL_INTR_STAT, val);
  		return IRQ_HANDLED;
  	}
  
++<<<<<<< HEAD
 +	val = snd_sof_dsp_read(sdev, ACP_DSP_BAR, ACP_DSP_SW_INTR_STAT);
 +	if (val & ACP_DSP_TO_HOST_IRQ) {
 +		while (snd_sof_dsp_read(sdev, ACP_DSP_BAR, ACP_AXI2DAGB_SEM_0)) {
 +			/* Wait until acquired HW Semaphore lock or timeout */
 +			count--;
 +			if (!count) {
 +				dev_err(sdev->dev, "%s: Failed to acquire HW lock\n", __func__);
 +				return IRQ_NONE;
 +			}
 +		}
 +
 +		sof_ops(sdev)->irq_thread(irq, sdev);
 +		val |= ACP_DSP_TO_HOST_IRQ;
 +		snd_sof_dsp_write(sdev, ACP_DSP_BAR, ACP_DSP_SW_INTR_STAT, val);
 +
 +		/* Unlock or Release HW Semaphore */
 +		snd_sof_dsp_write(sdev, ACP_DSP_BAR, ACP_AXI2DAGB_SEM_0, 0x0);
 +
 +		return IRQ_HANDLED;
++=======
+ 	while (snd_sof_dsp_read(sdev, ACP_DSP_BAR, desc->hw_semaphore_offset)) {
+ 		/* Wait until acquired HW Semaphore lock or timeout */
+ 		count--;
+ 		if (!count) {
+ 			dev_err(sdev->dev, "%s: Failed to acquire HW lock\n", __func__);
+ 			return IRQ_NONE;
+ 		}
++>>>>>>> 2e7c6652f9b8 (ASoC: SOF: amd: Fix for handling spurious interrupts from DSP)
  	}
  
- 	return IRQ_NONE;
+ 	sof_ops(sdev)->irq_thread(irq, sdev);
+ 	/* Unlock or Release HW Semaphore */
+ 	snd_sof_dsp_write(sdev, ACP_DSP_BAR, desc->hw_semaphore_offset, 0x0);
+ 
+ 	return IRQ_HANDLED;
  };
  
  static irqreturn_t acp_irq_handler(int irq, void *dev_id)
  {
  	struct snd_sof_dev *sdev = dev_id;
 -	const struct sof_amd_acp_desc *desc = get_chip_info(sdev->pdata);
 -	unsigned int base = desc->dsp_intr_base;
  	unsigned int val;
  
++<<<<<<< HEAD
 +	val = snd_sof_dsp_read(sdev, ACP_DSP_BAR, ACP_DSP_SW_INTR_STAT);
 +	if (val)
++=======
+ 	val = snd_sof_dsp_read(sdev, ACP_DSP_BAR, base + DSP_SW_INTR_STAT_OFFSET);
+ 	if (val) {
+ 		val |= ACP_DSP_TO_HOST_IRQ;
+ 		snd_sof_dsp_write(sdev, ACP_DSP_BAR, base + DSP_SW_INTR_STAT_OFFSET, val);
++>>>>>>> 2e7c6652f9b8 (ASoC: SOF: amd: Fix for handling spurious interrupts from DSP)
  		return IRQ_WAKE_THREAD;
+ 	}
  
  	return IRQ_NONE;
  }
* Unmerged path sound/soc/sof/amd/acp.c
