KVM: x86: Purge "highest ISR" cache when updating APICv state

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-499.el8
commit-author Sean Christopherson <seanjc@google.com>
commit 97a71c444a147ae41c7d0ab5b3d855d7f762f3ed
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-499.el8/97a71c44.failed

Purge the "highest ISR" cache when updating APICv state on a vCPU.  The
cache must not be used when APICv is active as hardware may emulate EOIs
(and other operations) without exiting to KVM.

This fixes a bug where KVM will effectively block IRQs in perpetuity due
to the "highest ISR" never getting reset if APICv is activated on a vCPU
while an IRQ is in-service.  Hardware emulates the EOI and KVM never gets
a chance to update its cache.

Fixes: b26a695a1d78 ("kvm: lapic: Introduce APICv update helper function")
	Cc: stable@vger.kernel.org
	Cc: Suravee Suthikulpanit <suravee.suthikulpanit@amd.com>
	Cc: Maxim Levitsky <mlevitsk@redhat.com>
	Reviewed-by: Paolo Bonzini <pbonzini@redhat.com>
	Reviewed-by: Maxim Levitsky <mlevitsk@redhat.com>
	Signed-off-by: Sean Christopherson <seanjc@google.com>
Message-Id: <20230106011306.85230-3-seanjc@google.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 97a71c444a147ae41c7d0ab5b3d855d7f762f3ed)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/lapic.c
diff --cc arch/x86/kvm/lapic.c
index 298958a4caaa,33a661d82da7..000000000000
--- a/arch/x86/kvm/lapic.c
+++ b/arch/x86/kvm/lapic.c
@@@ -2393,43 -2424,8 +2393,44 @@@ void kvm_apic_update_apicv(struct kvm_v
  		 */
  		apic->isr_count = count_vectors(apic->regs + APIC_ISR);
  	}
+ 	apic->highest_isr_cache = -1;
  }
 +EXPORT_SYMBOL_GPL(kvm_apic_update_apicv);
 +
 +int kvm_alloc_apic_access_page(struct kvm *kvm)
 +{
 +	struct page *page;
 +	void __user *hva;
 +	int ret = 0;
 +
 +	mutex_lock(&kvm->slots_lock);
 +	if (kvm->arch.apic_access_memslot_enabled)
 +		goto out;
 +
 +	hva = __x86_set_memory_region(kvm, APIC_ACCESS_PAGE_PRIVATE_MEMSLOT,
 +				      APIC_DEFAULT_PHYS_BASE, PAGE_SIZE);
 +	if (IS_ERR(hva)) {
 +		ret = PTR_ERR(hva);
 +		goto out;
 +	}
 +
 +	page = gfn_to_page(kvm, APIC_DEFAULT_PHYS_BASE >> PAGE_SHIFT);
 +	if (is_error_page(page)) {
 +		ret = -EFAULT;
 +		goto out;
 +	}
 +
 +	/*
 +	 * Do not pin the page in memory, so that memory hot-unplug
 +	 * is able to migrate it.
 +	 */
 +	put_page(page);
 +	kvm->arch.apic_access_memslot_enabled = true;
 +out:
 +	mutex_unlock(&kvm->slots_lock);
 +	return ret;
 +}
 +EXPORT_SYMBOL_GPL(kvm_alloc_apic_access_page);
  
  void kvm_lapic_reset(struct kvm_vcpu *vcpu, bool init_event)
  {
@@@ -2770,11 -2767,10 +2770,15 @@@ int kvm_apic_set_state(struct kvm_vcpu 
  	__start_apic_timer(apic, APIC_TMCCT);
  	kvm_lapic_set_reg(apic, APIC_TMCCT, 0);
  	kvm_apic_update_apicv(vcpu);
++<<<<<<< HEAD
 +	apic->highest_isr_cache = -1;
 +	if (vcpu->arch.apicv_active) {
++=======
+ 	if (apic->apicv_active) {
++>>>>>>> 97a71c444a14 (KVM: x86: Purge "highest ISR" cache when updating APICv state)
  		static_call_cond(kvm_x86_apicv_post_state_restore)(vcpu);
  		static_call_cond(kvm_x86_hwapic_irr_update)(vcpu, apic_find_highest_irr(apic));
 -		static_call_cond(kvm_x86_hwapic_isr_update)(apic_find_highest_isr(apic));
 +		static_call_cond(kvm_x86_hwapic_isr_update)(vcpu, apic_find_highest_isr(apic));
  	}
  	kvm_make_request(KVM_REQ_EVENT, vcpu);
  	if (ioapic_in_kernel(vcpu->kvm))
* Unmerged path arch/x86/kvm/lapic.c
