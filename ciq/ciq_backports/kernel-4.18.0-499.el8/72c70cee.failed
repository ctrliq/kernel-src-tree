KVM: x86: Add helpers to recalc physical vs. logical optimized APIC maps

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-499.el8
commit-author Sean Christopherson <seanjc@google.com>
commit 72c70ceeaf59330b1d63380add768bdbdeb24b7c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-499.el8/72c70cee.failed

Move the guts of kvm_recalculate_apic_map()'s main loop to two separate
helpers to handle recalculating the physical and logical pieces of the
optimized map.  Having 100+ lines of code in the for-loop makes it hard
to understand what is being calculated where.

No functional change intended.

	Suggested-by: Maxim Levitsky <mlevitsk@redhat.com>
	Signed-off-by: Sean Christopherson <seanjc@google.com>
Message-Id: <20230106011306.85230-34-seanjc@google.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 72c70ceeaf59330b1d63380add768bdbdeb24b7c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/lapic.c
diff --cc arch/x86/kvm/lapic.c
index b2ebf9176db0,669ea125b7e2..000000000000
--- a/arch/x86/kvm/lapic.c
+++ b/arch/x86/kvm/lapic.c
@@@ -274,116 -403,13 +402,60 @@@ void kvm_recalculate_apic_map(struct kv
  		if (!kvm_apic_present(vcpu))
  			continue;
  
++<<<<<<< HEAD
 +		xapic_id = kvm_xapic_id(apic);
 +		x2apic_id = kvm_x2apic_id(apic);
 +
 +		/*
 +		 * Apply KVM's hotplug hack if userspace has enable 32-bit APIC
 +		 * IDs.  Allow sending events to vCPUs by their x2APIC ID even
 +		 * if the target vCPU is in legacy xAPIC mode, and silently
 +		 * ignore aliased xAPIC IDs (the x2APIC ID is truncated to 8
 +		 * bits, causing IDs > 0xff to wrap and collide).
 +		 *
 +		 * Honor the architectural (and KVM's non-optimized) behavior
 +		 * if userspace has not enabled 32-bit x2APIC IDs.  Each APIC
 +		 * is supposed to process messages independently.  If multiple
 +		 * vCPUs have the same effective APIC ID, e.g. due to the
 +		 * x2APIC wrap or because the guest manually modified its xAPIC
 +		 * IDs, events targeting that ID are supposed to be recognized
 +		 * by all vCPUs with said ID.
 +		 */
 +		if (kvm->arch.x2apic_format) {
 +			/* See also kvm_apic_match_physical_addr(). */
 +			if ((apic_x2apic_mode(apic) || x2apic_id > 0xff) &&
 +			    x2apic_id <= new->max_apic_id)
 +				new->phys_map[x2apic_id] = apic;
 +
 +			if (!apic_x2apic_mode(apic) && !new->phys_map[xapic_id])
 +				new->phys_map[xapic_id] = apic;
 +		} else {
 +			/*
 +			 * Disable the optimized map if the physical APIC ID is
 +			 * already mapped, i.e. is aliased to multiple vCPUs.
 +			 * The optimized map requires a strict 1:1 mapping
 +			 * between IDs and vCPUs.
 +			 */
 +			if (apic_x2apic_mode(apic))
 +				physical_id = x2apic_id;
 +			else
 +				physical_id = xapic_id;
 +
 +			if (new->phys_map[physical_id]) {
 +				kvfree(new);
 +				new = NULL;
 +				goto out;
 +			}
 +			new->phys_map[physical_id] = apic;
++=======
+ 		if (kvm_recalculate_phys_map(new, vcpu, &xapic_id_mismatch)) {
+ 			kvfree(new);
+ 			new = NULL;
+ 			goto out;
++>>>>>>> 72c70ceeaf59 (KVM: x86: Add helpers to recalc physical vs. logical optimized APIC maps)
  		}
  
- 		if (new->logical_mode == KVM_APIC_MODE_MAP_DISABLED ||
- 		    !kvm_apic_sw_enabled(apic))
- 			continue;
- 
- 		ldr = kvm_lapic_get_reg(apic, APIC_LDR);
- 		if (!ldr)
- 			continue;
- 
- 		if (apic_x2apic_mode(apic)) {
- 			logical_mode = KVM_APIC_MODE_X2APIC;
- 		} else {
- 			ldr = GET_APIC_LOGICAL_ID(ldr);
- 			if (kvm_lapic_get_reg(apic, APIC_DFR) == APIC_DFR_FLAT)
- 				logical_mode = KVM_APIC_MODE_XAPIC_FLAT;
- 			else
- 				logical_mode = KVM_APIC_MODE_XAPIC_CLUSTER;
- 		}
- 
- 		/*
- 		 * To optimize logical mode delivery, all software-enabled APICs must
- 		 * be configured for the same mode.
- 		 */
- 		if (new->logical_mode == KVM_APIC_MODE_SW_DISABLED) {
- 			new->logical_mode = logical_mode;
- 		} else if (new->logical_mode != logical_mode) {
- 			new->logical_mode = KVM_APIC_MODE_MAP_DISABLED;
- 			continue;
- 		}
- 
- 		/*
- 		 * In x2APIC mode, the LDR is read-only and derived directly
- 		 * from the x2APIC ID, thus is guaranteed to be addressable.
- 		 * KVM reuses kvm_apic_map.phys_map to optimize logical mode
- 		 * x2APIC interrupts by reversing the LDR calculation to get
- 		 * cluster of APICs, i.e. no additional work is required.
- 		 */
- 		if (apic_x2apic_mode(apic)) {
- 			WARN_ON_ONCE(ldr != kvm_apic_calc_x2apic_ldr(x2apic_id));
- 			continue;
- 		}
- 
- 		if (WARN_ON_ONCE(!kvm_apic_map_get_logical_dest(new, ldr,
- 								&cluster, &mask))) {
- 			new->logical_mode = KVM_APIC_MODE_MAP_DISABLED;
- 			continue;
- 		}
- 
- 		if (!mask)
- 			continue;
- 
- 		ldr = ffs(mask) - 1;
- 		if (!is_power_of_2(mask) || cluster[ldr]) {
- 			new->logical_mode = KVM_APIC_MODE_MAP_DISABLED;
- 			continue;
- 		}
- 		cluster[ldr] = apic;
+ 		kvm_recalculate_logical_map(new, vcpu);
  	}
  out:
  	/*
* Unmerged path arch/x86/kvm/lapic.c
