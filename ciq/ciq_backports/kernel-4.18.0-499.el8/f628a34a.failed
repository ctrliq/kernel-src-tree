KVM: SVM: Replace "avic_mode" enum with "x2avic_enabled" boolean

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-499.el8
commit-author Sean Christopherson <seanjc@google.com>
commit f628a34a9d5228d963e3c2f15e6ee92856a0a66b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-499.el8/f628a34a.failed

Replace the "avic_mode" enum with a single bool to track whether or not
x2AVIC is enabled.  KVM already has "apicv_enabled" that tracks if any
flavor of AVIC is enabled, i.e. AVIC_MODE_NONE and AVIC_MODE_X1 are
redundant and unnecessary noise.

No functional change intended.

	Signed-off-by: Sean Christopherson <seanjc@google.com>
	Reviewed-by: Maxim Levitsky <mlevitsk@redhat.com>
Message-Id: <20230106011306.85230-12-seanjc@google.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit f628a34a9d5228d963e3c2f15e6ee92856a0a66b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/svm/avic.c
#	arch/x86/kvm/svm/svm.c
diff --cc arch/x86/kvm/svm/avic.c
index d59e6b7fc313,10b0e996e2e3..000000000000
--- a/arch/x86/kvm/svm/avic.c
+++ b/arch/x86/kvm/svm/avic.c
@@@ -81,7 -71,15 +81,19 @@@ static void avic_activate_vmcb(struct v
  	vmcb->control.avic_physical_id &= ~AVIC_PHYSICAL_MAX_INDEX_MASK;
  
  	vmcb->control.int_ctl |= AVIC_ENABLE_MASK;
++<<<<<<< HEAD
 +	if (apic_x2apic_mode(svm->vcpu.arch.apic)) {
++=======
+ 
+ 	/*
+ 	 * Note: KVM supports hybrid-AVIC mode, where KVM emulates x2APIC MSR
+ 	 * accesses, while interrupt injection to a running vCPU can be
+ 	 * achieved using AVIC doorbell.  KVM disables the APIC access page
+ 	 * (deletes the memslot) if any vCPU has x2APIC enabled, thus enabling
+ 	 * AVIC in hybrid mode activates only the doorbell mechanism.
+ 	 */
+ 	if (x2avic_enabled && apic_x2apic_mode(svm->vcpu.arch.apic)) {
++>>>>>>> f628a34a9d52 (KVM: SVM: Replace "avic_mode" enum with "x2avic_enabled" boolean)
  		vmcb->control.int_ctl |= X2APIC_MODE_MASK;
  		vmcb->control.avic_physical_id |= X2AVIC_MAX_PHYSICAL_ID;
  		/* Disabling MSR intercept for x2APIC registers */
@@@ -1054,12 -1064,11 +1066,17 @@@ void avic_refresh_apicv_exec_ctrl(struc
  {
  	struct vcpu_svm *svm = to_svm(vcpu);
  	struct vmcb *vmcb = svm->vmcb01.ptr;
++<<<<<<< HEAD
 +	bool activated = kvm_vcpu_apicv_active(vcpu);
 +
 +	if (!enable_apicv)
++=======
+ 
+ 	if (!lapic_in_kernel(vcpu) || !enable_apicv)
++>>>>>>> f628a34a9d52 (KVM: SVM: Replace "avic_mode" enum with "x2avic_enabled" boolean)
  		return;
  
 -	if (kvm_vcpu_apicv_active(vcpu)) {
 +	if (activated) {
  		/**
  		 * During AVIC temporary deactivation, guest could update
  		 * APIC ID, DFR and LDR registers, which would not be trapped
diff --cc arch/x86/kvm/svm/svm.c
index 511235200d8c,9f172f2de195..000000000000
--- a/arch/x86/kvm/svm/svm.c
+++ b/arch/x86/kvm/svm/svm.c
@@@ -4950,6 -5027,9 +4950,12 @@@ static __init int svm_hardware_setup(vo
  	if (!enable_apicv) {
  		svm_x86_ops.vcpu_blocking = NULL;
  		svm_x86_ops.vcpu_unblocking = NULL;
++<<<<<<< HEAD
++=======
+ 		svm_x86_ops.vcpu_get_apicv_inhibit_reasons = NULL;
+ 	} else if (!x2avic_enabled) {
+ 		svm_x86_ops.allow_apicv_in_x2apic_without_x2apic_virtualization = true;
++>>>>>>> f628a34a9d52 (KVM: SVM: Replace "avic_mode" enum with "x2avic_enabled" boolean)
  	}
  
  	if (vls) {
* Unmerged path arch/x86/kvm/svm/avic.c
* Unmerged path arch/x86/kvm/svm/svm.c
diff --git a/arch/x86/kvm/svm/svm.h b/arch/x86/kvm/svm/svm.h
index e934343c57f0..1fe7c71a21fb 100644
--- a/arch/x86/kvm/svm/svm.h
+++ b/arch/x86/kvm/svm/svm.h
@@ -34,14 +34,7 @@
 extern u32 msrpm_offsets[MSRPM_OFFSETS] __read_mostly;
 extern bool npt_enabled;
 extern bool intercept_smi;
-
-enum avic_modes {
-	AVIC_MODE_NONE = 0,
-	AVIC_MODE_X1,
-	AVIC_MODE_X2,
-};
-
-extern enum avic_modes avic_mode;
+extern bool x2avic_enabled;
 
 /*
  * Clean bits in VMCB.
