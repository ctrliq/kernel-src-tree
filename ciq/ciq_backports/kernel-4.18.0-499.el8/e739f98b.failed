genirq: Move prio assignment into the newly created thread

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-499.el8
commit-author Thomas Gleixner <tglx@linutronix.de>
commit e739f98b4b11337a4e3865364b8922a9e5ad32b6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-499.el8/e739f98b.failed

With enabled threaded interrupts the nouveau driver reported the
following:

| Chain exists of:
|   &mm->mmap_lock#2 --> &device->mutex --> &cpuset_rwsem
|
|  Possible unsafe locking scenario:
|
|        CPU0                    CPU1
|        ----                    ----
|   lock(&cpuset_rwsem);
|                                lock(&device->mutex);
|                                lock(&cpuset_rwsem);
|   lock(&mm->mmap_lock#2);

The device->mutex is nvkm_device::mutex.

Unblocking the lockchain at `cpuset_rwsem' is probably the easiest
thing to do.  Move the priority assignment to the start of the newly
created thread.

Fixes: 710da3c8ea7df ("sched/core: Prevent race condition between cpuset and __sched_setscheduler()")
	Reported-by: Mike Galbraith <efault@gmx.de>
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
[bigeasy: Patch description]
	Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
Link: https://lkml.kernel.org/r/a23a826af7c108ea5651e73b8fbae5e653f16e86.camel@gmx.de
(cherry picked from commit e739f98b4b11337a4e3865364b8922a9e5ad32b6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/irq/manage.c
diff --cc kernel/irq/manage.c
index 310dc7a9e554,7405e384e5ed..000000000000
--- a/kernel/irq/manage.c
+++ b/kernel/irq/manage.c
@@@ -1227,8 -1259,10 +1227,15 @@@ static int irq_thread(void *data
  	irqreturn_t (*handler_fn)(struct irq_desc *desc,
  			struct irqaction *action);
  
++<<<<<<< HEAD
 +	if (force_irqthreads && test_bit(IRQTF_FORCED_THREAD,
 +					&action->thread_flags))
++=======
+ 	sched_set_fifo(current);
+ 
+ 	if (force_irqthreads() && test_bit(IRQTF_FORCED_THREAD,
+ 					   &action->thread_flags))
++>>>>>>> e739f98b4b11 (genirq: Move prio assignment into the newly created thread)
  		handler_fn = irq_forced_thread_fn;
  	else
  		handler_fn = irq_thread_fn;
* Unmerged path kernel/irq/manage.c
