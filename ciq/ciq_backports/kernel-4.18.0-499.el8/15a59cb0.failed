ALSA: hda: cs35l41: Don't return -EINVAL from system suspend/resume

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-499.el8
commit-author Takashi Iwai <tiwai@suse.de>
commit 15a59cb0a3d6ddf2cb79f8dc3081b3130aad3767
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-499.el8/15a59cb0.failed

The recent commit to support the system suspend for CS35L41 caused a
regression on the models with CS35L41_EXT_BOOST_NO_VSPK_SWITC boost
type, as the suspend/resume callbacks just return -EINVAL.  This is
eventually handled as a fatal error and blocks the whole system
suspend/resume.

For avoiding the problem, this patch corrects the return code from
cs35l41_system_suspend() and _resume() to 0, and replace dev_err()
with dev_err_once() for stop spamming too much.

Fixes: 88672826e2a4 ("ALSA: hda: cs35l41: Support System Suspend")
	Cc: <stable@vger.kernel.org>
Link: https://lore.kernel.org/all/e6751ac2-34f3-d13f-13db-8174fade8308@pm.me
Link: https://lore.kernel.org/r/20230105093531.16960-1-tiwai@suse.de
	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit 15a59cb0a3d6ddf2cb79f8dc3081b3130aad3767)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/pci/hda/cs35l41_hda.c
diff --cc sound/pci/hda/cs35l41_hda.c
index a8f8b4e8bc18,0a5cee730268..000000000000
--- a/sound/pci/hda/cs35l41_hda.c
+++ b/sound/pci/hda/cs35l41_hda.c
@@@ -571,6 -573,80 +571,83 @@@ static int cs35l41_hda_channel_map(stru
  				    rx_slot);
  }
  
++<<<<<<< HEAD
++=======
+ static void cs35l41_ready_for_reset(struct cs35l41_hda *cs35l41)
+ {
+ 	mutex_lock(&cs35l41->fw_mutex);
+ 	if (cs35l41->firmware_running) {
+ 
+ 		regcache_cache_only(cs35l41->regmap, false);
+ 
+ 		cs35l41_exit_hibernate(cs35l41->dev, cs35l41->regmap);
+ 		cs35l41_shutdown_dsp(cs35l41);
+ 		cs35l41_safe_reset(cs35l41->regmap, cs35l41->hw_cfg.bst_type);
+ 
+ 		regcache_cache_only(cs35l41->regmap, true);
+ 		regcache_mark_dirty(cs35l41->regmap);
+ 	}
+ 	mutex_unlock(&cs35l41->fw_mutex);
+ }
+ 
+ static int cs35l41_system_suspend(struct device *dev)
+ {
+ 	struct cs35l41_hda *cs35l41 = dev_get_drvdata(dev);
+ 	int ret;
+ 
+ 	dev_dbg(cs35l41->dev, "System Suspend\n");
+ 
+ 	if (cs35l41->hw_cfg.bst_type == CS35L41_EXT_BOOST_NO_VSPK_SWITCH) {
+ 		dev_err_once(cs35l41->dev, "System Suspend not supported\n");
+ 		return 0; /* don't block the whole system suspend */
+ 	}
+ 
+ 	ret = pm_runtime_force_suspend(dev);
+ 	if (ret)
+ 		return ret;
+ 
+ 	/* Shutdown DSP before system suspend */
+ 	cs35l41_ready_for_reset(cs35l41);
+ 
+ 	/*
+ 	 * Reset GPIO may be shared, so cannot reset here.
+ 	 * However beyond this point, amps may be powered down.
+ 	 */
+ 	return 0;
+ }
+ 
+ static int cs35l41_system_resume(struct device *dev)
+ {
+ 	struct cs35l41_hda *cs35l41 = dev_get_drvdata(dev);
+ 	int ret;
+ 
+ 	dev_dbg(cs35l41->dev, "System Resume\n");
+ 
+ 	if (cs35l41->hw_cfg.bst_type == CS35L41_EXT_BOOST_NO_VSPK_SWITCH) {
+ 		dev_err_once(cs35l41->dev, "System Resume not supported\n");
+ 		return 0; /* don't block the whole system resume */
+ 	}
+ 
+ 	if (cs35l41->reset_gpio) {
+ 		usleep_range(2000, 2100);
+ 		gpiod_set_value_cansleep(cs35l41->reset_gpio, 1);
+ 	}
+ 
+ 	usleep_range(2000, 2100);
+ 
+ 	ret = pm_runtime_force_resume(dev);
+ 
+ 	mutex_lock(&cs35l41->fw_mutex);
+ 	if (!ret && cs35l41->request_fw_load && !cs35l41->fw_request_ongoing) {
+ 		cs35l41->fw_request_ongoing = true;
+ 		schedule_work(&cs35l41->fw_load_work);
+ 	}
+ 	mutex_unlock(&cs35l41->fw_mutex);
+ 
+ 	return ret;
+ }
+ 
++>>>>>>> 15a59cb0a3d6 (ALSA: hda: cs35l41: Don't return -EINVAL from system suspend/resume)
  static int cs35l41_runtime_suspend(struct device *dev)
  {
  	struct cs35l41_hda *cs35l41 = dev_get_drvdata(dev);
* Unmerged path sound/pci/hda/cs35l41_hda.c
