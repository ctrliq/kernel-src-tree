ASoC: SOF: amd: refactor dmic codec platform device creation

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-499.el8
commit-author Vijendar Mukunda <Vijendar.Mukunda@amd.com>
commit dd6bdd8b4d41b8f9db4b88dff2d10c0c62dbeb1d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-499.el8/dd6bdd8b.failed

Under snd_sof_dev device scope, create platform device for dmic
codec.

	Signed-off-by: Vijendar Mukunda <Vijendar.Mukunda@amd.com>
Link: https://lore.kernel.org/r/168050621098.26.7486882101201297853@mailman-core.alsa-project.org
	Signed-off-by: Mark Brown <broonie@kernel.org>
(cherry picked from commit dd6bdd8b4d41b8f9db4b88dff2d10c0c62dbeb1d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/soc/sof/amd/pci-rmb.c
#	sound/soc/sof/amd/pci-rn.c
diff --cc sound/soc/sof/amd/pci-rn.c
index 5a20c5c657da,4809cb644152..000000000000
--- a/sound/soc/sof/amd/pci-rn.c
+++ b/sound/soc/sof/amd/pci-rn.c
@@@ -25,26 -26,15 +25,29 @@@
  #define ACP3x_REG_START		0x1240000
  #define ACP3x_REG_END		0x125C000
  
++<<<<<<< HEAD
 +static struct platform_device *dmic_dev;
 +static struct platform_device *pdev;
 +
 +static const struct resource renoir_res[] = {
 +	{
 +		.start = 0,
 +		.end = ACP3x_REG_END - ACP3x_REG_START,
 +		.name = "acp_mem",
 +		.flags = IORESOURCE_MEM,
 +	},
 +	{
 +		.start = 0,
 +		.end = 0,
 +		.name = "acp_dai_irq",
 +		.flags = IORESOURCE_IRQ,
 +	},
 +};
 +
++=======
++>>>>>>> dd6bdd8b4d41 (ASoC: SOF: amd: refactor dmic codec platform device creation)
  static const struct sof_amd_acp_desc renoir_chip_info = {
 -	.rev		= 3,
  	.host_bridge_id = HOST_BRIDGE_CZN,
 -	.pgfsm_base	= ACP3X_PGFSM_BASE,
 -	.ext_intr_stat	= ACP3X_EXT_INTR_STAT,
 -	.dsp_intr_base	= ACP3X_DSP_SW_INTR_BASE,
 -	.sram_pte_offset = ACP3X_SRAM_PTE_OFFSET,
 -	.hw_semaphore_offset = ACP3X_AXI2DAGB_SEM_0,
 -	.acp_clkmux_sel	= ACP3X_CLKMUX_SEL,
  };
  
  static const struct sof_dev_desc renoir_desc = {
@@@ -72,84 -63,17 +75,95 @@@
  
  static int acp_pci_rn_probe(struct pci_dev *pci, const struct pci_device_id *pci_id)
  {
++<<<<<<< HEAD
 +	struct platform_device_info pdevinfo;
 +	struct device *dev = &pci->dev;
 +	const struct resource *res_i2s;
 +	struct resource *res;
 +	unsigned int flag, i, addr;
 +	int ret;
++=======
+ 	unsigned int flag;
++>>>>>>> dd6bdd8b4d41 (ASoC: SOF: amd: refactor dmic codec platform device creation)
  
  	flag = snd_amd_acp_find_config(pci);
  	if (flag != FLAG_AMD_SOF && flag != FLAG_AMD_SOF_ONLY_DMIC)
  		return -ENODEV;
  
++<<<<<<< HEAD
 +	ret = sof_pci_probe(pci, pci_id);
 +	if (ret != 0)
 +		return ret;
 +
 +	dmic_dev = platform_device_register_data(dev, "dmic-codec", PLATFORM_DEVID_NONE, NULL, 0);
 +	if (IS_ERR(dmic_dev)) {
 +		dev_err(dev, "failed to create DMIC device\n");
 +		sof_pci_remove(pci);
 +		return PTR_ERR(dmic_dev);
 +	}
 +
 +	/* Register platform device only if flag set to FLAG_AMD_SOF_ONLY_DMIC */
 +	if (flag != FLAG_AMD_SOF_ONLY_DMIC)
 +		return 0;
 +
 +	addr = pci_resource_start(pci, 0);
 +	res = devm_kzalloc(&pci->dev, sizeof(struct resource) * ARRAY_SIZE(renoir_res), GFP_KERNEL);
 +	if (!res) {
 +		sof_pci_remove(pci);
 +		platform_device_unregister(dmic_dev);
 +		return -ENOMEM;
 +	}
 +
 +	res_i2s = renoir_res;
 +	for (i = 0; i < ARRAY_SIZE(renoir_res); i++, res_i2s++) {
 +		res[i].name = res_i2s->name;
 +		res[i].flags = res_i2s->flags;
 +		res[i].start = addr + res_i2s->start;
 +		res[i].end = addr + res_i2s->end;
 +		if (res_i2s->flags == IORESOURCE_IRQ) {
 +			res[i].start = pci->irq;
 +			res[i].end = res[i].start;
 +		}
 +	}
 +
 +	memset(&pdevinfo, 0, sizeof(pdevinfo));
 +
 +	/*
 +	 * We have common PCI driver probe for ACP device but we have to support I2S without SOF
 +	 * for some distributions. Register platform device that will be used to support non dsp
 +	 * ACP's audio ends points on some machines.
 +	 */
 +
 +	pdevinfo.name = "acp_asoc_renoir";
 +	pdevinfo.id = 0;
 +	pdevinfo.parent = &pci->dev;
 +	pdevinfo.num_res = ARRAY_SIZE(renoir_res);
 +	pdevinfo.res = &res[0];
 +
 +	pdev = platform_device_register_full(&pdevinfo);
 +	if (IS_ERR(pdev)) {
 +		dev_err(&pci->dev, "cannot register %s device\n", pdevinfo.name);
 +		sof_pci_remove(pci);
 +		platform_device_unregister(dmic_dev);
 +		ret = PTR_ERR(pdev);
 +	}
 +
 +	return ret;
++=======
+ 	return sof_pci_probe(pci, pci_id);
++>>>>>>> dd6bdd8b4d41 (ASoC: SOF: amd: refactor dmic codec platform device creation)
  };
  
  static void acp_pci_rn_remove(struct pci_dev *pci)
  {
++<<<<<<< HEAD
 +	if (dmic_dev)
 +		platform_device_unregister(dmic_dev);
 +	if (pdev)
 +		platform_device_unregister(pdev);
 +
++=======
++>>>>>>> dd6bdd8b4d41 (ASoC: SOF: amd: refactor dmic codec platform device creation)
  	return sof_pci_remove(pci);
  }
  
* Unmerged path sound/soc/sof/amd/pci-rmb.c
diff --git a/sound/soc/sof/amd/acp.c b/sound/soc/sof/amd/acp.c
index b2e402ecceb2..13b15208c350 100644
--- a/sound/soc/sof/amd/acp.c
+++ b/sound/soc/sof/amd/acp.c
@@ -474,11 +474,18 @@ int amd_sof_acp_probe(struct snd_sof_dev *sdev)
 		return -ENOMEM;
 
 	adata->dev = sdev;
+	adata->dmic_dev = platform_device_register_data(sdev->dev, "dmic-codec",
+							PLATFORM_DEVID_NONE, NULL, 0);
+	if (IS_ERR(adata->dmic_dev)) {
+		dev_err(sdev->dev, "failed to register platform for dmic codec\n");
+		return PTR_ERR(adata->dmic_dev);
+	}
 	addr = pci_resource_start(pci, ACP_DSP_BAR);
 	sdev->bar[ACP_DSP_BAR] = devm_ioremap(sdev->dev, addr, pci_resource_len(pci, ACP_DSP_BAR));
 	if (!sdev->bar[ACP_DSP_BAR]) {
 		dev_err(sdev->dev, "ioremap error\n");
-		return -ENXIO;
+		ret = -ENXIO;
+		goto unregister_dev;
 	}
 
 	pci_set_master(pci);
@@ -487,7 +494,8 @@ int amd_sof_acp_probe(struct snd_sof_dev *sdev)
 	adata->smn_dev = pci_get_device(PCI_VENDOR_ID_AMD, chip->host_bridge_id, NULL);
 	if (!adata->smn_dev) {
 		dev_err(sdev->dev, "Failed to get host bridge device\n");
-		return -ENODEV;
+		ret = -ENODEV;
+		goto unregister_dev;
 	}
 
 	sdev->ipc_irq = pci->irq;
@@ -513,6 +521,8 @@ int amd_sof_acp_probe(struct snd_sof_dev *sdev)
 	free_irq(sdev->ipc_irq, sdev);
 free_smn_dev:
 	pci_dev_put(adata->smn_dev);
+unregister_dev:
+	platform_device_unregister(adata->dmic_dev);
 	return ret;
 }
 EXPORT_SYMBOL(amd_sof_acp_probe);
@@ -527,6 +537,9 @@ int amd_sof_acp_remove(struct snd_sof_dev *sdev)
 	if (sdev->ipc_irq)
 		free_irq(sdev->ipc_irq, sdev);
 
+	if (adata->dmic_dev)
+		platform_device_unregister(adata->dmic_dev);
+
 	return acp_reset(sdev);
 }
 EXPORT_SYMBOL(amd_sof_acp_remove);
diff --git a/sound/soc/sof/amd/acp.h b/sound/soc/sof/amd/acp.h
index 4c42b8fd6abf..33fcebd1013a 100644
--- a/sound/soc/sof/amd/acp.h
+++ b/sound/soc/sof/amd/acp.h
@@ -142,6 +142,8 @@ struct acp_dsp_stream {
 /* Common device data struct for ACP devices */
 struct acp_dev_data {
 	struct snd_sof_dev  *dev;
+	/* DMIC device */
+	struct platform_device *dmic_dev;
 	unsigned int fw_bin_size;
 	unsigned int fw_data_bin_size;
 	u32 fw_bin_page_count;
* Unmerged path sound/soc/sof/amd/pci-rmb.c
* Unmerged path sound/soc/sof/amd/pci-rn.c
