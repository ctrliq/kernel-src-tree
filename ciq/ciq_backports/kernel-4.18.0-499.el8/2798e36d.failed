tcp: add TCP_MINTTL drop reason

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-499.el8
commit-author Eric Dumazet <edumazet@google.com>
commit 2798e36dc233a409a5d3f26f73029596dc504020
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-499.el8/2798e36d.failed

In the unlikely case incoming packets are dropped because
of IP_MINTTL / IPV6_MINHOPCOUNT constraints...

	Signed-off-by: Eric Dumazet <edumazet@google.com>
Link: https://lore.kernel.org/r/20230201174345.2708943-1-edumazet@google.com
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit 2798e36dc233a409a5d3f26f73029596dc504020)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/tcp_ipv4.c
#	net/ipv6/tcp_ipv6.c
diff --cc net/ipv4/tcp_ipv4.c
index 52e76fe9604a,ea370afa70ed..000000000000
--- a/net/ipv4/tcp_ipv4.c
+++ b/net/ipv4/tcp_ipv4.c
@@@ -1921,9 -2097,14 +1921,20 @@@ process
  			return 0;
  		}
  	}
++<<<<<<< HEAD
 +	if (unlikely(iph->ttl < inet_sk(sk)->min_ttl)) {
 +		__NET_INC_STATS(net, LINUX_MIB_TCPMINTTLDROP);
 +		goto discard_and_relse;
++=======
+ 
+ 	if (static_branch_unlikely(&ip4_min_ttl)) {
+ 		/* min_ttl can be changed concurrently from do_ip_setsockopt() */
+ 		if (unlikely(iph->ttl < READ_ONCE(inet_sk(sk)->min_ttl))) {
+ 			__NET_INC_STATS(net, LINUX_MIB_TCPMINTTLDROP);
+ 			drop_reason = SKB_DROP_REASON_TCP_MINTTL;
+ 			goto discard_and_relse;
+ 		}
++>>>>>>> 2798e36dc233 (tcp: add TCP_MINTTL drop reason)
  	}
  
  	if (!xfrm4_policy_check(sk, XFRM_POLICY_IN, skb)) {
diff --cc net/ipv6/tcp_ipv6.c
index 198be8a1c61c,543ee2167720..000000000000
--- a/net/ipv6/tcp_ipv6.c
+++ b/net/ipv6/tcp_ipv6.c
@@@ -1574,9 -1705,14 +1574,20 @@@ process
  			return 0;
  		}
  	}
++<<<<<<< HEAD
 +	if (hdr->hop_limit < inet6_sk(sk)->min_hopcount) {
 +		__NET_INC_STATS(net, LINUX_MIB_TCPMINTTLDROP);
 +		goto discard_and_relse;
++=======
+ 
+ 	if (static_branch_unlikely(&ip6_min_hopcount)) {
+ 		/* min_hopcount can be changed concurrently from do_ipv6_setsockopt() */
+ 		if (unlikely(hdr->hop_limit < READ_ONCE(tcp_inet6_sk(sk)->min_hopcount))) {
+ 			__NET_INC_STATS(net, LINUX_MIB_TCPMINTTLDROP);
+ 			drop_reason = SKB_DROP_REASON_TCP_MINTTL;
+ 			goto discard_and_relse;
+ 		}
++>>>>>>> 2798e36dc233 (tcp: add TCP_MINTTL drop reason)
  	}
  
  	if (!xfrm6_policy_check(sk, XFRM_POLICY_IN, skb)) {
diff --git a/include/net/dropreason.h b/include/net/dropreason.h
index 70539288f995..94bc3d5d8803 100644
--- a/include/net/dropreason.h
+++ b/include/net/dropreason.h
@@ -71,6 +71,7 @@
 	FN(DUP_FRAG)			\
 	FN(FRAG_REASM_TIMEOUT)		\
 	FN(FRAG_TOO_FAR)		\
+	FN(TCP_MINTTL)			\
 	FNe(MAX)
 
 /**
@@ -312,6 +313,11 @@ enum skb_drop_reason {
 	 * (/proc/sys/net/ipv4/ipfrag_max_dist)
 	 */
 	SKB_DROP_REASON_FRAG_TOO_FAR,
+	/**
+	 * @SKB_DROP_REASON_TCP_MINTTL: ipv4 ttl or ipv6 hoplimit below
+	 * the threshold (IP_MINTTL or IPV6_MINHOPCOUNT).
+	 */
+	SKB_DROP_REASON_TCP_MINTTL,
 	/**
 	 * @SKB_DROP_REASON_MAX: the maximum of drop reason, which shouldn't be
 	 * used as a real 'reason'
* Unmerged path net/ipv4/tcp_ipv4.c
* Unmerged path net/ipv6/tcp_ipv6.c
