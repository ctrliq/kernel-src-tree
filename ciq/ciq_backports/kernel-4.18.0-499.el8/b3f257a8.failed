KVM: x86: Track required APICv inhibits with variable, not callback

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-499.el8
commit-author Sean Christopherson <seanjc@google.com>
commit b3f257a846960d06bdaa893dbee100189fbf2234
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-499.el8/b3f257a8.failed

Track the per-vendor required APICv inhibits with a variable instead of
calling into vendor code every time KVM wants to query the set of
required inhibits.  The required inhibits are a property of the vendor's
virtualization architecture, i.e. are 100% static.

Using a variable allows the compiler to inline the check, e.g. generate
a single-uop TEST+Jcc, and thus eliminates any desire to avoid checking
inhibits for performance reasons.

No functional change intended.

	Reviewed-by: Maxim Levitsky <mlevitsk@redhat.com>
	Signed-off-by: Sean Christopherson <seanjc@google.com>
Message-Id: <20230106011306.85230-32-seanjc@google.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit b3f257a846960d06bdaa893dbee100189fbf2234)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/kvm_host.h
#	arch/x86/kvm/svm/avic.c
#	arch/x86/kvm/svm/svm.h
diff --cc arch/x86/include/asm/kvm_host.h
index c2b9dc63c3f8,7ca854714ccd..000000000000
--- a/arch/x86/include/asm/kvm_host.h
+++ b/arch/x86/include/asm/kvm_host.h
@@@ -1490,9 -1623,11 +1490,14 @@@ struct kvm_x86_ops 
  	void (*enable_irq_window)(struct kvm_vcpu *vcpu);
  	void (*update_cr8_intercept)(struct kvm_vcpu *vcpu, int tpr, int irr);
  	bool (*check_apicv_inhibit_reasons)(enum kvm_apicv_inhibit reason);
++<<<<<<< HEAD
++=======
+ 	const unsigned long required_apicv_inhibits;
+ 	bool allow_apicv_in_x2apic_without_x2apic_virtualization;
++>>>>>>> b3f257a84696 (KVM: x86: Track required APICv inhibits with variable, not callback)
  	void (*refresh_apicv_exec_ctrl)(struct kvm_vcpu *vcpu);
  	void (*hwapic_irr_update)(struct kvm_vcpu *vcpu, int max_irr);
 -	void (*hwapic_isr_update)(int isr);
 +	void (*hwapic_isr_update)(struct kvm_vcpu *vcpu, int isr);
  	bool (*guest_apic_has_interrupt)(struct kvm_vcpu *vcpu);
  	void (*load_eoi_exitmap)(struct kvm_vcpu *vcpu, u64 *eoi_exit_bitmap);
  	void (*set_virtual_apic_mode)(struct kvm_vcpu *vcpu);
diff --cc arch/x86/kvm/svm/avic.c
index b013cced2893,14677bc31b83..000000000000
--- a/arch/x86/kvm/svm/avic.c
+++ b/arch/x86/kvm/svm/avic.c
@@@ -939,26 -963,6 +939,29 @@@ out
  	return ret;
  }
  
++<<<<<<< HEAD
 +bool avic_check_apicv_inhibit_reasons(enum kvm_apicv_inhibit reason)
 +{
 +	ulong supported = BIT(APICV_INHIBIT_REASON_DISABLE) |
 +			  BIT(APICV_INHIBIT_REASON_ABSENT) |
 +			  BIT(APICV_INHIBIT_REASON_HYPERV) |
 +			  BIT(APICV_INHIBIT_REASON_NESTED) |
 +			  BIT(APICV_INHIBIT_REASON_IRQWIN) |
 +			  BIT(APICV_INHIBIT_REASON_PIT_REINJ) |
 +			  BIT(APICV_INHIBIT_REASON_X2APIC) |
 +			  BIT(APICV_INHIBIT_REASON_BLOCKIRQ) |
 +			  BIT(APICV_INHIBIT_REASON_SEV)      |
 +			  BIT(APICV_INHIBIT_REASON_PHYSICAL_ID_ALIASED) |
 +			  BIT(APICV_INHIBIT_REASON_APIC_ID_MODIFIED) |
 +			  BIT(APICV_INHIBIT_REASON_APIC_BASE_MODIFIED) |
 +			  BIT(APICV_INHIBIT_REASON_LOGICAL_ID_ALIASED);
 +
 +	return supported & BIT(reason);
 +}
 +
 +
++=======
++>>>>>>> b3f257a84696 (KVM: x86: Track required APICv inhibits with variable, not callback)
  static inline int
  avic_update_iommu_vcpu_affinity(struct kvm_vcpu *vcpu, int cpu, bool r)
  {
diff --cc arch/x86/kvm/svm/svm.h
index e934343c57f0,41eabb098b13..000000000000
--- a/arch/x86/kvm/svm/svm.h
+++ b/arch/x86/kvm/svm/svm.h
@@@ -603,8 -621,23 +603,23 @@@ void svm_switch_vmcb(struct vcpu_svm *s
  extern struct kvm_x86_nested_ops svm_nested_ops;
  
  /* avic.c */
+ #define AVIC_REQUIRED_APICV_INHIBITS			\
+ (							\
+ 	BIT(APICV_INHIBIT_REASON_DISABLE) |		\
+ 	BIT(APICV_INHIBIT_REASON_ABSENT) |		\
+ 	BIT(APICV_INHIBIT_REASON_HYPERV) |		\
+ 	BIT(APICV_INHIBIT_REASON_NESTED) |		\
+ 	BIT(APICV_INHIBIT_REASON_IRQWIN) |		\
+ 	BIT(APICV_INHIBIT_REASON_PIT_REINJ) |		\
+ 	BIT(APICV_INHIBIT_REASON_BLOCKIRQ) |		\
+ 	BIT(APICV_INHIBIT_REASON_SEV)      |		\
+ 	BIT(APICV_INHIBIT_REASON_PHYSICAL_ID_ALIASED) |	\
+ 	BIT(APICV_INHIBIT_REASON_APIC_ID_MODIFIED) |	\
+ 	BIT(APICV_INHIBIT_REASON_APIC_BASE_MODIFIED) |	\
+ 	BIT(APICV_INHIBIT_REASON_LOGICAL_ID_ALIASED)	\
+ )
  
 -bool avic_hardware_setup(struct kvm_x86_ops *ops);
 +bool avic_hardware_setup(void);
  int avic_ga_log_notifier(u32 ga_tag);
  void avic_vm_destroy(struct kvm *kvm);
  int avic_vm_init(struct kvm *kvm);
@@@ -615,12 -648,7 +630,15 @@@ int avic_init_vcpu(struct vcpu_svm *svm
  void avic_vcpu_load(struct kvm_vcpu *vcpu, int cpu);
  void avic_vcpu_put(struct kvm_vcpu *vcpu);
  void avic_apicv_post_state_restore(struct kvm_vcpu *vcpu);
 +void avic_set_virtual_apic_mode(struct kvm_vcpu *vcpu);
  void avic_refresh_apicv_exec_ctrl(struct kvm_vcpu *vcpu);
++<<<<<<< HEAD
 +bool avic_check_apicv_inhibit_reasons(enum kvm_apicv_inhibit reason);
 +void avic_hwapic_irr_update(struct kvm_vcpu *vcpu, int max_irr);
 +void avic_hwapic_isr_update(struct kvm_vcpu *vcpu, int max_isr);
 +bool avic_dy_apicv_has_pending_interrupt(struct kvm_vcpu *vcpu);
++=======
++>>>>>>> b3f257a84696 (KVM: x86: Track required APICv inhibits with variable, not callback)
  int avic_pi_update_irte(struct kvm *kvm, unsigned int host_irq,
  			uint32_t guest_irq, bool set);
  void avic_vcpu_blocking(struct kvm_vcpu *vcpu);
diff --git a/arch/x86/include/asm/kvm-x86-ops.h b/arch/x86/include/asm/kvm-x86-ops.h
index ac5b01a846b1..56488c0e4cc8 100644
--- a/arch/x86/include/asm/kvm-x86-ops.h
+++ b/arch/x86/include/asm/kvm-x86-ops.h
@@ -73,7 +73,6 @@ KVM_X86_OP(set_nmi_mask)
 KVM_X86_OP(enable_nmi_window)
 KVM_X86_OP(enable_irq_window)
 KVM_X86_OP_OPTIONAL(update_cr8_intercept)
-KVM_X86_OP(check_apicv_inhibit_reasons)
 KVM_X86_OP(refresh_apicv_exec_ctrl)
 KVM_X86_OP_OPTIONAL(hwapic_irr_update)
 KVM_X86_OP_OPTIONAL(hwapic_isr_update)
* Unmerged path arch/x86/include/asm/kvm_host.h
* Unmerged path arch/x86/kvm/svm/avic.c
diff --git a/arch/x86/kvm/svm/svm.c b/arch/x86/kvm/svm/svm.c
index 511235200d8c..ac5153f8b4bc 100644
--- a/arch/x86/kvm/svm/svm.c
+++ b/arch/x86/kvm/svm/svm.c
@@ -4701,8 +4701,8 @@ static struct kvm_x86_ops svm_x86_ops __initdata = {
 	.enable_irq_window = svm_enable_irq_window,
 	.update_cr8_intercept = svm_update_cr8_intercept,
 	.refresh_apicv_exec_ctrl = avic_refresh_apicv_exec_ctrl,
-	.check_apicv_inhibit_reasons = avic_check_apicv_inhibit_reasons,
 	.apicv_post_state_restore = avic_apicv_post_state_restore,
+	.required_apicv_inhibits = AVIC_REQUIRED_APICV_INHIBITS,
 
 	.set_tss_addr = svm_set_tss_addr,
 	.set_identity_map_addr = svm_set_identity_map_addr,
* Unmerged path arch/x86/kvm/svm/svm.h
diff --git a/arch/x86/kvm/vmx/vmx.c b/arch/x86/kvm/vmx/vmx.c
index d4bde92d6827..1b5cf0127db2 100644
--- a/arch/x86/kvm/vmx/vmx.c
+++ b/arch/x86/kvm/vmx/vmx.c
@@ -7763,18 +7763,16 @@ static void vmx_hardware_unsetup(void)
 	free_kvm_area();
 }
 
-static bool vmx_check_apicv_inhibit_reasons(enum kvm_apicv_inhibit reason)
-{
-	ulong supported = BIT(APICV_INHIBIT_REASON_DISABLE) |
-			  BIT(APICV_INHIBIT_REASON_ABSENT) |
-			  BIT(APICV_INHIBIT_REASON_HYPERV) |
-			  BIT(APICV_INHIBIT_REASON_BLOCKIRQ) |
-			  BIT(APICV_INHIBIT_REASON_PHYSICAL_ID_ALIASED) |
-			  BIT(APICV_INHIBIT_REASON_APIC_ID_MODIFIED) |
-			  BIT(APICV_INHIBIT_REASON_APIC_BASE_MODIFIED);
-
-	return supported & BIT(reason);
-}
+#define VMX_REQUIRED_APICV_INHIBITS			\
+(							\
+	BIT(APICV_INHIBIT_REASON_DISABLE)|		\
+	BIT(APICV_INHIBIT_REASON_ABSENT) |		\
+	BIT(APICV_INHIBIT_REASON_HYPERV) |		\
+	BIT(APICV_INHIBIT_REASON_BLOCKIRQ) |		\
+	BIT(APICV_INHIBIT_REASON_PHYSICAL_ID_ALIASED) |	\
+	BIT(APICV_INHIBIT_REASON_APIC_ID_MODIFIED) |	\
+	BIT(APICV_INHIBIT_REASON_APIC_BASE_MODIFIED)	\
+)
 
 static struct kvm_x86_ops vmx_x86_ops __initdata = {
 	.name = "kvm_intel",
@@ -7849,7 +7847,7 @@ static struct kvm_x86_ops vmx_x86_ops __initdata = {
 	.refresh_apicv_exec_ctrl = vmx_refresh_apicv_exec_ctrl,
 	.load_eoi_exitmap = vmx_load_eoi_exitmap,
 	.apicv_post_state_restore = vmx_apicv_post_state_restore,
-	.check_apicv_inhibit_reasons = vmx_check_apicv_inhibit_reasons,
+	.required_apicv_inhibits = VMX_REQUIRED_APICV_INHIBITS,
 	.hwapic_irr_update = vmx_hwapic_irr_update,
 	.hwapic_isr_update = vmx_hwapic_isr_update,
 	.guest_apic_has_interrupt = vmx_guest_apic_has_interrupt,
diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c
index d5c8a8210410..be3a8852be6a 100644
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@ -9521,7 +9521,7 @@ void __kvm_set_or_clear_apicv_inhibit(struct kvm *kvm,
 
 	lockdep_assert_held_write(&kvm->arch.apicv_update_lock);
 
-	if (!static_call(kvm_x86_check_apicv_inhibit_reasons)(reason))
+	if (!(kvm_x86_ops.required_apicv_inhibits & BIT(reason)))
 		return;
 
 	old = new = kvm->arch.apicv_inhibit_reasons;
