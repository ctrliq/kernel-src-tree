ASoC: SOF: Intel: hda-mlink: add helper to retrieve eml_lock

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-499.el8
commit-author Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
commit 681f27f302ff85ddf3f6e7fd0231059f99c0f26e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-499.el8/681f27f3.failed

For SoundWire usages, we need to use the global eml_lock to
serialize/protect all accesses to shared registers.  Due to the split
implementation across two subsystems, we need to pass a pointer
around.

	Signed-off-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
	Reviewed-by: Rander Wang <rander.wang@intel.com>
	Reviewed-by: PÃ©ter Ujfalusi <peter.ujfalusi@linux.intel.com>
	Reviewed-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
	Signed-off-by: Peter Ujfalusi <peter.ujfalusi@linux.intel.com>
	Reviewed-by: Takashi Iwai <tiwai@suse.de>
Link: https://lore.kernel.org/r/20230404104127.5629-19-peter.ujfalusi@linux.intel.com
	Signed-off-by: Mark Brown <broonie@kernel.org>
(cherry picked from commit 681f27f302ff85ddf3f6e7fd0231059f99c0f26e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/sound/hda-mlink.h
#	sound/soc/sof/intel/hda-mlink.c
diff --cc sound/soc/sof/intel/hda-mlink.c
index 2f512ba2a874,775582ab7494..000000000000
--- a/sound/soc/sof/intel/hda-mlink.c
+++ b/sound/soc/sof/intel/hda-mlink.c
@@@ -64,5 -761,105 +64,106 @@@ void hda_bus_ml_reset_losidv(struct hda
  	list_for_each_entry(hlink, &bus->hlink_list, list)
  		writel(0, hlink->ml_addr + AZX_REG_ML_LOSIDV);
  }
++<<<<<<< HEAD
++=======
+ EXPORT_SYMBOL_NS(hda_bus_ml_reset_losidv, SND_SOC_SOF_HDA_MLINK);
+ 
+ int hda_bus_ml_resume(struct hdac_bus *bus)
+ {
+ 	struct hdac_ext_link *hlink;
+ 	int ret;
+ 
+ 	/* power up links that were active before suspend */
+ 	list_for_each_entry(hlink, &bus->hlink_list, list) {
+ 		struct hdac_ext2_link *h2link = hdac_ext_link_to_ext2(hlink);
+ 
+ 		if (!h2link->alt && hlink->ref_count) {
+ 			ret = snd_hdac_ext_bus_link_power_up(hlink);
+ 			if (ret < 0)
+ 				return ret;
+ 		}
+ 	}
+ 	return 0;
+ }
+ EXPORT_SYMBOL_NS(hda_bus_ml_resume, SND_SOC_SOF_HDA_MLINK);
+ 
+ int hda_bus_ml_suspend(struct hdac_bus *bus)
+ {
+ 	struct hdac_ext_link *hlink;
+ 	int ret;
+ 
+ 	list_for_each_entry(hlink, &bus->hlink_list, list) {
+ 		struct hdac_ext2_link *h2link = hdac_ext_link_to_ext2(hlink);
+ 
+ 		if (!h2link->alt) {
+ 			ret = snd_hdac_ext_bus_link_power_down(hlink);
+ 			if (ret < 0)
+ 				return ret;
+ 		}
+ 	}
+ 	return 0;
+ }
+ EXPORT_SYMBOL_NS(hda_bus_ml_suspend, SND_SOC_SOF_HDA_MLINK);
+ 
+ struct mutex *hdac_bus_eml_get_mutex(struct hdac_bus *bus, bool alt, int elid)
+ {
+ 	struct hdac_ext2_link *h2link;
+ 
+ 	h2link = find_ext2_link(bus, alt, elid);
+ 	if (!h2link)
+ 		return NULL;
+ 
+ 	return &h2link->eml_lock;
+ }
+ EXPORT_SYMBOL_NS(hdac_bus_eml_get_mutex, SND_SOC_SOF_HDA_MLINK);
+ 
+ struct hdac_ext_link *hdac_bus_eml_ssp_get_hlink(struct hdac_bus *bus)
+ {
+ 	struct hdac_ext2_link *h2link;
+ 
+ 	h2link = find_ext2_link(bus, true, AZX_REG_ML_LEPTR_ID_INTEL_SSP);
+ 	if (!h2link)
+ 		return NULL;
+ 
+ 	return &h2link->hext_link;
+ }
+ EXPORT_SYMBOL_NS(hdac_bus_eml_ssp_get_hlink, SND_SOC_SOF_HDA_MLINK);
+ 
+ struct hdac_ext_link *hdac_bus_eml_dmic_get_hlink(struct hdac_bus *bus)
+ {
+ 	struct hdac_ext2_link *h2link;
+ 
+ 	h2link = find_ext2_link(bus, true, AZX_REG_ML_LEPTR_ID_INTEL_DMIC);
+ 	if (!h2link)
+ 		return NULL;
+ 
+ 	return &h2link->hext_link;
+ }
+ EXPORT_SYMBOL_NS(hdac_bus_eml_dmic_get_hlink, SND_SOC_SOF_HDA_MLINK);
+ 
+ int hdac_bus_eml_enable_offload(struct hdac_bus *bus, bool alt, int elid, bool enable)
+ {
+ 	struct hdac_ext2_link *h2link;
+ 	struct hdac_ext_link *hlink;
+ 
+ 	h2link = find_ext2_link(bus, alt, elid);
+ 	if (!h2link)
+ 		return -ENODEV;
+ 
+ 	if (!h2link->ofls)
+ 		return 0;
+ 
+ 	hlink = &h2link->hext_link;
+ 
+ 	mutex_lock(&h2link->eml_lock);
+ 
+ 	hdaml_lctl_offload_enable(hlink->ml_addr + AZX_REG_ML_LCTL, enable);
+ 
+ 	mutex_unlock(&h2link->eml_lock);
+ 
+ 	return 0;
+ }
+ EXPORT_SYMBOL_NS(hdac_bus_eml_enable_offload, SND_SOC_SOF_HDA_MLINK);
++>>>>>>> 681f27f302ff (ASoC: SOF: Intel: hda-mlink: add helper to retrieve eml_lock)
  
  #endif
 -
 -MODULE_LICENSE("Dual BSD/GPL");
* Unmerged path include/sound/hda-mlink.h
* Unmerged path include/sound/hda-mlink.h
* Unmerged path sound/soc/sof/intel/hda-mlink.c
