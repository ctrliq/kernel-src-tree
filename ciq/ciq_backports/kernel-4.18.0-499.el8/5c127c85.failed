KVM: SVM: Adding support for configuring x2APIC MSRs interception

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-499.el8
commit-author Suravee Suthikulpanit <suravee.suthikulpanit@amd.com>
commit 5c127c85472c0c4c9d1f88e2807adcab9335d97c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-499.el8/5c127c85.failed

When enabling x2APIC virtualization (x2AVIC), the interception of
x2APIC MSRs must be disabled to let the hardware virtualize guest
MSR accesses.

Current implementation keeps track of list of MSR interception state
in the svm_direct_access_msrs array. Therefore, extends the array to
include x2APIC MSRs.

	Reviewed-by: Maxim Levitsky <mlevitsk@redhat.com>
	Signed-off-by: Suravee Suthikulpanit <suravee.suthikulpanit@amd.com>
Message-Id: <20220519102709.24125-8-suravee.suthikulpanit@amd.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 5c127c85472c0c4c9d1f88e2807adcab9335d97c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/svm/svm.c
#	arch/x86/kvm/svm/svm.h
diff --cc arch/x86/kvm/svm/svm.c
index bd469d8a514f,382edac728c7..000000000000
--- a/arch/x86/kvm/svm/svm.c
+++ b/arch/x86/kvm/svm/svm.c
@@@ -100,6 -99,32 +100,35 @@@ static const struct svm_direct_access_m
  	{ .index = MSR_EFER,				.always = false },
  	{ .index = MSR_IA32_CR_PAT,			.always = false },
  	{ .index = MSR_AMD64_SEV_ES_GHCB,		.always = true  },
++<<<<<<< HEAD
++=======
+ 	{ .index = MSR_TSC_AUX,				.always = false },
+ 	{ .index = (APIC_BASE_MSR + APIC_ID),		.always = false },
+ 	{ .index = (APIC_BASE_MSR + APIC_LVR),		.always = false },
+ 	{ .index = (APIC_BASE_MSR + APIC_TASKPRI),	.always = false },
+ 	{ .index = (APIC_BASE_MSR + APIC_ARBPRI),	.always = false },
+ 	{ .index = (APIC_BASE_MSR + APIC_PROCPRI),	.always = false },
+ 	{ .index = (APIC_BASE_MSR + APIC_EOI),		.always = false },
+ 	{ .index = (APIC_BASE_MSR + APIC_RRR),		.always = false },
+ 	{ .index = (APIC_BASE_MSR + APIC_LDR),		.always = false },
+ 	{ .index = (APIC_BASE_MSR + APIC_DFR),		.always = false },
+ 	{ .index = (APIC_BASE_MSR + APIC_SPIV),		.always = false },
+ 	{ .index = (APIC_BASE_MSR + APIC_ISR),		.always = false },
+ 	{ .index = (APIC_BASE_MSR + APIC_TMR),		.always = false },
+ 	{ .index = (APIC_BASE_MSR + APIC_IRR),		.always = false },
+ 	{ .index = (APIC_BASE_MSR + APIC_ESR),		.always = false },
+ 	{ .index = (APIC_BASE_MSR + APIC_ICR),		.always = false },
+ 	{ .index = (APIC_BASE_MSR + APIC_ICR2),		.always = false },
+ 	{ .index = (APIC_BASE_MSR + APIC_LVTT),		.always = false },
+ 	{ .index = (APIC_BASE_MSR + APIC_LVTTHMR),	.always = false },
+ 	{ .index = (APIC_BASE_MSR + APIC_LVTPC),	.always = false },
+ 	{ .index = (APIC_BASE_MSR + APIC_LVT0),		.always = false },
+ 	{ .index = (APIC_BASE_MSR + APIC_LVT1),		.always = false },
+ 	{ .index = (APIC_BASE_MSR + APIC_LVTERR),	.always = false },
+ 	{ .index = (APIC_BASE_MSR + APIC_TMICT),	.always = false },
+ 	{ .index = (APIC_BASE_MSR + APIC_TMCCT),	.always = false },
+ 	{ .index = (APIC_BASE_MSR + APIC_TDCR),		.always = false },
++>>>>>>> 5c127c85472c (KVM: SVM: Adding support for configuring x2APIC MSRs interception)
  	{ .index = MSR_INVALID,				.always = false },
  };
  
diff --cc arch/x86/kvm/svm/svm.h
index a7508177c11a,172c2a37e60e..000000000000
--- a/arch/x86/kvm/svm/svm.h
+++ b/arch/x86/kvm/svm/svm.h
@@@ -29,10 -29,11 +29,15 @@@
  #define	IOPM_SIZE PAGE_SIZE * 3
  #define	MSRPM_SIZE PAGE_SIZE * 2
  
++<<<<<<< HEAD
 +#define MAX_DIRECT_ACCESS_MSRS	20
 +#define MSRPM_OFFSETS	16
++=======
+ #define MAX_DIRECT_ACCESS_MSRS	46
+ #define MSRPM_OFFSETS	32
++>>>>>>> 5c127c85472c (KVM: SVM: Adding support for configuring x2APIC MSRs interception)
  extern u32 msrpm_offsets[MSRPM_OFFSETS] __read_mostly;
  extern bool npt_enabled;
 -extern int vgif;
  extern bool intercept_smi;
  
  enum avic_modes {
* Unmerged path arch/x86/kvm/svm/svm.c
* Unmerged path arch/x86/kvm/svm/svm.h
