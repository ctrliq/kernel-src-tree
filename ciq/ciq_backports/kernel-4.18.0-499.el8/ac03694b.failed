ipv6: icmp6: add drop reason support to icmpv6_echo_reply()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-499.el8
commit-author Eric Dumazet <edumazet@google.com>
commit ac03694bc009703022cf45a9c90675d5505c584c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-499.el8/ac03694b.failed

Change icmpv6_echo_reply() to return a drop reason.

For the moment, return NOT_SPECIFIED or SKB_CONSUMED.

	Signed-off-by: Eric Dumazet <edumazet@google.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit ac03694bc009703022cf45a9c90675d5505c584c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv6/icmp.c
diff --cc net/ipv6/icmp.c
index 58b7804d918a,1f53f2a74480..000000000000
--- a/net/ipv6/icmp.c
+++ b/net/ipv6/icmp.c
@@@ -686,18 -719,36 +686,35 @@@ static enum skb_drop_reason icmpv6_echo
  	struct dst_entry *dst;
  	struct ipcm6_cookie ipc6;
  	u32 mark = IP6_REPLY_MARK(net, skb->mark);
++<<<<<<< HEAD
 +
 +	saddr = &ipv6_hdr(skb)->daddr;
 +
++=======
+ 	SKB_DR(reason);
+ 	bool acast;
+ 	u8 type;
+ 
+ 	if (ipv6_addr_is_multicast(&ipv6_hdr(skb)->daddr) &&
+ 	    net->ipv6.sysctl.icmpv6_echo_ignore_multicast)
+ 		return reason;
+ 
+ 	saddr = &ipv6_hdr(skb)->daddr;
+ 
+ 	acast = ipv6_anycast_destination(skb_dst(skb), saddr);
+ 	if (acast && net->ipv6.sysctl.icmpv6_echo_ignore_anycast)
+ 		return reason;
+ 
++>>>>>>> ac03694bc009 (ipv6: icmp6: add drop reason support to icmpv6_echo_reply())
  	if (!ipv6_unicast_destination(skb) &&
 -	    !(net->ipv6.sysctl.anycast_src_echo_reply && acast))
 +	    !(net->ipv6.sysctl.anycast_src_echo_reply &&
 +	      ipv6_anycast_destination(skb_dst(skb), saddr)))
  		saddr = NULL;
  
 -	if (icmph->icmp6_type == ICMPV6_EXT_ECHO_REQUEST)
 -		type = ICMPV6_EXT_ECHO_REPLY;
 -	else
 -		type = ICMPV6_ECHO_REPLY;
 -
  	memcpy(&tmp_hdr, icmph, sizeof(tmp_hdr));
 -	tmp_hdr.icmp6_type = type;
 +	tmp_hdr.icmp6_type = ICMPV6_ECHO_REPLY;
  
  	memset(&fl6, 0, sizeof(fl6));
 -	if (net->ipv6.sysctl.flowlabel_reflect & FLOWLABEL_REFLECT_ICMPV6_ECHO_REPLIES)
 -		fl6.flowlabel = ip6_flowlabel(ipv6_hdr(skb));
 -
  	fl6.flowi6_proto = IPPROTO_ICMPV6;
  	fl6.daddr = ipv6_hdr(skb)->saddr;
  	if (saddr)
@@@ -745,17 -805,24 +762,19 @@@
  	} else {
  		icmpv6_push_pending_frames(sk, &fl6, &tmp_hdr,
  					   skb->len + sizeof(struct icmp6hdr));
+ 		reason = SKB_CONSUMED;
  	}
 -out_dst_release:
  	dst_release(dst);
  out:
  	icmpv6_xmit_unlock(sk);
  out_bh_enable:
  	local_bh_enable();
+ 	return reason;
  }
  
 -enum skb_drop_reason icmpv6_notify(struct sk_buff *skb, u8 type,
 -				   u8 code, __be32 info)
 +void icmpv6_notify(struct sk_buff *skb, u8 type, u8 code, __be32 info)
  {
 -	struct inet6_skb_parm *opt = IP6CB(skb);
 -	struct net *net = dev_net(skb->dev);
  	const struct inet6_protocol *ipprot;
 -	enum skb_drop_reason reason;
  	int inner_offset;
  	__be16 frag_off;
  	u8 nexthdr;
@@@ -857,7 -931,13 +876,17 @@@ static int icmpv6_rcv(struct sk_buff *s
  
  	switch (type) {
  	case ICMPV6_ECHO_REQUEST:
++<<<<<<< HEAD
 +		icmpv6_echo_reply(skb);
++=======
+ 		if (!net->ipv6.sysctl.icmpv6_echo_ignore_all)
+ 			reason = icmpv6_echo_reply(skb);
+ 		break;
+ 	case ICMPV6_EXT_ECHO_REQUEST:
+ 		if (!net->ipv6.sysctl.icmpv6_echo_ignore_all &&
+ 		    READ_ONCE(net->ipv4.sysctl_icmp_echo_enable_probe))
+ 			reason = icmpv6_echo_reply(skb);
++>>>>>>> ac03694bc009 (ipv6: icmp6: add drop reason support to icmpv6_echo_reply())
  		break;
  
  	case ICMPV6_ECHO_REPLY:
* Unmerged path net/ipv6/icmp.c
