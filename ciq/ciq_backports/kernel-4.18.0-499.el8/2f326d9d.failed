ipv6: icmp6: add drop reason support to ndisc_router_discovery()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-499.el8
commit-author Eric Dumazet <edumazet@google.com>
commit 2f326d9d9ff46fb2e45fb3b6ae77eff04332dde6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-499.el8/2f326d9d.failed

Change ndisc_router_discovery() to return a drop reason.

For the moment, return PKT_TOO_SMALL, NOT_SPECIFIED
and SKB_CONSUMED.

More reasons are added later.

	Signed-off-by: Eric Dumazet <edumazet@google.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 2f326d9d9ff46fb2e45fb3b6ae77eff04332dde6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv6/ndisc.c
diff --cc net/ipv6/ndisc.c
index 33b2d2fbbba7,7c8ba308ea49..000000000000
--- a/net/ipv6/ndisc.c
+++ b/net/ipv6/ndisc.c
@@@ -1156,19 -1231,21 +1156,28 @@@ errout
  	rtnl_set_sk_err(net, RTNLGRP_ND_USEROPT, err);
  }
  
- static void ndisc_router_discovery(struct sk_buff *skb)
+ static enum skb_drop_reason ndisc_router_discovery(struct sk_buff *skb)
  {
  	struct ra_msg *ra_msg = (struct ra_msg *)skb_transport_header(skb);
+ 	bool send_ifinfo_notify = false;
  	struct neighbour *neigh = NULL;
++<<<<<<< HEAD
 +	struct inet6_dev *in6_dev;
 +	struct fib6_info *rt = NULL;
 +	struct net *net;
 +	int lifetime;
++=======
++>>>>>>> 2f326d9d9ff4 (ipv6: icmp6: add drop reason support to ndisc_router_discovery())
  	struct ndisc_options ndopts;
- 	int optlen;
+ 	struct fib6_info *rt = NULL;
+ 	struct inet6_dev *in6_dev;
+ 	u32 defrtr_usr_metric;
  	unsigned int pref = 0;
  	__u32 old_if_flags;
- 	bool send_ifinfo_notify = false;
+ 	struct net *net;
+ 	SKB_DR(reason);
+ 	int lifetime;
+ 	int optlen;
  
  	__u8 *opt = (__u8 *)(ra_msg + 1);
  
@@@ -1290,11 -1364,14 +1297,11 @@@
  				  "RA: %s got default router without neighbour\n",
  				  __func__);
  			fib6_info_release(rt);
- 			return;
+ 			return reason;
  		}
  	}
 -	/* Set default route metric as specified by user */
 -	defrtr_usr_metric = in6_dev->cnf.ra_defrtr_metric;
 -	/* delete the route if lifetime is 0 or if metric needs change */
 -	if (rt && (lifetime == 0 || rt->fib6_metric != defrtr_usr_metric)) {
 -		ip6_del_rt(net, rt, false);
 +	if (rt && lifetime == 0) {
 +		ip6_del_rt(net, rt);
  		rt = NULL;
  	}
  
@@@ -1309,22 -1389,26 +1316,22 @@@
  			ND_PRINTK(0, err,
  				  "RA: %s failed to add default route\n",
  				  __func__);
- 			return;
+ 			return reason;
  		}
  
 -		neigh = ip6_neigh_lookup(&rt->fib6_nh->fib_nh_gw6,
 -					 rt->fib6_nh->fib_nh_dev, NULL,
 +		neigh = ip6_neigh_lookup(&rt->fib6_nh.nh_gw,
 +					 rt->fib6_nh.nh_dev, NULL,
  					  &ipv6_hdr(skb)->saddr);
  		if (!neigh) {
  			ND_PRINTK(0, err,
  				  "RA: %s got default router without neighbour\n",
  				  __func__);
  			fib6_info_release(rt);
- 			return;
+ 			return reason;
  		}
  		neigh->flags |= NTF_ROUTER;
 -	} else if (rt && IPV6_EXTRACT_PREF(rt->fib6_flags) != pref) {
 -		struct nl_info nlinfo = {
 -			.nl_net = net,
 -		};
 +	} else if (rt) {
  		rt->fib6_flags = (rt->fib6_flags & ~RTF_PREF_MASK) | RTF_PREF(pref);
 -		inet6_rt_notify(RTM_NEWROUTE, rt, &nlinfo, NLM_F_REPLACE);
  	}
  
  	if (rt)
* Unmerged path net/ipv6/ndisc.c
