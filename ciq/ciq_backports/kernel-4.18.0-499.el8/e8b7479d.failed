ASoC: SOF: Intel: hda-codec: use GPL-2.0-only license

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-499.el8
commit-author Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
commit e8b7479d06d565432f87d684d2876d0b0d1f0210
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-499.el8/e8b7479d.failed

All the HDAudio codec handling is completely specific to Linux and
completely dependency on GPL2.0 code, specifically the snd_hdac_
library.

There was no intention to have a dual-license for this code, this was
an oversight that needs to be corrected. Update the SPDX and
EXPORT_SYMBOL information, no functionality change otherwise.

	Signed-off-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
	Reviewed-by: Rander Wang <rander.wang@intel.com>
	Reviewed-by: Bard Liao <yung-chuan.liao@linux.intel.com>
	Reviewed-by: PÃ©ter Ujfalusi <peter.ujfalusi@linux.intel.com>
	Reviewed-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
Link: https://lore.kernel.org/r/20221027193540.259520-21-pierre-louis.bossart@linux.intel.com
	Signed-off-by: Mark Brown <broonie@kernel.org>
(cherry picked from commit e8b7479d06d565432f87d684d2876d0b0d1f0210)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/soc/sof/intel/hda-codec.c
diff --cc sound/soc/sof/intel/hda-codec.c
index 054ae8172679,64a7c51a9992..000000000000
--- a/sound/soc/sof/intel/hda-codec.c
+++ b/sound/soc/sof/intel/hda-codec.c
@@@ -80,6 -80,7 +77,10 @@@ void hda_codec_jack_wake_enable(struct 
  
  	snd_hdac_chip_updatew(bus, WAKEEN, STATESTS_INT_MASK, mask);
  }
++<<<<<<< HEAD
++=======
+ EXPORT_SYMBOL_NS_GPL(hda_codec_jack_wake_enable, SND_SOC_SOF_HDA_AUDIO_CODEC);
++>>>>>>> e8b7479d06d5 (ASoC: SOF: Intel: hda-codec: use GPL-2.0-only license)
  
  /* check jack status after resuming from suspend mode */
  void hda_codec_jack_check(struct snd_sof_dev *sdev)
@@@ -95,12 -96,7 +96,16 @@@
  		if (codec->jacktbl.used)
  			pm_request_resume(&codec->core.dev);
  }
++<<<<<<< HEAD
 +#else
 +void hda_codec_jack_wake_enable(struct snd_sof_dev *sdev, bool enable) {}
 +void hda_codec_jack_check(struct snd_sof_dev *sdev) {}
 +#endif /* CONFIG_SND_SOC_SOF_HDA_AUDIO_CODEC */
 +EXPORT_SYMBOL(hda_codec_jack_wake_enable);
 +EXPORT_SYMBOL(hda_codec_jack_check);
++=======
+ EXPORT_SYMBOL_NS_GPL(hda_codec_jack_check, SND_SOC_SOF_HDA_AUDIO_CODEC);
++>>>>>>> e8b7479d06d5 (ASoC: SOF: Intel: hda-codec: use GPL-2.0-only license)
  
  #if IS_ENABLED(CONFIG_SND_HDA_GENERIC)
  #define is_generic_config(bus) \
@@@ -246,7 -221,131 +251,135 @@@ void hda_codec_probe_bus(struct snd_sof
  		}
  	}
  }
++<<<<<<< HEAD
 +EXPORT_SYMBOL(hda_codec_probe_bus);
++=======
+ EXPORT_SYMBOL_NS_GPL(hda_codec_probe_bus, SND_SOC_SOF_HDA_AUDIO_CODEC);
+ 
+ void hda_codec_check_for_state_change(struct snd_sof_dev *sdev)
+ {
+ 	struct hdac_bus *bus = sof_to_bus(sdev);
+ 	unsigned int codec_mask;
+ 
+ 	codec_mask = snd_hdac_chip_readw(bus, STATESTS);
+ 	if (codec_mask) {
+ 		hda_codec_jack_check(sdev);
+ 		snd_hdac_chip_writew(bus, STATESTS, codec_mask);
+ 	}
+ }
+ EXPORT_SYMBOL_NS_GPL(hda_codec_check_for_state_change, SND_SOC_SOF_HDA_AUDIO_CODEC);
+ 
+ void hda_codec_detect_mask(struct snd_sof_dev *sdev)
+ {
+ 	struct hdac_bus *bus = sof_to_bus(sdev);
+ 
+ 	/* Accept unsolicited responses */
+ 	snd_hdac_chip_updatel(bus, GCTL, AZX_GCTL_UNSOL, AZX_GCTL_UNSOL);
+ 
+ 	/* detect codecs */
+ 	if (!bus->codec_mask) {
+ 		bus->codec_mask = snd_hdac_chip_readw(bus, STATESTS);
+ 		dev_dbg(bus->dev, "codec_mask = 0x%lx\n", bus->codec_mask);
+ 	}
+ 
+ 	if (hda_codec_mask != -1) {
+ 		bus->codec_mask &= hda_codec_mask;
+ 		dev_dbg(bus->dev, "filtered codec_mask = 0x%lx\n",
+ 			bus->codec_mask);
+ 	}
+ }
+ EXPORT_SYMBOL_NS_GPL(hda_codec_detect_mask, SND_SOC_SOF_HDA_AUDIO_CODEC);
+ 
+ void hda_codec_init_cmd_io(struct snd_sof_dev *sdev)
+ {
+ 	struct hdac_bus *bus = sof_to_bus(sdev);
+ 
+ 	/* initialize the codec command I/O */
+ 	snd_hdac_bus_init_cmd_io(bus);
+ }
+ EXPORT_SYMBOL_NS_GPL(hda_codec_init_cmd_io, SND_SOC_SOF_HDA_AUDIO_CODEC);
+ 
+ void hda_codec_resume_cmd_io(struct snd_sof_dev *sdev)
+ {
+ 	struct hdac_bus *bus = sof_to_bus(sdev);
+ 
+ 	/* set up CORB/RIRB buffers if was on before suspend */
+ 	if (bus->cmd_dma_state)
+ 		snd_hdac_bus_init_cmd_io(bus);
+ }
+ EXPORT_SYMBOL_NS_GPL(hda_codec_resume_cmd_io, SND_SOC_SOF_HDA_AUDIO_CODEC);
+ 
+ void hda_codec_stop_cmd_io(struct snd_sof_dev *sdev)
+ {
+ 	struct hdac_bus *bus = sof_to_bus(sdev);
+ 
+ 	/* initialize the codec command I/O */
+ 	snd_hdac_bus_stop_cmd_io(bus);
+ }
+ EXPORT_SYMBOL_NS_GPL(hda_codec_stop_cmd_io, SND_SOC_SOF_HDA_AUDIO_CODEC);
+ 
+ void hda_codec_suspend_cmd_io(struct snd_sof_dev *sdev)
+ {
+ 	struct hdac_bus *bus = sof_to_bus(sdev);
+ 
+ 	/* stop the CORB/RIRB DMA if it is On */
+ 	if (bus->cmd_dma_state)
+ 		snd_hdac_bus_stop_cmd_io(bus);
+ 
+ }
+ EXPORT_SYMBOL_NS_GPL(hda_codec_suspend_cmd_io, SND_SOC_SOF_HDA_AUDIO_CODEC);
+ 
+ void hda_codec_rirb_status_clear(struct snd_sof_dev *sdev)
+ {
+ 	struct hdac_bus *bus = sof_to_bus(sdev);
+ 
+ 	/* clear rirb status */
+ 	snd_hdac_chip_writeb(bus, RIRBSTS, RIRB_INT_MASK);
+ }
+ EXPORT_SYMBOL_NS_GPL(hda_codec_rirb_status_clear, SND_SOC_SOF_HDA_AUDIO_CODEC);
+ 
+ void hda_codec_set_codec_wakeup(struct snd_sof_dev *sdev, bool status)
+ {
+ 	struct hdac_bus *bus = sof_to_bus(sdev);
+ 
+ 	snd_hdac_set_codec_wakeup(bus, status);
+ }
+ EXPORT_SYMBOL_NS_GPL(hda_codec_set_codec_wakeup, SND_SOC_SOF_HDA_AUDIO_CODEC);
+ 
+ bool hda_codec_check_rirb_status(struct snd_sof_dev *sdev)
+ {
+ 	struct hdac_bus *bus = sof_to_bus(sdev);
+ 	bool active = false;
+ 	u32 rirb_status;
+ 
+ 	rirb_status = snd_hdac_chip_readb(bus, RIRBSTS);
+ 	if (rirb_status & RIRB_INT_MASK) {
+ 		/*
+ 		 * Clearing the interrupt status here ensures
+ 		 * that no interrupt gets masked after the RIRB
+ 		 * wp is read in snd_hdac_bus_update_rirb.
+ 		 */
+ 		snd_hdac_chip_writeb(bus, RIRBSTS,
+ 				     RIRB_INT_MASK);
+ 		active = true;
+ 		if (rirb_status & RIRB_INT_RESPONSE)
+ 			snd_hdac_bus_update_rirb(bus);
+ 	}
+ 	return active;
+ }
+ EXPORT_SYMBOL_NS_GPL(hda_codec_check_rirb_status, SND_SOC_SOF_HDA_AUDIO_CODEC);
+ 
+ void hda_codec_device_remove(struct snd_sof_dev *sdev)
+ {
+ 	struct hdac_bus *bus = sof_to_bus(sdev);
+ 
+ 	/* codec removal, invoke bus_device_remove */
+ 	snd_hdac_ext_bus_device_remove(bus);
+ }
+ EXPORT_SYMBOL_NS_GPL(hda_codec_device_remove, SND_SOC_SOF_HDA_AUDIO_CODEC);
+ 
+ #endif /* CONFIG_SND_SOC_SOF_HDA_AUDIO_CODEC */
++>>>>>>> e8b7479d06d5 (ASoC: SOF: Intel: hda-codec: use GPL-2.0-only license)
  
  #if IS_ENABLED(CONFIG_SND_SOC_SOF_HDA_AUDIO_CODEC) && IS_ENABLED(CONFIG_SND_HDA_CODEC_HDMI)
  
@@@ -259,7 -358,7 +392,11 @@@ void hda_codec_i915_display_power(struc
  		snd_hdac_display_power(bus, HDA_CODEC_IDX_CONTROLLER, enable);
  	}
  }
++<<<<<<< HEAD
 +EXPORT_SYMBOL(hda_codec_i915_display_power);
++=======
+ EXPORT_SYMBOL_NS_GPL(hda_codec_i915_display_power, SND_SOC_SOF_HDA_AUDIO_CODEC_I915);
++>>>>>>> e8b7479d06d5 (ASoC: SOF: Intel: hda-codec: use GPL-2.0-only license)
  
  int hda_codec_i915_init(struct snd_sof_dev *sdev)
  {
@@@ -276,7 -375,7 +413,11 @@@
  
  	return 0;
  }
++<<<<<<< HEAD
 +EXPORT_SYMBOL(hda_codec_i915_init);
++=======
+ EXPORT_SYMBOL_NS_GPL(hda_codec_i915_init, SND_SOC_SOF_HDA_AUDIO_CODEC_I915);
++>>>>>>> e8b7479d06d5 (ASoC: SOF: Intel: hda-codec: use GPL-2.0-only license)
  
  int hda_codec_i915_exit(struct snd_sof_dev *sdev)
  {
@@@ -290,7 -389,7 +431,11 @@@
  
  	return snd_hdac_i915_exit(bus);
  }
++<<<<<<< HEAD
 +EXPORT_SYMBOL(hda_codec_i915_exit);
++=======
+ EXPORT_SYMBOL_NS_GPL(hda_codec_i915_exit, SND_SOC_SOF_HDA_AUDIO_CODEC_I915);
++>>>>>>> e8b7479d06d5 (ASoC: SOF: Intel: hda-codec: use GPL-2.0-only license)
  
  #endif
  
* Unmerged path sound/soc/sof/intel/hda-codec.c
