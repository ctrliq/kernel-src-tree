soundwire: intel: move bus common sequences to different file

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-499.el8
commit-author Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
commit 1a1a6a692e9cd58c235651fa281219dab02afeed
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-499.el8/1a1a6a69.failed

Now that the bus start/stop/clock_stop sequences use the ops, we can
move them to a different file to reuse them.

Note that we could in theory remove the abstraction for all those
sequences and directly call the functions in intel_auxdevice.c. To
allow for more flexibility and have means to special-case new
platforms, we decided to keep the abstraction. If in time it becomes
clear there is no benefit the abstraction will be simplified.

	Signed-off-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
	Reviewed-by: Rander Wang <rander.wang@intel.com>
	Signed-off-by: Bard Liao <yung-chuan.liao@linux.intel.com>
Link: https://lore.kernel.org/r/20230314015410.487311-9-yung-chuan.liao@linux.intel.com
	Signed-off-by: Vinod Koul <vkoul@kernel.org>
(cherry picked from commit 1a1a6a692e9cd58c235651fa281219dab02afeed)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/soundwire/Makefile
#	drivers/soundwire/intel.c
diff --cc drivers/soundwire/Makefile
index 986776787b9e,8038e840ac5b..000000000000
--- a/drivers/soundwire/Makefile
+++ b/drivers/soundwire/Makefile
@@@ -20,7 -20,8 +20,12 @@@ soundwire-cadence-y := cadence_master.
  obj-$(CONFIG_SOUNDWIRE_CADENCE) += soundwire-cadence.o
  
  #Intel driver
++<<<<<<< HEAD
 +soundwire-intel-y :=	intel.o intel_init.o dmi-quirks.o
++=======
+ soundwire-intel-y :=	intel.o intel_auxdevice.o intel_init.o dmi-quirks.o \
+ 			intel_bus_common.o
++>>>>>>> 1a1a6a692e9c (soundwire: intel: move bus common sequences to different file)
  obj-$(CONFIG_SOUNDWIRE_INTEL) += soundwire-intel.o
  
  #Qualcomm driver
diff --cc drivers/soundwire/intel.c
index 0f130e4b38bd,77d698908595..000000000000
--- a/drivers/soundwire/intel.c
+++ b/drivers/soundwire/intel.c
@@@ -1178,820 -1122,31 +1178,823 @@@ static int intel_register_dai(struct sd
  					       dais, num_dai);
  }
  
++<<<<<<< HEAD
 +static int intel_start_bus(struct sdw_intel *sdw)
 +{
 +	struct device *dev = sdw->cdns.dev;
 +	struct sdw_cdns *cdns = &sdw->cdns;
 +	struct sdw_bus *bus = &cdns->bus;
 +	int ret;
 +
 +	ret = sdw_cdns_enable_interrupt(cdns, true);
 +	if (ret < 0) {
 +		dev_err(dev, "%s: cannot enable interrupts: %d\n", __func__, ret);
 +		return ret;
 +	}
 +
 +	/*
 +	 * follow recommended programming flows to avoid timeouts when
 +	 * gsync is enabled
 +	 */
 +	if (bus->multi_link)
 +		intel_shim_sync_arm(sdw);
 +
 +	ret = sdw_cdns_init(cdns);
 +	if (ret < 0) {
 +		dev_err(dev, "%s: unable to initialize Cadence IP: %d\n", __func__, ret);
 +		goto err_interrupt;
 +	}
 +
 +	ret = sdw_cdns_exit_reset(cdns);
 +	if (ret < 0) {
 +		dev_err(dev, "%s: unable to exit bus reset sequence: %d\n", __func__, ret);
 +		goto err_interrupt;
 +	}
 +
 +	if (bus->multi_link) {
 +		ret = intel_shim_sync_go(sdw);
 +		if (ret < 0) {
 +			dev_err(dev, "%s: sync go failed: %d\n", __func__, ret);
 +			goto err_interrupt;
 +		}
 +	}
 +	sdw_cdns_check_self_clearing_bits(cdns, __func__,
 +					  true, INTEL_MASTER_RESET_ITERATIONS);
 +
 +	return 0;
 +
 +err_interrupt:
 +	sdw_cdns_enable_interrupt(cdns, false);
 +	return ret;
 +}
 +
 +static int intel_start_bus_after_reset(struct sdw_intel *sdw)
 +{
 +	struct device *dev = sdw->cdns.dev;
 +	struct sdw_cdns *cdns = &sdw->cdns;
 +	struct sdw_bus *bus = &cdns->bus;
 +	bool clock_stop0;
 +	int status;
 +	int ret;
 +
 +	/*
 +	 * An exception condition occurs for the CLK_STOP_BUS_RESET
 +	 * case if one or more masters remain active. In this condition,
 +	 * all the masters are powered on for they are in the same power
 +	 * domain. Master can preserve its context for clock stop0, so
 +	 * there is no need to clear slave status and reset bus.
 +	 */
 +	clock_stop0 = sdw_cdns_is_clock_stop(&sdw->cdns);
 +
 +	if (!clock_stop0) {
 +
 +		/*
 +		 * make sure all Slaves are tagged as UNATTACHED and
 +		 * provide reason for reinitialization
 +		 */
 +
 +		status = SDW_UNATTACH_REQUEST_MASTER_RESET;
 +		sdw_clear_slave_status(bus, status);
 +
 +		ret = sdw_cdns_enable_interrupt(cdns, true);
 +		if (ret < 0) {
 +			dev_err(dev, "cannot enable interrupts during resume\n");
 +			return ret;
 +		}
 +
 +		/*
 +		 * follow recommended programming flows to avoid
 +		 * timeouts when gsync is enabled
 +		 */
 +		if (bus->multi_link)
 +			intel_shim_sync_arm(sdw);
 +
 +		/*
 +		 * Re-initialize the IP since it was powered-off
 +		 */
 +		sdw_cdns_init(&sdw->cdns);
 +
 +	} else {
 +		ret = sdw_cdns_enable_interrupt(cdns, true);
 +		if (ret < 0) {
 +			dev_err(dev, "cannot enable interrupts during resume\n");
 +			return ret;
 +		}
 +	}
 +
 +	ret = sdw_cdns_clock_restart(cdns, !clock_stop0);
 +	if (ret < 0) {
 +		dev_err(dev, "unable to restart clock during resume\n");
 +		goto err_interrupt;
 +	}
 +
 +	if (!clock_stop0) {
 +		ret = sdw_cdns_exit_reset(cdns);
 +		if (ret < 0) {
 +			dev_err(dev, "unable to exit bus reset sequence during resume\n");
 +			goto err_interrupt;
 +		}
 +
 +		if (bus->multi_link) {
 +			ret = intel_shim_sync_go(sdw);
 +			if (ret < 0) {
 +				dev_err(sdw->cdns.dev, "sync go failed during resume\n");
 +				goto err_interrupt;
 +			}
 +		}
 +	}
 +	sdw_cdns_check_self_clearing_bits(cdns, __func__, true, INTEL_MASTER_RESET_ITERATIONS);
 +
 +	return 0;
 +
 +err_interrupt:
 +	sdw_cdns_enable_interrupt(cdns, false);
 +	return ret;
 +}
 +
 +static void intel_check_clock_stop(struct sdw_intel *sdw)
 +{
 +	struct device *dev = sdw->cdns.dev;
 +	bool clock_stop0;
 +
 +	clock_stop0 = sdw_cdns_is_clock_stop(&sdw->cdns);
 +	if (!clock_stop0)
 +		dev_err(dev, "%s: invalid configuration, clock was not stopped\n", __func__);
 +}
 +
 +static int intel_start_bus_after_clock_stop(struct sdw_intel *sdw)
 +{
 +	struct device *dev = sdw->cdns.dev;
 +	struct sdw_cdns *cdns = &sdw->cdns;
 +	int ret;
 +
 +	ret = sdw_cdns_enable_interrupt(cdns, true);
 +	if (ret < 0) {
 +		dev_err(dev, "%s: cannot enable interrupts: %d\n", __func__, ret);
 +		return ret;
 +	}
 +
 +	ret = sdw_cdns_clock_restart(cdns, false);
 +	if (ret < 0) {
 +		dev_err(dev, "%s: unable to restart clock: %d\n", __func__, ret);
 +		sdw_cdns_enable_interrupt(cdns, false);
 +		return ret;
 +	}
 +
 +	sdw_cdns_check_self_clearing_bits(cdns, "intel_resume_runtime no_quirks",
 +					  true, INTEL_MASTER_RESET_ITERATIONS);
 +
 +	return 0;
 +}
 +
 +static int intel_stop_bus(struct sdw_intel *sdw, bool clock_stop)
 +{
 +	struct device *dev = sdw->cdns.dev;
 +	struct sdw_cdns *cdns = &sdw->cdns;
 +	bool wake_enable = false;
 +	int ret;
 +
 +	if (clock_stop) {
 +		ret = sdw_cdns_clock_stop(cdns, true);
 +		if (ret < 0)
 +			dev_err(dev, "%s: cannot stop clock: %d\n", __func__, ret);
 +		else
 +			wake_enable = true;
 +	}
 +
 +	ret = sdw_cdns_enable_interrupt(cdns, false);
 +	if (ret < 0) {
 +		dev_err(dev, "%s: cannot disable interrupts: %d\n", __func__, ret);
 +		return ret;
 +	}
 +
 +	ret = sdw_intel_link_power_down(sdw);
 +	if (ret) {
 +		dev_err(dev, "%s: Link power down failed: %d\n", __func__, ret);
 +		return ret;
 +	}
 +
 +	sdw_intel_shim_wake(sdw, wake_enable);
 +
 +	return 0;
 +}
++=======
++>>>>>>> 1a1a6a692e9c (soundwire: intel: move bus common sequences to different file)
 +
 +static int sdw_master_read_intel_prop(struct sdw_bus *bus)
 +{
 +	struct sdw_master_prop *prop = &bus->prop;
 +	struct fwnode_handle *link;
 +	char name[32];
 +	u32 quirk_mask;
 +
 +	/* Find master handle */
 +	snprintf(name, sizeof(name),
 +		 "mipi-sdw-link-%d-subproperties", bus->link_id);
 +
 +	link = device_get_named_child_node(bus->dev, name);
 +	if (!link) {
 +		dev_err(bus->dev, "Master node %s not found\n", name);
 +		return -EIO;
 +	}
 +
 +	fwnode_property_read_u32(link,
 +				 "intel-sdw-ip-clock",
 +				 &prop->mclk_freq);
 +
 +	/* the values reported by BIOS are the 2x clock, not the bus clock */
 +	prop->mclk_freq /= 2;
  
 -const struct sdw_intel_hw_ops sdw_intel_cnl_hw_ops = {
 -	.debugfs_init = intel_debugfs_init,
 -	.debugfs_exit = intel_debugfs_exit,
 +	fwnode_property_read_u32(link,
 +				 "intel-quirk-mask",
 +				 &quirk_mask);
  
 -	.register_dai = intel_register_dai,
 +	if (quirk_mask & SDW_INTEL_QUIRK_MASK_BUS_DISABLE)
 +		prop->hw_disabled = true;
  
 -	.check_clock_stop = intel_check_clock_stop,
 -	.start_bus = intel_start_bus,
 -	.start_bus_after_reset = intel_start_bus_after_reset,
 -	.start_bus_after_clock_stop = intel_start_bus_after_clock_stop,
 -	.stop_bus = intel_stop_bus,
 +	prop->quirks = SDW_MASTER_QUIRKS_CLEAR_INITIAL_CLASH |
 +		SDW_MASTER_QUIRKS_CLEAR_INITIAL_PARITY;
  
 -	.link_power_up = intel_link_power_up,
 -	.link_power_down = intel_link_power_down,
 +	return 0;
 +}
  
 -	.shim_check_wake = intel_shim_check_wake,
 -	.shim_wake = intel_shim_wake,
 +static int intel_prop_read(struct sdw_bus *bus)
 +{
 +	/* Initialize with default handler to read all DisCo properties */
 +	sdw_master_read_prop(bus);
  
 +	/* read Intel-specific properties */
 +	sdw_master_read_intel_prop(bus);
 +
 +	return 0;
 +}
 +
 +static struct sdw_master_ops sdw_intel_ops = {
 +	.read_prop = intel_prop_read,
 +	.override_adr = sdw_dmi_override_adr,
 +	.xfer_msg = cdns_xfer_msg,
 +	.xfer_msg_defer = cdns_xfer_msg_defer,
 +	.reset_page_addr = cdns_reset_page_addr,
 +	.set_bus_conf = cdns_bus_conf,
  	.pre_bank_switch = intel_pre_bank_switch,
  	.post_bank_switch = intel_post_bank_switch,
 +	.read_ping_status = cdns_read_ping_status,
 +};
 +
 +/*
 + * probe and init (aux_dev_id argument is required by function prototype but not used)
 + */
 +static int intel_link_probe(struct auxiliary_device *auxdev,
 +			    const struct auxiliary_device_id *aux_dev_id)
 +
 +{
 +	struct device *dev = &auxdev->dev;
 +	struct sdw_intel_link_dev *ldev = auxiliary_dev_to_sdw_intel_link_dev(auxdev);
 +	struct sdw_intel *sdw;
 +	struct sdw_cdns *cdns;
 +	struct sdw_bus *bus;
 +	int ret;
 +
 +	sdw = devm_kzalloc(dev, sizeof(*sdw), GFP_KERNEL);
 +	if (!sdw)
 +		return -ENOMEM;
 +
 +	cdns = &sdw->cdns;
 +	bus = &cdns->bus;
 +
 +	sdw->instance = auxdev->id;
 +	sdw->link_res = &ldev->link_res;
 +	cdns->dev = dev;
 +	cdns->registers = sdw->link_res->registers;
 +	cdns->instance = sdw->instance;
 +	cdns->msg_count = 0;
 +
 +	bus->link_id = auxdev->id;
 +	bus->dev_num_ida_min = INTEL_DEV_NUM_IDA_MIN;
 +	bus->clk_stop_timeout = 1;
 +
 +	sdw_cdns_probe(cdns);
 +
 +	/* Set ops */
 +	bus->ops = &sdw_intel_ops;
 +
 +	/* set driver data, accessed by snd_soc_dai_get_drvdata() */
 +	auxiliary_set_drvdata(auxdev, cdns);
 +
 +	/* use generic bandwidth allocation algorithm */
 +	sdw->cdns.bus.compute_params = sdw_compute_params;
 +
 +	/* avoid resuming from pm_runtime suspend if it's not required */
 +	dev_pm_set_driver_flags(dev, DPM_FLAG_SMART_SUSPEND);
 +
 +	ret = sdw_bus_master_add(bus, dev, dev->fwnode);
 +	if (ret) {
 +		dev_err(dev, "sdw_bus_master_add fail: %d\n", ret);
 +		return ret;
 +	}
 +
 +	if (bus->prop.hw_disabled)
 +		dev_info(dev,
 +			 "SoundWire master %d is disabled, will be ignored\n",
 +			 bus->link_id);
 +	/*
 +	 * Ignore BIOS err_threshold, it's a really bad idea when dealing
 +	 * with multiple hardware synchronized links
 +	 */
 +	bus->prop.err_threshold = 0;
 +
 +	return 0;
 +}
 +
 +int intel_link_startup(struct auxiliary_device *auxdev)
 +{
 +	struct device *dev = &auxdev->dev;
 +	struct sdw_cdns *cdns = auxiliary_get_drvdata(auxdev);
 +	struct sdw_intel *sdw = cdns_to_intel(cdns);
 +	struct sdw_bus *bus = &cdns->bus;
 +	int link_flags;
 +	bool multi_link;
 +	u32 clock_stop_quirks;
 +	int ret;
 +
 +	if (bus->prop.hw_disabled) {
 +		dev_info(dev,
 +			 "SoundWire master %d is disabled, ignoring\n",
 +			 sdw->instance);
 +		return 0;
 +	}
 +
 +	link_flags = md_flags >> (bus->link_id * 8);
 +	multi_link = !(link_flags & SDW_INTEL_MASTER_DISABLE_MULTI_LINK);
 +	if (!multi_link) {
 +		dev_dbg(dev, "Multi-link is disabled\n");
 +	} else {
 +		/*
 +		 * hardware-based synchronization is required regardless
 +		 * of the number of segments used by a stream: SSP-based
 +		 * synchronization is gated by gsync when the multi-master
 +		 * mode is set.
 +		 */
 +		bus->hw_sync_min_links = 1;
 +	}
 +	bus->multi_link = multi_link;
 +
 +	/* Initialize shim, controller */
 +	ret = intel_link_power_up(sdw);
 +	if (ret)
 +		goto err_init;
 +
 +	/* Register DAIs */
 +	ret = intel_register_dai(sdw);
 +	if (ret) {
 +		dev_err(dev, "DAI registration failed: %d\n", ret);
 +		goto err_power_up;
 +	}
 +
 +	intel_debugfs_init(sdw);
 +
 +	/* start bus */
 +	ret = intel_start_bus(sdw);
 +	if (ret) {
 +		dev_err(dev, "bus start failed: %d\n", ret);
 +		goto err_power_up;
 +	}
 +
 +	/* Enable runtime PM */
 +	if (!(link_flags & SDW_INTEL_MASTER_DISABLE_PM_RUNTIME)) {
 +		pm_runtime_set_autosuspend_delay(dev,
 +						 INTEL_MASTER_SUSPEND_DELAY_MS);
 +		pm_runtime_use_autosuspend(dev);
 +		pm_runtime_mark_last_busy(dev);
 +
 +		pm_runtime_set_active(dev);
 +		pm_runtime_enable(dev);
 +	}
 +
 +	clock_stop_quirks = sdw->link_res->clock_stop_quirks;
 +	if (clock_stop_quirks & SDW_INTEL_CLK_STOP_NOT_ALLOWED) {
 +		/*
 +		 * To keep the clock running we need to prevent
 +		 * pm_runtime suspend from happening by increasing the
 +		 * reference count.
 +		 * This quirk is specified by the parent PCI device in
 +		 * case of specific latency requirements. It will have
 +		 * no effect if pm_runtime is disabled by the user via
 +		 * a module parameter for testing purposes.
 +		 */
 +		pm_runtime_get_noresume(dev);
 +	}
 +
 +	/*
 +	 * The runtime PM status of Slave devices is "Unsupported"
 +	 * until they report as ATTACHED. If they don't, e.g. because
 +	 * there are no Slave devices populated or if the power-on is
 +	 * delayed or dependent on a power switch, the Master will
 +	 * remain active and prevent its parent from suspending.
 +	 *
 +	 * Conditionally force the pm_runtime core to re-evaluate the
 +	 * Master status in the absence of any Slave activity. A quirk
 +	 * is provided to e.g. deal with Slaves that may be powered on
 +	 * with a delay. A more complete solution would require the
 +	 * definition of Master properties.
 +	 */
 +	if (!(link_flags & SDW_INTEL_MASTER_DISABLE_PM_RUNTIME_IDLE))
 +		pm_runtime_idle(dev);
 +
 +	sdw->startup_done = true;
 +	return 0;
 +
 +err_power_up:
 +	intel_link_power_down(sdw);
 +err_init:
 +	return ret;
 +}
 +
 +static void intel_link_remove(struct auxiliary_device *auxdev)
 +{
 +	struct sdw_cdns *cdns = auxiliary_get_drvdata(auxdev);
 +	struct sdw_intel *sdw = cdns_to_intel(cdns);
 +	struct sdw_bus *bus = &cdns->bus;
 +
 +	/*
 +	 * Since pm_runtime is already disabled, we don't decrease
 +	 * the refcount when the clock_stop_quirk is
 +	 * SDW_INTEL_CLK_STOP_NOT_ALLOWED
 +	 */
 +	if (!bus->prop.hw_disabled) {
 +		intel_debugfs_exit(sdw);
 +		sdw_cdns_enable_interrupt(cdns, false);
 +	}
 +	sdw_bus_master_delete(bus);
 +}
 +
 +int intel_link_process_wakeen_event(struct auxiliary_device *auxdev)
 +{
 +	struct device *dev = &auxdev->dev;
 +	struct sdw_intel *sdw;
 +	struct sdw_bus *bus;
 +
 +	sdw = auxiliary_get_drvdata(auxdev);
 +	bus = &sdw->cdns.bus;
 +
 +	if (bus->prop.hw_disabled || !sdw->startup_done) {
 +		dev_dbg(dev, "SoundWire master %d is disabled or not-started, ignoring\n",
 +			bus->link_id);
 +		return 0;
 +	}
 +
 +	if (!intel_shim_check_wake(sdw))
 +		return 0;
 +
 +	/* disable WAKEEN interrupt ASAP to prevent interrupt flood */
 +	intel_shim_wake(sdw, false);
 +
 +	/*
 +	 * resume the Master, which will generate a bus reset and result in
 +	 * Slaves re-attaching and be re-enumerated. The SoundWire physical
 +	 * device which generated the wake will trigger an interrupt, which
 +	 * will in turn cause the corresponding Linux Slave device to be
 +	 * resumed and the Slave codec driver to check the status.
 +	 */
 +	pm_request_resume(dev);
 +
 +	return 0;
 +}
 +
 +/*
 + * PM calls
 + */
 +
 +static int intel_resume_child_device(struct device *dev, void *data)
 +{
 +	int ret;
 +	struct sdw_slave *slave = dev_to_sdw_dev(dev);
 +
 +	if (!slave->probed) {
 +		dev_dbg(dev, "skipping device, no probed driver\n");
 +		return 0;
 +	}
 +	if (!slave->dev_num_sticky) {
 +		dev_dbg(dev, "skipping device, never detected on bus\n");
 +		return 0;
 +	}
 +
 +	ret = pm_request_resume(dev);
 +	if (ret < 0)
 +		dev_err(dev, "%s: pm_request_resume failed: %d\n", __func__, ret);
 +
 +	return ret;
 +}
 +
 +static int __maybe_unused intel_pm_prepare(struct device *dev)
 +{
 +	struct sdw_cdns *cdns = dev_get_drvdata(dev);
 +	struct sdw_intel *sdw = cdns_to_intel(cdns);
 +	struct sdw_bus *bus = &cdns->bus;
 +	u32 clock_stop_quirks;
 +	int ret;
 +
 +	if (bus->prop.hw_disabled || !sdw->startup_done) {
 +		dev_dbg(dev, "SoundWire master %d is disabled or not-started, ignoring\n",
 +			bus->link_id);
 +		return 0;
 +	}
 +
 +	clock_stop_quirks = sdw->link_res->clock_stop_quirks;
 +
 +	if (pm_runtime_suspended(dev) &&
 +	    pm_runtime_suspended(dev->parent) &&
 +	    ((clock_stop_quirks & SDW_INTEL_CLK_STOP_BUS_RESET) ||
 +	     !clock_stop_quirks)) {
 +		/*
 +		 * if we've enabled clock stop, and the parent is suspended, the SHIM registers
 +		 * are not accessible and the shim wake cannot be disabled.
 +		 * The only solution is to resume the entire bus to full power
 +		 */
 +
 +		/*
 +		 * If any operation in this block fails, we keep going since we don't want
 +		 * to prevent system suspend from happening and errors should be recoverable
 +		 * on resume.
 +		 */
 +
 +		/*
 +		 * first resume the device for this link. This will also by construction
 +		 * resume the PCI parent device.
 +		 */
 +		ret = pm_request_resume(dev);
 +		if (ret < 0) {
 +			dev_err(dev, "%s: pm_request_resume failed: %d\n", __func__, ret);
 +			return 0;
 +		}
 +
 +		/*
 +		 * Continue resuming the entire bus (parent + child devices) to exit
 +		 * the clock stop mode. If there are no devices connected on this link
 +		 * this is a no-op.
 +		 * The resume to full power could have been implemented with a .prepare
 +		 * step in SoundWire codec drivers. This would however require a lot
 +		 * of code to handle an Intel-specific corner case. It is simpler in
 +		 * practice to add a loop at the link level.
 +		 */
 +		ret = device_for_each_child(bus->dev, NULL, intel_resume_child_device);
 +
 +		if (ret < 0)
 +			dev_err(dev, "%s: intel_resume_child_device failed: %d\n", __func__, ret);
 +	}
 +
 +	return 0;
 +}
 +
 +static int __maybe_unused intel_suspend(struct device *dev)
 +{
 +	struct sdw_cdns *cdns = dev_get_drvdata(dev);
 +	struct sdw_intel *sdw = cdns_to_intel(cdns);
 +	struct sdw_bus *bus = &cdns->bus;
 +	u32 clock_stop_quirks;
 +	int ret;
 +
 +	if (bus->prop.hw_disabled || !sdw->startup_done) {
 +		dev_dbg(dev, "SoundWire master %d is disabled or not-started, ignoring\n",
 +			bus->link_id);
 +		return 0;
 +	}
 +
 +	if (pm_runtime_suspended(dev)) {
 +		dev_dbg(dev, "pm_runtime status: suspended\n");
 +
 +		clock_stop_quirks = sdw->link_res->clock_stop_quirks;
 +
 +		if ((clock_stop_quirks & SDW_INTEL_CLK_STOP_BUS_RESET) ||
 +		    !clock_stop_quirks) {
 +
 +			if (pm_runtime_suspended(dev->parent)) {
 +				/*
 +				 * paranoia check: this should not happen with the .prepare
 +				 * resume to full power
 +				 */
 +				dev_err(dev, "%s: invalid config: parent is suspended\n", __func__);
 +			} else {
 +				intel_shim_wake(sdw, false);
 +			}
 +		}
  
 -	.sync_arm = intel_shim_sync_arm,
 -	.sync_go_unlocked = intel_shim_sync_go_unlocked,
 -	.sync_go = intel_shim_sync_go,
 +		return 0;
 +	}
 +
 +	ret = intel_stop_bus(sdw, false);
 +	if (ret < 0) {
 +		dev_err(dev, "%s: cannot stop bus: %d\n", __func__, ret);
 +		return ret;
 +	}
 +
 +	return 0;
 +}
 +
 +static int __maybe_unused intel_suspend_runtime(struct device *dev)
 +{
 +	struct sdw_cdns *cdns = dev_get_drvdata(dev);
 +	struct sdw_intel *sdw = cdns_to_intel(cdns);
 +	struct sdw_bus *bus = &cdns->bus;
 +	u32 clock_stop_quirks;
 +	int ret;
 +
 +	if (bus->prop.hw_disabled || !sdw->startup_done) {
 +		dev_dbg(dev, "SoundWire master %d is disabled or not-started, ignoring\n",
 +			bus->link_id);
 +		return 0;
 +	}
 +
 +	clock_stop_quirks = sdw->link_res->clock_stop_quirks;
 +
 +	if (clock_stop_quirks & SDW_INTEL_CLK_STOP_TEARDOWN) {
 +		ret = intel_stop_bus(sdw, false);
 +		if (ret < 0) {
 +			dev_err(dev, "%s: cannot stop bus during teardown: %d\n",
 +				__func__, ret);
 +			return ret;
 +		}
 +	} else if (clock_stop_quirks & SDW_INTEL_CLK_STOP_BUS_RESET || !clock_stop_quirks) {
 +		ret = intel_stop_bus(sdw, true);
 +		if (ret < 0) {
 +			dev_err(dev, "%s: cannot stop bus during clock_stop: %d\n",
 +				__func__, ret);
 +			return ret;
 +		}
 +	} else {
 +		dev_err(dev, "%s clock_stop_quirks %x unsupported\n",
 +			__func__, clock_stop_quirks);
 +		ret = -EINVAL;
 +	}
 +
 +	return ret;
 +}
 +
 +static int __maybe_unused intel_resume(struct device *dev)
 +{
 +	struct sdw_cdns *cdns = dev_get_drvdata(dev);
 +	struct sdw_intel *sdw = cdns_to_intel(cdns);
 +	struct sdw_bus *bus = &cdns->bus;
 +	int link_flags;
 +	int ret;
 +
 +	if (bus->prop.hw_disabled || !sdw->startup_done) {
 +		dev_dbg(dev, "SoundWire master %d is disabled or not-started, ignoring\n",
 +			bus->link_id);
 +		return 0;
 +	}
 +
 +	link_flags = md_flags >> (bus->link_id * 8);
 +
 +	if (pm_runtime_suspended(dev)) {
 +		dev_dbg(dev, "pm_runtime status was suspended, forcing active\n");
 +
 +		/* follow required sequence from runtime_pm.rst */
 +		pm_runtime_disable(dev);
 +		pm_runtime_set_active(dev);
 +		pm_runtime_mark_last_busy(dev);
 +		pm_runtime_enable(dev);
 +
 +		link_flags = md_flags >> (bus->link_id * 8);
 +
 +		if (!(link_flags & SDW_INTEL_MASTER_DISABLE_PM_RUNTIME_IDLE))
 +			pm_runtime_idle(dev);
 +	}
 +
 +	ret = intel_link_power_up(sdw);
 +	if (ret) {
 +		dev_err(dev, "%s failed: %d\n", __func__, ret);
 +		return ret;
 +	}
 +
 +	/*
 +	 * make sure all Slaves are tagged as UNATTACHED and provide
 +	 * reason for reinitialization
 +	 */
 +	sdw_clear_slave_status(bus, SDW_UNATTACH_REQUEST_MASTER_RESET);
 +
 +	ret = intel_start_bus(sdw);
 +	if (ret < 0) {
 +		dev_err(dev, "cannot start bus during resume\n");
 +		intel_link_power_down(sdw);
 +		return ret;
 +	}
 +
 +	/*
 +	 * after system resume, the pm_runtime suspend() may kick in
 +	 * during the enumeration, before any children device force the
 +	 * master device to remain active.  Using pm_runtime_get()
 +	 * routines is not really possible, since it'd prevent the
 +	 * master from suspending.
 +	 * A reasonable compromise is to update the pm_runtime
 +	 * counters and delay the pm_runtime suspend by several
 +	 * seconds, by when all enumeration should be complete.
 +	 */
 +	pm_runtime_mark_last_busy(dev);
 +
 +	return 0;
 +}
 +
 +static int __maybe_unused intel_resume_runtime(struct device *dev)
 +{
 +	struct sdw_cdns *cdns = dev_get_drvdata(dev);
 +	struct sdw_intel *sdw = cdns_to_intel(cdns);
 +	struct sdw_bus *bus = &cdns->bus;
 +	u32 clock_stop_quirks;
 +	int ret;
 +
 +	if (bus->prop.hw_disabled || !sdw->startup_done) {
 +		dev_dbg(dev, "SoundWire master %d is disabled or not-started, ignoring\n",
 +			bus->link_id);
 +		return 0;
 +	}
 +
 +	/* unconditionally disable WAKEEN interrupt */
 +	intel_shim_wake(sdw, false);
 +
 +	clock_stop_quirks = sdw->link_res->clock_stop_quirks;
 +
 +	if (clock_stop_quirks & SDW_INTEL_CLK_STOP_TEARDOWN) {
 +		ret = intel_link_power_up(sdw);
 +		if (ret) {
 +			dev_err(dev, "%s: power_up failed after teardown: %d\n", __func__, ret);
 +			return ret;
 +		}
 +
 +		/*
 +		 * make sure all Slaves are tagged as UNATTACHED and provide
 +		 * reason for reinitialization
 +		 */
 +		sdw_clear_slave_status(bus, SDW_UNATTACH_REQUEST_MASTER_RESET);
 +
 +		ret = intel_start_bus(sdw);
 +		if (ret < 0) {
 +			dev_err(dev, "%s: cannot start bus after teardown: %d\n", __func__, ret);
 +			intel_link_power_down(sdw);
 +			return ret;
 +		}
 +
 +
 +	} else if (clock_stop_quirks & SDW_INTEL_CLK_STOP_BUS_RESET) {
 +		ret = intel_link_power_up(sdw);
 +		if (ret) {
 +			dev_err(dev, "%s: power_up failed after bus reset: %d\n", __func__, ret);
 +			return ret;
 +		}
 +
 +		ret = intel_start_bus_after_reset(sdw);
 +		if (ret < 0) {
 +			dev_err(dev, "%s: cannot start bus after reset: %d\n", __func__, ret);
 +			intel_link_power_down(sdw);
 +			return ret;
 +		}
 +	} else if (!clock_stop_quirks) {
 +
 +		intel_check_clock_stop(sdw);
 +
 +		ret = intel_link_power_up(sdw);
 +		if (ret) {
 +			dev_err(dev, "%s: power_up failed: %d\n", __func__, ret);
 +			return ret;
 +		}
 +
 +		ret = intel_start_bus_after_clock_stop(sdw);
 +		if (ret < 0) {
 +			dev_err(dev, "%s: cannot start bus after clock stop: %d\n", __func__, ret);
 +			intel_link_power_down(sdw);
 +			return ret;
 +		}
 +	} else {
 +		dev_err(dev, "%s: clock_stop_quirks %x unsupported\n",
 +			__func__, clock_stop_quirks);
 +		ret = -EINVAL;
 +	}
 +
 +	return ret;
 +}
 +
 +static const struct dev_pm_ops intel_pm = {
 +	.prepare = intel_pm_prepare,
 +	SET_SYSTEM_SLEEP_PM_OPS(intel_suspend, intel_resume)
 +	SET_RUNTIME_PM_OPS(intel_suspend_runtime, intel_resume_runtime, NULL)
 +};
 +
 +static const struct auxiliary_device_id intel_link_id_table[] = {
 +	{ .name = "soundwire_intel.link" },
 +	{},
 +};
 +MODULE_DEVICE_TABLE(auxiliary, intel_link_id_table);
 +
 +static struct auxiliary_driver sdw_intel_drv = {
 +	.probe = intel_link_probe,
 +	.remove = intel_link_remove,
 +	.driver = {
 +		/* auxiliary_driver_register() sets .name to be the modname */
 +		.pm = &intel_pm,
 +	},
 +	.id_table = intel_link_id_table
  };
 -EXPORT_SYMBOL_NS(sdw_intel_cnl_hw_ops, SOUNDWIRE_INTEL);
 +module_auxiliary_driver(sdw_intel_drv);
  
 +MODULE_LICENSE("Dual BSD/GPL");
 +MODULE_DESCRIPTION("Intel Soundwire Link Driver");
* Unmerged path drivers/soundwire/Makefile
* Unmerged path drivers/soundwire/intel.c
diff --git a/drivers/soundwire/intel.h b/drivers/soundwire/intel.h
index cd93a44dba9a..0dae0365e653 100644
--- a/drivers/soundwire/intel.h
+++ b/drivers/soundwire/intel.h
@@ -58,4 +58,11 @@ struct sdw_intel_link_dev {
 #define auxiliary_dev_to_sdw_intel_link_dev(auxiliary_dev) \
 	container_of(auxiliary_dev, struct sdw_intel_link_dev, auxdev)
 
+/* common bus management */
+int intel_start_bus(struct sdw_intel *sdw);
+int intel_start_bus_after_reset(struct sdw_intel *sdw);
+void intel_check_clock_stop(struct sdw_intel *sdw);
+int intel_start_bus_after_clock_stop(struct sdw_intel *sdw);
+int intel_stop_bus(struct sdw_intel *sdw, bool clock_stop);
+
 #endif /* __SDW_INTEL_LOCAL_H */
diff --git a/drivers/soundwire/intel_bus_common.c b/drivers/soundwire/intel_bus_common.c
new file mode 100644
index 000000000000..9a06ab58018b
--- /dev/null
+++ b/drivers/soundwire/intel_bus_common.c
@@ -0,0 +1,210 @@
+// SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)
+// Copyright(c) 2015-2023 Intel Corporation. All rights reserved.
+
+#include <linux/acpi.h>
+#include <linux/soundwire/sdw_registers.h>
+#include <linux/soundwire/sdw.h>
+#include <linux/soundwire/sdw_intel.h>
+#include "cadence_master.h"
+#include "bus.h"
+#include "intel.h"
+
+int intel_start_bus(struct sdw_intel *sdw)
+{
+	struct device *dev = sdw->cdns.dev;
+	struct sdw_cdns *cdns = &sdw->cdns;
+	struct sdw_bus *bus = &cdns->bus;
+	int ret;
+
+	ret = sdw_cdns_enable_interrupt(cdns, true);
+	if (ret < 0) {
+		dev_err(dev, "%s: cannot enable interrupts: %d\n", __func__, ret);
+		return ret;
+	}
+
+	/*
+	 * follow recommended programming flows to avoid timeouts when
+	 * gsync is enabled
+	 */
+	if (bus->multi_link)
+		sdw_intel_sync_arm(sdw);
+
+	ret = sdw_cdns_init(cdns);
+	if (ret < 0) {
+		dev_err(dev, "%s: unable to initialize Cadence IP: %d\n", __func__, ret);
+		goto err_interrupt;
+	}
+
+	ret = sdw_cdns_exit_reset(cdns);
+	if (ret < 0) {
+		dev_err(dev, "%s: unable to exit bus reset sequence: %d\n", __func__, ret);
+		goto err_interrupt;
+	}
+
+	if (bus->multi_link) {
+		ret = sdw_intel_sync_go(sdw);
+		if (ret < 0) {
+			dev_err(dev, "%s: sync go failed: %d\n", __func__, ret);
+			goto err_interrupt;
+		}
+	}
+	sdw_cdns_check_self_clearing_bits(cdns, __func__,
+					  true, INTEL_MASTER_RESET_ITERATIONS);
+
+	return 0;
+
+err_interrupt:
+	sdw_cdns_enable_interrupt(cdns, false);
+	return ret;
+}
+
+int intel_start_bus_after_reset(struct sdw_intel *sdw)
+{
+	struct device *dev = sdw->cdns.dev;
+	struct sdw_cdns *cdns = &sdw->cdns;
+	struct sdw_bus *bus = &cdns->bus;
+	bool clock_stop0;
+	int status;
+	int ret;
+
+	/*
+	 * An exception condition occurs for the CLK_STOP_BUS_RESET
+	 * case if one or more masters remain active. In this condition,
+	 * all the masters are powered on for they are in the same power
+	 * domain. Master can preserve its context for clock stop0, so
+	 * there is no need to clear slave status and reset bus.
+	 */
+	clock_stop0 = sdw_cdns_is_clock_stop(&sdw->cdns);
+
+	if (!clock_stop0) {
+
+		/*
+		 * make sure all Slaves are tagged as UNATTACHED and
+		 * provide reason for reinitialization
+		 */
+
+		status = SDW_UNATTACH_REQUEST_MASTER_RESET;
+		sdw_clear_slave_status(bus, status);
+
+		ret = sdw_cdns_enable_interrupt(cdns, true);
+		if (ret < 0) {
+			dev_err(dev, "cannot enable interrupts during resume\n");
+			return ret;
+		}
+
+		/*
+		 * follow recommended programming flows to avoid
+		 * timeouts when gsync is enabled
+		 */
+		if (bus->multi_link)
+			sdw_intel_sync_arm(sdw);
+
+		/*
+		 * Re-initialize the IP since it was powered-off
+		 */
+		sdw_cdns_init(&sdw->cdns);
+
+	} else {
+		ret = sdw_cdns_enable_interrupt(cdns, true);
+		if (ret < 0) {
+			dev_err(dev, "cannot enable interrupts during resume\n");
+			return ret;
+		}
+	}
+
+	ret = sdw_cdns_clock_restart(cdns, !clock_stop0);
+	if (ret < 0) {
+		dev_err(dev, "unable to restart clock during resume\n");
+		goto err_interrupt;
+	}
+
+	if (!clock_stop0) {
+		ret = sdw_cdns_exit_reset(cdns);
+		if (ret < 0) {
+			dev_err(dev, "unable to exit bus reset sequence during resume\n");
+			goto err_interrupt;
+		}
+
+		if (bus->multi_link) {
+			ret = sdw_intel_sync_go(sdw);
+			if (ret < 0) {
+				dev_err(sdw->cdns.dev, "sync go failed during resume\n");
+				goto err_interrupt;
+			}
+		}
+	}
+	sdw_cdns_check_self_clearing_bits(cdns, __func__, true, INTEL_MASTER_RESET_ITERATIONS);
+
+	return 0;
+
+err_interrupt:
+	sdw_cdns_enable_interrupt(cdns, false);
+	return ret;
+}
+
+void intel_check_clock_stop(struct sdw_intel *sdw)
+{
+	struct device *dev = sdw->cdns.dev;
+	bool clock_stop0;
+
+	clock_stop0 = sdw_cdns_is_clock_stop(&sdw->cdns);
+	if (!clock_stop0)
+		dev_err(dev, "%s: invalid configuration, clock was not stopped\n", __func__);
+}
+
+int intel_start_bus_after_clock_stop(struct sdw_intel *sdw)
+{
+	struct device *dev = sdw->cdns.dev;
+	struct sdw_cdns *cdns = &sdw->cdns;
+	int ret;
+
+	ret = sdw_cdns_enable_interrupt(cdns, true);
+	if (ret < 0) {
+		dev_err(dev, "%s: cannot enable interrupts: %d\n", __func__, ret);
+		return ret;
+	}
+
+	ret = sdw_cdns_clock_restart(cdns, false);
+	if (ret < 0) {
+		dev_err(dev, "%s: unable to restart clock: %d\n", __func__, ret);
+		sdw_cdns_enable_interrupt(cdns, false);
+		return ret;
+	}
+
+	sdw_cdns_check_self_clearing_bits(cdns, "intel_resume_runtime no_quirks",
+					  true, INTEL_MASTER_RESET_ITERATIONS);
+
+	return 0;
+}
+
+int intel_stop_bus(struct sdw_intel *sdw, bool clock_stop)
+{
+	struct device *dev = sdw->cdns.dev;
+	struct sdw_cdns *cdns = &sdw->cdns;
+	bool wake_enable = false;
+	int ret;
+
+	if (clock_stop) {
+		ret = sdw_cdns_clock_stop(cdns, true);
+		if (ret < 0)
+			dev_err(dev, "%s: cannot stop clock: %d\n", __func__, ret);
+		else
+			wake_enable = true;
+	}
+
+	ret = sdw_cdns_enable_interrupt(cdns, false);
+	if (ret < 0) {
+		dev_err(dev, "%s: cannot disable interrupts: %d\n", __func__, ret);
+		return ret;
+	}
+
+	ret = sdw_intel_link_power_down(sdw);
+	if (ret) {
+		dev_err(dev, "%s: Link power down failed: %d\n", __func__, ret);
+		return ret;
+	}
+
+	sdw_intel_shim_wake(sdw, wake_enable);
+
+	return 0;
+}
