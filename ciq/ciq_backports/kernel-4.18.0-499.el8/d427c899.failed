net-next: skbuff: refactor pskb_pull

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-499.el8
commit-author Richard Gobert <richardbgobert@gmail.com>
commit d427c8999b071af2003203b42a007c4a80156c18
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-499.el8/d427c899.failed

pskb_may_pull already contains all of the checks performed by
pskb_pull.
Use pskb_may_pull for validation in pskb_pull, eliminating the
duplication and making __pskb_pull obsolete.
Replace __pskb_pull with pskb_pull where applicable.

	Signed-off-by: Richard Gobert <richardbgobert@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit d427c8999b071af2003203b42a007c4a80156c18)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/skbuff.h
diff --cc include/linux/skbuff.h
index 16143289a49f,9fcf534f2d92..000000000000
--- a/include/linux/skbuff.h
+++ b/include/linux/skbuff.h
@@@ -2357,28 -2612,16 +2357,32 @@@ static inline void *skb_pull_inline(str
  	return unlikely(len > skb->len) ? NULL : __skb_pull(skb, len);
  }
  
 -void *skb_pull_data(struct sk_buff *skb, size_t len);
 -
  void *__pskb_pull_tail(struct sk_buff *skb, int delta);
  
++<<<<<<< HEAD
 +static inline void *__pskb_pull(struct sk_buff *skb, unsigned int len)
 +{
 +	if (len > skb_headlen(skb) &&
 +	    !__pskb_pull_tail(skb, len - skb_headlen(skb)))
 +		return NULL;
 +	skb->len -= len;
 +	return skb->data += len;
 +}
 +
 +static inline void *pskb_pull(struct sk_buff *skb, unsigned int len)
 +{
 +	return unlikely(len > skb->len) ? NULL : __pskb_pull(skb, len);
 +}
 +
 +static inline int pskb_may_pull(struct sk_buff *skb, unsigned int len)
++=======
+ static inline bool pskb_may_pull(struct sk_buff *skb, unsigned int len)
++>>>>>>> d427c8999b07 (net-next: skbuff: refactor pskb_pull)
  {
  	if (likely(len <= skb_headlen(skb)))
 -		return true;
 +		return 1;
  	if (unlikely(len > skb->len))
 -		return false;
 +		return 0;
  	return __pskb_pull_tail(skb, len - skb_headlen(skb)) != NULL;
  }
  
* Unmerged path include/linux/skbuff.h
diff --git a/net/ipv6/ip6_offload.c b/net/ipv6/ip6_offload.c
index 34e480bbc5e4..b3dfa44c6715 100644
--- a/net/ipv6/ip6_offload.c
+++ b/net/ipv6/ip6_offload.c
@@ -215,7 +215,7 @@ INDIRECT_CALLABLE_SCOPE struct sk_buff *ipv6_gro_receive(struct list_head *head,
 	proto = iph->nexthdr;
 	ops = rcu_dereference(inet6_offloads[proto]);
 	if (!ops || !ops->callbacks.gro_receive) {
-		__pskb_pull(skb, skb_gro_offset(skb));
+		pskb_pull(skb, skb_gro_offset(skb));
 		skb_gro_frag0_invalidate(skb);
 		proto = ipv6_gso_pull_exthdrs(skb, proto);
 		skb_gro_pull(skb, -skb_transport_offset(skb));
diff --git a/net/mac80211/rx.c b/net/mac80211/rx.c
index c5f1f9db75b3..31c5f2c9f03c 100644
--- a/net/mac80211/rx.c
+++ b/net/mac80211/rx.c
@@ -49,7 +49,7 @@ static struct sk_buff *ieee80211_clean_skb(struct sk_buff *skb,
 
 	if (present_fcs_len)
 		__pskb_trim(skb, skb->len - present_fcs_len);
-	__pskb_pull(skb, rtap_space);
+	pskb_pull(skb, rtap_space);
 
 	hdr = (void *)skb->data;
 	fc = hdr->frame_control;
@@ -74,7 +74,7 @@ static struct sk_buff *ieee80211_clean_skb(struct sk_buff *skb,
 
 	memmove(skb->data + IEEE80211_HT_CTL_LEN, skb->data,
 		hdrlen - IEEE80211_HT_CTL_LEN);
-	__pskb_pull(skb, IEEE80211_HT_CTL_LEN);
+	pskb_pull(skb, IEEE80211_HT_CTL_LEN);
 
 	return skb;
 }
diff --git a/net/xfrm/espintcp.c b/net/xfrm/espintcp.c
index d85b85982178..3ec8b637498e 100644
--- a/net/xfrm/espintcp.c
+++ b/net/xfrm/espintcp.c
@@ -91,7 +91,7 @@ static void espintcp_rcv(struct strparser *strp, struct sk_buff *skb)
 	}
 
 	/* remove header, leave non-ESP marker/SPI */
-	if (!__pskb_pull(skb, rxm->offset + 2)) {
+	if (!pskb_pull(skb, rxm->offset + 2)) {
 		XFRM_INC_STATS(sock_net(strp->sk), LINUX_MIB_XFRMINERROR);
 		kfree_skb(skb);
 		return;
