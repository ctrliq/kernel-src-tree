KVM: x86: Allow APICv APIC ID inhibit to be cleared

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-499.el8
commit-author Greg Edwards <gedwards@ddn.com>
commit d471bd853d38117c90ec02ecc51b3ca731674745
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-499.el8/d471bd85.failed

Legacy kernels prior to commit 4399c03c6780 ("x86/apic: Remove
verify_local_APIC()") write the APIC ID of the boot CPU twice to verify
a functioning local APIC.  This results in APIC acceleration inhibited
on these kernels for reason APICV_INHIBIT_REASON_APIC_ID_MODIFIED.

Allow the APICV_INHIBIT_REASON_APIC_ID_MODIFIED inhibit reason to be
cleared if/when all APICs in xAPIC mode set their APIC ID back to the
expected vcpu_id value.

Fold the functionality previously in kvm_lapic_xapic_id_updated() into
kvm_recalculate_apic_map(), as this allows examining all APICs in one
pass.

Fixes: 3743c2f02517 ("KVM: x86: inhibit APICv/AVIC on changes to APIC ID or APIC base")
	Signed-off-by: Greg Edwards <gedwards@ddn.com>
Link: https://lore.kernel.org/r/20221117183247.94314-1-gedwards@ddn.com
	Signed-off-by: Sean Christopherson <seanjc@google.com>
Message-Id: <20230106011306.85230-33-seanjc@google.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit d471bd853d38117c90ec02ecc51b3ca731674745)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/lapic.c
diff --cc arch/x86/kvm/lapic.c
index b2ebf9176db0,856e81a2dc64..000000000000
--- a/arch/x86/kvm/lapic.c
+++ b/arch/x86/kvm/lapic.c
@@@ -2135,26 -2175,14 +2150,37 @@@ static void apic_manage_nmi_watchdog(st
  	}
  }
  
++<<<<<<< HEAD
 +static void kvm_lapic_xapic_id_updated(struct kvm_lapic *apic)
 +{
 +	struct kvm *kvm = apic->vcpu->kvm;
 +
 +	if (!kvm_apic_hw_enabled(apic))
 +		return;
 +
 +	if (KVM_BUG_ON(apic_x2apic_mode(apic), kvm))
 +		return;
 +
 +	/*
 +	 * Deliberately truncate the vCPU ID when detecting a modified APIC ID
 +	 * to avoid false positives if the vCPU ID, i.e. x2APIC ID, is a 32-bit
 +	 * value.  If the wrap/truncation results in unwanted aliasing, APICv
 +	 * will be inhibited as part of updating KVM's optimized APIC maps.
 +	 */
 +	if (kvm_xapic_id(apic) == (u8)apic->vcpu->vcpu_id)
 +		return;
 +
 +	kvm_set_apicv_inhibit(apic->vcpu->kvm, APICV_INHIBIT_REASON_APIC_ID_MODIFIED);
++=======
+ static int get_lvt_index(u32 reg)
+ {
+ 	if (reg == APIC_LVTCMCI)
+ 		return LVT_CMCI;
+ 	if (reg < APIC_LVTT || reg > APIC_LVTERR)
+ 		return -1;
+ 	return array_index_nospec(
+ 			(reg - APIC_LVTT) >> 4, KVM_APIC_MAX_NR_LVT_ENTRIES);
++>>>>>>> d471bd853d38 (KVM: x86: Allow APICv APIC ID inhibit to be cleared)
  }
  
  static int kvm_lapic_reg_write(struct kvm_lapic *apic, u32 reg, u32 val)
* Unmerged path arch/x86/kvm/lapic.c
