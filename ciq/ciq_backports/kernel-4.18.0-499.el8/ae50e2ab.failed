ALSA: hda: cs35l41: Check runtime suspend capability at runtime_idle

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-499.el8
commit-author Takashi Iwai <tiwai@suse.de>
commit ae50e2ab122cef68f46b7799fb9deffe3334f5e2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-499.el8/ae50e2ab.failed

The runtime PM core checks with runtime_idle callback whether it can
goes to the runtime suspend or not, and we can put the boost type
check there instead of runtime_suspend and _resume calls.  This will
reduce the unnecessary runtime_suspend() calls.

Fixes: 1873ebd30cc8 ("ALSA: hda: cs35l41: Support Hibernation during Suspend")
	Cc: <stable@vger.kernel.org>
Link: https://lore.kernel.org/r/20230105093531.16960-2-tiwai@suse.de
	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit ae50e2ab122cef68f46b7799fb9deffe3334f5e2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/pci/hda/cs35l41_hda.c
diff --cc sound/pci/hda/cs35l41_hda.c
index a8f8b4e8bc18,f7815ee24f83..000000000000
--- a/sound/pci/hda/cs35l41_hda.c
+++ b/sound/pci/hda/cs35l41_hda.c
@@@ -571,6 -573,89 +571,92 @@@ static int cs35l41_hda_channel_map(stru
  				    rx_slot);
  }
  
++<<<<<<< HEAD
++=======
+ static void cs35l41_ready_for_reset(struct cs35l41_hda *cs35l41)
+ {
+ 	mutex_lock(&cs35l41->fw_mutex);
+ 	if (cs35l41->firmware_running) {
+ 
+ 		regcache_cache_only(cs35l41->regmap, false);
+ 
+ 		cs35l41_exit_hibernate(cs35l41->dev, cs35l41->regmap);
+ 		cs35l41_shutdown_dsp(cs35l41);
+ 		cs35l41_safe_reset(cs35l41->regmap, cs35l41->hw_cfg.bst_type);
+ 
+ 		regcache_cache_only(cs35l41->regmap, true);
+ 		regcache_mark_dirty(cs35l41->regmap);
+ 	}
+ 	mutex_unlock(&cs35l41->fw_mutex);
+ }
+ 
+ static int cs35l41_system_suspend(struct device *dev)
+ {
+ 	struct cs35l41_hda *cs35l41 = dev_get_drvdata(dev);
+ 	int ret;
+ 
+ 	dev_dbg(cs35l41->dev, "System Suspend\n");
+ 
+ 	if (cs35l41->hw_cfg.bst_type == CS35L41_EXT_BOOST_NO_VSPK_SWITCH) {
+ 		dev_err_once(cs35l41->dev, "System Suspend not supported\n");
+ 		return 0; /* don't block the whole system suspend */
+ 	}
+ 
+ 	ret = pm_runtime_force_suspend(dev);
+ 	if (ret)
+ 		return ret;
+ 
+ 	/* Shutdown DSP before system suspend */
+ 	cs35l41_ready_for_reset(cs35l41);
+ 
+ 	/*
+ 	 * Reset GPIO may be shared, so cannot reset here.
+ 	 * However beyond this point, amps may be powered down.
+ 	 */
+ 	return 0;
+ }
+ 
+ static int cs35l41_system_resume(struct device *dev)
+ {
+ 	struct cs35l41_hda *cs35l41 = dev_get_drvdata(dev);
+ 	int ret;
+ 
+ 	dev_dbg(cs35l41->dev, "System Resume\n");
+ 
+ 	if (cs35l41->hw_cfg.bst_type == CS35L41_EXT_BOOST_NO_VSPK_SWITCH) {
+ 		dev_err_once(cs35l41->dev, "System Resume not supported\n");
+ 		return 0; /* don't block the whole system resume */
+ 	}
+ 
+ 	if (cs35l41->reset_gpio) {
+ 		usleep_range(2000, 2100);
+ 		gpiod_set_value_cansleep(cs35l41->reset_gpio, 1);
+ 	}
+ 
+ 	usleep_range(2000, 2100);
+ 
+ 	ret = pm_runtime_force_resume(dev);
+ 
+ 	mutex_lock(&cs35l41->fw_mutex);
+ 	if (!ret && cs35l41->request_fw_load && !cs35l41->fw_request_ongoing) {
+ 		cs35l41->fw_request_ongoing = true;
+ 		schedule_work(&cs35l41->fw_load_work);
+ 	}
+ 	mutex_unlock(&cs35l41->fw_mutex);
+ 
+ 	return ret;
+ }
+ 
+ static int cs35l41_runtime_idle(struct device *dev)
+ {
+ 	struct cs35l41_hda *cs35l41 = dev_get_drvdata(dev);
+ 
+ 	if (cs35l41->hw_cfg.bst_type == CS35L41_EXT_BOOST_NO_VSPK_SWITCH)
+ 		return -EBUSY; /* suspend not supported yet on this model */
+ 	return 0;
+ }
+ 
++>>>>>>> ae50e2ab122c (ALSA: hda: cs35l41: Check runtime suspend capability at runtime_idle)
  static int cs35l41_runtime_suspend(struct device *dev)
  {
  	struct cs35l41_hda *cs35l41 = dev_get_drvdata(dev);
@@@ -1423,13 -1542,17 +1509,19 @@@ void cs35l41_hda_remove(struct device *
  	gpiod_put(cs35l41->reset_gpio);
  	kfree(cs35l41->acpi_subsystem_id);
  }
 -EXPORT_SYMBOL_NS_GPL(cs35l41_hda_remove, SND_HDA_SCODEC_CS35L41);
 +EXPORT_SYMBOL_GPL(cs35l41_hda_remove);
  
  const struct dev_pm_ops cs35l41_hda_pm_ops = {
++<<<<<<< HEAD
 +	SET_RUNTIME_PM_OPS(cs35l41_runtime_suspend, cs35l41_runtime_resume, NULL)
++=======
+ 	RUNTIME_PM_OPS(cs35l41_runtime_suspend, cs35l41_runtime_resume,
+ 		       cs35l41_runtime_idle)
+ 	SYSTEM_SLEEP_PM_OPS(cs35l41_system_suspend, cs35l41_system_resume)
++>>>>>>> ae50e2ab122c (ALSA: hda: cs35l41: Check runtime suspend capability at runtime_idle)
  };
 -EXPORT_SYMBOL_NS_GPL(cs35l41_hda_pm_ops, SND_HDA_SCODEC_CS35L41);
 +EXPORT_SYMBOL_GPL(cs35l41_hda_pm_ops);
  
  MODULE_DESCRIPTION("CS35L41 HDA Driver");
 -MODULE_IMPORT_NS(SND_HDA_CS_DSP_CONTROLS);
  MODULE_AUTHOR("Lucas Tanure, Cirrus Logic Inc, <tanureal@opensource.cirrus.com>");
  MODULE_LICENSE("GPL");
 -MODULE_IMPORT_NS(FW_CS_DSP);
* Unmerged path sound/pci/hda/cs35l41_hda.c
