efi: Store mask of supported runtime services in struct efi

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-499.el8
commit-author Ard Biesheuvel <ardb@kernel.org>
commit 96a3dd3dece8134ba19b0ded7e6663136d3107b9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-499.el8/96a3dd3d.failed

Revision 2.8 of the UEFI spec introduces provisions for firmware to
advertise lack of support for certain runtime services at OS runtime.
Let's store this mask in struct efi for easy access.

	Signed-off-by: Ard Biesheuvel <ardb@kernel.org>
(cherry picked from commit 96a3dd3dece8134ba19b0ded7e6663136d3107b9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/firmware/efi/efi.c
#	include/linux/efi.h
diff --cc drivers/firmware/efi/efi.c
index 8fd298143c0e,703a019d81b4..000000000000
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@@ -36,7 -34,7 +36,11 @@@
  #include <asm/early_ioremap.h>
  
  struct efi __read_mostly efi = {
++<<<<<<< HEAD
 +	.mps			= EFI_INVALID_TABLE_ADDR,
++=======
+ 	.runtime_supported_mask = EFI_RT_SUPPORTED_ALL,
++>>>>>>> 96a3dd3dece8 (efi: Store mask of supported runtime services in struct efi)
  	.acpi			= EFI_INVALID_TABLE_ADDR,
  	.acpi20			= EFI_INVALID_TABLE_ADDR,
  	.smbios			= EFI_INVALID_TABLE_ADDR,
diff --cc include/linux/efi.h
index 39ccebd964b7,57695f400044..000000000000
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@@ -1198,47 -521,57 +1198,99 @@@ typedef struct 
   * All runtime access to EFI goes through this structure:
   */
  extern struct efi {
++<<<<<<< HEAD
 +	efi_system_table_t *systab;	/* EFI system table */
 +	unsigned int runtime_version;	/* Runtime services version */
 +	unsigned long mps;		/* MPS table */
 +	unsigned long acpi;		/* ACPI table  (IA64 ext 0.71) */
 +	unsigned long acpi20;		/* ACPI table  (ACPI 2.0) */
 +	unsigned long smbios;		/* SMBIOS table (32 bit entry point) */
 +	unsigned long smbios3;		/* SMBIOS table (64 bit entry point) */
 +	unsigned long sal_systab;	/* SAL system table */
 +	unsigned long boot_info;	/* boot info table */
 +	unsigned long hcdp;		/* HCDP table */
 +	unsigned long uga;		/* UGA table */
 +	unsigned long fw_vendor;	/* fw_vendor */
 +	unsigned long runtime;		/* runtime table */
 +	unsigned long config_table;	/* config tables */
 +	unsigned long esrt;		/* ESRT table */
 +	unsigned long properties_table;	/* properties table */
 +	unsigned long mem_attr_table;	/* memory attributes table */
 +	unsigned long rng_seed;		/* UEFI firmware random seed */
 +	unsigned long tpm_log;		/* TPM2 Event Log table */
 +	unsigned long tpm_final_log;	/* TPM2 Final Events Log table */
 +	unsigned long mem_reserve;	/* Linux EFI memreserve table */
 +	unsigned long mokvar_table;	/* MOK variable config table */
 +	efi_get_time_t *get_time;
 +	efi_set_time_t *set_time;
 +	efi_get_wakeup_time_t *get_wakeup_time;
 +	efi_set_wakeup_time_t *set_wakeup_time;
 +	efi_get_variable_t *get_variable;
 +	efi_get_next_variable_t *get_next_variable;
 +	efi_set_variable_t *set_variable;
 +	efi_set_variable_t *set_variable_nonblocking;
 +	efi_query_variable_info_t *query_variable_info;
 +	efi_query_variable_info_t *query_variable_info_nonblocking;
 +	efi_update_capsule_t *update_capsule;
 +	efi_query_capsule_caps_t *query_capsule_caps;
 +	efi_get_next_high_mono_count_t *get_next_high_mono_count;
 +	efi_reset_system_t *reset_system;
 +	efi_set_virtual_address_map_t *set_virtual_address_map;
 +	struct efi_memory_map memmap;
 +	unsigned long flags;
++=======
+ 	const efi_runtime_services_t	*runtime;		/* EFI runtime services table */
+ 	unsigned int			runtime_version;	/* Runtime services version */
+ 	unsigned int			runtime_supported_mask;
+ 
+ 	unsigned long			acpi;			/* ACPI table  (IA64 ext 0.71) */
+ 	unsigned long			acpi20;			/* ACPI table  (ACPI 2.0) */
+ 	unsigned long			smbios;			/* SMBIOS table (32 bit entry point) */
+ 	unsigned long			smbios3;		/* SMBIOS table (64 bit entry point) */
+ 	unsigned long			esrt;			/* ESRT table */
+ 	unsigned long			tpm_log;		/* TPM2 Event Log table */
+ 	unsigned long			tpm_final_log;		/* TPM2 Final Events Log table */
+ 
+ 	efi_get_time_t			*get_time;
+ 	efi_set_time_t			*set_time;
+ 	efi_get_wakeup_time_t		*get_wakeup_time;
+ 	efi_set_wakeup_time_t		*set_wakeup_time;
+ 	efi_get_variable_t		*get_variable;
+ 	efi_get_next_variable_t		*get_next_variable;
+ 	efi_set_variable_t		*set_variable;
+ 	efi_set_variable_t		*set_variable_nonblocking;
+ 	efi_query_variable_info_t	*query_variable_info;
+ 	efi_query_variable_info_t	*query_variable_info_nonblocking;
+ 	efi_update_capsule_t		*update_capsule;
+ 	efi_query_capsule_caps_t	*query_capsule_caps;
+ 	efi_get_next_high_mono_count_t	*get_next_high_mono_count;
+ 	efi_reset_system_t		*reset_system;
+ 
+ 	struct efi_memory_map		memmap;
+ 	unsigned long			flags;
++>>>>>>> 96a3dd3dece8 (efi: Store mask of supported runtime services in struct efi)
  } efi;
  
+ #define EFI_RT_SUPPORTED_GET_TIME 				0x0001
+ #define EFI_RT_SUPPORTED_SET_TIME 				0x0002
+ #define EFI_RT_SUPPORTED_GET_WAKEUP_TIME			0x0004
+ #define EFI_RT_SUPPORTED_SET_WAKEUP_TIME			0x0008
+ #define EFI_RT_SUPPORTED_GET_VARIABLE				0x0010
+ #define EFI_RT_SUPPORTED_GET_NEXT_VARIABLE_NAME			0x0020
+ #define EFI_RT_SUPPORTED_SET_VARIABLE				0x0040
+ #define EFI_RT_SUPPORTED_SET_VIRTUAL_ADDRESS_MAP		0x0080
+ #define EFI_RT_SUPPORTED_CONVERT_POINTER			0x0100
+ #define EFI_RT_SUPPORTED_GET_NEXT_HIGH_MONOTONIC_COUNT		0x0200
+ #define EFI_RT_SUPPORTED_RESET_SYSTEM				0x0400
+ #define EFI_RT_SUPPORTED_UPDATE_CAPSULE				0x0800
+ #define EFI_RT_SUPPORTED_QUERY_CAPSULE_CAPABILITIES		0x1000
+ #define EFI_RT_SUPPORTED_QUERY_VARIABLE_INFO			0x2000
+ 
+ #define EFI_RT_SUPPORTED_ALL					0x3fff
+ 
+ #define EFI_RT_SUPPORTED_TIME_SERVICES				0x000f
+ #define EFI_RT_SUPPORTED_VARIABLE_SERVICES			0x0070
+ 
  extern struct mm_struct efi_mm;
  
  static inline int
@@@ -1450,7 -783,10 +1502,14 @@@ static inline bool __pure efi_soft_rese
  		&& __efi_soft_reserve_enabled();
  }
  
++<<<<<<< HEAD
 +extern void __init efi_set_secure_boot(enum efi_secureboot_mode mode);
++=======
+ static inline bool efi_rt_services_supported(unsigned int mask)
+ {
+ 	return (efi.runtime_supported_mask & mask) == mask;
+ }
++>>>>>>> 96a3dd3dece8 (efi: Store mask of supported runtime services in struct efi)
  #else
  static inline bool efi_enabled(int feature)
  {
@@@ -1470,7 -806,10 +1529,14 @@@ static inline bool efi_soft_reserve_ena
  	return false;
  }
  
++<<<<<<< HEAD
 +static inline void efi_set_secure_boot(enum efi_secureboot_mode mode) {}
++=======
+ static inline bool efi_rt_services_supported(unsigned int mask)
+ {
+ 	return false;
+ }
++>>>>>>> 96a3dd3dece8 (efi: Store mask of supported runtime services in struct efi)
  #endif
  
  extern int efi_status_to_err(efi_status_t status);
* Unmerged path drivers/firmware/efi/efi.c
* Unmerged path include/linux/efi.h
