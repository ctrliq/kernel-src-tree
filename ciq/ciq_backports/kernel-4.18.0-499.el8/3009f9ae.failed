ipv6: icmp6: add drop reason support to ndisc_recv_na()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-499.el8
commit-author Eric Dumazet <edumazet@google.com>
commit 3009f9ae21ec539985977dcaa0cebb628afeb181
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-499.el8/3009f9ae.failed

Change ndisc_recv_na() to return a drop reason.

For the moment, return PKT_TOO_SMALL, NOT_SPECIFIED
or SKB_CONSUMED. More reasons are added later.

	Signed-off-by: Eric Dumazet <edumazet@google.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 3009f9ae21ec539985977dcaa0cebb628afeb181)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv6/ndisc.c
diff --cc net/ipv6/ndisc.c
index fa9db238ea9c,9354cb3669c8..000000000000
--- a/net/ipv6/ndisc.c
+++ b/net/ipv6/ndisc.c
@@@ -938,7 -968,26 +938,30 @@@ out
  	return reason;
  }
  
++<<<<<<< HEAD
 +static void ndisc_recv_na(struct sk_buff *skb)
++=======
+ static int accept_untracked_na(struct net_device *dev, struct in6_addr *saddr)
+ {
+ 	struct inet6_dev *idev = __in6_dev_get(dev);
+ 
+ 	switch (idev->cnf.accept_untracked_na) {
+ 	case 0: /* Don't accept untracked na (absent in neighbor cache) */
+ 		return 0;
+ 	case 1: /* Create new entries from na if currently untracked */
+ 		return 1;
+ 	case 2: /* Create new entries from untracked na only if saddr is in the
+ 		 * same subnet as an address configured on the interface that
+ 		 * received the na
+ 		 */
+ 		return !!ipv6_chk_prefix(saddr, dev);
+ 	default:
+ 		return 0;
+ 	}
+ }
+ 
+ static enum skb_drop_reason ndisc_recv_na(struct sk_buff *skb)
++>>>>>>> 3009f9ae21ec (ipv6: icmp6: add drop reason support to ndisc_recv_na())
  {
  	struct nd_msg *msg = (struct nd_msg *)skb_transport_header(skb);
  	struct in6_addr *saddr = &ipv6_hdr(skb)->saddr;
@@@ -951,11 -1000,11 +974,14 @@@
  	struct inet6_dev *idev = __in6_dev_get(dev);
  	struct inet6_ifaddr *ifp;
  	struct neighbour *neigh;
++<<<<<<< HEAD
++=======
+ 	SKB_DR(reason);
+ 	u8 new_state;
++>>>>>>> 3009f9ae21ec (ipv6: icmp6: add drop reason support to ndisc_recv_na())
  
- 	if (skb->len < sizeof(struct nd_msg)) {
- 		ND_PRINTK(2, warn, "NA: packet too short\n");
- 		return;
- 	}
+ 	if (skb->len < sizeof(struct nd_msg))
+ 		return SKB_DROP_REASON_PKT_TOO_SMALL;
  
  	if (ipv6_addr_is_multicast(&msg->target)) {
  		ND_PRINTK(2, warn, "NA: target address is multicast\n");
@@@ -1009,11 -1059,35 +1035,11 @@@
  				  "NA: %pM advertised our address %pI6c on %s!\n",
  				  eth_hdr(skb)->h_source, &ifp->addr, ifp->idev->dev->name);
  		in6_ifa_put(ifp);
- 		return;
+ 		return reason;
  	}
 -
  	neigh = neigh_lookup(&nd_tbl, &msg->target, dev);
  
 -	/* RFC 9131 updates original Neighbour Discovery RFC 4861.
 -	 * NAs with Target LL Address option without a corresponding
 -	 * entry in the neighbour cache can now create a STALE neighbour
 -	 * cache entry on routers.
 -	 *
 -	 *   entry accept  fwding  solicited        behaviour
 -	 * ------- ------  ------  ---------    ----------------------
 -	 * present      X       X         0     Set state to STALE
 -	 * present      X       X         1     Set state to REACHABLE
 -	 *  absent      0       X         X     Do nothing
 -	 *  absent      1       0         X     Do nothing
 -	 *  absent      1       1         X     Add a new STALE entry
 -	 *
 -	 * Note that we don't do a (daddr == all-routers-mcast) check.
 -	 */
 -	new_state = msg->icmph.icmp6_solicited ? NUD_REACHABLE : NUD_STALE;
 -	if (!neigh && lladdr && idev && idev->cnf.forwarding) {
 -		if (accept_untracked_na(dev, saddr)) {
 -			neigh = neigh_create(&nd_tbl, &msg->target, dev);
 -			new_state = NUD_STALE;
 -		}
 -	}
 -
 -	if (neigh && !IS_ERR(neigh)) {
 +	if (neigh) {
  		u8 old_flags = neigh->flags;
  		struct net *net = dev_net(dev);
  
* Unmerged path net/ipv6/ndisc.c
