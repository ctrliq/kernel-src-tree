rxrpc: Use consume_skb() rather than kfree_skb_reason()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-499.el8
commit-author David Howells <dhowells@redhat.com>
commit 16d5677ef1041beee18b5709bf5759611ec82875
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-499.el8/16d5677e.failed

Use consume_skb() rather than kfree_skb_reason().

	Reported-by: Paolo Abeni <pabeni@redhat.com>
	Signed-off-by: David Howells <dhowells@redhat.com>
cc: Marc Dionne <marc.dionne@auristor.com>
cc: linux-afs@lists.infradead.org
(cherry picked from commit 16d5677ef1041beee18b5709bf5759611ec82875)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/rxrpc/skbuff.c
diff --cc net/rxrpc/skbuff.c
index b8985d01876a,3bcd6ee80396..000000000000
--- a/net/rxrpc/skbuff.c
+++ b/net/rxrpc/skbuff.c
@@@ -54,32 -47,23 +54,38 @@@ void rxrpc_get_skb(struct sk_buff *skb
  }
  
  /*
 - * Note the dropping of a ref on a socket buffer by the core.
 + * Note the destruction of a socket buffer.
   */
 -void rxrpc_eaten_skb(struct sk_buff *skb, enum rxrpc_skb_trace why)
 +void rxrpc_free_skb(struct sk_buff *skb, enum rxrpc_skb_trace op)
  {
 -	int n = atomic_inc_return(&rxrpc_n_rx_skbs);
 -	trace_rxrpc_skb(skb, 0, n, why);
 +	const void *here = __builtin_return_address(0);
 +	if (skb) {
++<<<<<<< HEAD
 +		int n;
 +		CHECK_SLAB_OKAY(&skb->users);
 +		n = atomic_dec_return(select_skb_count(op));
 +		trace_rxrpc_skb(skb, op, refcount_read(&skb->users), n, here);
 +		kfree_skb(skb);
 +	}
  }
  
  /*
 - * Note the destruction of a socket buffer.
 + * Note the injected loss of a socket buffer.
   */
 -void rxrpc_free_skb(struct sk_buff *skb, enum rxrpc_skb_trace why)
 +void rxrpc_lose_skb(struct sk_buff *skb, enum rxrpc_skb_trace op)
  {
 +	const void *here = __builtin_return_address(0);
  	if (skb) {
 +		int n;
 +		CHECK_SLAB_OKAY(&skb->users);
 +		n = atomic_dec_return(select_skb_count(op));
 +		trace_rxrpc_skb(skb, op, refcount_read(&skb->users), n, here);
 +		kfree_skb(skb);
++=======
+ 		int n = atomic_dec_return(select_skb_count(skb));
+ 		trace_rxrpc_skb(skb, refcount_read(&skb->users), n, why);
+ 		consume_skb(skb);
++>>>>>>> 16d5677ef104 (rxrpc: Use consume_skb() rather than kfree_skb_reason())
  	}
  }
  
@@@ -88,12 -72,12 +94,19 @@@
   */
  void rxrpc_purge_queue(struct sk_buff_head *list)
  {
 +	const void *here = __builtin_return_address(0);
  	struct sk_buff *skb;
 -
  	while ((skb = skb_dequeue((list))) != NULL) {
++<<<<<<< HEAD
 +		int n = atomic_dec_return(select_skb_count(rxrpc_skb_rx_purged));
 +		trace_rxrpc_skb(skb, rxrpc_skb_rx_purged,
 +				refcount_read(&skb->users), n, here);
 +		kfree_skb(skb);
++=======
+ 		int n = atomic_dec_return(select_skb_count(skb));
+ 		trace_rxrpc_skb(skb, refcount_read(&skb->users), n,
+ 				rxrpc_skb_put_purge);
+ 		consume_skb(skb);
++>>>>>>> 16d5677ef104 (rxrpc: Use consume_skb() rather than kfree_skb_reason())
  	}
  }
* Unmerged path net/rxrpc/skbuff.c
