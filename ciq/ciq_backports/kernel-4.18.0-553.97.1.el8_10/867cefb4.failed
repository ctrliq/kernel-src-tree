xen: Fix x86 sched_clock() interface for xen

jira KERNEL-548
Rebuild_History Non-Buildable kernel-4.18.0-553.97.1.el8_10
commit-author Juergen Gross <jgross@suse.com>
commit 867cefb4cb1012f42cada1c7d1f35ac8dd276071
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.97.1.el8_10/867cefb4.failed

Commit f94c8d11699759 ("sched/clock, x86/tsc: Rework the x86 'unstable'
sched_clock() interface") broke Xen guest time handling across
migration:

[  187.249951] Freezing user space processes ... (elapsed 0.001 seconds) done.
[  187.251137] OOM killer disabled.
[  187.251137] Freezing remaining freezable tasks ... (elapsed 0.001 seconds) done.
[  187.252299] suspending xenstore...
[  187.266987] xen:grant_table: Grant tables using version 1 layout
[18446743811.706476] OOM killer enabled.
[18446743811.706478] Restarting tasks ... done.
[18446743811.720505] Setting capacity to 16777216

Fix that by setting xen_sched_clock_offset at resume time to ensure a
monotonic clock value.

[boris: replaced pr_info() with pr_info_once() in xen_callback_vector()
 to avoid printing with incorrect timestamp during resume (as we
 haven't re-adjusted the clock yet)]

Fixes: f94c8d11699759 ("sched/clock, x86/tsc: Rework the x86 'unstable' sched_clock() interface")
	Cc: <stable@vger.kernel.org> # 4.11
	Reported-by: Hans van Kranenburg <hans.van.kranenburg@mendix.com>
	Signed-off-by: Juergen Gross <jgross@suse.com>
	Tested-by: Hans van Kranenburg <hans.van.kranenburg@mendix.com>
	Signed-off-by: Boris Ostrovsky <boris.ostrovsky@oracle.com>
(cherry picked from commit 867cefb4cb1012f42cada1c7d1f35ac8dd276071)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/xen/events/events_base.c
diff --cc drivers/xen/events/events_base.c
index dc1457dba38e,117e76b2f939..000000000000
--- a/drivers/xen/events/events_base.c
+++ b/drivers/xen/events/events_base.c
@@@ -1643,24 -1644,19 +1643,30 @@@ void xen_setup_callback_vector(void
  
  	if (xen_have_vector_callback) {
  		callback_via = HVM_CALLBACK_VECTOR(HYPERVISOR_CALLBACK_VECTOR);
 -		rc = xen_set_callback_via(callback_via);
 -		if (rc) {
 +		if (xen_set_callback_via(callback_via)) {
  			pr_err("Request for Xen HVM callback vector failed\n");
  			xen_have_vector_callback = 0;
 -			return;
  		}
++<<<<<<< HEAD
++=======
+ 		pr_info_once("Xen HVM callback vector for event delivery is enabled\n");
+ 		alloc_intr_gate(HYPERVISOR_CALLBACK_VECTOR,
+ 				xen_hvm_callback_vector);
++>>>>>>> 867cefb4cb10 (xen: Fix x86 sched_clock() interface for xen)
  	}
  }
 +
 +static __init void xen_alloc_callback_vector(void)
 +{
 +	if (!xen_have_vector_callback)
 +		return;
 +
 +	pr_info("Xen HVM callback vector for event delivery is enabled\n");
 +	alloc_intr_gate(HYPERVISOR_CALLBACK_VECTOR, xen_hvm_callback_vector);
 +}
  #else
 -void xen_callback_vector(void) {}
 +void xen_setup_callback_vector(void) {}
 +static inline void xen_alloc_callback_vector(void) {}
  #endif
  
  #undef MODULE_PARAM_PREFIX
diff --git a/arch/x86/xen/time.c b/arch/x86/xen/time.c
index 77c1717c9f3e..85530143740a 100644
--- a/arch/x86/xen/time.c
+++ b/arch/x86/xen/time.c
@@ -368,8 +368,6 @@ void xen_timer_resume(void)
 {
 	int cpu;
 
-	pvclock_resume();
-
 	if (xen_clockevent != &xen_vcpuop_clockevent)
 		return;
 
@@ -386,12 +384,15 @@ static const struct pv_time_ops xen_time_ops __initconst = {
 };
 
 static struct pvclock_vsyscall_time_info *xen_clock __read_mostly;
+static u64 xen_clock_value_saved;
 
 void xen_save_time_memory_area(void)
 {
 	struct vcpu_register_time_memory_area t;
 	int ret;
 
+	xen_clock_value_saved = xen_clocksource_read() - xen_sched_clock_offset;
+
 	if (!xen_clock)
 		return;
 
@@ -411,7 +412,7 @@ void xen_restore_time_memory_area(void)
 	int ret;
 
 	if (!xen_clock)
-		return;
+		goto out;
 
 	t.addr.v = &xen_clock->pvti;
 
@@ -429,6 +430,11 @@ void xen_restore_time_memory_area(void)
 	if (ret != 0)
 		pr_notice("Cannot restore secondary vcpu_time_info (err %d)",
 			  ret);
+
+out:
+	/* Need pvclock_resume() before using xen_clocksource_read(). */
+	pvclock_resume();
+	xen_sched_clock_offset = xen_clocksource_read() - xen_clock_value_saved;
 }
 
 static void xen_setup_vsyscall_time_info(void)
* Unmerged path drivers/xen/events/events_base.c
