scsi: lpfc: Modify handling of ADISC based on ndlp state and RPI registration

jira KERNEL-548
Rebuild_History Non-Buildable kernel-4.18.0-553.97.1.el8_10
commit-author Justin Tee <justin.tee@broadcom.com>
commit ee80d8c2d4ccebed1015f6c9ba6a07c85e149785
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.97.1.el8_10/ee80d8c2.failed

In lpfc_check_adisc, remove the requirement that the ndlp object must have
been RPI registered.  Whether or not the ndlp is RPI registered is
unrelated to verifying that the received ADISC is intended for that ndlp
rport object.

After ADISC receipt, there's no need to put the ndlp state into NPR.  Let
the cmpl routines from the actions taken earlier in ADISC handling set the
proper ndlp state.

Also, refactor when a RESUME_RPI mailbox command should be sent.  It should
only be sent if the RPI registered flag is set.

	Signed-off-by: Justin Tee <justin.tee@broadcom.com>
Link: https://lore.kernel.org/r/20241212233309.71356-5-justintee8345@gmail.com
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit ee80d8c2d4ccebed1015f6c9ba6a07c85e149785)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/lpfc/lpfc_nportdisc.c
diff --cc drivers/scsi/lpfc/lpfc_nportdisc.c
index 297b4db5a986,5aa21c683ac6..000000000000
--- a/drivers/scsi/lpfc/lpfc_nportdisc.c
+++ b/drivers/scsi/lpfc/lpfc_nportdisc.c
@@@ -52,9 -64,6 +52,12 @@@ static in
  lpfc_check_adisc(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,
  		 struct lpfc_name *nn, struct lpfc_name *pn)
  {
++<<<<<<< HEAD
 +	/* First, we MUST have a RPI registered */
 +	if (!(ndlp->nlp_flag & NLP_RPI_REGISTERED))
 +		return 0;
++=======
++>>>>>>> ee80d8c2d4cc (scsi: lpfc: Modify handling of ADISC based on ndlp state and RPI registration)
  
  	/* Compare the ADISC rsp WWNN / WWPN matches our internal node
  	 * table entry for that node.
@@@ -692,11 -730,11 +695,12 @@@ lpfc_rcv_padisc(struct lpfc_vport *vpor
  	struct lpfc_name   *pnn, *ppn;
  	struct ls_rjt stat;
  	ADISC *ap;
 +	IOCB_t *icmd;
  	uint32_t *lp;
  	uint32_t cmd;
+ 	int rc;
  
 -	pcmd = cmdiocb->cmd_dmabuf;
 +	pcmd = (struct lpfc_dmabuf *) cmdiocb->context2;
  	lp = (uint32_t *) pcmd->virt;
  
  	cmd = *lp++;
@@@ -719,22 -757,29 +723,39 @@@
  		 * resume the RPI before the ACC goes out.
  		 */
  		if (vport->phba->sli_rev == LPFC_SLI_REV4) {
++<<<<<<< HEAD
 +			elsiocb = kmalloc(sizeof(struct lpfc_iocbq),
 +				GFP_KERNEL);
 +			if (elsiocb) {
 +
 +				/* Save info from cmd IOCB used in rsp */
 +				memcpy((uint8_t *)elsiocb, (uint8_t *)cmdiocb,
 +					sizeof(struct lpfc_iocbq));
- 
- 				/* Save the ELS cmd */
- 				elsiocb->drvrTimeout = cmd;
- 
- 				if (lpfc_sli4_resume_rpi(ndlp,
- 						lpfc_mbx_cmpl_resume_rpi,
- 						elsiocb))
- 					kfree(elsiocb);
- 				goto out;
++=======
+ 			/* Don't resume an unregistered RPI - unnecessary
+ 			 * mailbox. Just send the ACC when the RPI is not
+ 			 * registered.
+ 			 */
+ 			if (test_bit(NLP_RPI_REGISTERED, &ndlp->nlp_flag)) {
+ 				elsiocb = kmalloc(sizeof(*elsiocb), GFP_KERNEL);
+ 				if (elsiocb) {
+ 					/* Save info from cmd IOCB used in
+ 					 * rsp
+ 					 */
+ 					memcpy(elsiocb, cmdiocb,
+ 					       sizeof(*elsiocb));
++>>>>>>> ee80d8c2d4cc (scsi: lpfc: Modify handling of ADISC based on ndlp state and RPI registration)
+ 
+ 					elsiocb->drvrTimeout = cmd;
+ 
+ 					rc = lpfc_sli4_resume_rpi(ndlp,
+ 								  lpfc_mbx_cmpl_resume_rpi,
+ 								  elsiocb);
+ 					if (rc)
+ 						kfree(elsiocb);
+ 
+ 					goto out;
+ 				}
  			}
  		}
  
@@@ -773,12 -818,9 +794,11 @@@ out
  	/* 1 sec timeout */
  	mod_timer(&ndlp->nlp_delayfunc, jiffies + msecs_to_jiffies(1000));
  
 -	set_bit(NLP_DELAY_TMO, &ndlp->nlp_flag);
 +	spin_lock_irq(&ndlp->lock);
 +	ndlp->nlp_flag |= NLP_DELAY_TMO;
 +	spin_unlock_irq(&ndlp->lock);
  	ndlp->nlp_last_elscmd = ELS_CMD_PLOGI;
  	ndlp->nlp_prev_state = ndlp->nlp_state;
- 	lpfc_nlp_set_state(vport, ndlp, NLP_STE_NPR_NODE);
  	return 0;
  }
  
* Unmerged path drivers/scsi/lpfc/lpfc_nportdisc.c
