scsi: lpfc: Revise NPIV ELS unsol rcv cmpl logic to drop ndlp based on nlp_state

jira KERNEL-548
Rebuild_History Non-Buildable kernel-4.18.0-553.97.1.el8_10
commit-author Justin Tee <justin.tee@broadcom.com>
commit 9914a3d033d3e1d836a43e93e9738e7dd44a096a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.97.1.el8_10/9914a3d0.failed

When NPIV ports are zoned to devices that support both initiator and target
mode, a remote device's initiated PRLI results in unintended final kref
clean up of the device's ndlp structure.  This disrupts NPIV ports'
discovery for target devices that support both initiator and target mode.

Modify the NPIV lpfc_drop_node clause such that we allow the ndlp to live
so long as it was in NLP_STE_PLOGI_ISSUE, NLP_STE_REG_LOGIN_ISSUE, or
NLP_STE_PRLI_ISSUE nlp_state.  This allows lpfc's issued PRLI completion
routine to determine if the final kref clean up should execute rather than
a remote device's issued PRLI.

Fixes: db651ec22524 ("scsi: lpfc: Correct used_rpi count when devloss tmo fires with no recovery")
	Signed-off-by: Justin Tee <justin.tee@broadcom.com>
Link: https://lore.kernel.org/r/20230523183206.7728-5-justintee8345@gmail.com
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 9914a3d033d3e1d836a43e93e9738e7dd44a096a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/lpfc/lpfc_els.c
diff --cc drivers/scsi/lpfc/lpfc_els.c
index 1fcc5ef24ddf,2bad9954c355..000000000000
--- a/drivers/scsi/lpfc/lpfc_els.c
+++ b/drivers/scsi/lpfc/lpfc_els.c
@@@ -5420,15 -5441,30 +5420,42 @@@ out
  	 * these conditions and release the RPI.
  	 */
  	if (phba->sli_rev == LPFC_SLI_REV4 &&
++<<<<<<< HEAD
 +	    (vport && vport->port_type == LPFC_NPIV_PORT) &&
 +	    !(ndlp->fc4_xpt_flags & SCSI_XPT_REGD) &&
 +	    ndlp->nlp_flag & NLP_RELEASE_RPI) {
 +		lpfc_sli4_free_rpi(phba, ndlp->nlp_rpi);
 +		spin_lock_irq(&ndlp->lock);
 +		ndlp->nlp_rpi = LPFC_RPI_ALLOC_ERROR;
 +		ndlp->nlp_flag &= ~NLP_RELEASE_RPI;
 +		spin_unlock_irq(&ndlp->lock);
 +		lpfc_drop_node(vport, ndlp);
++=======
+ 	    vport && vport->port_type == LPFC_NPIV_PORT &&
+ 	    !(ndlp->fc4_xpt_flags & SCSI_XPT_REGD)) {
+ 		if (ndlp->nlp_flag & NLP_RELEASE_RPI) {
+ 			if (ndlp->nlp_state != NLP_STE_PLOGI_ISSUE &&
+ 			    ndlp->nlp_state != NLP_STE_REG_LOGIN_ISSUE) {
+ 				lpfc_sli4_free_rpi(phba, ndlp->nlp_rpi);
+ 				spin_lock_irq(&ndlp->lock);
+ 				ndlp->nlp_rpi = LPFC_RPI_ALLOC_ERROR;
+ 				ndlp->nlp_flag &= ~NLP_RELEASE_RPI;
+ 				spin_unlock_irq(&ndlp->lock);
+ 			}
+ 			lpfc_drop_node(vport, ndlp);
+ 		} else if (ndlp->nlp_state != NLP_STE_PLOGI_ISSUE &&
+ 			   ndlp->nlp_state != NLP_STE_REG_LOGIN_ISSUE &&
+ 			   ndlp->nlp_state != NLP_STE_PRLI_ISSUE) {
+ 			/* Drop ndlp if there is no planned or outstanding
+ 			 * issued PRLI.
+ 			 *
+ 			 * In cases when the ndlp is acting as both an initiator
+ 			 * and target function, let our issued PRLI determine
+ 			 * the final ndlp kref drop.
+ 			 */
+ 			lpfc_drop_node(vport, ndlp);
+ 		}
++>>>>>>> 9914a3d033d3 (scsi: lpfc: Revise NPIV ELS unsol rcv cmpl logic to drop ndlp based on nlp_state)
  	}
  
  	/* Release the originating I/O reference. */
* Unmerged path drivers/scsi/lpfc/lpfc_els.c
