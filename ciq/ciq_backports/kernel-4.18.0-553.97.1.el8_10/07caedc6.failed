scsi: lpfc: Fix reusing an ndlp that is marked NLP_DROPPED during FLOGI

jira KERNEL-548
Rebuild_History Non-Buildable kernel-4.18.0-553.97.1.el8_10
commit-author Justin Tee <justin.tee@broadcom.com>
commit 07caedc6a3887938813727beafea40f07c497705
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.97.1.el8_10/07caedc6.failed

It's possible for an unstable link to repeatedly bounce allowing a FLOGI
retry, but then bounce again forcing an abort of the FLOGI.  Ensure that
the initial reference count on the FLOGI ndlp is restored in this faulty
link scenario.

	Signed-off-by: Justin Tee <justin.tee@broadcom.com>
Link: https://patch.msgid.link/20251106224639.139176-8-justintee8345@gmail.com
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 07caedc6a3887938813727beafea40f07c497705)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/lpfc/lpfc_els.c
#	drivers/scsi/lpfc/lpfc_hbadisc.c
diff --cc drivers/scsi/lpfc/lpfc_els.c
index 5c9369b9b870,0045c1e29619..000000000000
--- a/drivers/scsi/lpfc/lpfc_els.c
+++ b/drivers/scsi/lpfc/lpfc_els.c
@@@ -1061,15 -995,15 +1066,24 @@@ lpfc_cmpl_els_flogi(struct lpfc_hba *ph
  
  stop_rr_fcf_flogi:
  		/* FLOGI failure */
 -		if (!(ulp_status == IOSTAT_LOCAL_REJECT &&
 -		      ((ulp_word4 & IOERR_PARAM_MASK) ==
 +		if (!(irsp->ulpStatus == IOSTAT_LOCAL_REJECT &&
 +		      ((irsp->un.ulpWord[4] & IOERR_PARAM_MASK) ==
  					IOERR_LOOP_OPEN_FAILURE)))
++<<<<<<< HEAD
 +			lpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,
 +					 "2858 FLOGI failure Status:x%x/x%x TMO"
 +					 ":x%x Data x%x x%x\n",
 +					 irsp->ulpStatus, irsp->un.ulpWord[4],
 +					 irsp->ulpTimeout, phba->hba_flag,
 +					 phba->fcf.fcf_flag);
++=======
+ 			lpfc_vlog_msg(vport, KERN_WARNING, LOG_ELS,
+ 				      "2858 FLOGI Status:x%x/x%x TMO"
+ 				      ":x%x Data x%lx x%x x%lx x%x\n",
+ 				      ulp_status, ulp_word4, tmo,
+ 				      phba->hba_flag, phba->fcf.fcf_flag,
+ 				      ndlp->nlp_flag, ndlp->fc4_xpt_flags);
++>>>>>>> 07caedc6a388 (scsi: lpfc: Fix reusing an ndlp that is marked NLP_DROPPED during FLOGI)
  
  		/* Check for retry */
  		if (lpfc_els_retry(phba, cmdiocb, rspiocb)) {
@@@ -1086,28 -1020,35 +1100,43 @@@
  		 * registered with the SCSI transport, remove the initial
  		 * reference to trigger node release.
  		 */
++<<<<<<< HEAD
 +		if (!(ndlp->nlp_flag & NLP_IN_DEV_LOSS) &&
 +		    !(ndlp->fc4_xpt_flags & SCSI_XPT_REGD))
++=======
+ 		if (!test_bit(NLP_IN_DEV_LOSS, &ndlp->nlp_flag) &&
+ 		    !test_bit(NLP_DROPPED, &ndlp->nlp_flag) &&
+ 		    !(ndlp->fc4_xpt_flags & SCSI_XPT_REGD)) {
+ 			set_bit(NLP_DROPPED, &ndlp->nlp_flag);
++>>>>>>> 07caedc6a388 (scsi: lpfc: Fix reusing an ndlp that is marked NLP_DROPPED during FLOGI)
  			lpfc_nlp_put(ndlp);
+ 		}
  
  		lpfc_printf_vlog(vport, KERN_WARNING, LOG_ELS,
++<<<<<<< HEAD
 +				 "0150 FLOGI failure Status:x%x/x%x "
 +				 "xri x%x TMO:x%x refcnt %d\n",
 +				 irsp->ulpStatus, irsp->un.ulpWord[4],
 +				 cmdiocb->sli4_xritag, irsp->ulpTimeout,
 +				 kref_read(&ndlp->kref));
++=======
+ 				 "0150 FLOGI Status:x%x/x%x "
+ 				 "xri x%x iotag x%x TMO:x%x refcnt %d\n",
+ 				 ulp_status, ulp_word4, cmdiocb->sli4_xritag,
+ 				 cmdiocb->iotag, tmo, kref_read(&ndlp->kref));
++>>>>>>> 07caedc6a388 (scsi: lpfc: Fix reusing an ndlp that is marked NLP_DROPPED during FLOGI)
  
  		/* If this is not a loop open failure, bail out */
 -		if (!(ulp_status == IOSTAT_LOCAL_REJECT &&
 -		      ((ulp_word4 & IOERR_PARAM_MASK) ==
 -					IOERR_LOOP_OPEN_FAILURE))) {
 -			/* Warn FLOGI status */
 -			lpfc_vlog_msg(vport, KERN_WARNING, LOG_ELS,
 -				      "0100 FLOGI Status:x%x/x%x "
 -				      "TMO:x%x\n",
 -				      ulp_status, ulp_word4, tmo);
 +		if (!(irsp->ulpStatus == IOSTAT_LOCAL_REJECT &&
 +		      ((irsp->un.ulpWord[4] & IOERR_PARAM_MASK) ==
 +					IOERR_LOOP_OPEN_FAILURE)))
  			goto flogifail;
 -		}
  
  		/* FLOGI failed, so there is no fabric */
 -		clear_bit(FC_FABRIC, &vport->fc_flag);
 -		clear_bit(FC_PUBLIC_LOOP, &vport->fc_flag);
 -		clear_bit(FC_PT2PT_NO_NVME, &vport->fc_flag);
 +		spin_lock_irq(shost->host_lock);
 +		vport->fc_flag &= ~(FC_FABRIC | FC_PUBLIC_LOOP |
 +				    FC_PT2PT_NO_NVME);
 +		spin_unlock_irq(shost->host_lock);
  
  		/* If private loop, then allow max outstanding els to be
  		 * LPFC_MAX_DISC_THREADS (32). Scanning in the case of no
diff --cc drivers/scsi/lpfc/lpfc_hbadisc.c
index 2be2e893f962,717ae56c8e4b..000000000000
--- a/drivers/scsi/lpfc/lpfc_hbadisc.c
+++ b/drivers/scsi/lpfc/lpfc_hbadisc.c
@@@ -415,12 -423,8 +415,17 @@@ voi
  lpfc_check_nlp_post_devloss(struct lpfc_vport *vport,
  			    struct lpfc_nodelist *ndlp)
  {
++<<<<<<< HEAD
 +	unsigned long iflags;
 +
 +	spin_lock_irqsave(&ndlp->lock, iflags);
 +	if (ndlp->save_flags & NLP_IN_RECOV_POST_DEV_LOSS) {
 +		ndlp->save_flags &= ~NLP_IN_RECOV_POST_DEV_LOSS;
 +		spin_unlock_irqrestore(&ndlp->lock, iflags);
++=======
+ 	if (test_and_clear_bit(NLP_IN_RECOV_POST_DEV_LOSS, &ndlp->save_flags)) {
+ 		clear_bit(NLP_DROPPED, &ndlp->nlp_flag);
++>>>>>>> 07caedc6a388 (scsi: lpfc: Fix reusing an ndlp that is marked NLP_DROPPED during FLOGI)
  		lpfc_nlp_get(ndlp);
  		lpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY | LOG_NODE,
  				 "8438 Devloss timeout reversed on DID x%x "
* Unmerged path drivers/scsi/lpfc/lpfc_els.c
* Unmerged path drivers/scsi/lpfc/lpfc_hbadisc.c
