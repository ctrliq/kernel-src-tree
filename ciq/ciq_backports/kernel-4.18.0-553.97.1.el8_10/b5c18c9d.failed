scsi: lpfc: Fix unsolicited FLOGI kref imbalance when in direct attached topology

jira KERNEL-548
Rebuild_History Non-Buildable kernel-4.18.0-553.97.1.el8_10
commit-author Justin Tee <justin.tee@broadcom.com>
commit b5c18c9dd138733c16893613345af44deadcf05e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.97.1.el8_10/b5c18c9d.failed

In direct attached topology, certain target vendors that are quick to issue
FLOGI followed by a cable pull for more than dev_loss_tmo may result in a
kref imbalance for the remote port ndlp object.

Add an nlp_get when the defer_flogi_acc flag is set.  This is expected to
balance the nlp_put in the defer_flogi_acc clause in the
lpfc_issue_els_flogi() routine.  Because we need to retain the ndlp ptr,
reorganize all of the defer_flogi_acc information into one
lpfc_defer_flogi_acc struct.

	Signed-off-by: Justin Tee <justin.tee@broadcom.com>
Link: https://lore.kernel.org/r/20240726231512.92867-6-justintee8345@gmail.com
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit b5c18c9dd138733c16893613345af44deadcf05e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/lpfc/lpfc_els.c
#	drivers/scsi/lpfc/lpfc_hbadisc.c
diff --cc drivers/scsi/lpfc/lpfc_els.c
index 5c9369b9b870,b5a8d050419a..000000000000
--- a/drivers/scsi/lpfc/lpfc_els.c
+++ b/drivers/scsi/lpfc/lpfc_els.c
@@@ -1435,8 -1388,11 +1435,8 @@@ lpfc_issue_els_flogi(struct lpfc_vport 
  		return 1;
  	}
  
 -	/* Clear external loopback plug detected flag */
 -	phba->link_flag &= ~LS_EXTERNAL_LOOPBACK;
 -
  	/* Check for a deferred FLOGI ACC condition */
- 	if (phba->defer_flogi_acc_flag) {
+ 	if (phba->defer_flogi_acc.flag) {
  		/* lookup ndlp for received FLOGI */
  		ndlp = lpfc_findnode_did(vport, 0);
  		if (!ndlp)
@@@ -1447,28 -1403,41 +1447,59 @@@
  
  		memset(&defer_flogi_acc, 0, sizeof(struct lpfc_iocbq));
  
++<<<<<<< HEAD
 +		defer_flogi_acc.iocb.ulpContext = phba->defer_flogi_acc_rx_id;
 +		defer_flogi_acc.iocb.unsli3.rcvsli3.ox_id =
 +						phba->defer_flogi_acc_ox_id;
 +
 +		lpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,
 +				 "3354 Xmit deferred FLOGI ACC: rx_id: x%x,"
 +				 " ox_id: x%x, hba_flag x%x\n",
 +				 phba->defer_flogi_acc_rx_id,
 +				 phba->defer_flogi_acc_ox_id, phba->hba_flag);
++=======
+ 		if (phba->sli_rev == LPFC_SLI_REV4) {
+ 			bf_set(wqe_ctxt_tag,
+ 			       &defer_flogi_acc.wqe.xmit_els_rsp.wqe_com,
+ 			       phba->defer_flogi_acc.rx_id);
+ 			bf_set(wqe_rcvoxid,
+ 			       &defer_flogi_acc.wqe.xmit_els_rsp.wqe_com,
+ 			       phba->defer_flogi_acc.ox_id);
+ 		} else {
+ 			icmd = &defer_flogi_acc.iocb;
+ 			icmd->ulpContext = phba->defer_flogi_acc.rx_id;
+ 			icmd->unsli3.rcvsli3.ox_id =
+ 				phba->defer_flogi_acc.ox_id;
+ 		}
+ 
+ 		lpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,
+ 				 "3354 Xmit deferred FLOGI ACC: rx_id: x%x,"
+ 				 " ox_id: x%x, hba_flag x%lx\n",
+ 				 phba->defer_flogi_acc.rx_id,
+ 				 phba->defer_flogi_acc.ox_id, phba->hba_flag);
++>>>>>>> b5c18c9dd138 (scsi: lpfc: Fix unsolicited FLOGI kref imbalance when in direct attached topology)
  
  		/* Send deferred FLOGI ACC */
  		lpfc_els_rsp_acc(vport, ELS_CMD_FLOGI, &defer_flogi_acc,
  				 ndlp, NULL);
  
++<<<<<<< HEAD
 +		phba->defer_flogi_acc_flag = false;
 +
 +		vport->fc_myDID = did;
++=======
+ 		phba->defer_flogi_acc.flag = false;
++>>>>>>> b5c18c9dd138 (scsi: lpfc: Fix unsolicited FLOGI kref imbalance when in direct attached topology)
  
- 		/* Decrement ndlp reference count to indicate the node can be
- 		 * released when other references are removed.
+ 		/* Decrement the held ndlp that was incremented when the
+ 		 * deferred flogi acc flag was set.
  		 */
- 		lpfc_nlp_put(ndlp);
+ 		if (phba->defer_flogi_acc.ndlp) {
+ 			lpfc_nlp_put(phba->defer_flogi_acc.ndlp);
+ 			phba->defer_flogi_acc.ndlp = NULL;
+ 		}
+ 
+ 		vport->fc_myDID = did;
  	}
  
  	return 0;
@@@ -8277,21 -8459,28 +8308,41 @@@ lpfc_els_rcv_flogi(struct lpfc_vport *v
  	memcpy(&phba->fc_fabparam, sp, sizeof(struct serv_parm));
  
  	/* Defer ACC response until AFTER we issue a FLOGI */
++<<<<<<< HEAD
 +	if (!(phba->hba_flag & HBA_FLOGI_ISSUED)) {
 +		phba->defer_flogi_acc_rx_id = cmdiocb->iocb.ulpContext;
 +		phba->defer_flogi_acc_ox_id =
 +					cmdiocb->iocb.unsli3.rcvsli3.ox_id;
++=======
+ 	if (!test_bit(HBA_FLOGI_ISSUED, &phba->hba_flag)) {
+ 		phba->defer_flogi_acc.rx_id = bf_get(wqe_ctxt_tag,
+ 						     &wqe->xmit_els_rsp.wqe_com);
+ 		phba->defer_flogi_acc.ox_id = bf_get(wqe_rcvoxid,
+ 						     &wqe->xmit_els_rsp.wqe_com);
++>>>>>>> b5c18c9dd138 (scsi: lpfc: Fix unsolicited FLOGI kref imbalance when in direct attached topology)
  
  		vport->fc_myDID = did;
  
  		lpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,
  				 "3344 Deferring FLOGI ACC: rx_id: x%x,"
++<<<<<<< HEAD
 +				 " ox_id: x%x, hba_flag x%x\n",
 +				 phba->defer_flogi_acc_rx_id,
 +				 phba->defer_flogi_acc_ox_id, phba->hba_flag);
- 
- 		phba->defer_flogi_acc_flag = true;
- 
++=======
+ 				 " ox_id: x%x, hba_flag x%lx\n",
+ 				 phba->defer_flogi_acc.rx_id,
+ 				 phba->defer_flogi_acc.ox_id, phba->hba_flag);
++>>>>>>> b5c18c9dd138 (scsi: lpfc: Fix unsolicited FLOGI kref imbalance when in direct attached topology)
+ 
+ 		phba->defer_flogi_acc.flag = true;
+ 
+ 		/* This nlp_get is paired with nlp_puts that reset the
+ 		 * defer_flogi_acc.flag back to false.  We need to retain
+ 		 * a kref on the ndlp until the deferred FLOGI ACC is
+ 		 * processed or cancelled.
+ 		 */
+ 		phba->defer_flogi_acc.ndlp = lpfc_nlp_get(ndlp);
  		return 0;
  	}
  
diff --cc drivers/scsi/lpfc/lpfc_hbadisc.c
index fbc39594371d,35c9181c6608..000000000000
--- a/drivers/scsi/lpfc/lpfc_hbadisc.c
+++ b/drivers/scsi/lpfc/lpfc_hbadisc.c
@@@ -1261,8 -1255,18 +1261,15 @@@ lpfc_linkdown(struct lpfc_hba *phba
  	lpfc_scsi_dev_block(phba);
  	offline = pci_channel_offline(phba->pcidev);
  
- 	phba->defer_flogi_acc_flag = false;
+ 	/* Decrement the held ndlp if there is a deferred flogi acc */
+ 	if (phba->defer_flogi_acc.flag) {
+ 		if (phba->defer_flogi_acc.ndlp) {
+ 			lpfc_nlp_put(phba->defer_flogi_acc.ndlp);
+ 			phba->defer_flogi_acc.ndlp = NULL;
+ 		}
+ 	}
+ 	phba->defer_flogi_acc.flag = false;
  
 -	/* Clear external loopback plug detected flag */
 -	phba->link_flag &= ~LS_EXTERNAL_LOOPBACK;
 -
  	spin_lock_irq(&phba->hbalock);
  	phba->fcf.fcf_flag &= ~(FCF_AVAILABLE | FCF_SCAN_DONE);
  	spin_unlock_irq(&phba->hbalock);
@@@ -1381,19 -1384,22 +1388,36 @@@ lpfc_linkup_port(struct lpfc_vport *vpo
  		(vport != phba->pport))
  		return;
  
++<<<<<<< HEAD
 +	if (vport->cfg_enable_fc4_type != LPFC_ENABLE_NVME)
 +		fc_host_post_event(shost, fc_get_event_number(),
 +				   FCH_EVT_LINKUP, 0);
++=======
+ 	if (phba->defer_flogi_acc.flag) {
+ 		clear_bit(FC_ABORT_DISCOVERY, &vport->fc_flag);
+ 		clear_bit(FC_RSCN_MODE, &vport->fc_flag);
+ 		clear_bit(FC_NLP_MORE, &vport->fc_flag);
+ 		clear_bit(FC_RSCN_DISCOVERY, &vport->fc_flag);
+ 	} else {
+ 		clear_bit(FC_PT2PT, &vport->fc_flag);
+ 		clear_bit(FC_PT2PT_PLOGI, &vport->fc_flag);
+ 		clear_bit(FC_ABORT_DISCOVERY, &vport->fc_flag);
+ 		clear_bit(FC_RSCN_MODE, &vport->fc_flag);
+ 		clear_bit(FC_NLP_MORE, &vport->fc_flag);
+ 		clear_bit(FC_RSCN_DISCOVERY, &vport->fc_flag);
+ 	}
+ 	set_bit(FC_NDISC_ACTIVE, &vport->fc_flag);
++>>>>>>> b5c18c9dd138 (scsi: lpfc: Fix unsolicited FLOGI kref imbalance when in direct attached topology)
  
  	spin_lock_irq(shost->host_lock);
 +	if (phba->defer_flogi_acc_flag)
 +		vport->fc_flag &= ~(FC_ABORT_DISCOVERY | FC_RSCN_MODE |
 +				    FC_NLP_MORE | FC_RSCN_DISCOVERY);
 +	else
 +		vport->fc_flag &= ~(FC_PT2PT | FC_PT2PT_PLOGI |
 +				    FC_ABORT_DISCOVERY | FC_RSCN_MODE |
 +				    FC_NLP_MORE | FC_RSCN_DISCOVERY);
 +	vport->fc_flag |= FC_NDISC_ACTIVE;
  	vport->fc_ns_retry = 0;
  	spin_unlock_irq(shost->host_lock);
  	lpfc_setup_fdmi_mask(vport);
diff --git a/drivers/scsi/lpfc/lpfc.h b/drivers/scsi/lpfc/lpfc.h
index a38e59817023..bed936e993f4 100644
--- a/drivers/scsi/lpfc/lpfc.h
+++ b/drivers/scsi/lpfc/lpfc.h
@@ -310,6 +310,14 @@ struct lpfc_stats {
 
 struct lpfc_hba;
 
+/* Data structure to keep withheld FLOGI_ACC information */
+struct lpfc_defer_flogi_acc {
+	bool flag;
+	u16 rx_id;
+	u16 ox_id;
+	struct lpfc_nodelist *ndlp;
+
+};
 
 #define LPFC_VMID_TIMER   300	/* timer interval in seconds */
 
@@ -1442,9 +1450,7 @@ struct lpfc_hba {
 	uint16_t vlan_id;
 	struct list_head fcf_conn_rec_list;
 
-	bool defer_flogi_acc_flag;
-	uint16_t defer_flogi_acc_rx_id;
-	uint16_t defer_flogi_acc_ox_id;
+	struct lpfc_defer_flogi_acc defer_flogi_acc;
 
 	spinlock_t ct_ev_lock; /* synchronize access to ct_ev_waiters */
 	struct list_head ct_ev_waiters;
* Unmerged path drivers/scsi/lpfc/lpfc_els.c
* Unmerged path drivers/scsi/lpfc/lpfc_hbadisc.c
