PCI/MSI: Make arch_.*_msi_irq[s] fallbacks selectable

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-425.13.1.el8_7
Rebuild_CHGLOG: - PCI/MSI: Make arch_.*_msi_irq[s] fallbacks selectable (Jerry Snitselaar) [2149474 2118428]
Rebuild_FUZZ: 96.08%
commit-author Thomas Gleixner <tglx@linutronix.de>
commit 077ee78e392869e46ae6bdc6ba2a3c4249d0b5e1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-425.13.1.el8_7/077ee78e.failed

The arch_.*_msi_irq[s] fallbacks are compiled in whether an architecture
requires them or not. Architectures which are fully utilizing hierarchical
irq domains should never call into that code.

It's not only architectures which depend on that by implementing one or
more of the weak functions, there is also a bunch of drivers which relies
on the weak functions which invoke msi_controller::setup_irq[s] and
msi_controller::teardown_irq.

Make the architectures and drivers which rely on them select them in Kconfig
and if not selected replace them by stub functions which emit a warning and
fail the PCI/MSI interrupt allocation.

	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
Link: https://lore.kernel.org/r/20200826112333.992429909@linutronix.de
(cherry picked from commit 077ee78e392869e46ae6bdc6ba2a3c4249d0b5e1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/ia64/Kconfig
#	arch/mips/Kconfig
#	arch/powerpc/Kconfig
#	arch/s390/Kconfig
#	arch/sparc/Kconfig
#	drivers/pci/controller/Kconfig
diff --cc arch/ia64/Kconfig
index d6f777303de9,7ff5b3bbf160..000000000000
--- a/arch/ia64/Kconfig
+++ b/arch/ia64/Kconfig
@@@ -55,6 -55,8 +55,11 @@@ config IA6
  	select HAVE_ARCH_AUDITSYSCALL
  	select NEED_DMA_MAP_STATE
  	select NEED_SG_DMA_LENGTH
++<<<<<<< HEAD
++=======
+ 	select NUMA if !FLATMEM
+ 	select PCI_MSI_ARCH_FALLBACKS
++>>>>>>> 077ee78e3928 (PCI/MSI: Make arch_.*_msi_irq[s] fallbacks selectable)
  	default y
  	help
  	  The Itanium Processor Family is Intel's 64-bit successor to
diff --cc arch/mips/Kconfig
index 8ef87c03cf44,3690582eb61f..000000000000
--- a/arch/mips/Kconfig
+++ b/arch/mips/Kconfig
@@@ -69,10 -82,12 +69,15 @@@ config MIP
  	select HAVE_SYSCALL_TRACEPOINTS
  	select HAVE_VIRT_CPU_ACCOUNTING_GEN if 64BIT || !SMP
  	select IRQ_FORCED_THREADING
 -	select ISA if EISA
 -	select MODULES_USE_ELF_REL if MODULES
  	select MODULES_USE_ELF_RELA if MODULES && 64BIT
 +	select MODULES_USE_ELF_REL if MODULES
  	select PERF_USE_VMALLOC
++<<<<<<< HEAD
 +	select RTC_LIB if !MACH_LOONGSON64
++=======
+ 	select PCI_MSI_ARCH_FALLBACKS
+ 	select RTC_LIB
++>>>>>>> 077ee78e3928 (PCI/MSI: Make arch_.*_msi_irq[s] fallbacks selectable)
  	select SYSCTL_EXCEPTION_TRACE
  	select VIRT_TO_BUS
  
diff --cc arch/powerpc/Kconfig
index 7d9887476f0b,9e66ca1376af..000000000000
--- a/arch/powerpc/Kconfig
+++ b/arch/powerpc/Kconfig
@@@ -231,10 -241,13 +231,16 @@@ config PP
  	select NEED_DMA_MAP_STATE		if PPC64 || NOT_COHERENT_CACHE
  	select NEED_SG_DMA_LENGTH
  	select OF
 -	select OF_DMA_DEFAULT_COHERENT		if !NOT_COHERENT_CACHE
  	select OF_EARLY_FLATTREE
 +	select OF_RESERVED_MEM
  	select OLD_SIGACTION			if PPC32
  	select OLD_SIGSUSPEND
++<<<<<<< HEAD
++=======
+ 	select PCI_DOMAINS			if PCI
+ 	select PCI_MSI_ARCH_FALLBACKS
+ 	select PCI_SYSCALL			if PCI
++>>>>>>> 077ee78e3928 (PCI/MSI: Make arch_.*_msi_irq[s] fallbacks selectable)
  	select PPC_DAWR				if PPC64
  	select RTC_LIB
  	select SPARSE_IRQ
diff --cc arch/s390/Kconfig
index 53b3712d90ef,63dd5a0aa252..000000000000
--- a/arch/s390/Kconfig
+++ b/arch/s390/Kconfig
@@@ -168,9 -175,17 +168,15 @@@ config S39
  	select HAVE_RSEQ
  	select HAVE_SYSCALL_TRACEPOINTS
  	select HAVE_VIRT_CPU_ACCOUNTING
 -	select IOMMU_HELPER		if PCI
 -	select IOMMU_SUPPORT		if PCI
  	select MODULES_USE_ELF_RELA
 -	select NEED_DMA_MAP_STATE	if PCI
 -	select NEED_SG_DMA_LENGTH	if PCI
  	select OLD_SIGACTION
  	select OLD_SIGSUSPEND3
++<<<<<<< HEAD
++=======
+ 	select PCI_DOMAINS		if PCI
+ 	select PCI_MSI			if PCI
+ 	select PCI_MSI_ARCH_FALLBACKS
++>>>>>>> 077ee78e3928 (PCI/MSI: Make arch_.*_msi_irq[s] fallbacks selectable)
  	select SPARSE_IRQ
  	select SYSCTL_EXCEPTION_TRACE
  	select THREAD_INFO_IN_TASK
diff --cc arch/sparc/Kconfig
index 12d490d796fe,21a3239870c0..000000000000
--- a/arch/sparc/Kconfig
+++ b/arch/sparc/Kconfig
@@@ -38,9 -42,10 +38,14 @@@ config SPAR
  	select GENERIC_STRNCPY_FROM_USER
  	select GENERIC_STRNLEN_USER
  	select MODULES_USE_ELF_RELA
++<<<<<<< HEAD
++=======
+ 	select PCI_SYSCALL if PCI
+ 	select PCI_MSI_ARCH_FALLBACKS
++>>>>>>> 077ee78e3928 (PCI/MSI: Make arch_.*_msi_irq[s] fallbacks selectable)
  	select ODD_RT_SIGACTION
  	select OLD_SIGSUSPEND
 +	select ARCH_HAS_SG_CHAIN
  	select CPU_NO_EFFICIENT_FFS
  	select LOCKDEP_SMALL if LOCKDEP
  	select NEED_DMA_MAP_STATE
diff --cc drivers/pci/controller/Kconfig
index 63b92f8a2a57,4a7afbe189f8..000000000000
--- a/drivers/pci/controller/Kconfig
+++ b/drivers/pci/controller/Kconfig
@@@ -84,8 -59,27 +85,29 @@@ config PCIE_RCA
  	bool "Renesas R-Car PCIe controller"
  	depends on ARCH_RENESAS || COMPILE_TEST
  	depends on PCI_MSI_IRQ_DOMAIN
 -	select PCIE_RCAR_HOST
  	help
  	  Say Y here if you want PCIe controller support on R-Car SoCs.
++<<<<<<< HEAD
++=======
+ 	  This option will be removed after arm64 defconfig is updated.
+ 
+ config PCIE_RCAR_HOST
+ 	bool "Renesas R-Car PCIe host controller"
+ 	depends on ARCH_RENESAS || COMPILE_TEST
+ 	depends on PCI_MSI_IRQ_DOMAIN
+ 	select PCI_MSI_ARCH_FALLBACKS
+ 	help
+ 	  Say Y here if you want PCIe controller support on R-Car SoCs in host
+ 	  mode.
+ 
+ config PCIE_RCAR_EP
+ 	bool "Renesas R-Car PCIe endpoint controller"
+ 	depends on ARCH_RENESAS || COMPILE_TEST
+ 	depends on PCI_ENDPOINT
+ 	help
+ 	  Say Y here if you want PCIe controller support on R-Car SoCs in
+ 	  endpoint mode.
++>>>>>>> 077ee78e3928 (PCI/MSI: Make arch_.*_msi_irq[s] fallbacks selectable)
  
  config PCI_HOST_COMMON
  	tristate
* Unmerged path arch/ia64/Kconfig
* Unmerged path arch/mips/Kconfig
* Unmerged path arch/powerpc/Kconfig
* Unmerged path arch/s390/Kconfig
* Unmerged path arch/sparc/Kconfig
diff --git a/arch/x86/Kconfig b/arch/x86/Kconfig
index 50963a2ee16c..2cdbcd7b598a 100644
--- a/arch/x86/Kconfig
+++ b/arch/x86/Kconfig
@@ -217,6 +217,7 @@ config X86
 	select IRQ_FORCED_THREADING
 	select NEED_SG_DMA_LENGTH
 	select PCI_LOCKLESS_CONFIG		if PCI
+	select PCI_MSI_ARCH_FALLBACKS
 	select PERF_EVENTS
 	select RTC_LIB
 	select RTC_MC146818_LIB
diff --git a/drivers/pci/Kconfig b/drivers/pci/Kconfig
index 0d6ee215b080..6418723ca0ab 100644
--- a/drivers/pci/Kconfig
+++ b/drivers/pci/Kconfig
@@ -26,6 +26,9 @@ config PCI_MSI_IRQ_DOMAIN
 	depends on PCI_MSI
 	select GENERIC_MSI_IRQ_DOMAIN
 
+config PCI_MSI_ARCH_FALLBACKS
+	bool
+
 config PCI_QUIRKS
 	default y
 	bool "Enable PCI quirk workarounds" if EXPERT
* Unmerged path drivers/pci/controller/Kconfig
diff --git a/drivers/pci/msi.c b/drivers/pci/msi.c
index 21baeb425b27..a24671fb8db2 100644
--- a/drivers/pci/msi.c
+++ b/drivers/pci/msi.c
@@ -60,8 +60,8 @@ static void pci_msi_teardown_msi_irqs(struct pci_dev *dev)
 #define pci_msi_teardown_msi_irqs	arch_teardown_msi_irqs
 #endif
 
+#ifdef CONFIG_PCI_MSI_ARCH_FALLBACKS
 /* Arch hooks */
-
 int __weak arch_setup_msi_irq(struct pci_dev *dev, struct msi_desc *desc)
 {
 	struct msi_controller *chip = dev->bus->msi;
@@ -134,6 +134,7 @@ void __weak arch_teardown_msi_irqs(struct pci_dev *dev)
 {
 	return default_teardown_msi_irqs(dev);
 }
+#endif /* CONFIG_PCI_MSI_ARCH_FALLBACKS */
 
 static void default_restore_msi_irq(struct pci_dev *dev, int irq)
 {
diff --git a/include/linux/msi.h b/include/linux/msi.h
index 8d241c6c3d8c..8a169cbeab3c 100644
--- a/include/linux/msi.h
+++ b/include/linux/msi.h
@@ -226,17 +226,38 @@ void pci_msi_mask_irq(struct irq_data *data);
 void pci_msi_unmask_irq(struct irq_data *data);
 
 /*
- * The arch hooks to setup up msi irqs. Those functions are
- * implemented as weak symbols so that they /can/ be overriden by
- * architecture specific code if needed.
+ * The arch hooks to setup up msi irqs. Default functions are implemented
+ * as weak symbols so that they /can/ be overriden by architecture specific
+ * code if needed. These hooks must be enabled by the architecture or by
+ * drivers which depend on them via msi_controller based MSI handling.
+ *
+ * If CONFIG_PCI_MSI_ARCH_FALLBACKS is not selected they are replaced by
+ * stubs with warnings.
  */
+#ifdef CONFIG_PCI_MSI_ARCH_FALLBACKS
 int arch_setup_msi_irq(struct pci_dev *dev, struct msi_desc *desc);
 void arch_teardown_msi_irq(unsigned int irq);
 int arch_setup_msi_irqs(struct pci_dev *dev, int nvec, int type);
 void arch_teardown_msi_irqs(struct pci_dev *dev);
-void arch_restore_msi_irqs(struct pci_dev *dev);
-
 void default_teardown_msi_irqs(struct pci_dev *dev);
+#else
+static inline int arch_setup_msi_irqs(struct pci_dev *dev, int nvec, int type)
+{
+	WARN_ON_ONCE(1);
+	return -ENODEV;
+}
+
+static inline void arch_teardown_msi_irqs(struct pci_dev *dev)
+{
+	WARN_ON_ONCE(1);
+}
+#endif
+
+/*
+ * The restore hooks are still available as they are useful even
+ * for fully irq domain based setups. Courtesy to XEN/X86.
+ */
+void arch_restore_msi_irqs(struct pci_dev *dev);
 void default_restore_msi_irqs(struct pci_dev *dev);
 
 struct msi_controller {
