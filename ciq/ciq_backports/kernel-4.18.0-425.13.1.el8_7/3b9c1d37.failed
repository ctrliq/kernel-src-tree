x86/msi: Consolidate MSI allocation

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-425.13.1.el8_7
commit-author Thomas Gleixner <tglx@linutronix.de>
commit 3b9c1d377d67072d1d8a2373b4969103cca00dab
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-425.13.1.el8_7/3b9c1d37.failed

Convert the interrupt remap drivers to retrieve the pci device from the msi
descriptor and use info::hwirq.

This is the first step to prepare x86 for using the generic MSI domain ops.

	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Acked-by: Wei Liu <wei.liu@kernel.org>
	Acked-by: Joerg Roedel <jroedel@suse.de>
Link: https://lore.kernel.org/r/20200826112332.466405395@linutronix.de

(cherry picked from commit 3b9c1d377d67072d1d8a2373b4969103cca00dab)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/hw_irq.h
#	drivers/iommu/intel/irq_remapping.c
diff --cc arch/x86/include/asm/hw_irq.h
index d565a3a6fc63,a4aeeaace040..000000000000
--- a/arch/x86/include/asm/hw_irq.h
+++ b/arch/x86/include/asm/hw_irq.h
@@@ -109,21 -86,6 +109,24 @@@ struct irq_alloc_info 
  	union {
  		struct ioapic_alloc_info	ioapic;
  		struct uv_alloc_info		uv;
++<<<<<<< HEAD
 +
 +		int		unused;
 +#ifdef	CONFIG_HPET_TIMER
 +		struct {
 +			int		hpet_id;
 +			int		hpet_index;
 +			void		*hpet_data;
 +		};
 +#endif
 +#ifdef	CONFIG_PCI_MSI
 +		struct {
 +			struct pci_dev	*msi_dev;
 +			irq_hw_number_t	msi_hwirq;
 +		};
 +#endif
++=======
++>>>>>>> 3b9c1d377d67 (x86/msi: Consolidate MSI allocation)
  	};
  };
  
diff --cc drivers/iommu/intel/irq_remapping.c
index c409e2e81e8b,d9db2f37b831..000000000000
--- a/drivers/iommu/intel/irq_remapping.c
+++ b/drivers/iommu/intel/irq_remapping.c
@@@ -1131,10 -1121,10 +1131,10 @@@ static struct irq_domain *intel_get_irq
  	case X86_IRQ_ALLOC_TYPE_IOAPIC_GET_PARENT:
  		return map_ioapic_to_ir(info->devid);
  	case X86_IRQ_ALLOC_TYPE_HPET_GET_PARENT:
 -		return map_hpet_to_ir(info->devid);
 +		return map_hpet_to_ir(info->hpet_id);
  	case X86_IRQ_ALLOC_TYPE_PCI_MSI:
  	case X86_IRQ_ALLOC_TYPE_PCI_MSIX:
- 		return map_dev_to_ir(info->msi_dev);
+ 		return map_dev_to_ir(msi_desc_to_pci_dev(info->desc));
  	default:
  		WARN_ON_ONCE(1);
  		return NULL;
@@@ -1301,9 -1291,9 +1301,13 @@@ static void intel_irq_remapping_prepare
  	case X86_IRQ_ALLOC_TYPE_PCI_MSI:
  	case X86_IRQ_ALLOC_TYPE_PCI_MSIX:
  		if (info->type == X86_IRQ_ALLOC_TYPE_HPET)
 -			set_hpet_sid(irte, info->devid);
 +			set_hpet_sid(irte, info->hpet_id);
  		else
++<<<<<<< HEAD
 +			set_msi_sid(irte, pci_real_dma_dev(info->msi_dev));
++=======
+ 			set_msi_sid(irte, msi_desc_to_pci_dev(info->desc));
++>>>>>>> 3b9c1d377d67 (x86/msi: Consolidate MSI allocation)
  
  		msg->address_hi = MSI_ADDR_BASE_HI;
  		msg->data = sub_handle;
* Unmerged path arch/x86/include/asm/hw_irq.h
diff --git a/arch/x86/kernel/apic/msi.c b/arch/x86/kernel/apic/msi.c
index bed38e81fe87..7a8842bdae70 100644
--- a/arch/x86/kernel/apic/msi.c
+++ b/arch/x86/kernel/apic/msi.c
@@ -162,7 +162,6 @@ int native_setup_msi_irqs(struct pci_dev *dev, int nvec, int type)
 
 	init_irq_alloc_info(&info, NULL);
 	info.type = X86_IRQ_ALLOC_TYPE_PCI_MSI;
-	info.msi_dev = dev;
 
 	domain = irq_remapping_get_irq_domain(&info);
 	if (domain == NULL)
@@ -181,7 +180,7 @@ void native_teardown_msi_irq(unsigned int irq)
 static irq_hw_number_t pci_msi_get_hwirq(struct msi_domain_info *info,
 					 msi_alloc_info_t *arg)
 {
-	return arg->msi_hwirq;
+	return arg->hwirq;
 }
 
 int pci_msi_prepare(struct irq_domain *domain, struct device *dev, int nvec,
@@ -191,7 +190,6 @@ int pci_msi_prepare(struct irq_domain *domain, struct device *dev, int nvec,
 	struct msi_desc *desc = first_pci_msi_entry(pdev);
 
 	init_irq_alloc_info(arg, NULL);
-	arg->msi_dev = pdev;
 	if (desc->msi_attrib.is_msix) {
 		arg->type = X86_IRQ_ALLOC_TYPE_PCI_MSIX;
 	} else {
@@ -205,7 +203,8 @@ EXPORT_SYMBOL_GPL(pci_msi_prepare);
 
 void pci_msi_set_desc(msi_alloc_info_t *arg, struct msi_desc *desc)
 {
-	arg->msi_hwirq = pci_msi_domain_calc_hwirq(desc);
+	arg->desc = desc;
+	arg->hwirq = pci_msi_domain_calc_hwirq(desc);
 }
 EXPORT_SYMBOL_GPL(pci_msi_set_desc);
 
diff --git a/drivers/iommu/amd/iommu.c b/drivers/iommu/amd/iommu.c
index deb0ce876932..1de062164f80 100644
--- a/drivers/iommu/amd/iommu.c
+++ b/drivers/iommu/amd/iommu.c
@@ -3052,7 +3052,7 @@ static int get_devid(struct irq_alloc_info *info)
 		return get_hpet_devid(info->hpet_id);
 	case X86_IRQ_ALLOC_TYPE_PCI_MSI:
 	case X86_IRQ_ALLOC_TYPE_PCI_MSIX:
-		return get_device_id(&info->msi_dev->dev);
+		return get_device_id(msi_desc_to_dev(info->desc));
 	default:
 		WARN_ON_ONCE(1);
 		return -1;
@@ -3231,7 +3231,8 @@ static int irq_remapping_alloc(struct irq_domain *domain, unsigned int virq,
 		   info->type == X86_IRQ_ALLOC_TYPE_PCI_MSIX) {
 		bool align = (info->type == X86_IRQ_ALLOC_TYPE_PCI_MSI);
 
-		index = alloc_irq_index(devid, nr_irqs, align, info->msi_dev);
+		index = alloc_irq_index(devid, nr_irqs, align,
+					msi_desc_to_pci_dev(info->desc));
 	} else {
 		index = alloc_irq_index(devid, nr_irqs, false, NULL);
 	}
* Unmerged path drivers/iommu/intel/irq_remapping.c
diff --git a/drivers/pci/controller/pci-hyperv.c b/drivers/pci/controller/pci-hyperv.c
index e492e486f75b..13f4dd3edafb 100644
--- a/drivers/pci/controller/pci-hyperv.c
+++ b/drivers/pci/controller/pci-hyperv.c
@@ -1926,7 +1926,7 @@ static struct irq_chip hv_msi_irq_chip = {
 static irq_hw_number_t hv_msi_domain_ops_get_hwirq(struct msi_domain_info *info,
 						   msi_alloc_info_t *arg)
 {
-	return arg->msi_hwirq;
+	return arg->hwirq;
 }
 #endif
 
