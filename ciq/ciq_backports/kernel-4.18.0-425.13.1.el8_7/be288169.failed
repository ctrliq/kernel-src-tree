cgroup: reduce dependency on cgroup_mutex

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-425.13.1.el8_7
commit-author Shakeel Butt <shakeelb@google.com>
commit be288169712f3dea0bc6b50c00b3ab53d85f1435
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-425.13.1.el8_7/be288169.failed

Currently cgroup_get_from_path() and cgroup_get_from_id() grab
cgroup_mutex before traversing the default hierarchy to find the
kernfs_node corresponding to the path/id and then extract the linked
cgroup. Since cgroup_mutex is still held, it is guaranteed that the
cgroup will be alive and the reference can be taken on it.

However similar guarantee can be provided without depending on the
cgroup_mutex and potentially reducing avenues of cgroup_mutex contentions.
The kernfs_node's priv pointer is RCU protected pointer and with just
rcu read lock we can grab the reference on the cgroup without
cgroup_mutex. So, remove cgroup_mutex from them.

	Signed-off-by: Shakeel Butt <shakeelb@google.com>
	Signed-off-by: Tejun Heo <tj@kernel.org>
(cherry picked from commit be288169712f3dea0bc6b50c00b3ab53d85f1435)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/cgroup/cgroup.c
diff --cc kernel/cgroup/cgroup.c
index 6425d3380332,003204c85893..000000000000
--- a/kernel/cgroup/cgroup.c
+++ b/kernel/cgroup/cgroup.c
@@@ -5855,17 -5932,20 +5855,25 @@@ struct cgroup *cgroup_get_from_id(u64 i
  	struct kernfs_node *kn;
  	struct cgroup *cgrp = NULL;
  
++<<<<<<< HEAD
 +	mutex_lock(&cgroup_mutex);
 +	kn = kernfs_get_node_by_id(cgrp_dfl_root.kf_root, id);
++=======
+ 	kn = kernfs_find_and_get_node_by_id(cgrp_dfl_root.kf_root, id);
++>>>>>>> be288169712f (cgroup: reduce dependency on cgroup_mutex)
  	if (!kn)
- 		goto out_unlock;
+ 		goto out;
+ 
+ 	rcu_read_lock();
  
- 	cgrp = kn->priv;
- 	if (cgroup_is_dead(cgrp) || !cgroup_tryget(cgrp))
+ 	cgrp = rcu_dereference(*(void __rcu __force **)&kn->priv);
+ 	if (cgrp && !cgroup_tryget(cgrp))
  		cgrp = NULL;
+ 
+ 	rcu_read_unlock();
+ 
  	kernfs_put(kn);
- out_unlock:
- 	mutex_unlock(&cgroup_mutex);
+ out:
  	return cgrp;
  }
  EXPORT_SYMBOL_GPL(cgroup_get_from_id);
* Unmerged path kernel/cgroup/cgroup.c
