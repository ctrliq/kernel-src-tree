x86/msi: Use generic MSI domain ops

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-425.13.1.el8_7
commit-author Thomas Gleixner <tglx@linutronix.de>
commit 9006c133a422f474d7d8e10a8baae179f70c22f5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-425.13.1.el8_7/9006c133.failed

pci_msi_get_hwirq() and pci_msi_set_desc are not longer special. Enable the
generic MSI domain ops in the core and PCI MSI code unconditionally and get
rid of the x86 specific implementations in the X86 MSI code and in the
hyperv PCI driver.

	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Reviewed-by: Marc Zyngier <maz@kernel.org>
Link: https://lore.kernel.org/r/20200826112332.564274859@linutronix.de

(cherry picked from commit 9006c133a422f474d7d8e10a8baae179f70c22f5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/msi.h
#	arch/x86/kernel/apic/msi.c
#	drivers/pci/controller/pci-hyperv.c
diff --cc arch/x86/include/asm/msi.h
index cb6733019d62,cd30013d15d3..000000000000
--- a/arch/x86/include/asm/msi.h
+++ b/arch/x86/include/asm/msi.h
@@@ -9,56 -9,4 +9,59 @@@ typedef struct irq_alloc_info msi_alloc
  int pci_msi_prepare(struct irq_domain *domain, struct device *dev, int nvec,
  		    msi_alloc_info_t *arg);
  
++<<<<<<< HEAD
 +void pci_msi_set_desc(msi_alloc_info_t *arg, struct msi_desc *desc);
 +
 +/* Structs and defines for the X86 specific MSI message format */
 +
 +typedef struct x86_msi_data {
 +	u32	vector			:  8,
 +		delivery_mode		:  3,
 +		dest_mode_logical	:  1,
 +		reserved		:  2,
 +		active_low		:  1,
 +		is_level		:  1;
 +
 +	u32	dmar_subhandle;
 +} __attribute__ ((packed)) arch_msi_msg_data_t;
 +#define arch_msi_msg_data	x86_msi_data
 +
 +typedef struct x86_msi_addr_lo {
 +	union {
 +		struct {
 +			u32	reserved_0		:  2,
 +				dest_mode_logical	:  1,
 +				redirect_hint		:  1,
 +				reserved_1		:  1,
 +				virt_destid_8_14	:  7,
 +				destid_0_7		:  8,
 +				base_address		: 12;
 +		};
 +		struct {
 +			u32	dmar_reserved_0		:  2,
 +				dmar_index_15		:  1,
 +				dmar_subhandle_valid	:  1,
 +				dmar_format		:  1,
 +				dmar_index_0_14		: 15,
 +				dmar_base_address	: 12;
 +		};
 +	};
 +} __attribute__ ((packed)) arch_msi_msg_addr_lo_t;
 +#define arch_msi_msg_addr_lo	x86_msi_addr_lo
 +
 +#define X86_MSI_BASE_ADDRESS_LOW	(0xfee00000 >> 20)
 +
 +typedef struct x86_msi_addr_hi {
 +	u32	reserved		:  8,
 +		destid_8_31		: 24;
 +} __attribute__ ((packed)) arch_msi_msg_addr_hi_t;
 +#define arch_msi_msg_addr_hi	x86_msi_addr_hi
 +
 +#define X86_MSI_BASE_ADDRESS_HIGH	(0)
 +
 +struct msi_msg;
 +u32 x86_msi_msg_get_destid(struct msi_msg *msg, bool extid);
 +
++=======
++>>>>>>> 9006c133a422 (x86/msi: Use generic MSI domain ops)
  #endif /* _ASM_X86_MSI_H */
diff --cc arch/x86/kernel/apic/msi.c
index eb944445adf2,378c692a4170..000000000000
--- a/arch/x86/kernel/apic/msi.c
+++ b/arch/x86/kernel/apic/msi.c
@@@ -178,12 -203,6 +178,15 @@@ void native_teardown_msi_irq(unsigned i
  	irq_domain_free_irqs(irq, 1);
  }
  
++<<<<<<< HEAD
 +static irq_hw_number_t pci_msi_get_hwirq(struct msi_domain_info *info,
 +					 msi_alloc_info_t *arg)
 +{
 +	return arg->msi_hwirq;
 +}
 +
++=======
++>>>>>>> 9006c133a422 (x86/msi: Use generic MSI domain ops)
  int pci_msi_prepare(struct irq_domain *domain, struct device *dev, int nvec,
  		    msi_alloc_info_t *arg)
  {
@@@ -203,16 -221,8 +206,17 @@@
  }
  EXPORT_SYMBOL_GPL(pci_msi_prepare);
  
++<<<<<<< HEAD
 +void pci_msi_set_desc(msi_alloc_info_t *arg, struct msi_desc *desc)
 +{
 +	arg->msi_hwirq = pci_msi_domain_calc_hwirq(desc);
 +}
 +EXPORT_SYMBOL_GPL(pci_msi_set_desc);
 +
++=======
++>>>>>>> 9006c133a422 (x86/msi: Use generic MSI domain ops)
  static struct msi_domain_ops pci_msi_domain_ops = {
- 	.get_hwirq	= pci_msi_get_hwirq,
  	.msi_prepare	= pci_msi_prepare,
- 	.set_desc	= pci_msi_set_desc,
  };
  
  static struct msi_domain_info pci_msi_domain_info = {
@@@ -413,12 -398,6 +411,15 @@@ static struct irq_chip hpet_msi_control
  	.flags = IRQCHIP_SKIP_SET_WAKE,
  };
  
++<<<<<<< HEAD
 +static irq_hw_number_t hpet_msi_get_hwirq(struct msi_domain_info *info,
 +					  msi_alloc_info_t *arg)
 +{
 +	return arg->hpet_index;
 +}
 +
++=======
++>>>>>>> 9006c133a422 (x86/msi: Use generic MSI domain ops)
  static int hpet_msi_init(struct irq_domain *domain,
  			 struct msi_domain_info *info, unsigned int virq,
  			 irq_hw_number_t hwirq, msi_alloc_info_t *arg)
diff --cc drivers/pci/controller/pci-hyperv.c
index e492e486f75b,25b4c9023bfa..000000000000
--- a/drivers/pci/controller/pci-hyperv.c
+++ b/drivers/pci/controller/pci-hyperv.c
@@@ -1922,20 -1531,8 +1922,25 @@@ static struct irq_chip hv_msi_irq_chip 
  	.irq_unmask		= hv_irq_unmask,
  };
  
++<<<<<<< HEAD
 +#ifdef CONFIG_X86
 +static irq_hw_number_t hv_msi_domain_ops_get_hwirq(struct msi_domain_info *info,
 +						   msi_alloc_info_t *arg)
 +{
 +	return arg->msi_hwirq;
 +}
 +#endif
 +
 +static struct msi_domain_ops hv_msi_ops = {
 +#ifdef CONFIG_X86
 +	.get_hwirq	= hv_msi_domain_ops_get_hwirq,
 +	.set_desc	= pci_msi_set_desc,
 +#endif
 +	.msi_prepare	= hv_msi_prepare,
++=======
+ static struct msi_domain_ops hv_msi_ops = {
+ 	.msi_prepare	= pci_msi_prepare,
++>>>>>>> 9006c133a422 (x86/msi: Use generic MSI domain ops)
  	.msi_free	= hv_msi_free,
  };
  
* Unmerged path arch/x86/include/asm/msi.h
* Unmerged path arch/x86/kernel/apic/msi.c
* Unmerged path drivers/pci/controller/pci-hyperv.c
diff --git a/drivers/pci/msi.c b/drivers/pci/msi.c
index 21baeb425b27..d4cdcd4db19f 100644
--- a/drivers/pci/msi.c
+++ b/drivers/pci/msi.c
@@ -1387,7 +1387,7 @@ void pci_msi_domain_write_msg(struct irq_data *irq_data, struct msi_msg *msg)
  *
  * The ID number is only used within the irqdomain.
  */
-irq_hw_number_t pci_msi_domain_calc_hwirq(struct msi_desc *desc)
+static irq_hw_number_t pci_msi_domain_calc_hwirq(struct msi_desc *desc)
 {
 	struct pci_dev *dev = msi_desc_to_pci_dev(desc);
 
@@ -1438,16 +1438,12 @@ static int pci_msi_domain_handle_error(struct irq_domain *domain,
 	return error;
 }
 
-#ifdef GENERIC_MSI_DOMAIN_OPS
 static void pci_msi_domain_set_desc(msi_alloc_info_t *arg,
 				    struct msi_desc *desc)
 {
 	arg->desc = desc;
 	arg->hwirq = pci_msi_domain_calc_hwirq(desc);
 }
-#else
-#define pci_msi_domain_set_desc		NULL
-#endif
 
 static struct msi_domain_ops pci_msi_domain_ops_default = {
 	.set_desc	= pci_msi_domain_set_desc,
diff --git a/include/linux/msi.h b/include/linux/msi.h
index 8d241c6c3d8c..1b203e841bff 100644
--- a/include/linux/msi.h
+++ b/include/linux/msi.h
@@ -428,7 +428,6 @@ void pci_msi_domain_write_msg(struct irq_data *irq_data, struct msi_msg *msg);
 struct irq_domain *pci_msi_create_irq_domain(struct fwnode_handle *fwnode,
 					     struct msi_domain_info *info,
 					     struct irq_domain *parent);
-irq_hw_number_t pci_msi_domain_calc_hwirq(struct msi_desc *desc);
 int pci_msi_domain_check_cap(struct irq_domain *domain,
 			     struct msi_domain_info *info, struct device *dev);
 u32 pci_msi_domain_get_msi_rid(struct irq_domain *domain, struct pci_dev *pdev);
diff --git a/kernel/irq/msi.c b/kernel/irq/msi.c
index 6c229e5d3fcb..dc0e2d7fbdfd 100644
--- a/kernel/irq/msi.c
+++ b/kernel/irq/msi.c
@@ -187,7 +187,6 @@ static const struct irq_domain_ops msi_domain_ops = {
 	.deactivate	= msi_domain_deactivate,
 };
 
-#ifdef GENERIC_MSI_DOMAIN_OPS
 static irq_hw_number_t msi_domain_ops_get_hwirq(struct msi_domain_info *info,
 						msi_alloc_info_t *arg)
 {
@@ -206,11 +205,6 @@ static void msi_domain_ops_set_desc(msi_alloc_info_t *arg,
 {
 	arg->desc = desc;
 }
-#else
-#define msi_domain_ops_get_hwirq	NULL
-#define msi_domain_ops_prepare		NULL
-#define msi_domain_ops_set_desc		NULL
-#endif /* !GENERIC_MSI_DOMAIN_OPS */
 
 static int msi_domain_ops_init(struct irq_domain *domain,
 			       struct msi_domain_info *info,
