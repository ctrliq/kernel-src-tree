xfs: fix sparse inode limits on runt AG

jira LE-3201
Rebuild_History Non-Buildable kernel-rt-4.18.0-553.34.1.rt7.375.el8_10
commit-author Dave Chinner <dchinner@redhat.com>
commit 13325333582d4820d39b9e8f63d6a54e745585d9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-rt-4.18.0-553.34.1.rt7.375.el8_10/13325333.failed

The runt AG at the end of a filesystem is almost always smaller than
the mp->m_sb.sb_agblocks. Unfortunately, when setting the max_agbno
limit for the inode chunk allocation, we do not take this into
account. This means we can allocate a sparse inode chunk that
overlaps beyond the end of an AG. When we go to allocate an inode
from that sparse chunk, the irec fails validation because the
agbno of the start of the irec is beyond valid limits for the runt
AG.

Prevent this from happening by taking into account the size of the
runt AG when allocating inode chunks. Also convert the various
checks for valid inode chunk agbnos to use xfs_ag_block_count()
so that they will also catch such issues in the future.

Fixes: 56d1115c9bc7 ("xfs: allocate sparse inode chunks on full chunk allocation failure")
	Signed-off-by: Dave Chinner <dchinner@redhat.com>
	Reviewed-by: Darrick J. Wong <djwong@kernel.org>
	Signed-off-by: Carlos Maiolino <cem@kernel.org>

(cherry picked from commit 13325333582d4820d39b9e8f63d6a54e745585d9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/libxfs/xfs_ialloc.c
diff --cc fs/xfs/libxfs/xfs_ialloc.c
index 75930a32c8e8,f3a840a425f5..000000000000
--- a/fs/xfs/libxfs/xfs_ialloc.c
+++ b/fs/xfs/libxfs/xfs_ialloc.c
@@@ -2295,11 -2473,10 +2296,16 @@@ xfs_imap
  	/*
  	 * Split up the inode number into its parts.
  	 */
 +	pag = xfs_perag_get(mp, XFS_INO_TO_AGNO(mp, ino));
  	agino = XFS_INO_TO_AGINO(mp, ino);
  	agbno = XFS_AGINO_TO_AGBNO(mp, agino);
++<<<<<<< HEAD
 +	if (!pag || agbno >= mp->m_sb.sb_agblocks ||
 +	    ino != XFS_AGINO_TO_INO(mp, pag->pag_agno, agino)) {
++=======
+ 	if (agbno >= xfs_ag_block_count(mp, pag_agno(pag)) ||
+ 	    ino != xfs_agino_to_ino(pag, agino)) {
++>>>>>>> 13325333582d (xfs: fix sparse inode limits on runt AG)
  		error = -EINVAL;
  #ifdef DEBUG
  		/*
@@@ -2307,24 -2484,19 +2313,30 @@@
  		 * as they can be invalid without implying corruption.
  		 */
  		if (flags & XFS_IGET_UNTRUSTED)
++<<<<<<< HEAD
 +			goto out_drop;
 +		if (!pag) {
 +			xfs_alert(mp,
 +				"%s: agno (%d) >= mp->m_sb.sb_agcount (%d)",
 +				__func__, XFS_INO_TO_AGNO(mp, ino),
 +				mp->m_sb.sb_agcount);
 +		}
 +		if (agbno >= mp->m_sb.sb_agblocks) {
++=======
+ 			return error;
+ 		if (agbno >= xfs_ag_block_count(mp, pag_agno(pag))) {
++>>>>>>> 13325333582d (xfs: fix sparse inode limits on runt AG)
  			xfs_alert(mp,
  		"%s: agbno (0x%llx) >= mp->m_sb.sb_agblocks (0x%lx)",
  				__func__, (unsigned long long)agbno,
- 				(unsigned long)mp->m_sb.sb_agblocks);
+ 				(unsigned long)xfs_ag_block_count(mp,
+ 							pag_agno(pag)));
  		}
 -		if (ino != xfs_agino_to_ino(pag, agino)) {
 +		if (pag && ino != XFS_AGINO_TO_INO(mp, pag->pag_agno, agino)) {
  			xfs_alert(mp,
 -		"%s: ino (0x%llx) != xfs_agino_to_ino() (0x%llx)",
 +		"%s: ino (0x%llx) != XFS_AGINO_TO_INO() (0x%llx)",
  				__func__, ino,
 -				xfs_agino_to_ino(pag, agino));
 +				XFS_AGINO_TO_INO(mp, pag->pag_agno, agino));
  		}
  		xfs_stack_trace();
  #endif /* DEBUG */
* Unmerged path fs/xfs/libxfs/xfs_ialloc.c
