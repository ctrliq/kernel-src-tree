sched/cputime: Add vtime idle task state

jira LE-1907
Rebuild_History Non-Buildable kernel-rt-4.18.0-372.13.1.rt7.170.el8_6
commit-author Frederic Weisbecker <frederic@kernel.org>
commit 14faf6fcac4ba33f8fd8d9b2d0278010a9eb1742
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-rt-4.18.0-372.13.1.rt7.170.el8_6/14faf6fc.failed

Record idle as a VTIME state instead of guessing it from VTIME_SYS and
is_idle_task(). This is going to simplify the cputime read side
especially as its state machine is going to further expand in order to
fully support kcpustat on nohz_full.

	Signed-off-by: Frederic Weisbecker <frederic@kernel.org>
	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
	Cc: Jacek Anaszewski <jacek.anaszewski@gmail.com>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Pavel Machek <pavel@ucw.cz>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Rafael J . Wysocki <rjw@rjwysocki.net>
	Cc: Rik van Riel <riel@surriel.com>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: Viresh Kumar <viresh.kumar@linaro.org>
	Cc: Wanpeng Li <wanpengli@tencent.com>
	Cc: Yauheni Kaliuta <yauheni.kaliuta@redhat.com>
Link: https://lkml.kernel.org/r/20191016025700.31277-3-frederic@kernel.org
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 14faf6fcac4ba33f8fd8d9b2d0278010a9eb1742)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/sched/cputime.c
diff --cc kernel/sched/cputime.c
index bb1a48b548e0,2e885e870aa1..000000000000
--- a/kernel/sched/cputime.c
+++ b/kernel/sched/cputime.c
@@@ -765,16 -813,23 +765,26 @@@ void arch_vtime_task_switch(struct task
  	struct vtime *vtime = &prev->vtime;
  
  	write_seqcount_begin(&vtime->seqcount);
++<<<<<<< HEAD
++=======
+ 	if (vtime->state == VTIME_IDLE)
+ 		vtime_account_idle(prev);
+ 	else
+ 		__vtime_account_kernel(prev, vtime);
++>>>>>>> 14faf6fcac4b (sched/cputime: Add vtime idle task state)
  	vtime->state = VTIME_INACTIVE;
 -	vtime->cpu = -1;
 +	prev->task_struct_rh->vtime_cpu = -1;
  	write_seqcount_end(&vtime->seqcount);
  
  	vtime = &current->vtime;
  
  	write_seqcount_begin(&vtime->seqcount);
- 	vtime->state = VTIME_SYS;
+ 	if (is_idle_task(current))
+ 		vtime->state = VTIME_IDLE;
+ 	else
+ 		vtime->state = VTIME_SYS;
  	vtime->starttime = sched_clock();
 -	vtime->cpu = smp_processor_id();
 +	prev->task_struct_rh->vtime_cpu = smp_processor_id();
  	write_seqcount_end(&vtime->seqcount);
  }
  
@@@ -785,9 -840,9 +795,9 @@@ void vtime_init_idle(struct task_struc
  
  	local_irq_save(flags);
  	write_seqcount_begin(&vtime->seqcount);
- 	vtime->state = VTIME_SYS;
+ 	vtime->state = VTIME_IDLE;
  	vtime->starttime = sched_clock();
 -	vtime->cpu = cpu;
 +	t->task_struct_rh->vtime_cpu = cpu;
  	write_seqcount_end(&vtime->seqcount);
  	local_irq_restore(flags);
  }
@@@ -838,11 -891,10 +848,11 @@@ bool task_cputime(struct task_struct *t
  		*utime = t->utime;
  		*stime = t->stime;
  
- 		/* Task is sleeping, nothing to add */
- 		if (vtime->state == VTIME_INACTIVE || is_idle_task(t))
+ 		/* Task is sleeping or idle, nothing to add */
+ 		if (vtime->state < VTIME_SYS)
  			continue;
  
 +		ret = true;
  		delta = vtime_delta(vtime);
  
  		/*
diff --git a/include/linux/sched.h b/include/linux/sched.h
index 4b4d818f5651..4e08b5489306 100644
--- a/include/linux/sched.h
+++ b/include/linux/sched.h
@@ -313,10 +313,12 @@ struct prev_cputime {
 enum vtime_state {
 	/* Task is sleeping or running in a CPU with VTIME inactive: */
 	VTIME_INACTIVE = 0,
-	/* Task runs in userspace in a CPU with VTIME active: */
-	VTIME_USER,
+	/* Task is idle */
+	VTIME_IDLE,
 	/* Task runs in kernelspace in a CPU with VTIME active: */
 	VTIME_SYS,
+	/* Task runs in userspace in a CPU with VTIME active: */
+	VTIME_USER,
 };
 
 struct vtime {
* Unmerged path kernel/sched/cputime.c
