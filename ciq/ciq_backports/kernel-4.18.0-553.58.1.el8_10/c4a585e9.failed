s390/pci: Fix potential double remove of hotplug slot

jira LE-3467
Rebuild_History Non-Buildable kernel-4.18.0-553.58.1.el8_10
commit-author Niklas Schnelle <schnelle@linux.ibm.com>
commit c4a585e952ca403a370586d3f16e8331a7564901
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.58.1.el8_10/c4a585e9.failed

In commit 6ee600bfbe0f ("s390/pci: remove hotplug slot when releasing the
device") the zpci_exit_slot() was moved from zpci_device_reserved() to
zpci_release_device() with the intention of keeping the hotplug slot
around until the device is actually removed.

Now zpci_release_device() is only called once all references are
dropped. Since the zPCI subsystem only drops its reference once the
device is in the reserved state it follows that zpci_release_device()
must only deal with devices in the reserved state. Despite that it
contains code to tear down from both configured and standby state. For
the standby case this already includes the removal of the hotplug slot
so would cause a double removal if a device was ever removed in
either configured or standby state.

Instead of causing a potential double removal in a case that should
never happen explicitly WARN_ON() if a device in non-reserved state is
released and get rid of the dead code cases.

Fixes: 6ee600bfbe0f ("s390/pci: remove hotplug slot when releasing the device")
	Reviewed-by: Matthew Rosato <mjrosato@linux.ibm.com>
	Reviewed-by: Gerd Bayer <gbayer@linux.ibm.com>
	Tested-by: Gerd Bayer <gbayer@linux.ibm.com>
	Signed-off-by: Niklas Schnelle <schnelle@linux.ibm.com>
	Signed-off-by: Heiko Carstens <hca@linux.ibm.com>
(cherry picked from commit c4a585e952ca403a370586d3f16e8331a7564901)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/s390/pci/pci.c
diff --cc arch/s390/pci/pci.c
index 661c4e000c5b,7aeab522f28d..000000000000
--- a/arch/s390/pci/pci.c
+++ b/arch/s390/pci/pci.c
@@@ -1023,8 -914,32 +1023,12 @@@ int zpci_deconfigure_device(struct zpci
  void zpci_release_device(struct kref *kref)
  {
  	struct zpci_dev *zdev = container_of(kref, struct zpci_dev, kref);
- 	int ret;
  
++<<<<<<< HEAD
++=======
+ 	WARN_ON(zdev->state != ZPCI_FN_STATE_RESERVED);
+ 
++>>>>>>> c4a585e952ca (s390/pci: Fix potential double remove of hotplug slot)
  	if (zdev->zbus->bus)
  		zpci_bus_remove_device(zdev, false);
  
@@@ -1033,31 -946,16 +1037,42 @@@
  	if (zdev_enabled(zdev))
  		zpci_disable_device(zdev);
  
++<<<<<<< HEAD
 +	switch (zdev->state) {
 +	case ZPCI_FN_STATE_CONFIGURED:
 +		ret = sclp_pci_deconfigure(zdev->fid);
 +		zpci_dbg(3, "deconf fid:%x, rc:%d\n", zdev->fid, ret);
 +		fallthrough;
 +	case ZPCI_FN_STATE_STANDBY:
 +		if (zdev->has_hp_slot)
 +			zpci_exit_slot(zdev);
 +		spin_lock(&zpci_list_lock);
 +		list_del(&zdev->entry);
 +		spin_unlock(&zpci_list_lock);
 +		zpci_dbg(3, "rsv fid:%x\n", zdev->fid);
 +		fallthrough;
 +	case ZPCI_FN_STATE_RESERVED:
 +		if (zdev->has_resources)
 +			zpci_cleanup_bus_resources(zdev);
 +		zpci_bus_device_unregister(zdev);
 +		zpci_destroy_iommu(zdev);
 +		/* fallthrough */
 +	default:
 +		break;
 +	}
 +
++=======
+ 	if (zdev->has_hp_slot)
+ 		zpci_exit_slot(zdev);
+ 
+ 	if (zdev->has_resources)
+ 		zpci_cleanup_bus_resources(zdev);
+ 
+ 	zpci_bus_device_unregister(zdev);
+ 	zpci_destroy_iommu(zdev);
++>>>>>>> c4a585e952ca (s390/pci: Fix potential double remove of hotplug slot)
  	zpci_dbg(3, "rem fid:%x\n", zdev->fid);
 -	kfree_rcu(zdev, rcu);
 +	kfree(zdev);
  }
  
  int zpci_report_error(struct pci_dev *pdev,
* Unmerged path arch/s390/pci/pci.c
