idpf: avoid bloating &idpf_q_vector with big %NR_CPUS

jira LE-3467
Rebuild_History Non-Buildable kernel-4.18.0-553.58.1.el8_10
commit-author Alexander Lobakin <aleksander.lobakin@intel.com>
commit bf9bf7042a38ebd2485592467772db50605bd4a2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.58.1.el8_10/bf9bf704.failed

With CONFIG_MAXSMP, sizeof(cpumask_t) is 1 Kb. The queue vector
structure has them embedded, which means 1 additional Kb of not
really hotpath data.
We have cpumask_var_t, which is either an embedded cpumask or a pointer
for allocating it dynamically when it's big. Use it instead of plain
cpumasks and put &idpf_q_vector on a good diet.
Also remove redundant pointer to the interrupt name from the structure.
request_irq() saves it and free_irq() returns it on deinit, so that you
can free the memory.

	Reviewed-by: Przemek Kitszel <przemyslaw.kitszel@intel.com>
	Signed-off-by: Alexander Lobakin <aleksander.lobakin@intel.com>
	Signed-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>
(cherry picked from commit bf9bf7042a38ebd2485592467772db50605bd4a2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/idpf/idpf_txrx.c
#	drivers/net/ethernet/intel/idpf/idpf_txrx.h
diff --cc drivers/net/ethernet/intel/idpf/idpf_txrx.c
index 4a7062c55fcb,f569ea389b04..000000000000
--- a/drivers/net/ethernet/intel/idpf/idpf_txrx.c
+++ b/drivers/net/ethernet/intel/idpf/idpf_txrx.c
@@@ -4142,21 -4302,18 +4145,28 @@@ int idpf_vport_intr_alloc(struct idpf_v
  		q_vector->rx_intr_mode = IDPF_ITR_DYNAMIC;
  		q_vector->rx_itr_idx = VIRTCHNL2_ITR_IDX_0;
  
++<<<<<<< HEAD
 +		q_vector->tx = kcalloc(txqs_per_vector,
 +				       sizeof(struct idpf_queue *),
++=======
+ 		if (!zalloc_cpumask_var(&q_vector->affinity_mask, GFP_KERNEL))
+ 			goto error;
+ 
+ 		q_vector->tx = kcalloc(txqs_per_vector, sizeof(*q_vector->tx),
++>>>>>>> bf9bf7042a38 (idpf: avoid bloating &idpf_q_vector with big %NR_CPUS)
  				       GFP_KERNEL);
 -		if (!q_vector->tx)
 +		if (!q_vector->tx) {
 +			err = -ENOMEM;
  			goto error;
 +		}
  
 -		q_vector->rx = kcalloc(rxqs_per_vector, sizeof(*q_vector->rx),
 +		q_vector->rx = kcalloc(rxqs_per_vector,
 +				       sizeof(struct idpf_queue *),
  				       GFP_KERNEL);
 -		if (!q_vector->rx)
 +		if (!q_vector->rx) {
 +			err = -ENOMEM;
  			goto error;
 +		}
  
  		if (!idpf_is_queue_model_split(vport->rxq_model))
  			continue;
diff --cc drivers/net/ethernet/intel/idpf/idpf_txrx.h
index 1669bf01ba1d,5daa8f905f86..000000000000
--- a/drivers/net/ethernet/intel/idpf/idpf_txrx.h
+++ b/drivers/net/ethernet/intel/idpf/idpf_txrx.h
@@@ -518,8 -525,7 +517,12 @@@ struct idpf_intr_reg 
   * @num_bufq: Number of buffer queues
   * @bufq: Array of buffer queues to service
   * @total_events: Number of interrupts processed
++<<<<<<< HEAD
 + * @wb_on_itr: whether WB on ITR is enabled
 + * @name: Queue vector name
++=======
+  * @affinity_mask: CPU affinity mask
++>>>>>>> bf9bf7042a38 (idpf: avoid bloating &idpf_q_vector with big %NR_CPUS)
   */
  struct idpf_q_vector {
  	struct idpf_vport *vport;
@@@ -543,11 -551,11 +545,16 @@@
  	u32 rx_itr_idx;
  
  	u16 num_bufq;
 -	struct idpf_buf_queue **bufq;
 +	struct idpf_queue **bufq;
  
  	u16 total_events;
++<<<<<<< HEAD
 +	bool wb_on_itr;
 +	char *name;
++=======
+ 
+ 	cpumask_var_t affinity_mask;
++>>>>>>> bf9bf7042a38 (idpf: avoid bloating &idpf_q_vector with big %NR_CPUS)
  };
  
  struct idpf_rx_queue_stats {
diff --git a/drivers/net/ethernet/intel/idpf/idpf_lib.c b/drivers/net/ethernet/intel/idpf/idpf_lib.c
index ae8a48c48070..4c8fe567f702 100644
--- a/drivers/net/ethernet/intel/idpf/idpf_lib.c
+++ b/drivers/net/ethernet/intel/idpf/idpf_lib.c
@@ -69,7 +69,7 @@ static void idpf_deinit_vector_stack(struct idpf_adapter *adapter)
 static void idpf_mb_intr_rel_irq(struct idpf_adapter *adapter)
 {
 	clear_bit(IDPF_MB_INTR_MODE, adapter->flags);
-	free_irq(adapter->msix_entries[0].vector, adapter);
+	kfree(free_irq(adapter->msix_entries[0].vector, adapter));
 	queue_delayed_work(adapter->mbx_wq, &adapter->mbx_task, 0);
 }
 
@@ -124,15 +124,14 @@ static void idpf_mb_irq_enable(struct idpf_adapter *adapter)
  */
 static int idpf_mb_intr_req_irq(struct idpf_adapter *adapter)
 {
-	struct idpf_q_vector *mb_vector = &adapter->mb_vector;
 	int irq_num, mb_vidx = 0, err;
+	char *name;
 
 	irq_num = adapter->msix_entries[mb_vidx].vector;
-	mb_vector->name = kasprintf(GFP_KERNEL, "%s-%s-%d",
-				    dev_driver_string(&adapter->pdev->dev),
-				    "Mailbox", mb_vidx);
-	err = request_irq(irq_num, adapter->irq_mb_handler, 0,
-			  mb_vector->name, adapter);
+	name = kasprintf(GFP_KERNEL, "%s-%s-%d",
+			 dev_driver_string(&adapter->pdev->dev),
+			 "Mailbox", mb_vidx);
+	err = request_irq(irq_num, adapter->irq_mb_handler, 0, name, adapter);
 	if (err) {
 		dev_err(&adapter->pdev->dev,
 			"IRQ request for mailbox failed, error: %d\n", err);
* Unmerged path drivers/net/ethernet/intel/idpf/idpf_txrx.c
* Unmerged path drivers/net/ethernet/intel/idpf/idpf_txrx.h
