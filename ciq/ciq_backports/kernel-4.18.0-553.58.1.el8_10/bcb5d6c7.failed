s390/pci: introduce lock to synchronize state of zpci_dev's

jira LE-3467
Rebuild_History Non-Buildable kernel-4.18.0-553.58.1.el8_10
commit-author Gerd Bayer <gbayer@linux.ibm.com>
commit bcb5d6c769039c8358a2359e7c3ea5d97ce93108
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.58.1.el8_10/bcb5d6c7.failed

There's a number of tasks that need the state of a zpci device
to be stable. Other tasks need to be synchronized as they change the state.

State changes could be generated by the system as availability or error
events, or be requested by the user through manipulations in sysfs.
Some other actions accessible through sysfs - like device resets - need the
state to be stable.

Unsynchronized state handling could lead to unusable devices. This has
been observed in cases of concurrent state changes through systemd udev
rules and DPM boot control. Some breakage can be provoked by artificial
tests, e.g. through repetitively injecting "recover" on a PCI function
through sysfs while running a "hotplug remove/add" in a loop through a
PCI slot's "power" attribute in sysfs. After a few iterations this could
result in a kernel oops.

So introduce a new mutex "state_lock" to guard the state property of the
struct zpci_dev. Acquire this lock in all task that modify the state:

- hotplug add and remove, through the PCI hotplug slot entry,
- avaiability events, as reported by the platform,
- error events, as reported by the platform,
- during device resets, explicit through sysfs requests or
  implict through the common PCI layer.

Break out an inner _do_recover() routine out of recover_store() to
separte the necessary synchronizations from the actual manipulations of
the zpci_dev required for the reset.

With the following changes I was able to run the inject loops for hours
without hitting an error.

	Signed-off-by: Gerd Bayer <gbayer@linux.ibm.com>
	Reviewed-by: Niklas Schnelle <schnelle@linux.ibm.com>
	Signed-off-by: Heiko Carstens <hca@linux.ibm.com>
(cherry picked from commit bcb5d6c769039c8358a2359e7c3ea5d97ce93108)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/s390/pci/pci.c
#	arch/s390/pci/pci_sysfs.c
diff --cc arch/s390/pci/pci.c
index 661c4e000c5b,17267f659d22..000000000000
--- a/arch/s390/pci/pci.c
+++ b/arch/s390/pci/pci.c
@@@ -27,7 -27,8 +27,12 @@@
  #include <linux/seq_file.h>
  #include <linux/jump_label.h>
  #include <linux/pci.h>
++<<<<<<< HEAD
 +#include <linux/list_sort.h>
++=======
+ #include <linux/printk.h>
+ #include <linux/lockdep.h>
++>>>>>>> bcb5d6c76903 (s390/pci: introduce lock to synchronize state of zpci_dev's)
  
  #include <asm/isc.h>
  #include <asm/airq.h>
@@@ -885,33 -807,11 +891,39 @@@ struct zpci_dev *zpci_create_device(u3
  		goto error;
  	zdev->state =  state;
  
++<<<<<<< HEAD
 +	mutex_init(&zdev->lock);
++=======
+ 	kref_init(&zdev->kref);
+ 	mutex_init(&zdev->state_lock);
+ 	mutex_init(&zdev->fmb_lock);
++>>>>>>> bcb5d6c76903 (s390/pci: introduce lock to synchronize state of zpci_dev's)
  	mutex_init(&zdev->kzdev_lock);
  
 +	return zdev;
 +
 +error:
 +	zpci_dbg(0, "crt fid:%x, rc:%d\n", fid, rc);
 +	kfree(zdev);
 +	return ERR_PTR(rc);
 +}
 +
 +/**
 + * zpci_add_device() - Add a previously created zPCI device to the zPCI subsystem
 + * @zdev: The zPCI device to be added
 + *
 + * A struct zpci_dev is added to the zPCI subsystem and to a virtual PCI bus creating
 + * a new one as necessary. A hotplug slot is created and events start to be handled.
 + * If successful from this point on zpci_zdev_get() and zpci_zdev_put() must be used.
 + * If adding the struct zpci_dev fails the device was not added and should be freed.
 + *
 + * Return: 0 on success, or an error code otherwise
 + */
 +int zpci_add_device(struct zpci_dev *zdev)
 +{
 +	int rc;
 +
 +	zpci_dbg(1, "add fid:%x, fh:%x, c:%d\n", zdev->fid, zdev->fh, zdev->state);
  	rc = zpci_init_iommu(zdev);
  	if (rc)
  		goto error;
diff --cc arch/s390/pci/pci_sysfs.c
index cae280e5c047,a0b872b74fe3..000000000000
--- a/arch/s390/pci/pci_sysfs.c
+++ b/arch/s390/pci/pci_sysfs.c
@@@ -81,39 -120,13 +120,48 @@@ static ssize_t recover_store(struct dev
  	 */
  	pci_lock_rescan_remove();
  	if (pci_dev_is_added(pdev)) {
++<<<<<<< HEAD
 +		pci_stop_and_remove_bus_device(pdev);
 +		if (zdev->dma_table) {
 +			ret = zpci_dma_exit_device(zdev);
 +			if (ret)
 +				goto out;
 +		}
 +
 +		if (zdev_enabled(zdev)) {
 +			ret = zpci_disable_device(zdev);
 +			/*
 +			 * Due to a z/VM vs LPAR inconsistency in the error
 +			 * state the FH may indicate an enabled device but
 +			 * disable says the device is already disabled don't
 +			 * treat it as an error here.
 +			 */
 +			if (ret == -EINVAL)
 +				ret = 0;
 +			if (ret)
 +				goto out;
 +		}
 +
 +		ret = zpci_enable_device(zdev);
 +		if (ret)
 +			goto out;
 +		ret = zpci_dma_init_device(zdev);
 +		if (ret) {
 +			zpci_disable_device(zdev);
 +			goto out;
 +		}
 +		pci_rescan_bus(zdev->zbus->bus);
 +	}
 +out:
++=======
+ 		ret = _do_recover(pdev, zdev);
+ 	}
+ 	pci_rescan_bus(zdev->zbus->bus);
++>>>>>>> bcb5d6c76903 (s390/pci: introduce lock to synchronize state of zpci_dev's)
  	pci_unlock_rescan_remove();
+ 
+ out:
+ 	mutex_unlock(&zdev->state_lock);
  	if (kn)
  		sysfs_unbreak_active_protection(kn);
  	return ret ? ret : count;
diff --git a/arch/s390/include/asm/pci.h b/arch/s390/include/asm/pci.h
index 6652630be19e..9419eb1a7c43 100644
--- a/arch/s390/include/asm/pci.h
+++ b/arch/s390/include/asm/pci.h
@@ -123,6 +123,7 @@ struct zpci_dev {
 	struct kref kref;
 	struct hotplug_slot hotplug_slot;
 
+	struct mutex state_lock;	/* protect state changes */
 	enum zpci_state state;
 	u32		fid;		/* function ID, used by sclp */
 	u32		fh;		/* function handle, used by insn's */
* Unmerged path arch/s390/pci/pci.c
diff --git a/arch/s390/pci/pci_event.c b/arch/s390/pci/pci_event.c
index dcebe4118195..42c3c40cb1dd 100644
--- a/arch/s390/pci/pci_event.c
+++ b/arch/s390/pci/pci_event.c
@@ -260,6 +260,7 @@ static void __zpci_event_error(struct zpci_ccdf_err *ccdf)
 	zpci_err_hex(ccdf, sizeof(*ccdf));
 
 	if (zdev) {
+		mutex_lock(&zdev->state_lock);
 		zpci_update_fh(zdev, ccdf->fh);
 		if (zdev->zbus->bus)
 			pdev = pci_get_slot(zdev->zbus->bus, zdev->devfn);
@@ -288,6 +289,8 @@ static void __zpci_event_error(struct zpci_ccdf_err *ccdf)
 	}
 	pci_dev_put(pdev);
 no_pdev:
+	if (zdev)
+		mutex_unlock(&zdev->state_lock);
 	zpci_zdev_put(zdev);
 }
 
@@ -322,6 +325,10 @@ static void __zpci_event_availability(struct zpci_ccdf_avail *ccdf)
 
 	zpci_dbg(3, "avl fid:%x, fh:%x, pec:%x\n",
 		 ccdf->fid, ccdf->fh, ccdf->pec);
+
+	if (existing_zdev)
+		mutex_lock(&zdev->state_lock);
+
 	switch (ccdf->pec) {
 	case 0x0301: /* Reserved|Standby -> Configured */
 		if (!zdev) {
@@ -390,8 +397,10 @@ static void __zpci_event_availability(struct zpci_ccdf_avail *ccdf)
 	default:
 		break;
 	}
-	if (existing_zdev)
+	if (existing_zdev) {
+		mutex_unlock(&zdev->state_lock);
 		zpci_zdev_put(zdev);
+	}
 }
 
 void zpci_event_availability(void *data)
* Unmerged path arch/s390/pci/pci_sysfs.c
diff --git a/drivers/pci/hotplug/s390_pci_hpc.c b/drivers/pci/hotplug/s390_pci_hpc.c
index a89b7de72dcf..7333b305f2a5 100644
--- a/drivers/pci/hotplug/s390_pci_hpc.c
+++ b/drivers/pci/hotplug/s390_pci_hpc.c
@@ -26,58 +26,79 @@ static int enable_slot(struct hotplug_slot *hotplug_slot)
 					     hotplug_slot);
 	int rc;
 
-	if (zdev->state != ZPCI_FN_STATE_STANDBY)
-		return -EIO;
+	mutex_lock(&zdev->state_lock);
+	if (zdev->state != ZPCI_FN_STATE_STANDBY) {
+		rc = -EIO;
+		goto out;
+	}
 
 	rc = sclp_pci_configure(zdev->fid);
 	zpci_dbg(3, "conf fid:%x, rc:%d\n", zdev->fid, rc);
 	if (rc)
-		return rc;
+		goto out;
 	zdev->state = ZPCI_FN_STATE_CONFIGURED;
 
-	return zpci_scan_configured_device(zdev, zdev->fh);
+	rc = zpci_scan_configured_device(zdev, zdev->fh);
+out:
+	mutex_unlock(&zdev->state_lock);
+	return rc;
 }
 
 static int disable_slot(struct hotplug_slot *hotplug_slot)
 {
 	struct zpci_dev *zdev = container_of(hotplug_slot, struct zpci_dev,
 					     hotplug_slot);
-	struct pci_dev *pdev;
+	struct pci_dev *pdev = NULL;
+	int rc;
 
-	if (zdev->state != ZPCI_FN_STATE_CONFIGURED)
-		return -EIO;
+	mutex_lock(&zdev->state_lock);
+	if (zdev->state != ZPCI_FN_STATE_CONFIGURED) {
+		rc = -EIO;
+		goto out;
+	}
 
 	pdev = pci_get_slot(zdev->zbus->bus, zdev->devfn);
 	if (pdev && pci_num_vf(pdev)) {
 		pci_dev_put(pdev);
-		return -EBUSY;
+		rc = -EBUSY;
+		goto out;
 	}
-	pci_dev_put(pdev);
 
-	return zpci_deconfigure_device(zdev);
+	rc = zpci_deconfigure_device(zdev);
+out:
+	mutex_unlock(&zdev->state_lock);
+	if (pdev)
+		pci_dev_put(pdev);
+	return rc;
 }
 
 static int reset_slot(struct hotplug_slot *hotplug_slot, bool probe)
 {
 	struct zpci_dev *zdev = container_of(hotplug_slot, struct zpci_dev,
 					     hotplug_slot);
+	int rc = -EIO;
 
-	if (zdev->state != ZPCI_FN_STATE_CONFIGURED)
-		return -EIO;
 	/*
-	 * We can't take the zdev->lock as reset_slot may be called during
-	 * probing and/or device removal which already happens under the
-	 * zdev->lock. Instead the user should use the higher level
-	 * pci_reset_function() or pci_bus_reset() which hold the PCI device
-	 * lock preventing concurrent removal. If not using these functions
-	 * holding the PCI device lock is required.
+	 * If we can't get the zdev->state_lock the device state is
+	 * currently undergoing a transition and we bail out - just
+	 * the same as if the device's state is not configured at all.
 	 */
+	if (!mutex_trylock(&zdev->state_lock))
+		return rc;
 
-	/* As long as the function is configured we can reset */
-	if (probe)
-		return 0;
+	/* We can reset only if the function is configured */
+	if (zdev->state != ZPCI_FN_STATE_CONFIGURED)
+		goto out;
+
+	if (probe) {
+		rc = 0;
+		goto out;
+	}
 
-	return zpci_hot_reset_device(zdev);
+	rc = zpci_hot_reset_device(zdev);
+out:
+	mutex_unlock(&zdev->state_lock);
+	return rc;
 }
 
 static int get_power_status(struct hotplug_slot *hotplug_slot, u8 *value)
