idpf: fix a race in txq wakeup

jira LE-3467
Rebuild_History Non-Buildable kernel-4.18.0-553.58.1.el8_10
commit-author Brian Vazquez <brianvv@google.com>
commit 7292af042bcf22e2c18b96ed250f78498a5b28ab
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-553.58.1.el8_10/7292af04.failed

Add a helper function to correctly handle the lockless
synchronization when the sender needs to block. The paradigm is

        if (no_resources()) {
                stop_queue();
                barrier();
                if (!no_resources())
                        restart_queue();
        }

netif_subqueue_maybe_stop already handles the paradigm correctly, but
the code split the check for resources in three parts, the first one
(descriptors) followed the protocol, but the other two (completions and
tx_buf) were only doing the first part and so race prone.

Luckily netif_subqueue_maybe_stop macro already allows you to use a
function to evaluate the start/stop conditions so the fix only requires
the right helper function to evaluate all the conditions at once.

The patch removes idpf_tx_maybe_stop_common since it's no longer needed
and instead adjusts separately the conditions for singleq and splitq.

Note that idpf_tx_buf_hw_update doesn't need to check for resources
since that will be covered in idpf_tx_splitq_frame.

To reproduce:

Reduce the threshold for pending completions to increase the chances of
hitting this pause by changing your kernel:

drivers/net/ethernet/intel/idpf/idpf_txrx.h

-#define IDPF_TX_COMPLQ_OVERFLOW_THRESH(txcq)   ((txcq)->desc_count >> 1)
+#define IDPF_TX_COMPLQ_OVERFLOW_THRESH(txcq)   ((txcq)->desc_count >> 4)

Use pktgen to force the host to push small pkts very aggressively:

./pktgen_sample02_multiqueue.sh -i eth1 -s 100 -6 -d $IP -m $MAC \
  -p 10000-10000 -t 16 -n 0 -v -x -c 64

Fixes: 6818c4d5b3c2 ("idpf: add splitq start_xmit")
	Reviewed-by: Jacob Keller <jacob.e.keller@intel.com>
	Reviewed-by: Madhu Chittim <madhu.chittim@intel.com>
	Signed-off-by: Josh Hay <joshua.a.hay@intel.com>
	Signed-off-by: Brian Vazquez <brianvv@google.com>
	Signed-off-by: Luigi Rizzo <lrizzo@google.com>
	Reviewed-by: Simon Horman <horms@kernel.org>
	Tested-by: Samuel Salin <Samuel.salin@intel.com>
	Signed-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>
(cherry picked from commit 7292af042bcf22e2c18b96ed250f78498a5b28ab)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/idpf/idpf_txrx.c
diff --cc drivers/net/ethernet/intel/idpf/idpf_txrx.c
index 7501a74f8dd9,5cf440e09d0a..000000000000
--- a/drivers/net/ethernet/intel/idpf/idpf_txrx.c
+++ b/drivers/net/ethernet/intel/idpf/idpf_txrx.c
@@@ -1971,29 -2184,19 +1971,42 @@@ void idpf_tx_splitq_build_flow_desc(uni
  	desc->flow.qw1.compl_tag = cpu_to_le16(params->compl_tag);
  }
  
+ /* Global conditions to tell whether the txq (and related resources)
+  * has room to allow the use of "size" descriptors.
+  */
+ static int idpf_txq_has_room(struct idpf_tx_queue *tx_q, u32 size)
+ {
+ 	if (IDPF_DESC_UNUSED(tx_q) < size ||
+ 	    IDPF_TX_COMPLQ_PENDING(tx_q->txq_grp) >
+ 		IDPF_TX_COMPLQ_OVERFLOW_THRESH(tx_q->txq_grp->complq) ||
+ 	    IDPF_TX_BUF_RSV_LOW(tx_q))
+ 		return 0;
+ 	return 1;
+ }
+ 
 +/**
 + * idpf_tx_maybe_stop_common - 1st level check for common Tx stop conditions
 + * @tx_q: the queue to be checked
 + * @size: number of descriptors we want to assure is available
 + *
 + * Returns 0 if stop is not needed
 + */
 +int idpf_tx_maybe_stop_common(struct idpf_queue *tx_q, unsigned int size)
 +{
 +	struct netdev_queue *nq;
 +
 +	if (likely(IDPF_DESC_UNUSED(tx_q) >= size))
 +		return 0;
 +
 +	u64_stats_update_begin(&tx_q->stats_sync);
 +	u64_stats_inc(&tx_q->q_stats.tx.q_busy);
 +	u64_stats_update_end(&tx_q->stats_sync);
 +
 +	nq = netdev_get_tx_queue(tx_q->vport->netdev, tx_q->idx);
 +
 +	return netif_txq_maybe_stop(nq, IDPF_DESC_UNUSED(tx_q), size, size);
 +}
 +
  /**
   * idpf_tx_maybe_stop_splitq - 1st level check for Tx splitq stop conditions
   * @tx_q: the queue to be checked
@@@ -2001,33 -2204,17 +2014,41 @@@
   *
   * Returns 0 if stop is not needed
   */
 -static int idpf_tx_maybe_stop_splitq(struct idpf_tx_queue *tx_q,
 +static int idpf_tx_maybe_stop_splitq(struct idpf_queue *tx_q,
  				     unsigned int descs_needed)
  {
++<<<<<<< HEAD
 +	if (idpf_tx_maybe_stop_common(tx_q, descs_needed))
 +		goto splitq_stop;
 +
 +	/* If there are too many outstanding completions expected on the
 +	 * completion queue, stop the TX queue to give the device some time to
 +	 * catch up
 +	 */
 +	if (unlikely(IDPF_TX_COMPLQ_PENDING(tx_q->txq_grp) >
 +		     IDPF_TX_COMPLQ_OVERFLOW_THRESH(tx_q->txq_grp->complq)))
 +		goto splitq_stop;
 +
 +	/* Also check for available book keeping buffers; if we are low, stop
 +	 * the queue to wait for more completions
 +	 */
 +	if (unlikely(IDPF_TX_BUF_RSV_LOW(tx_q)))
 +		goto splitq_stop;
 +
 +	return 0;
 +
 +splitq_stop:
++=======
+ 	if (netif_subqueue_maybe_stop(tx_q->netdev, tx_q->idx,
+ 				      idpf_txq_has_room(tx_q, descs_needed),
+ 				      1, 1))
+ 		return 0;
+ 
++>>>>>>> 7292af042bcf (idpf: fix a race in txq wakeup)
  	u64_stats_update_begin(&tx_q->stats_sync);
 -	u64_stats_inc(&tx_q->q_stats.q_busy);
 +	u64_stats_inc(&tx_q->q_stats.tx.q_busy);
  	u64_stats_update_end(&tx_q->stats_sync);
 +	netif_stop_subqueue(tx_q->vport->netdev, tx_q->idx);
  
  	return -EBUSY;
  }
@@@ -2047,11 -2234,9 +2068,14 @@@ void idpf_tx_buf_hw_update(struct idpf_
  {
  	struct netdev_queue *nq;
  
 -	nq = netdev_get_tx_queue(tx_q->netdev, tx_q->idx);
 +	nq = netdev_get_tx_queue(tx_q->vport->netdev, tx_q->idx);
  	tx_q->next_to_use = val;
  
++<<<<<<< HEAD
 +	idpf_tx_maybe_stop_common(tx_q, IDPF_TX_DESC_NEEDED);
 +
++=======
++>>>>>>> 7292af042bcf (idpf: fix a race in txq wakeup)
  	/* Force memory writes to complete before letting h/w
  	 * know there are new descriptors to fetch.  (Only
  	 * applicable for weak-ordered memory model archs,
diff --git a/drivers/net/ethernet/intel/idpf/idpf_singleq_txrx.c b/drivers/net/ethernet/intel/idpf/idpf_singleq_txrx.c
index 5c3d34d3de8a..464b98b59418 100644
--- a/drivers/net/ethernet/intel/idpf/idpf_singleq_txrx.c
+++ b/drivers/net/ethernet/intel/idpf/idpf_singleq_txrx.c
@@ -356,17 +356,18 @@ static netdev_tx_t idpf_tx_singleq_frame(struct sk_buff *skb,
 {
 	struct idpf_tx_offload_params offload = { };
 	struct idpf_tx_buf *first;
+	int csum, tso, needed;
 	unsigned int count;
 	__be16 protocol;
-	int csum, tso;
 
 	count = idpf_tx_desc_count_required(tx_q, skb);
 	if (unlikely(!count))
 		return idpf_tx_drop_skb(tx_q, skb);
 
-	if (idpf_tx_maybe_stop_common(tx_q,
-				      count + IDPF_TX_DESCS_PER_CACHE_LINE +
-				      IDPF_TX_DESCS_FOR_CTX)) {
+	needed = count + IDPF_TX_DESCS_PER_CACHE_LINE + IDPF_TX_DESCS_FOR_CTX;
+	if (!netif_subqueue_maybe_stop(tx_q->netdev, tx_q->idx,
+				       IDPF_DESC_UNUSED(tx_q),
+				       needed, needed)) {
 		idpf_tx_buf_hw_update(tx_q, tx_q->next_to_use, false);
 
 		return NETDEV_TX_BUSY;
* Unmerged path drivers/net/ethernet/intel/idpf/idpf_txrx.c
