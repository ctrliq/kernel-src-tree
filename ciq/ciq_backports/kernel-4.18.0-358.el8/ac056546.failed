Bluetooth: btintel: Check firmware version before download

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Luiz Augusto von Dentz <luiz.von.dentz@intel.com>
commit ac0565462e330a2b762ca5849a4140b29d725786
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/ac056546.failed

This checks the firmware build number, week and year against the
repective loaded version. If details are a match, skip the download
process.

	Signed-off-by: Luiz Augusto von Dentz <luiz.von.dentz@intel.com>
	Tested-by: Tedd Ho-Jeong An <tedd.an@intel.com>
	Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
(cherry picked from commit ac0565462e330a2b762ca5849a4140b29d725786)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/bluetooth/btusb.c
diff --cc drivers/bluetooth/btusb.c
index 853b361339c6,de220ab7f231..000000000000
--- a/drivers/bluetooth/btusb.c
+++ b/drivers/bluetooth/btusb.c
@@@ -2446,6 -2431,190 +2446,193 @@@ static bool btusb_setup_intel_new_get_f
  	return true;
  }
  
++<<<<<<< HEAD
++=======
+ static void btusb_setup_intel_newgen_get_fw_name(const struct intel_version_tlv *ver_tlv,
+ 						 char *fw_name, size_t len,
+ 						 const char *suffix)
+ {
+ 	/* The firmware file name for new generation controllers will be
+ 	 * ibt-<cnvi_top type+cnvi_top step>-<cnvr_top type+cnvr_top step>
+ 	 */
+ 	snprintf(fw_name, len, "intel/ibt-%04x-%04x.%s",
+ 		 INTEL_CNVX_TOP_PACK_SWAB(INTEL_CNVX_TOP_TYPE(ver_tlv->cnvi_top),
+ 					  INTEL_CNVX_TOP_STEP(ver_tlv->cnvi_top)),
+ 		 INTEL_CNVX_TOP_PACK_SWAB(INTEL_CNVX_TOP_TYPE(ver_tlv->cnvr_top),
+ 					  INTEL_CNVX_TOP_STEP(ver_tlv->cnvr_top)),
+ 		 suffix);
+ }
+ 
+ static int btusb_intel_download_firmware_newgen(struct hci_dev *hdev,
+ 						struct intel_version_tlv *ver,
+ 						u32 *boot_param)
+ {
+ 	const struct firmware *fw;
+ 	char fwname[64];
+ 	int err;
+ 	struct btusb_data *data = hci_get_drvdata(hdev);
+ 
+ 	if (!ver || !boot_param)
+ 		return -EINVAL;
+ 
+ 	/* The hardware platform number has a fixed value of 0x37 and
+ 	 * for now only accept this single value.
+ 	 */
+ 	if (INTEL_HW_PLATFORM(ver->cnvi_bt) != 0x37) {
+ 		bt_dev_err(hdev, "Unsupported Intel hardware platform (0x%2x)",
+ 			   INTEL_HW_PLATFORM(ver->cnvi_bt));
+ 		return -EINVAL;
+ 	}
+ 
+ 	/* The firmware variant determines if the device is in bootloader
+ 	 * mode or is running operational firmware. The value 0x03 identifies
+ 	 * the bootloader and the value 0x23 identifies the operational
+ 	 * firmware.
+ 	 *
+ 	 * When the operational firmware is already present, then only
+ 	 * the check for valid Bluetooth device address is needed. This
+ 	 * determines if the device will be added as configured or
+ 	 * unconfigured controller.
+ 	 *
+ 	 * It is not possible to use the Secure Boot Parameters in this
+ 	 * case since that command is only available in bootloader mode.
+ 	 */
+ 	if (ver->img_type == 0x03) {
+ 		clear_bit(BTUSB_BOOTLOADER, &data->flags);
+ 		btintel_check_bdaddr(hdev);
+ 		return 0;
+ 	}
+ 
+ 	/* Check for supported iBT hardware variants of this firmware
+ 	 * loading method.
+ 	 *
+ 	 * This check has been put in place to ensure correct forward
+ 	 * compatibility options when newer hardware variants come along.
+ 	 */
+ 	switch (INTEL_HW_VARIANT(ver->cnvi_bt)) {
+ 	case 0x17:	/* TyP */
+ 	case 0x18:	/* Slr */
+ 	case 0x19:	/* Slr-F */
+ 		break;
+ 	default:
+ 		bt_dev_err(hdev, "Unsupported Intel hardware variant (0x%x)",
+ 			   INTEL_HW_VARIANT(ver->cnvi_bt));
+ 		return -EINVAL;
+ 	}
+ 
+ 	/* If the device is not in bootloader mode, then the only possible
+ 	 * choice is to return an error and abort the device initialization.
+ 	 */
+ 	if (ver->img_type != 0x01) {
+ 		bt_dev_err(hdev, "Unsupported Intel firmware variant (0x%x)",
+ 			   ver->img_type);
+ 		return -ENODEV;
+ 	}
+ 
+ 	/* It is required that every single firmware fragment is acknowledged
+ 	 * with a command complete event. If the boot parameters indicate
+ 	 * that this bootloader does not send them, then abort the setup.
+ 	 */
+ 	if (ver->limited_cce != 0x00) {
+ 		bt_dev_err(hdev, "Unsupported Intel firmware loading method (0x%x)",
+ 			   ver->limited_cce);
+ 		return -EINVAL;
+ 	}
+ 
+ 	/* Secure boot engine type should be either 1 (ECDSA) or 0 (RSA) */
+ 	if (ver->sbe_type > 0x01) {
+ 		bt_dev_err(hdev, "Unsupported Intel secure boot engine type (0x%x)",
+ 			   ver->sbe_type);
+ 		return -EINVAL;
+ 	}
+ 
+ 	/* If the OTP has no valid Bluetooth device address, then there will
+ 	 * also be no valid address for the operational firmware.
+ 	 */
+ 	if (!bacmp(&ver->otp_bd_addr, BDADDR_ANY)) {
+ 		bt_dev_info(hdev, "No device address configured");
+ 		set_bit(HCI_QUIRK_INVALID_BDADDR, &hdev->quirks);
+ 	}
+ 
+ 	btusb_setup_intel_newgen_get_fw_name(ver, fwname, sizeof(fwname), "sfi");
+ 	err = request_firmware(&fw, fwname, &hdev->dev);
+ 	if (err < 0) {
+ 		bt_dev_err(hdev, "Failed to load Intel firmware file %s (%d)",
+ 			   fwname, err);
+ 		return err;
+ 	}
+ 
+ 	bt_dev_info(hdev, "Found device firmware: %s", fwname);
+ 
+ 	if (fw->size < 644) {
+ 		bt_dev_err(hdev, "Invalid size of firmware file (%zu)",
+ 			   fw->size);
+ 		err = -EBADF;
+ 		goto done;
+ 	}
+ 
+ 	set_bit(BTUSB_DOWNLOADING, &data->flags);
+ 
+ 	/* Start firmware downloading and get boot parameter */
+ 	err = btintel_download_firmware_newgen(hdev, ver, fw, boot_param,
+ 					       INTEL_HW_VARIANT(ver->cnvi_bt),
+ 					       ver->sbe_type);
+ 	if (err < 0) {
+ 		if (err == -EALREADY) {
+ 			/* Firmware has already been loaded */
+ 			set_bit(BTUSB_FIRMWARE_LOADED, &data->flags);
+ 			err = 0;
+ 			goto done;
+ 		}
+ 
+ 		/* When FW download fails, send Intel Reset to retry
+ 		 * FW download.
+ 		 */
+ 		btintel_reset_to_bootloader(hdev);
+ 		goto done;
+ 	}
+ 	set_bit(BTUSB_FIRMWARE_LOADED, &data->flags);
+ 
+ 	bt_dev_info(hdev, "Waiting for firmware download to complete");
+ 
+ 	/* Before switching the device into operational mode and with that
+ 	 * booting the loaded firmware, wait for the bootloader notification
+ 	 * that all fragments have been successfully received.
+ 	 *
+ 	 * When the event processing receives the notification, then the
+ 	 * BTUSB_DOWNLOADING flag will be cleared.
+ 	 *
+ 	 * The firmware loading should not take longer than 5 seconds
+ 	 * and thus just timeout if that happens and fail the setup
+ 	 * of this device.
+ 	 */
+ 	err = wait_on_bit_timeout(&data->flags, BTUSB_DOWNLOADING,
+ 				  TASK_INTERRUPTIBLE,
+ 				  msecs_to_jiffies(5000));
+ 	if (err == -EINTR) {
+ 		bt_dev_err(hdev, "Firmware loading interrupted");
+ 		goto done;
+ 	}
+ 
+ 	if (err) {
+ 		bt_dev_err(hdev, "Firmware loading timeout");
+ 		err = -ETIMEDOUT;
+ 		btintel_reset_to_bootloader(hdev);
+ 		goto done;
+ 	}
+ 
+ 	if (test_bit(BTUSB_FIRMWARE_FAILED, &data->flags)) {
+ 		bt_dev_err(hdev, "Firmware loading failed");
+ 		err = -ENOEXEC;
+ 		goto done;
+ 	}
+ 
+ done:
+ 	release_firmware(fw);
+ 	return err;
+ }
+ 
++>>>>>>> ac0565462e33 (Bluetooth: btintel: Check firmware version before download)
  static int btusb_intel_download_firmware(struct hci_dev *hdev,
  					 struct intel_version *ver,
  					 struct intel_boot_params *params,
diff --git a/drivers/bluetooth/btintel.c b/drivers/bluetooth/btintel.c
index 7b72e62d6766..f32e3044b9a0 100644
--- a/drivers/bluetooth/btintel.c
+++ b/drivers/bluetooth/btintel.c
@@ -39,6 +39,14 @@
 #define ECDSA_OFFSET		644
 #define ECDSA_HEADER_LEN	320
 
+#define CMD_WRITE_BOOT_PARAMS	0xfc0e
+struct cmd_write_boot_params {
+	u32 boot_addr;
+	u8  fw_build_num;
+	u8  fw_build_ww;
+	u8  fw_build_yy;
+} __packed;
+
 int btintel_check_bdaddr(struct hci_dev *hdev)
 {
 	struct hci_rp_read_bd_addr *bda;
@@ -856,7 +864,7 @@ static int btintel_sfi_ecdsa_header_secure_send(struct hci_dev *hdev,
 
 static int btintel_download_firmware_payload(struct hci_dev *hdev,
 					     const struct firmware *fw,
-					     u32 *boot_param, size_t offset)
+					     size_t offset)
 {
 	int err;
 	const u8 *fw_ptr;
@@ -869,21 +877,6 @@ static int btintel_download_firmware_payload(struct hci_dev *hdev,
 	while (fw_ptr - fw->data < fw->size) {
 		struct hci_command_hdr *cmd = (void *)(fw_ptr + frag_len);
 
-		/* Each SKU has a different reset parameter to use in the
-		 * HCI_Intel_Reset command and it is embedded in the firmware
-		 * data. So, instead of using static value per SKU, check
-		 * the firmware data and save it for later use.
-		 */
-		if (le16_to_cpu(cmd->opcode) == 0xfc0e) {
-			/* The boot parameter is the first 32-bit value
-			 * and rest of 3 octets are reserved.
-			 */
-			*boot_param = get_unaligned_le32(fw_ptr + frag_len +
-							 sizeof(*cmd));
-
-			bt_dev_dbg(hdev, "boot_param=0x%x", *boot_param);
-		}
-
 		frag_len += sizeof(*cmd) + cmd->plen;
 
 		/* The parameter length of the secure send command requires
@@ -912,28 +905,101 @@ static int btintel_download_firmware_payload(struct hci_dev *hdev,
 	return err;
 }
 
+static bool btintel_firmware_version(struct hci_dev *hdev,
+				     u8 num, u8 ww, u8 yy,
+				     const struct firmware *fw,
+				     u32 *boot_addr)
+{
+	const u8 *fw_ptr;
+
+	fw_ptr = fw->data;
+
+	while (fw_ptr - fw->data < fw->size) {
+		struct hci_command_hdr *cmd = (void *)(fw_ptr);
+
+		/* Each SKU has a different reset parameter to use in the
+		 * HCI_Intel_Reset command and it is embedded in the firmware
+		 * data. So, instead of using static value per SKU, check
+		 * the firmware data and save it for later use.
+		 */
+		if (le16_to_cpu(cmd->opcode) == CMD_WRITE_BOOT_PARAMS) {
+			struct cmd_write_boot_params *params;
+
+			params = (void *)(fw_ptr + sizeof(*cmd));
+
+			bt_dev_info(hdev, "Boot Address: 0x%x",
+				    le32_to_cpu(params->boot_addr));
+
+			bt_dev_info(hdev, "Firmware Version: %u-%u.%u",
+				    params->fw_build_num, params->fw_build_ww,
+				    params->fw_build_yy);
+
+			return (num == params->fw_build_num &&
+				ww == params->fw_build_ww &&
+				yy == params->fw_build_yy);
+		}
+
+		fw_ptr += sizeof(*cmd) + cmd->plen;
+	}
+
+	return false;
+}
+
 int btintel_download_firmware(struct hci_dev *hdev,
+			      struct intel_version *ver,
 			      const struct firmware *fw,
 			      u32 *boot_param)
 {
 	int err;
 
+	/* SfP and WsP don't seem to update the firmware version on file
+	 * so version checking is currently not possible.
+	 */
+	switch (ver->hw_variant) {
+	case 0x0b:	/* SfP */
+	case 0x0c:	/* WsP */
+		/* Skip version checking */
+		break;
+	default:
+		/* Skip download if firmware has the same version */
+		if (btintel_firmware_version(hdev, ver->fw_build_num,
+					     ver->fw_build_ww, ver->fw_build_yy,
+					     fw, boot_param)) {
+			bt_dev_info(hdev, "Firmware already loaded");
+			/* Return -EALREADY to indicate that the firmware has
+			 * already been loaded.
+			 */
+			return -EALREADY;
+		}
+	}
+
 	err = btintel_sfi_rsa_header_secure_send(hdev, fw);
 	if (err)
 		return err;
 
-	return btintel_download_firmware_payload(hdev, fw, boot_param,
-						 RSA_HEADER_LEN);
+	return btintel_download_firmware_payload(hdev, fw, RSA_HEADER_LEN);
 }
 EXPORT_SYMBOL_GPL(btintel_download_firmware);
 
 int btintel_download_firmware_newgen(struct hci_dev *hdev,
+				     struct intel_version_tlv *ver,
 				     const struct firmware *fw, u32 *boot_param,
 				     u8 hw_variant, u8 sbe_type)
 {
 	int err;
 	u32 css_header_ver;
 
+	/* Skip download if firmware has the same version */
+	if (btintel_firmware_version(hdev, ver->min_fw_build_nn,
+				     ver->min_fw_build_cw, ver->min_fw_build_yy,
+				     fw, boot_param)) {
+		bt_dev_info(hdev, "Firmware already loaded");
+		/* Return -EALREADY to indicate that firmware has already been
+		 * loaded.
+		 */
+		return -EALREADY;
+	}
+
 	/* iBT hardware variants 0x0b, 0x0c, 0x11, 0x12, 0x13, 0x14 support
 	 * only RSA secure boot engine. Hence, the corresponding sfi file will
 	 * have RSA header of 644 bytes followed by Command Buffer.
@@ -963,7 +1029,7 @@ int btintel_download_firmware_newgen(struct hci_dev *hdev,
 		if (err)
 			return err;
 
-		err = btintel_download_firmware_payload(hdev, fw, boot_param, RSA_HEADER_LEN);
+		err = btintel_download_firmware_payload(hdev, fw, RSA_HEADER_LEN);
 		if (err)
 			return err;
 	} else if (hw_variant >= 0x17) {
@@ -984,7 +1050,6 @@ int btintel_download_firmware_newgen(struct hci_dev *hdev,
 				return err;
 
 			err = btintel_download_firmware_payload(hdev, fw,
-								boot_param,
 								RSA_HEADER_LEN + ECDSA_HEADER_LEN);
 			if (err)
 				return err;
@@ -994,7 +1059,6 @@ int btintel_download_firmware_newgen(struct hci_dev *hdev,
 				return err;
 
 			err = btintel_download_firmware_payload(hdev, fw,
-								boot_param,
 								RSA_HEADER_LEN + ECDSA_HEADER_LEN);
 			if (err)
 				return err;
diff --git a/drivers/bluetooth/btintel.h b/drivers/bluetooth/btintel.h
index 0722c22b45dc..5481cac360f0 100644
--- a/drivers/bluetooth/btintel.h
+++ b/drivers/bluetooth/btintel.h
@@ -178,9 +178,10 @@ struct regmap *btintel_regmap_init(struct hci_dev *hdev, u16 opcode_read,
 int btintel_send_intel_reset(struct hci_dev *hdev, u32 boot_param);
 int btintel_read_boot_params(struct hci_dev *hdev,
 			     struct intel_boot_params *params);
-int btintel_download_firmware(struct hci_dev *dev, const struct firmware *fw,
-			      u32 *boot_param);
+int btintel_download_firmware(struct hci_dev *dev, struct intel_version *ver,
+			      const struct firmware *fw, u32 *boot_param);
 int btintel_download_firmware_newgen(struct hci_dev *hdev,
+				     struct intel_version_tlv *ver,
 				     const struct firmware *fw,
 				     u32 *boot_param, u8 hw_variant,
 				     u8 sbe_type);
* Unmerged path drivers/bluetooth/btusb.c
diff --git a/drivers/bluetooth/hci_intel.c b/drivers/bluetooth/hci_intel.c
index a7705a70a15b..287d2855b560 100644
--- a/drivers/bluetooth/hci_intel.c
+++ b/drivers/bluetooth/hci_intel.c
@@ -750,7 +750,7 @@ static int intel_setup(struct hci_uart *hu)
 	set_bit(STATE_DOWNLOADING, &intel->flags);
 
 	/* Start firmware downloading and get boot parameter */
-	err = btintel_download_firmware(hdev, fw, &boot_param);
+	err = btintel_download_firmware(hdev, &ver, fw, &boot_param);
 	if (err < 0)
 		goto done;
 
@@ -799,7 +799,10 @@ static int intel_setup(struct hci_uart *hu)
 done:
 	release_firmware(fw);
 
-	if (err < 0)
+	/* Check if there was an error and if is not -EALREADY which means the
+	 * firmware has already been loaded.
+	 */
+	if (err < 0 && err != -EALREADY)
 		return err;
 
 	/* We need to restore the default speed before Intel reset */
