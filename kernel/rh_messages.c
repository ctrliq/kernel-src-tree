/*
 * WARNING: This file is auto-generated by an internal Red Hat script and,
 * in general, should not be modified by hand.
 */

/*
 * The following functions are used by Red Hat to indicate to users that
 * hardware and drivers are unsupported, or have limited support in RHEL major
 * and minor releases.  These functions output loud warning messages to the end
 * user and should be USED WITH CAUTION.
 *
 * Any use of these functions _MUST_ be documented in the RHEL Release Notes,
 * and have approval of management.
 *
 * Generally, the process of disabling a driver or device in RHEL requires the
 * driver or device to be marked as 'deprecated' in all existing releases, and
 * then either 'unmaintained' or 'disabled' in a future release.
 *
 * In general, deprecated and unmaintained drivers continue to receive security
 * related fixes until they are disabled.
 */

#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/pci.h>

#define DEV_DESC_LEN 256
static const char *rh_deprecated_drivers[] = {
	"team",
	"ebtables",
	"arp_tables",
	"ip_tables",
	"ip6_tables",
	"ip_set",
	"nft_compat",
	"firewire-core",
	""     /* Terminating entry */
};

static const char *rh_deprecated_init_fns[] = {
	"team_module_init",
	"ebtables_init",
	"arp_tables_init",
	"ip_tables_init",
	"ip6_tables_init",
	"ip_set_init",
	"nft_compat_module_init",
	"fw_core_init",
	""     /* Terminating entry */
};

static const char *rh_unmaintained_drivers[] = {
	"bnx2",
	"e1000",
	"dl2k",
	"hpsa",
	"mptbase",
	"mptsas",
	"mptscsih",
	"mptspi",
	"myri10ge",
	"netxen_nic",
	"qla3xxx",
	"hdlc_fr",
	"nvmet-fc",
	"nvmet-tcp",
	"team",
	"ebtables",
	"arp_tables",
	"ip_tables",
	"ip6_tables",
	"ip_set",
	"nft_compat",
	"nicvf",
	"nicpf",
	""     /* Terminating entry */
};

static const char *rh_unmaintained_init_fns[] = {
	"bnx2_pci_driver_init",
	"e1000_init_module",
	"rio_driver_init",
	"hpsa_init",
	"fusion_init",
	"mptsas_init",
	"fusion_init",
	"mptspi_init",
	"myri10ge_init_module",
	"netxen_init_module",
	"ql3xxx_driver_init",
	"hdlc_fr_init",
	"nvmet_fc_init_module",
	"nvmet_tcp_init",
	"team_module_init",
	"ebtables_init",
	"arp_tables_init",
	"ip_tables_init",
	"ip6_tables_init",
	"ip_set_init",
	"nft_compat_module_init",
	"nicvf_init_module",
	"nic_init_module",
	""     /* Terminating entry */
};

static const struct pci_device_id rh_deprecated_pci_devices[] = {
	{0}     /* Terminating entry */
};

static const struct pci_device_id rh_disabled_pci_devices[] = {
	{ 0x1011, 0x0046, 0x103c, 0x10c2 },
	{ 0x1011, 0x0046, 0x9005, 0x0364 },
	{ 0x1011, 0x0046, 0x9005, 0x0365 },
	{ 0x1011, 0x0046, 0x9005, 0x1364 },
	{ 0x1028, 0x0001, 0x1028, 0x0001 },
	{ 0x1028, 0x0002, 0x1028, 0x0002 },
	{ 0x1028, 0x0002, 0x1028, 0x00d1 },
	{ 0x1028, 0x0002, 0x1028, 0x00d9 },
	{ 0x1028, 0x0003, 0x1028, 0x0003 },
	{ 0x1028, 0x0004, 0x1028, 0x00d0 },
	{ 0x1028, 0x000a, 0x1028, 0x0106 },
	{ 0x1028, 0x000a, 0x1028, 0x011b },
	{ 0x1028, 0x000a, 0x1028, 0x0121 },
	{ 0x9005, 0x0200, 0x9005, 0x0200 },
	{ 0x9005, 0x0283, 0x9005, 0x0283 },
	{ 0x9005, 0x0284, 0x9005, 0x0284 },
	{ 0x9005, 0x0285, PCI_ANY_ID, PCI_ANY_ID },
	{ 0x9005, 0x0285, 0x1014, 0x02F2 },
	{ 0x9005, 0x0285, 0x1014, 0x0312 },
	{ 0x9005, 0x0285, 0x1028, PCI_ANY_ID },
	{ 0x9005, 0x0285, 0x1028, 0x0287 },
	{ 0x9005, 0x0285, 0x103C, 0x3227 },
	{ 0x9005, 0x0285, 0x17aa, PCI_ANY_ID },
	{ 0x9005, 0x0285, 0x17aa, 0x0286 },
	{ 0x9005, 0x0285, 0x17aa, 0x0287 },
	{ 0x9005, 0x0285, 0x9005, 0x0285 },
	{ 0x9005, 0x0285, 0x9005, 0x0286 },
	{ 0x9005, 0x0285, 0x9005, 0x0287 },
	{ 0x9005, 0x0285, 0x9005, 0x0288 },
	{ 0x9005, 0x0285, 0x9005, 0x0289 },
	{ 0x9005, 0x0285, 0x9005, 0x028a },
	{ 0x9005, 0x0285, 0x9005, 0x028b },
	{ 0x9005, 0x0285, 0x9005, 0x028e },
	{ 0x9005, 0x0285, 0x9005, 0x028f },
	{ 0x9005, 0x0285, 0x9005, 0x0290 },
	{ 0x9005, 0x0285, 0x9005, 0x0291 },
	{ 0x9005, 0x0285, 0x9005, 0x0292 },
	{ 0x9005, 0x0285, 0x9005, 0x0293 },
	{ 0x9005, 0x0285, 0x9005, 0x0294 },
	{ 0x9005, 0x0285, 0x9005, 0x0296 },
	{ 0x9005, 0x0285, 0x9005, 0x0297 },
	{ 0x9005, 0x0285, 0x9005, 0x0298 },
	{ 0x9005, 0x0285, 0x9005, 0x0299 },
	{ 0x9005, 0x0285, 0x9005, 0x029a },
	{ 0x9005, 0x0285, 0x9005, 0x02a4 },
	{ 0x9005, 0x0285, 0x9005, 0x02a5 },
	{ 0x9005, 0x0286, PCI_ANY_ID, PCI_ANY_ID },
	{ 0x9005, 0x0286, 0x1014, 0x9540 },
	{ 0x9005, 0x0286, 0x1014, 0x9580 },
	{ 0x9005, 0x0286, 0x9005, 0x028c },
	{ 0x9005, 0x0286, 0x9005, 0x028d },
	{ 0x9005, 0x0286, 0x9005, 0x029b },
	{ 0x9005, 0x0286, 0x9005, 0x029c },
	{ 0x9005, 0x0286, 0x9005, 0x029d },
	{ 0x9005, 0x0286, 0x9005, 0x029e },
	{ 0x9005, 0x0286, 0x9005, 0x029f },
	{ 0x9005, 0x0286, 0x9005, 0x02a0 },
	{ 0x9005, 0x0286, 0x9005, 0x02a1 },
	{ 0x9005, 0x0286, 0x9005, 0x02a2 },
	{ 0x9005, 0x0286, 0x9005, 0x02a3 },
	{ 0x9005, 0x0286, 0x9005, 0x02a6 },
	{ 0x9005, 0x0286, 0x9005, 0x0800 },
	{ 0x9005, 0x0287, 0x9005, 0x0800 },
	{ 0x9005, 0x0288, PCI_ANY_ID, PCI_ANY_ID },
	{ 0x19a2, 0x0700, PCI_ANY_ID, PCI_ANY_ID },
	{ 0x19a2, 0x0211, PCI_ANY_ID, PCI_ANY_ID },
	{ 0x19a2, 0x0710, PCI_ANY_ID, PCI_ANY_ID },
	{ 0x19a2, 0x0221, PCI_ANY_ID, PCI_ANY_ID },
	{ 0x19a2, 0xe220, PCI_ANY_ID, PCI_ANY_ID },
	{ 0x1000, 0x0060, PCI_ANY_ID, PCI_ANY_ID },
	{ 0x1000, 0x0078, PCI_ANY_ID, PCI_ANY_ID },
	{ 0x1000, 0x007C, PCI_ANY_ID, PCI_ANY_ID },
	{ 0x1000, 0x0411, PCI_ANY_ID, PCI_ANY_ID },
	{ 0x1000, 0x0413, PCI_ANY_ID, PCI_ANY_ID },
	{ 0x1028, 0x0015, PCI_ANY_ID, PCI_ANY_ID },
	{ 0x1000, 0x0064, PCI_ANY_ID, PCI_ANY_ID },
	{ 0x1000, 0x0065, PCI_ANY_ID, PCI_ANY_ID },
	{ 0x1000, 0x0070, PCI_ANY_ID, PCI_ANY_ID },
	{ 0x1000, 0x0072, PCI_ANY_ID, PCI_ANY_ID },
	{ 0x1000, 0x0074, PCI_ANY_ID, PCI_ANY_ID },
	{ 0x1000, 0x0076, PCI_ANY_ID, PCI_ANY_ID },
	{ 0x1000, 0x0077, PCI_ANY_ID, PCI_ANY_ID },
	{ 0x1000, 0x007E, PCI_ANY_ID, PCI_ANY_ID },
	{0}     /* Terminating entry */
};

static const struct pci_device_id rh_unmaintained_pci_devices[] = {
	{ 0x10df, 0x0724, PCI_ANY_ID, PCI_ANY_ID },
	{ 0x10df, 0xe200, PCI_ANY_ID, PCI_ANY_ID },
	{ 0x10df, 0xe220, PCI_ANY_ID, PCI_ANY_ID },
	{ 0x10df, 0xf011, PCI_ANY_ID, PCI_ANY_ID },
	{ 0x10df, 0xf015, PCI_ANY_ID, PCI_ANY_ID },
	{ 0x10df, 0xf100, PCI_ANY_ID, PCI_ANY_ID },
	{ 0x10df, 0xfc40, PCI_ANY_ID, PCI_ANY_ID },
	{ 0x1000, 0x005b, PCI_ANY_ID, PCI_ANY_ID },
	{ 0x1000, 0x0071, PCI_ANY_ID, PCI_ANY_ID },
	{ 0x1000, 0x0073, PCI_ANY_ID, PCI_ANY_ID },
	{ 0x1000, 0x0079, PCI_ANY_ID, PCI_ANY_ID },
	{ 0x1000, 0x006E, PCI_ANY_ID, PCI_ANY_ID },
	{ 0x1000, 0x0080, PCI_ANY_ID, PCI_ANY_ID },
	{ 0x1000, 0x0081, PCI_ANY_ID, PCI_ANY_ID },
	{ 0x1000, 0x0082, PCI_ANY_ID, PCI_ANY_ID },
	{ 0x1000, 0x0083, PCI_ANY_ID, PCI_ANY_ID },
	{ 0x1000, 0x0084, PCI_ANY_ID, PCI_ANY_ID },
	{ 0x1000, 0x0085, PCI_ANY_ID, PCI_ANY_ID },
	{ 0x1000, 0x0086, PCI_ANY_ID, PCI_ANY_ID },
	{ 0x1000, 0x0087, PCI_ANY_ID, PCI_ANY_ID },
	{ 0x1077, 0x2031, PCI_ANY_ID, PCI_ANY_ID },
	{ 0x1077, 0x2532, PCI_ANY_ID, PCI_ANY_ID },
	{ 0x1077, 0x8031, PCI_ANY_ID, PCI_ANY_ID },
	{ 0x1924, 0x0803, PCI_ANY_ID, PCI_ANY_ID },
	{ 0x1924, 0x0813, PCI_ANY_ID, PCI_ANY_ID },
	{ 0x177d, 0xa01e, PCI_ANY_ID, PCI_ANY_ID },
	{ 0x177d, 0xa034, PCI_ANY_ID, PCI_ANY_ID },
	{ 0x177d, 0x0011, PCI_ANY_ID, PCI_ANY_ID },
	{0}     /* Terminating entry */
};

/**
 * mark_hardware_unmaintained() - Mark hardware as unmaintained.
 * @driver_name: driver name
 * @fmt: format for device description
 * @...: args for device description
 *
 * Called to notify users that the device will no longer be tested on a routine
 * basis and driver code associated with this device is no longer being updated.
 * Red Hat may, at their own discretion, fix security-related and critical
 * issues.  Support for this device will be disabled in a future major release
 * and users deploying this device should plan to replace the device in
 * production systems.
 *
 * This function should be used when the driver's usage can be tied to a
 * specific hardware device.  For example, a network device driver loading on a
 * specific device that is no longer maintained by the manufacturer.
 *
 * Reserved for Internal Red Hat use only.
 */
void mark_hardware_unmaintained(const char *driver_name, char *fmt, ...)
{
	char device_description[DEV_DESC_LEN];
	va_list args;

	va_start(args, fmt);
	vsnprintf(device_description, DEV_DESC_LEN, fmt, args);
	pr_crit("Warning: Unmaintained Hardware is detected: %s:%s\n",
		driver_name, device_description);
	va_end(args);
}
EXPORT_SYMBOL(mark_hardware_unmaintained);

/**
 * mark_hardware_deprecated() - Mark hardware as deprecated.
 * @driver_name: driver name
 * @fmt: format for device description
 * @...: args for device description
 *
 * Called to notify users that support for the device is planned to be
 * unmaintained in a future major release, and will eventually be disabled in a
 * future major release.  This device should not be used in new production
 * environments and users should replace the device in production systems.
 *
 * This function should be used when the driver's usage can be tied to a
 * specific hardware device.  For example, a network device driver loading on a
 * specific device that is no longer maintained by the manufacturer.
 *
 * Reserved for Internal Red Hat use only.
 */
void mark_hardware_deprecated(const char *driver_name, char *fmt, ...)
{
	char device_description[DEV_DESC_LEN];
	va_list args;

	va_start(args, fmt);
	vsnprintf(device_description, DEV_DESC_LEN, fmt, args);
	pr_crit("Warning: Deprecated Hardware is detected: %s:%s will not be maintained in a future major release and may be disabled\n",
		driver_name, device_description);
	va_end(args);
}

/**
 * mark_hardware_disabled() - Mark a driver as removed.
 * @driver_name: driver name
 * @fmt: format for device description
 * @...: args for device description
 *
 * Called to notify users that a device's support has been completely disabled
 * and no future support updates will occur.  This device cannot be used in new
 * production environments, and users must replace the device in production
 * systems.
 *
 * This function should be used when the driver's usage can be tied to a
 * specific hardware device.  For example, a network device driver loading on a
 * specific device that is no longer maintained by the manufacturer.
 *
 * Reserved for Internal Red Hat use only.
 */
static void mark_hardware_disabled(const char *driver_name, char *fmt, ...)
{
	char device_description[DEV_DESC_LEN];
	va_list args;

	va_start(args, fmt);
	vsnprintf(device_description, DEV_DESC_LEN, fmt, args);
	pr_crit("Warning: Disabled Hardware is detected: %s:%s is no longer enabled in this release.\n",
		driver_name, device_description);
	va_end(args);
}

#ifdef CONFIG_PCI
/**
 * pci_hw_deprecated() - Mark a PCI device deprecated.
 * @dev: the PCI device structure to match against
 *
 * Called to check if this @dev is in the list of deprecated devices.
 *
 * Reserved for Internal Red Hat use only.
 */
static void pci_hw_deprecated(struct pci_dev *dev)
{
	const struct pci_device_id *ret = pci_match_id(rh_deprecated_pci_devices, dev);

	if (!ret)
		return;

	mark_hardware_deprecated(dev_driver_string(&dev->dev), "%04X:%04X @ %s",
				 dev->device, dev->vendor, pci_name(dev));
}

/**
 * pci_hw_unmaintained() - Mark a PCI device unmaintained.
 * @dev: the PCI device structure to match against
 *
 * Called to check if this @dev is in the list of unmaintained devices.
 *
 * Reserved for Internal Red Hat use only.
 */
static void pci_hw_unmaintained(struct pci_dev *dev)
{
	const struct pci_device_id *ret = pci_match_id(rh_unmaintained_pci_devices, dev);

	if (!ret)
		return;

	mark_hardware_unmaintained(dev_driver_string(&dev->dev), "%04X:%04X @ %s",
				   dev->device, dev->vendor, pci_name(dev));
}

/**
 * pci_hw_disabled() - Mark a PCI device disabled.
 * @dev: the PCI device structure to match against
 *
 * Called to check if this @dev is in the list of disabled devices.
 *
 * Reserved for Internal Red Hat use only.
 */
static bool pci_hw_disabled(struct pci_dev *dev)
{
	const struct pci_device_id *ret = pci_match_id(rh_disabled_pci_devices, dev);

	if (!ret)
		return false;

	mark_hardware_disabled(dev_driver_string(&dev->dev), "%04X:%04X @ %s",
				   dev->device, dev->vendor, pci_name(dev));
	return true;
}
#endif

/**
 * driver_unmaintained() - check to see if a driver is unmaintained
 * @module_name: module name
 *
 * Called to notify users that a driver will no longer be tested on a routine
 * basis and the driver code is no longer being updated.  Red Hat may fix
 * security-related and critical issues.  Support for this driver will be
 * disabled in a future major release, and users should replace any affected
 * devices in production systems.
 *
 * This function should be used when a driver's usage cannot be tied to a
 * specific hardware device.  For example, a network bonding driver or a higher
 * level storage layer driver that is no longer maintained upstream.
 *
 * Reserved for Internal Red Hat use only.
 */
static void driver_unmaintained(const char* module_name)
{
	int i = 0;

	while (rh_unmaintained_drivers[i]) {
		if (strcmp(rh_unmaintained_drivers[i], module_name) == 0) {
			pr_crit("Warning: Unmaintained driver is detected: %s\n", module_name);
			return;
		}
		i++;
	}
}

/**
 * driver_deprecated() - check to see if a driver is deprecated
 * @driver_name: module name
 *
 * Called to notify users that support for this driver is planned to be
 * unmaintained in a future major release, and will eventually be disabled in a
 * future major release.  This driver should not be used in new production
 * environments and users should replace any affected devices in production
 * systems.
 *
 * This function should be used when a driver's usage cannot be tied to a
 * specific hardware device.  For example, a network bonding driver or a higher
 * level storage layer driver that is no longer maintained upstream.
 *
 * Reserved for Internal Red Hat use only.
 */
static void driver_deprecated(const char* module_name)
{
	int i = 0;

	while (rh_deprecated_drivers[i]) {
		if (strcmp(rh_deprecated_drivers[i], module_name) == 0) {
			pr_crit("Warning: Deprecated Driver is detected: %s will not be maintained in a future major release and may be disabled\n", module_name);
			return;
		}
		i++;
	}
}

/* There is no driver_disabled() function.  Disabled drivers are configured off ;). */

/**
 * init_fn_unmaintained - check to see if a built-in driver is unmaintained.
 * @fn_name: module's module_init function name
 *
 * Called to notify users that a built-in driver will no longer be tested on a routine
 * basis and the built-in driver code is no longer being updated.  Red Hat may fix
 * security-related and critical issues.  Support for this built-in driver will be
 * disabled in a future major release, and users should replace any affected
 * devices in production systems.
 *
 * This function should be used when a built-in driver's usage cannot be tied to a
 * specific hardware device.  For example, a network bonding driver or a higher
 * level storage layer driver that is no longer maintained upstream.
 *
 * Reserved for Internal Red Hat use only.
 */

static void init_fn_unmaintained(char* fn_name)
{
	int i = 0;

	while (rh_unmaintained_init_fns[i]) {
		if (strcmp(rh_unmaintained_init_fns[i], fn_name) == 0) {
			pr_crit("Warning: Unmaintained driver is detected: %s\n", fn_name);
			return;
		}
		i++;
	}
}

/**
 * init_fn_deprecated() - check to see if a built-in driver is deprecated
 * @fn_name: module's module_init function name
 *
 * Called to notify users that support for this built-in driver is planned to be
 * unmaintained in a future major release, and will eventually be disabled in a
 * future major release.  This driver should not be used in new production
 * environments and users should replace any affected devices in production
 * systems.
 *
 * This function should be used when a built-in driver's usage cannot be tied to a
 * specific hardware device.  For example, a network bonding driver or a higher
 * level storage layer driver that is no longer maintained upstream.
 *
 * Reserved for Internal Red Hat use only.
 */
static void init_fn_deprecated(char* fn_name)
{
	int i = 0;

	while (rh_deprecated_init_fns[i]) {
		if (strcmp(rh_deprecated_init_fns[i], fn_name) == 0) {
			pr_crit("Warning: Deprecated Driver is detected: %s will not be maintained in a future major release and may be disabled\n", fn_name);
			return;
		}
		i++;
	}
}

/**
 * mark_tech_preview() - Mark driver or kernel subsystem as 'Tech Preview'
 * @msg: Driver or kernel subsystem name
 *
 * Called to minimize the support status of a new driver.  This does TAINT the
 * kernel.  Calling this function indicates that the driver or subsystem has
 * had limited testing and is not marked for full support within this RHEL
 * minor release.  The next RHEL minor release may contain full support for
 * this driver.  Red Hat does not guarantee that bugs reported against this
 * driver or subsystem will be resolved.
 *
 * Reserved for Internal Red Hat use only.
 */
void mark_tech_preview(const char *msg, struct module *mod)
{
	const char *str = NULL;

	if (msg)
		str = msg;
#ifdef CONFIG_MODULES
	else if (mod)
		str = mod->name;
#endif

	pr_warn("TECH PREVIEW: %s may not be fully supported.\n"
		"Please review provided documentation for limitations.\n",
		(str ? str : "kernel"));
	add_taint(TAINT_AUX, LOCKDEP_STILL_OK);
#ifdef CONFIG_MODULES
	if (mod)
		mod->taints |= (1U << TAINT_AUX);
#endif
}
EXPORT_SYMBOL(mark_tech_preview);
/**
 * mark_partner_supported() - Mark driver or kernel subsystem as 'Partner Supported'
 * @msg: Driver or kernel subsystem name
 *
 * Called to minimize the support status of a new driver.  This does TAINT the
 * kernel.  Calling this function indicates that the driver or subsystem has
 * is not supported directly by Red Hat but by a partner engineer.
 *
 * Reserved for Internal Red Hat use only.
 */
void mark_partner_supported(const char *msg, struct module *mod)
{
	const char *str = NULL;

	if (msg)
		str = msg;
#ifdef CONFIG_MODULES
	else if (mod)
		str = mod->name;
#endif

	pr_warn("Notice: %s is a Partner Supported GPL module and not supported directly by Red Hat.\n"
		"Please contact your provider for support.\n",
		(str ? str : "kernel"));
	add_taint(TAINT_PARTNER_SUPPORTED, LOCKDEP_STILL_OK);
#ifdef CONFIG_MODULES
	if (mod)
		mod->taints |= (1U << TAINT_PARTNER_SUPPORTED);
#endif
}
EXPORT_SYMBOL(mark_partner_supported);

/*
 *
 * Functions called by 'main' kernel code.
 *
 */

#ifdef CONFIG_PCI
/**
 * pci_rh_check_status - checks the status of a PCI device.
 * @pci_dev: PCI device to be examined
 *
 * This function is called by the PCI driver subsystem to check the status of a
 * PCI device.
 *
 * This function returns true if the PCI device is disabled, and false otherwise.
 *
 * Reserved for Internal Red Hat use only.
 */
bool pci_rh_check_status(struct pci_dev *pci_dev)
{
	if (pci_dev->driver->driver.owner != NULL) {
		if (!test_bit(TAINT_OOT_MODULE, &pci_dev->driver->driver.owner->taints)) {
			pci_hw_unmaintained(pci_dev);
			pci_hw_deprecated(pci_dev);
			return pci_hw_disabled(pci_dev);
		}
	}
	return false;
}
#endif

/** module_rh_check_status - checks the status of a module.
 * @module_name: Name of module to be examined
 *
 * This function is called by the module loading code to check the status of a
 * module.
 *
 * Reserved for Internal Red Hat use only.
 */
void module_rh_check_status(const char * module_name)
{
	driver_unmaintained(module_name);
	driver_deprecated(module_name);
}

/**
  * init_rh_check_status - checks the status of a built-in module.
  * @fn_name: init function of module to be examined
  *
  * This function is called by the init code to check the status of a built-in module.
  * When a module is built-in, the module_init() function is converted into an initcall.
  * The initcall is the called during boot with the other system initcalls.
  *
  * Reserved for Internal Red Hat use only.
  */
void init_rh_check_status(char *fn_name)
{
	init_fn_deprecated(fn_name);
	init_fn_unmaintained(fn_name);
}
